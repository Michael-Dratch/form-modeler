"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        function classNames2() {
          var classes2 = "";
          for (var i4 = 0; i4 < arguments.length; i4++) {
            var arg = arguments[i4];
            if (arg) {
              classes2 = appendClass(classes2, parseValue(arg));
            }
          }
          return classes2;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames2.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes2 = "";
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes2 = appendClass(classes2, key);
            }
          }
          return classes2;
        }
        function appendClass(value, newClass) {
          if (!newClass) {
            return value;
          }
          if (value) {
            return value + " " + newClass;
          }
          return value + newClass;
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames2.default = classNames2;
          module.exports = classNames2;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames2;
          });
        } else {
          window.classNames = classNames2;
        }
      })();
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module) {
      function eq(value, other2) {
        return value === other2 || value !== value && other2 !== other2;
      }
      module.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      module.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries2) {
        var index2 = -1, length = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag4 = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e3) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag4;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      function isObject2(value) {
        var type3 = typeof value;
        return value != null && (type3 == "object" || type3 == "function");
      }
      module.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag4 = baseGetTag(value);
        return tag4 == funcTag || tag4 == genTag || tag4 == asyncTag || tag4 == proxyTag;
      }
      module.exports = isFunction2;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction2 = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module.exports = Map2;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries2) {
        var index2 = -1, length = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type3 = typeof value;
        return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries2) {
        var index2 = -1, length = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack2(entries2) {
        var data = this.__data__ = new ListCache(entries2);
        this.size = data.size;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      module.exports = Stack2;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other2, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other2.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other2);
        if (arrStacked && othStacked) {
          return arrStacked == other2 && othStacked == array;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other2);
        stack.set(other2, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other2[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other2, array, stack) : customizer(arrValue, othValue, index2, array, other2, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other2, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other2);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map3) {
        var index2 = -1, result = Array(map3.size);
        map3.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set3) {
        var index2 = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other2, tag4, bitmask, customizer, equalFunc, stack) {
        switch (tag4) {
          case dataViewTag:
            if (object.byteLength != other2.byteLength || object.byteOffset != other2.byteOffset) {
              return false;
            }
            object = object.buffer;
            other2 = other2.buffer;
          case arrayBufferTag:
            if (object.byteLength != other2.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other2))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other2);
          case errorTag:
            return object.name == other2.name && object.message == other2.message;
          case regexpTag:
          case stringTag:
            return object == other2 + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other2.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other2;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other2);
            var result = equalArrays(convert(object), convert(other2), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other2);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush2(array, values2) {
        var index2 = -1, length = values2.length, offset2 = array.length;
        while (++index2 < length) {
          array[offset2 + index2] = values2[index2];
        }
        return array;
      }
      module.exports = arrayPush2;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module) {
      var isArray5 = Array.isArray;
      module.exports = isArray5;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush2 = require_arrayPush();
      var isArray5 = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray5(object) ? result : arrayPush2(result, symbolsFunc(object));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n3, iteratee) {
        var index2 = -1, result = Array(n3);
        while (++index2 < n3) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer3 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type3 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e3) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray5 = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray5(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction2 = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      module.exports = isArrayLike;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module.exports = keys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function equalObjects(object, other2, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other2), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other2 : hasOwnProperty2.call(other2, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other2);
        if (objStacked && othStacked) {
          return objStacked == other2 && othStacked == object;
        }
        var result = true;
        stack.set(object, other2);
        stack.set(other2, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other2[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other2, object, stack) : customizer(objValue, othValue, key, object, other2, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other2.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other2) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other2);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView = getNative(root, "DataView");
      module.exports = DataView;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module) {
      var DataView = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack2 = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray5 = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other2, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray5(object), othIsArr = isArray5(other2), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other2);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other2)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other2, bitmask, customizer, equalFunc, stack) : equalByTag(object, other2, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other2, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other2.value() : other2;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object, other2, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other2, bitmask, customizer, stack) {
        if (value === other2) {
          return true;
        }
        if (value == null || other2 == null || !isObjectLike(value) && !isObjectLike(other2)) {
          return value !== value && other2 !== other2;
        }
        return baseIsEqualDeep(value, other2, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/isEqual.js
  var require_isEqual = __commonJS({
    "node_modules/lodash/isEqual.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      function isEqual2(value, other2) {
        return baseIsEqual(value, other2);
      }
      module.exports = isEqual2;
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule && freeModule.require && freeModule.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e3) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            var value = array[index2];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (iteratee(array[index2], index2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (!predicate(array[index2], index2, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (comparator(value, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array[index2], index2, array);
          }
          return result;
        }
        function arrayPush2(array, values2) {
          var index2 = -1, length = values2.length, offset2 = array.length;
          while (++index2 < length) {
            array[offset2 + index2] = values2[index2];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array[index2], index2, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string2) {
          return string2.split("");
        }
        function asciiWords(string2) {
          return string2.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (comparator(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index2 = -1, length = array.length;
          while (++index2 < length) {
            var current = iteratee(array[index2]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n3, iteratee) {
          var index2 = -1, result = Array(n3);
          while (++index2 < n3) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string2) {
          return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array, placeholder2) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder2) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        function hasUnicodeWord(string2) {
          return reHasUnicodeWord.test(string2);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map3) {
          var index2 = -1, result = Array(map3.size);
          map3.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder2) {
          var index2 = -1, length = array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value === placeholder2 || value === PLACEHOLDER) {
              array[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set3) {
          var index2 = -1, result = Array(set3.size);
          set3.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set3) {
          var index2 = -1, result = Array(set3.size);
          set3.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string2) {
          return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function trimmedEndIndex(string2) {
          var index2 = string2.length;
          while (index2-- && reWhitespace.test(string2.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string2) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string2)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function unicodeWords(string2) {
          return string2.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _3.defaults(root.Object(), context, _3.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty2 = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer3 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e3) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray5(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty2.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray5(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type3 = data.type, computed = iteratee2(value);
                  if (type3 == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type3 == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries2) {
            var index2 = -1, length = entries2 == null ? 0 : entries2.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries2[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries2) {
            var index2 = -1, length = entries2 == null ? 0 : entries2.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries2[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined2 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries2) {
            var index2 = -1, length = entries2 == null ? 0 : entries2.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries2[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values3) {
            var index2 = -1, length = values3 == null ? 0 : values3.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values3[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack2(entries2) {
            var data = this.__data__ = new ListCache(entries2);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack2.prototype.clear = stackClear;
          Stack2.prototype["delete"] = stackDelete;
          Stack2.prototype.get = stackGet;
          Stack2.prototype.has = stackHas;
          Stack2.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray5(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType3, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n3) {
            return shuffleSelf(copyArray(array), baseClamp(n3, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index2 < length) {
              result2[index2] = skip ? undefined2 : get3(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number2, lower, upper) {
            if (number2 === number2) {
              if (upper !== undefined2) {
                number2 = number2 <= upper ? number2 : upper;
              }
              if (lower !== undefined2) {
                number2 = number2 >= lower ? number2 : lower;
              }
            }
            return number2;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray5(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag4 = getTag(value), isFunc = tag4 == funcTag || tag4 == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag4 == objectTag || tag4 == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag4]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag4, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values3, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values3 = arrayMap(values3, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values3.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values3 = new SetCache(values3);
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values3[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values3, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index2 = -1, length = array.length;
            while (++index2 < length) {
              var value = array[index2], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush2(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path2) {
            path2 = castPath(path2, object);
            var index2 = 0, length = path2.length;
            while (object != null && index2 < length) {
              object = object[toKey(path2[index2++])];
            }
            return index2 && index2 == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray5(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other2) {
            return value > other2;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty2.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number2, start, end) {
            return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path2, args) {
            path2 = castPath(path2, object);
            object = parent(object, path2);
            var func = object == null ? object : object[toKey(last2(path2))];
            return func == null ? undefined2 : apply2(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other2, bitmask, customizer, stack) {
            if (value === other2) {
              return true;
            }
            if (value == null || other2 == null || !isObjectLike(value) && !isObjectLike(other2)) {
              return value !== value && other2 !== other2;
            }
            return baseIsEqualDeep(value, other2, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other2, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray5(object), othIsArr = isArray5(other2), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other2);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other2)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other2, bitmask, customizer, equalFunc, stack) : equalByTag(object, other2, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other2, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other2.value() : other2;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects(object, other2, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity2;
            }
            if (typeof value == "object") {
              return isArray5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty2.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject2(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other2) {
            return value < other2;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path2, srcValue) {
            if (isKey2(path2) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path2), srcValue);
            }
            return function(object) {
              var objValue = get3(object, path2);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack2());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray5(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped3 = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped3) {
                if (isArray5(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped3) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n3) {
            var length = array.length;
            if (!length) {
              return;
            }
            n3 += n3 < 0 ? length : 0;
            return isIndex(n3, length) ? array[n3] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray5(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other2) {
              return compareMultiple(object, other2, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path2) {
              return hasIn(object, path2);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path2 = paths[index2], value = baseGet(object, path2);
              if (predicate(value, path2)) {
                baseSet(result2, castPath(path2, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path2) {
            return function(object) {
              return baseGet(object, path2);
            };
          }
          function basePullAll(array, values3, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values3.length, seen = array;
            if (array === values3) {
              values3 = copyArray(values3);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values3[index2], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex(index2)) {
                  splice.call(array, index2, 1);
                } else {
                  baseUnset(array, index2);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string2, n3) {
            var result2 = "";
            if (!string2 || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n3 % 2) {
                result2 += string2;
              }
              n3 = nativeFloor(n3 / 2);
              if (n3) {
                string2 += string2;
              }
            } while (n3);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values2(collection));
          }
          function baseSampleSize(collection, n3) {
            var array = values2(collection);
            return shuffleSelf(array, baseClamp(n3, 0, array.length));
          }
          function baseSet(object, path2, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path2 = castPath(path2, object);
            var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index2 < length) {
              var key = toKey(path2[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity2 : function(func, string2) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string2),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values2(collection));
          }
          function baseSlice(array, start, end) {
            var index2 = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array[index2 + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity2, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index2 = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray5(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set4 = iteratee2 ? null : createSet(array);
              if (set4) {
                return setToArray(set4);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path2) {
            path2 = castPath(path2, object);
            object = parent(object, path2);
            return object == null || delete object[toKey(last2(path2))];
          }
          function baseUpdate(object, path2, updater, customizer) {
            return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values3, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values3.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values3[index2] : undefined2;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity2;
          }
          function castPath(value, object) {
            if (isArray5(value)) {
              return value;
            }
            return isKey2(value, object) ? [value] : stringToPath(toString4(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other2) {
            if (value !== other2) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other2 !== undefined2, othIsNull = other2 === null, othIsReflexive = other2 === other2, othIsSymbol = isSymbol(other2);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other2 || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other2 || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other2, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other2.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order = orders[index2];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other2.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset2 = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset2 + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index2 = -1, length = source.length;
            array || (array = Array2(length));
            while (++index2 < length) {
              array[index2] = source[index2];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray5(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn4 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn4.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string2) {
              string2 = toString4(string2);
              var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string2) {
              return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder2 = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder2 && args[length - 1] !== placeholder2 ? [] : replaceHolders(args, placeholder2);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn4 = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply2(fn4, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray5(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder2 = getHolder(wrapper), holdersCount = countHolders(args, placeholder2);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder2);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn4 = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn4 = Ctor || createCtor(fn4);
              }
              return fn4.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator2, defaultValue) {
            return function(value, other2) {
              var result2;
              if (value === undefined2 && other2 === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other2 !== undefined2) {
                if (result2 === undefined2) {
                  return other2;
                }
                if (typeof value == "string" || typeof other2 == "string") {
                  value = baseToString(value);
                  other2 = baseToString(other2);
                } else {
                  value = baseToNumber(value);
                  other2 = baseToNumber(other2);
                }
                result2 = operator2(value, other2);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply2(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars4) {
            chars4 = chars4 === undefined2 ? " " : baseToString(chars4);
            var charsLength = chars4.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars4, length) : chars4;
            }
            var result2 = baseRepeat(chars4, nativeCeil(length / stringSize(chars4)));
            return hasUnicode(chars4) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn4 = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply2(fn4, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange3(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator2) {
            return function(value, other2) {
              if (!(typeof value == "string" && typeof other2 == "string")) {
                value = toNumber(value);
                other2 = toNumber(other2);
              }
              return operator2(value, other2);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder2, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder2;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number2, precision) {
              number2 = toNumber(number2);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number2)) {
                var pair2 = (toString4(number2) + "e").split("e"), value = func(pair2[0] + "e" + (+pair2[1] + precision));
                pair2 = (toString4(value) + "e").split("e");
                return +(pair2[0] + "e" + (+pair2[1] - precision));
              }
              return func(number2);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values3) {
            return new Set2(values3);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag4 = getTag(object);
              if (tag4 == mapTag) {
                return mapToArray(object);
              }
              if (tag4 == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other2, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other2.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other2);
            if (arrStacked && othStacked) {
              return arrStacked == other2 && othStacked == array;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other2);
            stack.set(other2, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other2[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other2, array, stack) : customizer(arrValue, othValue, index2, array, other2, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other2, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other2);
            return result2;
          }
          function equalByTag(object, other2, tag4, bitmask, customizer, equalFunc, stack) {
            switch (tag4) {
              case dataViewTag:
                if (object.byteLength != other2.byteLength || object.byteOffset != other2.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other2 = other2.buffer;
              case arrayBufferTag:
                if (object.byteLength != other2.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other2))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other2);
              case errorTag:
                return object.name == other2.name && object.message == other2.message;
              case regexpTag:
              case stringTag:
                return object == other2 + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other2.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other2;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other2);
                var result2 = equalArrays(convert(object), convert(other2), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other2);
                }
            }
            return false;
          }
          function equalObjects(object, other2, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other2), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other2 : hasOwnProperty2.call(other2, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other2);
            if (objStacked && othStacked) {
              return objStacked == other2 && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other2);
            stack.set(other2, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other2[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other2, object, stack) : customizer(objValue, othValue, key, object, other2, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other2.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other2) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other2);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten4), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop3 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map4, key) {
            var data = map4.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty2.call(value, symToStringTag), tag4 = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e3) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag4;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush2(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data = transforms[index2], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match2 = source.match(reWrapDetails);
            return match2 ? match2[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path2, hasFunc) {
            path2 = castPath(path2, object);
            var index2 = -1, length = path2.length, result2 = false;
            while (++index2 < length) {
              var key = toKey(path2[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray5(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag4, isDeep) {
            var Ctor = object.constructor;
            switch (tag4) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray5(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type3 = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index2, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type3 = typeof index2;
            if (type3 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type3 == "string" && index2 in object) {
              return eq(object[index2], value);
            }
            return false;
          }
          function isKey2(value, object) {
            if (isArray5(value)) {
              return false;
            }
            var type3 = typeof value;
            if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type3 = typeof value;
            return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other2 = lodash[funcName];
            if (typeof other2 != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other2) {
              return true;
            }
            var data = getData(other2);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction2 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index2 < length) {
                array[index2] = args[start + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start + 1);
              while (++index2 < start) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start] = transform2(array);
              return apply2(func, this, otherArgs);
            };
          }
          function parent(object, path2) {
            return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index2 = indexes[length];
              array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index2 = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index2 < size2) {
              var rand = baseRandom(index2, lastIndex), value = array[rand];
              array[rand] = array[index2];
              array[index2] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string2) {
            var result2 = [];
            if (string2.charCodeAt(0) === 46) {
              result2.push("");
            }
            string2.replace(rePropName, function(match2, number2, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e3) {
              }
              try {
                return func + "";
              } catch (e3) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair2) {
              var value = "_." + pair2[0];
              if (bitmask & pair2[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk2(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array, index2, index2 += size2);
            }
            return result2;
          }
          function compact(array) {
            var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush2(isArray5(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values3) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values3) {
            var iteratee2 = last2(values3);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values3) {
            var comparator = last2(values3);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array, n3 < 0 ? 0 : n3, length);
          }
          function dropRight(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length - n3;
            return baseSlice(array, 0, n3 < 0 ? 0 : n3);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex2(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
          }
          function flatten4(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair2 = pairs[index2];
              result2[pair2[0]] = pair2[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseIndexOf(array, value, index2);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last2(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last2(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
          }
          function nth(array, n3) {
            return array && array.length ? baseNth(array, toInteger(n3)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values3) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
          }
          function pullAllBy(array, values3, iteratee2) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values3, comparator) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index2) {
              return isIndex(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array[index2];
              if (predicate(value, index2, array)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice3(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value);
              if (index2 < length && eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n3, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            return baseSlice(array, 0, n3 < 0 ? 0 : n3);
          }
          function takeRight(array, n3, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
            n3 = length - n3;
            return baseSlice(array, n3 < 0 ? 0 : n3, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index2) {
              return arrayMap(array, baseProperty(index2));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply2(iteratee2, undefined2, group);
            });
          }
          var without2 = baseRest(function(array, values3) {
            return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values3) {
            return baseZipObject(props || [], values3 || [], assignValue);
          }
          function zipObjectDeep(props, values3) {
            return baseZipObject(props || [], values3 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone6 = wrapperClone(parent2);
              clone6.__index__ = 0;
              clone6.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone6;
              } else {
                result2 = clone6;
              }
              var previous = clone6;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray5(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray5(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find3 = createFind(findIndex2);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map3(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map3(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map3(collection, iteratee2), depth);
          }
          function forEach2(collection, iteratee2) {
            var func = isArray5(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray5(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy2 = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values2(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString5(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path2, args) {
            var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply2(path2, value, args) : baseInvoke(value, path2, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map3(collection, iteratee2) {
            var func = isArray5(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray5(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray5(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce2(collection, iteratee2, accumulator) {
            var func = isArray5(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray5(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray5(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray5(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n3, guard) {
            if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            var func = isArray5(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n3);
          }
          function shuffle(collection) {
            var func = isArray5(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString5(collection) ? stringSize(collection) : collection.length;
            }
            var tag4 = getTag(collection);
            if (tag4 == mapTag || tag4 == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some2(collection, predicate, guard) {
            var func = isArray5(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now2 = ctxNow || function() {
            return root.Date.now();
          };
          function after(n3, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n3, guard) {
            n3 = guard ? undefined2 : n3;
            n3 = func && n3 == null ? func.length : n3;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
          }
          function before3(n3, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n3 = toInteger(n3);
            return function() {
              if (--n3 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n3 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind2 = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce3(func, wait, options2) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options2)) {
              leading = !!options2.leading;
              maxing = "maxWait" in options2;
              maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options2 ? !!options2.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now2();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel2() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now2());
            }
            function debounced() {
              var time = now2(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel2;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay3 = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before3(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray5(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length = nativeMin(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply2(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush2(otherArgs, array);
              }
              return apply2(func, this, otherArgs);
            });
          }
          function throttle2(func, wait, options2) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options2)) {
              leading = "leading" in options2 ? !!options2.leading : leading;
              trailing = "trailing" in options2 ? !!options2.trailing : trailing;
            }
            return debounce3(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap2(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray5(value) ? value : [value];
          }
          function clone5(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other2) {
            return value === other2 || value !== value && other2 !== other2;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other2) {
            return value >= other2;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray5 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean3(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty2(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray5(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag4 = getTag(value);
            if (tag4 == mapTag || tag4 == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty2.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual2(value, other2) {
            return baseIsEqual(value, other2);
          }
          function isEqualWith(value, other2, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other2) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other2, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag4 = baseGetTag(value);
            return tag4 == errorTag || tag4 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag4 = baseGetTag(value);
            return tag4 == funcTag || tag4 == genTag || tag4 == asyncTag || tag4 == proxyTag;
          }
          function isInteger2(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type3 = typeof value;
            return value != null && (type3 == "object" || type3 == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber5(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil2(value) {
            return value == null;
          }
          function isNumber5(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString5(value) {
            return typeof value == "string" || !isArray5(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined3(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other2) {
            return value <= other2;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString5(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag4 = getTag(value), func = tag4 == mapTag ? mapToArray : tag4 == setTag ? setToArray : values2;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other2) ? other2 + "" : other2;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString4(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create2(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults3 = baseRest(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply2(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get3(object, path2, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path2);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has2(object, path2) {
            return object != null && hasPath(object, path2, baseHas);
          }
          function hasIn(object, path2) {
            return object != null && hasPath(object, path2, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity2));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty2.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path2) {
              path2 = castPath(path2, object);
              isDeep || (isDeep = path2.length > 1);
              return path2;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick2 = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path2) {
              return predicate(value, path2[0]);
            });
          }
          function result(object, path2, defaultValue) {
            path2 = castPath(path2, object);
            var index2 = -1, length = path2.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index2 < length) {
              var value = object == null ? undefined2 : object[toKey(path2[index2])];
              if (value === undefined2) {
                index2 = length;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set3(object, path2, value) {
            return object == null ? object : baseSet(object, path2, value);
          }
          function setWith(object, path2, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path2, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray5(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset2(object, path2) {
            return object == null ? true : baseUnset(object, path2);
          }
          function update(object, path2, updater) {
            return object == null ? object : baseUpdate(object, path2, castFunction(updater));
          }
          function updateWith(object, path2, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
          }
          function values2(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number2, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number2), lower, upper);
          }
          function inRange(number2, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number2 = toNumber(number2);
            return baseInRange(number2, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize(word) : word);
          });
          function capitalize(string2) {
            return upperFirst(toString4(string2).toLowerCase());
          }
          function deburr(string2) {
            string2 = toString4(string2);
            return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string2, target, position) {
            string2 = toString4(string2);
            target = baseToString(target);
            var length = string2.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string2.slice(position, end) == target;
          }
          function escape2(string2) {
            string2 = toString4(string2);
            return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
          }
          function escapeRegExp(string2) {
            string2 = toString4(string2);
            return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad2(string2, length, chars4) {
            string2 = toString4(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            if (!length || strLength >= length) {
              return string2;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars4) + string2 + createPadding(nativeCeil(mid), chars4);
          }
          function padEnd(string2, length, chars4) {
            string2 = toString4(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? string2 + createPadding(length - strLength, chars4) : string2;
          }
          function padStart2(string2, length, chars4) {
            string2 = toString4(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars4) + string2 : string2;
          }
          function parseInt2(string2, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString4(string2).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string2, n3, guard) {
            if (guard ? isIterateeCall(string2, n3, guard) : n3 === undefined2) {
              n3 = 1;
            } else {
              n3 = toInteger(n3);
            }
            return baseRepeat(toString4(string2), n3);
          }
          function replace2() {
            var args = arguments, string2 = toString4(args[0]);
            return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string2, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string2 = toString4(string2);
            if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string2)) {
                return castSlice(stringToArray(string2), 0, limit);
              }
            }
            return string2.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string2, target, position) {
            string2 = toString4(string2);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
            target = baseToString(target);
            return string2.slice(position, position + target.length) == target;
          }
          function template(string2, options2, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string2, options2, guard)) {
              options2 = undefined2;
            }
            string2 = toString4(string2);
            options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string2.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset2 + match2.length;
              return match2;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString4(value).toLowerCase();
          }
          function toUpper(value) {
            return toString4(value).toUpperCase();
          }
          function trim(string2, chars4, guard) {
            string2 = toString4(string2);
            if (string2 && (guard || chars4 === undefined2)) {
              return baseTrim(string2);
            }
            if (!string2 || !(chars4 = baseToString(chars4))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars4), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string2, chars4, guard) {
            string2 = toString4(string2);
            if (string2 && (guard || chars4 === undefined2)) {
              return string2.slice(0, trimmedEndIndex(string2) + 1);
            }
            if (!string2 || !(chars4 = baseToString(chars4))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars4)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string2, chars4, guard) {
            string2 = toString4(string2);
            if (string2 && (guard || chars4 === undefined2)) {
              return string2.replace(reTrimStart, "");
            }
            if (!string2 || !(chars4 = baseToString(chars4))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars4));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string2, options2) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options2)) {
              var separator = "separator" in options2 ? options2.separator : separator;
              length = "length" in options2 ? toInteger(options2.length) : length;
              omission = "omission" in options2 ? baseToString(options2.omission) : omission;
            }
            string2 = toString4(string2);
            var strLength = string2.length;
            if (hasUnicode(string2)) {
              var strSymbols = stringToArray(string2);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string2;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string2.slice(end).search(separator)) {
                var match2, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString4(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match2 = separator.exec(substring)) {
                  var newEnd = match2.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string2.indexOf(baseToString(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape(string2) {
            string2 = toString4(string2);
            return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string2, pattern, guard) {
            string2 = toString4(string2);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
            }
            return string2.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply2(func, undefined2, args);
            } catch (e3) {
              return isError(e3) ? e3 : new Error2(e3);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind2(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair2) {
              if (typeof pair2[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair2[0]), pair2[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair2 = pairs[index2];
                if (apply2(pair2[0], this, args)) {
                  return apply2(pair2[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity2(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches4(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path2, srcValue) {
            return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path2, args) {
            return function(object) {
              return baseInvoke(object, path2, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path2) {
              return baseInvoke(object, path2, args);
            };
          });
          function mixin(object, source, options2) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options2 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options2 = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush2([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop3() {
          }
          function nthArg(n3) {
            n3 = toInteger(n3);
            return baseRest(function(args) {
              return baseNth(args, n3);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path2) {
            return isKey2(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
          }
          function propertyOf(object) {
            return function(path2) {
              return object == null ? undefined2 : baseGet(object, path2);
            };
          }
          var range = createRange3();
          var rangeRight = createRange3(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n3, iteratee2) {
            n3 = toInteger(n3);
            if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n3 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index2 < n3) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray5(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString4(value)));
          }
          function uniqueId(prefix2) {
            var id2 = ++idCounter;
            return toString4(prefix2) + id2;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity2);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round2 = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum3(array) {
            return array && array.length ? baseSum(array, identity2) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before3;
          lodash.bind = bind2;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk2;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create2;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce3;
          lodash.defaults = defaults3;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay3;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten4;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy2;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map3;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches4;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick2;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set3;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice3;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle2;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset2;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values2;
          lodash.valuesIn = valuesIn;
          lodash.without = without2;
          lodash.words = words;
          lodash.wrap = wrap2;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add2;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone5;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape2;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find3;
          lodash.findIndex = findIndex2;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach2;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get3;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has2;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity2;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray5;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean3;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate2;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty2;
          lodash.isEqual = isEqual2;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger2;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil2;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber5;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString5;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined3;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last2;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop3;
          lodash.now = now2;
          lodash.pad = pad2;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart2;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce2;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace2;
          lodash.result = result;
          lodash.round = round2;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some2;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum3;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString4;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach2;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n3) {
              n3 = n3 === undefined2 ? 1 : nativeMax(toInteger(n3), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n3, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n3) {
              return this.reverse()[methodName](n3).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type3 = index2 + 1, isFilter = type3 == LAZY_FILTER_FLAG || type3 == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type3
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
            if (typeof path2 == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path2, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray5(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush2([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray5(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray5(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _3 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _3;
          define(function() {
            return _3;
          });
        } else if (freeModule) {
          (freeModule.exports = _3)._ = _3;
          freeExports._ = _3;
        } else {
          root._ = _3;
        }
      }).call(exports);
    }
  });

  // node_modules/ids/dist/index.esm.js
  function createCommonjsModule(fn4, module) {
    return module = { exports: {} }, fn4(module, module.exports), module.exports;
  }
  var hat_1 = createCommonjsModule(function(module) {
    var hat = module.exports = function(bits, base2) {
      if (!base2) base2 = 16;
      if (bits === void 0) bits = 128;
      if (bits <= 0) return "0";
      var digits = Math.log(Math.pow(2, bits)) / Math.log(base2);
      for (var i4 = 2; digits === Infinity; i4 *= 2) {
        digits = Math.log(Math.pow(2, bits / i4)) / Math.log(base2) * i4;
      }
      var rem = digits - Math.floor(digits);
      var res = "";
      for (var i4 = 0; i4 < Math.floor(digits); i4++) {
        var x3 = Math.floor(Math.random() * base2).toString(base2);
        res = x3 + res;
      }
      if (rem) {
        var b2 = Math.pow(base2, rem);
        var x3 = Math.floor(Math.random() * b2).toString(base2);
        res = x3 + res;
      }
      var parsed = parseInt(res, base2);
      if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base2);
      } else return res;
    };
    hat.rack = function(bits, base2, expandBy) {
      var fn4 = function(data) {
        var iters = 0;
        do {
          if (iters++ > 10) {
            if (expandBy) bits += expandBy;
            else throw new Error("too many ID collisions, use more bits");
          }
          var id2 = hat(bits, base2);
        } while (Object.hasOwnProperty.call(hats, id2));
        hats[id2] = data;
        return id2;
      };
      var hats = fn4.hats = {};
      fn4.get = function(id2) {
        return fn4.hats[id2];
      };
      fn4.set = function(id2, value) {
        fn4.hats[id2] = value;
        return fn4;
      };
      fn4.bits = bits || 128;
      fn4.base = base2 || 16;
      return fn4;
    };
  });
  function Ids(seed) {
    if (!(this instanceof Ids)) {
      return new Ids(seed);
    }
    seed = seed || [128, 36, 1];
    this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
  }
  Ids.prototype.next = function(element) {
    return this._seed(element || true);
  };
  Ids.prototype.nextPrefixed = function(prefix2, element) {
    var id2;
    do {
      id2 = prefix2 + this.next(true);
    } while (this.assigned(id2));
    this.claim(id2, element);
    return id2;
  };
  Ids.prototype.claim = function(id2, element) {
    this._seed.set(id2, element || true);
  };
  Ids.prototype.assigned = function(id2) {
    return this._seed.get(id2) || false;
  };
  Ids.prototype.unclaim = function(id2) {
    delete this._seed.hats[id2];
  };
  Ids.prototype.clear = function() {
    var hats = this._seed.hats, id2;
    for (id2 in hats) {
      this.unclaim(id2);
    }
  };
  var index_esm_default = Ids;

  // node_modules/min-dash/dist/index.esm.js
  var nativeToString = Object.prototype.toString;
  var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
  function isUndefined(obj) {
    return obj === void 0;
  }
  function isDefined(obj) {
    return obj !== void 0;
  }
  function isNil(obj) {
    return obj == null;
  }
  function isArray(obj) {
    return nativeToString.call(obj) === "[object Array]";
  }
  function isObject(obj) {
    return nativeToString.call(obj) === "[object Object]";
  }
  function isNumber(obj) {
    return nativeToString.call(obj) === "[object Number]";
  }
  function isFunction(obj) {
    const tag4 = nativeToString.call(obj);
    return tag4 === "[object Function]" || tag4 === "[object AsyncFunction]" || tag4 === "[object GeneratorFunction]" || tag4 === "[object AsyncGeneratorFunction]" || tag4 === "[object Proxy]";
  }
  function isString(obj) {
    return nativeToString.call(obj) === "[object String]";
  }
  function ensureArray(obj) {
    if (isArray(obj)) {
      return;
    }
    throw new Error("must supply array");
  }
  function has(target, key) {
    return !isNil(target) && nativeHasOwnProperty.call(target, key);
  }
  function find(collection, matcher) {
    const matchFn = toMatcher(matcher);
    let match2;
    forEach(collection, function(val, key) {
      if (matchFn(val, key)) {
        match2 = val;
        return false;
      }
    });
    return match2;
  }
  function findIndex(collection, matcher) {
    const matchFn = toMatcher(matcher);
    let idx = isArray(collection) ? -1 : void 0;
    forEach(collection, function(val, key) {
      if (matchFn(val, key)) {
        idx = key;
        return false;
      }
    });
    return idx;
  }
  function forEach(collection, iterator) {
    let val, result;
    if (isUndefined(collection)) {
      return;
    }
    const convertKey = isArray(collection) ? toNum : identity;
    for (let key in collection) {
      if (has(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }
  function without(arr, matcher) {
    if (isUndefined(arr)) {
      return [];
    }
    ensureArray(arr);
    const matchFn = toMatcher(matcher);
    return arr.filter(function(el, idx) {
      return !matchFn(el, idx);
    });
  }
  function reduce(collection, iterator, result) {
    forEach(collection, function(value, idx) {
      result = iterator(result, value, idx);
    });
    return result;
  }
  function some(collection, matcher) {
    return !!find(collection, matcher);
  }
  function map(collection, fn4) {
    let result = [];
    forEach(collection, function(val, key) {
      result.push(fn4(val, key));
    });
    return result;
  }
  function values(collection) {
    return map(collection, (val) => val);
  }
  function groupBy(collection, extractor, grouped = {}) {
    extractor = toExtractor(extractor);
    forEach(collection, function(val) {
      let discriminator = extractor(val) || "_";
      let group = grouped[discriminator];
      if (!group) {
        group = grouped[discriminator] = [];
      }
      group.push(val);
    });
    return grouped;
  }
  function uniqueBy(extractor, ...collections) {
    extractor = toExtractor(extractor);
    let grouped = {};
    forEach(collections, (c3) => groupBy(c3, extractor, grouped));
    let result = map(grouped, function(val, key) {
      return val[0];
    });
    return result;
  }
  function toExtractor(extractor) {
    return isFunction(extractor) ? extractor : (e3) => {
      return e3[extractor];
    };
  }
  function toMatcher(matcher) {
    return isFunction(matcher) ? matcher : (e3) => {
      return e3 === matcher;
    };
  }
  function identity(arg) {
    return arg;
  }
  function toNum(arg) {
    return Number(arg);
  }
  function debounce(fn4, timeout) {
    let timer;
    let lastArgs;
    let lastThis;
    let lastNow;
    function fire(force) {
      let now2 = Date.now();
      let scheduledDiff = force ? 0 : lastNow + timeout - now2;
      if (scheduledDiff > 0) {
        return schedule(scheduledDiff);
      }
      fn4.apply(lastThis, lastArgs);
      clear();
    }
    function schedule(timeout2) {
      timer = setTimeout(fire, timeout2);
    }
    function clear() {
      if (timer) {
        clearTimeout(timer);
      }
      timer = lastNow = lastArgs = lastThis = void 0;
    }
    function flush() {
      if (timer) {
        fire(true);
      }
      clear();
    }
    function callback(...args) {
      lastNow = Date.now();
      lastArgs = args;
      lastThis = this;
      if (!timer) {
        schedule(timeout);
      }
    }
    callback.flush = flush;
    callback.cancel = clear;
    return callback;
  }
  function bind(fn4, target) {
    return fn4.bind(target);
  }
  function assign(target, ...others) {
    return Object.assign(target, ...others);
  }
  function set(target, path2, value) {
    let currentTarget = target;
    forEach(path2, function(key, idx) {
      if (typeof key !== "number" && typeof key !== "string") {
        throw new Error("illegal key type: " + typeof key + ". Key should be of type number or string.");
      }
      if (key === "constructor") {
        throw new Error("illegal key: constructor");
      }
      if (key === "__proto__") {
        throw new Error("illegal key: __proto__");
      }
      let nextKey = path2[idx + 1];
      let nextTarget = currentTarget[key];
      if (isDefined(nextKey) && isNil(nextTarget)) {
        nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
      }
      if (isUndefined(nextKey)) {
        if (isUndefined(value)) {
          delete currentTarget[key];
        } else {
          currentTarget[key] = value;
        }
      } else {
        currentTarget = nextTarget;
      }
    });
    return target;
  }
  function get(target, path2, defaultValue) {
    let currentTarget = target;
    forEach(path2, function(key) {
      if (isNil(currentTarget)) {
        currentTarget = void 0;
        return false;
      }
      currentTarget = currentTarget[key];
    });
    return isUndefined(currentTarget) ? defaultValue : currentTarget;
  }

  // node_modules/big.js/big.mjs
  var DP = 20;
  var RM = 1;
  var MAX_DP = 1e6;
  var MAX_POWER = 1e6;
  var NE = -7;
  var PE = 21;
  var STRICT = false;
  var NAME = "[big.js] ";
  var INVALID = NAME + "Invalid ";
  var INVALID_DP = INVALID + "decimal places";
  var INVALID_RM = INVALID + "rounding mode";
  var DIV_BY_ZERO = NAME + "Division by zero";
  var P = {};
  var UNDEFINED = void 0;
  var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  function _Big_() {
    function Big2(n3) {
      var x3 = this;
      if (!(x3 instanceof Big2)) return n3 === UNDEFINED ? _Big_() : new Big2(n3);
      if (n3 instanceof Big2) {
        x3.s = n3.s;
        x3.e = n3.e;
        x3.c = n3.c.slice();
      } else {
        if (typeof n3 !== "string") {
          if (Big2.strict === true && typeof n3 !== "bigint") {
            throw TypeError(INVALID + "value");
          }
          n3 = n3 === 0 && 1 / n3 < 0 ? "-0" : String(n3);
        }
        parse(x3, n3);
      }
      x3.constructor = Big2;
    }
    Big2.prototype = P;
    Big2.DP = DP;
    Big2.RM = RM;
    Big2.NE = NE;
    Big2.PE = PE;
    Big2.strict = STRICT;
    Big2.roundDown = 0;
    Big2.roundHalfUp = 1;
    Big2.roundHalfEven = 2;
    Big2.roundUp = 3;
    return Big2;
  }
  function parse(x3, n3) {
    var e3, i4, nl;
    if (!NUMERIC.test(n3)) {
      throw Error(INVALID + "number");
    }
    x3.s = n3.charAt(0) == "-" ? (n3 = n3.slice(1), -1) : 1;
    if ((e3 = n3.indexOf(".")) > -1) n3 = n3.replace(".", "");
    if ((i4 = n3.search(/e/i)) > 0) {
      if (e3 < 0) e3 = i4;
      e3 += +n3.slice(i4 + 1);
      n3 = n3.substring(0, i4);
    } else if (e3 < 0) {
      e3 = n3.length;
    }
    nl = n3.length;
    for (i4 = 0; i4 < nl && n3.charAt(i4) == "0"; ) ++i4;
    if (i4 == nl) {
      x3.c = [x3.e = 0];
    } else {
      for (; nl > 0 && n3.charAt(--nl) == "0"; ) ;
      x3.e = e3 - i4 - 1;
      x3.c = [];
      for (e3 = 0; i4 <= nl; ) x3.c[e3++] = +n3.charAt(i4++);
    }
    return x3;
  }
  function round(x3, sd, rm2, more) {
    var xc = x3.c;
    if (rm2 === UNDEFINED) rm2 = x3.constructor.RM;
    if (rm2 !== 0 && rm2 !== 1 && rm2 !== 2 && rm2 !== 3) {
      throw Error(INVALID_RM);
    }
    if (sd < 1) {
      more = rm2 === 3 && (more || !!xc[0]) || sd === 0 && (rm2 === 1 && xc[0] >= 5 || rm2 === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
      xc.length = 1;
      if (more) {
        x3.e = x3.e - sd + 1;
        xc[0] = 1;
      } else {
        xc[0] = x3.e = 0;
      }
    } else if (sd < xc.length) {
      more = rm2 === 1 && xc[sd] >= 5 || rm2 === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm2 === 3 && (more || !!xc[0]);
      xc.length = sd;
      if (more) {
        for (; ++xc[--sd] > 9; ) {
          xc[sd] = 0;
          if (sd === 0) {
            ++x3.e;
            xc.unshift(1);
            break;
          }
        }
      }
      for (sd = xc.length; !xc[--sd]; ) xc.pop();
    }
    return x3;
  }
  function stringify(x3, doExponential, isNonzero) {
    var e3 = x3.e, s4 = x3.c.join(""), n3 = s4.length;
    if (doExponential) {
      s4 = s4.charAt(0) + (n3 > 1 ? "." + s4.slice(1) : "") + (e3 < 0 ? "e" : "e+") + e3;
    } else if (e3 < 0) {
      for (; ++e3; ) s4 = "0" + s4;
      s4 = "0." + s4;
    } else if (e3 > 0) {
      if (++e3 > n3) {
        for (e3 -= n3; e3--; ) s4 += "0";
      } else if (e3 < n3) {
        s4 = s4.slice(0, e3) + "." + s4.slice(e3);
      }
    } else if (n3 > 1) {
      s4 = s4.charAt(0) + "." + s4.slice(1);
    }
    return x3.s < 0 && isNonzero ? "-" + s4 : s4;
  }
  P.abs = function() {
    var x3 = new this.constructor(this);
    x3.s = 1;
    return x3;
  };
  P.cmp = function(y3) {
    var isneg, x3 = this, xc = x3.c, yc = (y3 = new x3.constructor(y3)).c, i4 = x3.s, j4 = y3.s, k3 = x3.e, l4 = y3.e;
    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j4 : i4;
    if (i4 != j4) return i4;
    isneg = i4 < 0;
    if (k3 != l4) return k3 > l4 ^ isneg ? 1 : -1;
    j4 = (k3 = xc.length) < (l4 = yc.length) ? k3 : l4;
    for (i4 = -1; ++i4 < j4; ) {
      if (xc[i4] != yc[i4]) return xc[i4] > yc[i4] ^ isneg ? 1 : -1;
    }
    return k3 == l4 ? 0 : k3 > l4 ^ isneg ? 1 : -1;
  };
  P.div = function(y3) {
    var x3 = this, Big2 = x3.constructor, a3 = x3.c, b2 = (y3 = new Big2(y3)).c, k3 = x3.s == y3.s ? 1 : -1, dp = Big2.DP;
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    if (!b2[0]) {
      throw Error(DIV_BY_ZERO);
    }
    if (!a3[0]) {
      y3.s = k3;
      y3.c = [y3.e = 0];
      return y3;
    }
    var bl, bt, n3, cmp, ri, bz = b2.slice(), ai = bl = b2.length, al = a3.length, r3 = a3.slice(0, bl), rl = r3.length, q4 = y3, qc = q4.c = [], qi = 0, p3 = dp + (q4.e = x3.e - y3.e) + 1;
    q4.s = k3;
    k3 = p3 < 0 ? 0 : p3;
    bz.unshift(0);
    for (; rl++ < bl; ) r3.push(0);
    do {
      for (n3 = 0; n3 < 10; n3++) {
        if (bl != (rl = r3.length)) {
          cmp = bl > rl ? 1 : -1;
        } else {
          for (ri = -1, cmp = 0; ++ri < bl; ) {
            if (b2[ri] != r3[ri]) {
              cmp = b2[ri] > r3[ri] ? 1 : -1;
              break;
            }
          }
        }
        if (cmp < 0) {
          for (bt = rl == bl ? b2 : bz; rl; ) {
            if (r3[--rl] < bt[rl]) {
              ri = rl;
              for (; ri && !r3[--ri]; ) r3[ri] = 9;
              --r3[ri];
              r3[rl] += 10;
            }
            r3[rl] -= bt[rl];
          }
          for (; !r3[0]; ) r3.shift();
        } else {
          break;
        }
      }
      qc[qi++] = cmp ? n3 : ++n3;
      if (r3[0] && cmp) r3[rl] = a3[ai] || 0;
      else r3 = [a3[ai]];
    } while ((ai++ < al || r3[0] !== UNDEFINED) && k3--);
    if (!qc[0] && qi != 1) {
      qc.shift();
      q4.e--;
      p3--;
    }
    if (qi > p3) round(q4, p3, Big2.RM, r3[0] !== UNDEFINED);
    return q4;
  };
  P.eq = function(y3) {
    return this.cmp(y3) === 0;
  };
  P.gt = function(y3) {
    return this.cmp(y3) > 0;
  };
  P.gte = function(y3) {
    return this.cmp(y3) > -1;
  };
  P.lt = function(y3) {
    return this.cmp(y3) < 0;
  };
  P.lte = function(y3) {
    return this.cmp(y3) < 1;
  };
  P.minus = P.sub = function(y3) {
    var i4, j4, t4, xlty, x3 = this, Big2 = x3.constructor, a3 = x3.s, b2 = (y3 = new Big2(y3)).s;
    if (a3 != b2) {
      y3.s = -b2;
      return x3.plus(y3);
    }
    var xc = x3.c.slice(), xe2 = x3.e, yc = y3.c, ye = y3.e;
    if (!xc[0] || !yc[0]) {
      if (yc[0]) {
        y3.s = -b2;
      } else if (xc[0]) {
        y3 = new Big2(x3);
      } else {
        y3.s = 1;
      }
      return y3;
    }
    if (a3 = xe2 - ye) {
      if (xlty = a3 < 0) {
        a3 = -a3;
        t4 = xc;
      } else {
        ye = xe2;
        t4 = yc;
      }
      t4.reverse();
      for (b2 = a3; b2--; ) t4.push(0);
      t4.reverse();
    } else {
      j4 = ((xlty = xc.length < yc.length) ? xc : yc).length;
      for (a3 = b2 = 0; b2 < j4; b2++) {
        if (xc[b2] != yc[b2]) {
          xlty = xc[b2] < yc[b2];
          break;
        }
      }
    }
    if (xlty) {
      t4 = xc;
      xc = yc;
      yc = t4;
      y3.s = -y3.s;
    }
    if ((b2 = (j4 = yc.length) - (i4 = xc.length)) > 0) for (; b2--; ) xc[i4++] = 0;
    for (b2 = i4; j4 > a3; ) {
      if (xc[--j4] < yc[j4]) {
        for (i4 = j4; i4 && !xc[--i4]; ) xc[i4] = 9;
        --xc[i4];
        xc[j4] += 10;
      }
      xc[j4] -= yc[j4];
    }
    for (; xc[--b2] === 0; ) xc.pop();
    for (; xc[0] === 0; ) {
      xc.shift();
      --ye;
    }
    if (!xc[0]) {
      y3.s = 1;
      xc = [ye = 0];
    }
    y3.c = xc;
    y3.e = ye;
    return y3;
  };
  P.mod = function(y3) {
    var ygtx, x3 = this, Big2 = x3.constructor, a3 = x3.s, b2 = (y3 = new Big2(y3)).s;
    if (!y3.c[0]) {
      throw Error(DIV_BY_ZERO);
    }
    x3.s = y3.s = 1;
    ygtx = y3.cmp(x3) == 1;
    x3.s = a3;
    y3.s = b2;
    if (ygtx) return new Big2(x3);
    a3 = Big2.DP;
    b2 = Big2.RM;
    Big2.DP = Big2.RM = 0;
    x3 = x3.div(y3);
    Big2.DP = a3;
    Big2.RM = b2;
    return this.minus(x3.times(y3));
  };
  P.neg = function() {
    var x3 = new this.constructor(this);
    x3.s = -x3.s;
    return x3;
  };
  P.plus = P.add = function(y3) {
    var e3, k3, t4, x3 = this, Big2 = x3.constructor;
    y3 = new Big2(y3);
    if (x3.s != y3.s) {
      y3.s = -y3.s;
      return x3.minus(y3);
    }
    var xe2 = x3.e, xc = x3.c, ye = y3.e, yc = y3.c;
    if (!xc[0] || !yc[0]) {
      if (!yc[0]) {
        if (xc[0]) {
          y3 = new Big2(x3);
        } else {
          y3.s = x3.s;
        }
      }
      return y3;
    }
    xc = xc.slice();
    if (e3 = xe2 - ye) {
      if (e3 > 0) {
        ye = xe2;
        t4 = yc;
      } else {
        e3 = -e3;
        t4 = xc;
      }
      t4.reverse();
      for (; e3--; ) t4.push(0);
      t4.reverse();
    }
    if (xc.length - yc.length < 0) {
      t4 = yc;
      yc = xc;
      xc = t4;
    }
    e3 = yc.length;
    for (k3 = 0; e3; xc[e3] %= 10) k3 = (xc[--e3] = xc[e3] + yc[e3] + k3) / 10 | 0;
    if (k3) {
      xc.unshift(k3);
      ++ye;
    }
    for (e3 = xc.length; xc[--e3] === 0; ) xc.pop();
    y3.c = xc;
    y3.e = ye;
    return y3;
  };
  P.pow = function(n3) {
    var x3 = this, one = new x3.constructor("1"), y3 = one, isneg = n3 < 0;
    if (n3 !== ~~n3 || n3 < -MAX_POWER || n3 > MAX_POWER) {
      throw Error(INVALID + "exponent");
    }
    if (isneg) n3 = -n3;
    for (; ; ) {
      if (n3 & 1) y3 = y3.times(x3);
      n3 >>= 1;
      if (!n3) break;
      x3 = x3.times(x3);
    }
    return isneg ? one.div(y3) : y3;
  };
  P.prec = function(sd, rm2) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + "precision");
    }
    return round(new this.constructor(this), sd, rm2);
  };
  P.round = function(dp, rm2) {
    if (dp === UNDEFINED) dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    return round(new this.constructor(this), dp + this.e + 1, rm2);
  };
  P.sqrt = function() {
    var r3, c3, t4, x3 = this, Big2 = x3.constructor, s4 = x3.s, e3 = x3.e, half = new Big2("0.5");
    if (!x3.c[0]) return new Big2(x3);
    if (s4 < 0) {
      throw Error(NAME + "No square root");
    }
    s4 = Math.sqrt(+stringify(x3, true, true));
    if (s4 === 0 || s4 === 1 / 0) {
      c3 = x3.c.join("");
      if (!(c3.length + e3 & 1)) c3 += "0";
      s4 = Math.sqrt(c3);
      e3 = ((e3 + 1) / 2 | 0) - (e3 < 0 || e3 & 1);
      r3 = new Big2((s4 == 1 / 0 ? "5e" : (s4 = s4.toExponential()).slice(0, s4.indexOf("e") + 1)) + e3);
    } else {
      r3 = new Big2(s4 + "");
    }
    e3 = r3.e + (Big2.DP += 4);
    do {
      t4 = r3;
      r3 = half.times(t4.plus(x3.div(t4)));
    } while (t4.c.slice(0, e3).join("") !== r3.c.slice(0, e3).join(""));
    return round(r3, (Big2.DP -= 4) + r3.e + 1, Big2.RM);
  };
  P.times = P.mul = function(y3) {
    var c3, x3 = this, Big2 = x3.constructor, xc = x3.c, yc = (y3 = new Big2(y3)).c, a3 = xc.length, b2 = yc.length, i4 = x3.e, j4 = y3.e;
    y3.s = x3.s == y3.s ? 1 : -1;
    if (!xc[0] || !yc[0]) {
      y3.c = [y3.e = 0];
      return y3;
    }
    y3.e = i4 + j4;
    if (a3 < b2) {
      c3 = xc;
      xc = yc;
      yc = c3;
      j4 = a3;
      a3 = b2;
      b2 = j4;
    }
    for (c3 = new Array(j4 = a3 + b2); j4--; ) c3[j4] = 0;
    for (i4 = b2; i4--; ) {
      b2 = 0;
      for (j4 = a3 + i4; j4 > i4; ) {
        b2 = c3[j4] + yc[i4] * xc[j4 - i4 - 1] + b2;
        c3[j4--] = b2 % 10;
        b2 = b2 / 10 | 0;
      }
      c3[j4] = b2;
    }
    if (b2) ++y3.e;
    else c3.shift();
    for (i4 = c3.length; !c3[--i4]; ) c3.pop();
    y3.c = c3;
    return y3;
  };
  P.toExponential = function(dp, rm2) {
    var x3 = this, n3 = x3.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x3 = round(new x3.constructor(x3), ++dp, rm2);
      for (; x3.c.length < dp; ) x3.c.push(0);
    }
    return stringify(x3, true, !!n3);
  };
  P.toFixed = function(dp, rm2) {
    var x3 = this, n3 = x3.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x3 = round(new x3.constructor(x3), dp + x3.e + 1, rm2);
      for (dp = dp + x3.e + 1; x3.c.length < dp; ) x3.c.push(0);
    }
    return stringify(x3, false, !!n3);
  };
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toJSON = P.toString = function() {
    var x3 = this, Big2 = x3.constructor;
    return stringify(x3, x3.e <= Big2.NE || x3.e >= Big2.PE, !!x3.c[0]);
  };
  P.toNumber = function() {
    var n3 = +stringify(this, true, true);
    if (this.constructor.strict === true && !this.eq(n3.toString())) {
      throw Error(NAME + "Imprecise conversion");
    }
    return n3;
  };
  P.toPrecision = function(sd, rm2) {
    var x3 = this, Big2 = x3.constructor, n3 = x3.c[0];
    if (sd !== UNDEFINED) {
      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
        throw Error(INVALID + "precision");
      }
      x3 = round(new Big2(x3), sd, rm2);
      for (; x3.c.length < sd; ) x3.c.push(0);
    }
    return stringify(x3, sd <= x3.e || x3.e <= Big2.NE || x3.e >= Big2.PE, !!n3);
  };
  P.valueOf = function() {
    var x3 = this, Big2 = x3.constructor;
    if (Big2.strict === true) {
      throw Error(NAME + "valueOf disallowed");
    }
    return stringify(x3, x3.e <= Big2.NE || x3.e >= Big2.PE, true);
  };
  var Big = _Big_();
  var big_default = Big;

  // node_modules/@bpmn-io/form-js-viewer/dist/index.es.js
  var import_classnames = __toESM(require_classnames());

  // node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var t;
  var i;
  var r;
  var o;
  var e;
  var f;
  var c;
  var s;
  var a;
  var h;
  var p = {};
  var y = [];
  var v = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  var w = Array.isArray;
  function d(n3, l4) {
    for (var u4 in l4) n3[u4] = l4[u4];
    return n3;
  }
  function g(n3) {
    n3 && n3.parentNode && n3.parentNode.removeChild(n3);
  }
  function _(l4, u4, t4) {
    var i4, r3, o3, e3 = {};
    for (o3 in u4) "key" == o3 ? i4 = u4[o3] : "ref" == o3 ? r3 = u4[o3] : e3[o3] = u4[o3];
    if (arguments.length > 2 && (e3.children = arguments.length > 3 ? n.call(arguments, 2) : t4), "function" == typeof l4 && null != l4.defaultProps) for (o3 in l4.defaultProps) null == e3[o3] && (e3[o3] = l4.defaultProps[o3]);
    return m(l4, e3, i4, r3, null);
  }
  function m(n3, t4, i4, r3, o3) {
    var e3 = { type: n3, props: t4, key: i4, ref: r3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o3 ? ++u : o3, __i: -1, __u: 0 };
    return null == o3 && null != l.vnode && l.vnode(e3), e3;
  }
  function k(n3) {
    return n3.children;
  }
  function x(n3, l4) {
    this.props = n3, this.context = l4;
  }
  function S(n3, l4) {
    if (null == l4) return n3.__ ? S(n3.__, n3.__i + 1) : null;
    for (var u4; l4 < n3.__k.length; l4++) if (null != (u4 = n3.__k[l4]) && null != u4.__e) return u4.__e;
    return "function" == typeof n3.type ? S(n3) : null;
  }
  function C(n3) {
    var l4, u4;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++) if (null != (u4 = n3.__k[l4]) && null != u4.__e) {
        n3.__e = n3.__c.base = u4.__e;
        break;
      }
      return C(n3);
    }
  }
  function M(n3) {
    (!n3.__d && (n3.__d = true) && i.push(n3) && !$.__r++ || r != l.debounceRendering) && ((r = l.debounceRendering) || o)($);
  }
  function $() {
    for (var n3, u4, t4, r3, o3, f4, c3, s4 = 1; i.length; ) i.length > s4 && i.sort(e), n3 = i.shift(), s4 = i.length, n3.__d && (t4 = void 0, o3 = (r3 = (u4 = n3).__v).__e, f4 = [], c3 = [], u4.__P && ((t4 = d({}, r3)).__v = r3.__v + 1, l.vnode && l.vnode(t4), O(u4.__P, t4, r3, u4.__n, u4.__P.namespaceURI, 32 & r3.__u ? [o3] : null, f4, null == o3 ? S(r3) : o3, !!(32 & r3.__u), c3), t4.__v = r3.__v, t4.__.__k[t4.__i] = t4, z(f4, t4, c3), t4.__e != o3 && C(t4)));
    $.__r = 0;
  }
  function I(n3, l4, u4, t4, i4, r3, o3, e3, f4, c3, s4) {
    var a3, h3, v4, w3, d3, g4, _3 = t4 && t4.__k || y, m3 = l4.length;
    for (f4 = P2(u4, l4, _3, f4, m3), a3 = 0; a3 < m3; a3++) null != (v4 = u4.__k[a3]) && (h3 = -1 == v4.__i ? p : _3[v4.__i] || p, v4.__i = a3, g4 = O(n3, v4, h3, i4, r3, o3, e3, f4, c3, s4), w3 = v4.__e, v4.ref && h3.ref != v4.ref && (h3.ref && q(h3.ref, null, v4), s4.push(v4.ref, v4.__c || w3, v4)), null == d3 && null != w3 && (d3 = w3), 4 & v4.__u || h3.__k === v4.__k ? f4 = A(v4, f4, n3) : "function" == typeof v4.type && void 0 !== g4 ? f4 = g4 : w3 && (f4 = w3.nextSibling), v4.__u &= -7);
    return u4.__e = d3, f4;
  }
  function P2(n3, l4, u4, t4, i4) {
    var r3, o3, e3, f4, c3, s4 = u4.length, a3 = s4, h3 = 0;
    for (n3.__k = new Array(i4), r3 = 0; r3 < i4; r3++) null != (o3 = l4[r3]) && "boolean" != typeof o3 && "function" != typeof o3 ? (f4 = r3 + h3, (o3 = n3.__k[r3] = "string" == typeof o3 || "number" == typeof o3 || "bigint" == typeof o3 || o3.constructor == String ? m(null, o3, null, null, null) : w(o3) ? m(k, { children: o3 }, null, null, null) : null == o3.constructor && o3.__b > 0 ? m(o3.type, o3.props, o3.key, o3.ref ? o3.ref : null, o3.__v) : o3).__ = n3, o3.__b = n3.__b + 1, e3 = null, -1 != (c3 = o3.__i = L(o3, u4, f4, a3)) && (a3--, (e3 = u4[c3]) && (e3.__u |= 2)), null == e3 || null == e3.__v ? (-1 == c3 && (i4 > s4 ? h3-- : i4 < s4 && h3++), "function" != typeof o3.type && (o3.__u |= 4)) : c3 != f4 && (c3 == f4 - 1 ? h3-- : c3 == f4 + 1 ? h3++ : (c3 > f4 ? h3-- : h3++, o3.__u |= 4))) : n3.__k[r3] = null;
    if (a3) for (r3 = 0; r3 < s4; r3++) null != (e3 = u4[r3]) && 0 == (2 & e3.__u) && (e3.__e == t4 && (t4 = S(e3)), B(e3, e3));
    return t4;
  }
  function A(n3, l4, u4) {
    var t4, i4;
    if ("function" == typeof n3.type) {
      for (t4 = n3.__k, i4 = 0; t4 && i4 < t4.length; i4++) t4[i4] && (t4[i4].__ = n3, l4 = A(t4[i4], l4, u4));
      return l4;
    }
    n3.__e != l4 && (l4 && n3.type && !u4.contains(l4) && (l4 = S(n3)), u4.insertBefore(n3.__e, l4 || null), l4 = n3.__e);
    do {
      l4 = l4 && l4.nextSibling;
    } while (null != l4 && 8 == l4.nodeType);
    return l4;
  }
  function H(n3, l4) {
    return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (w(n3) ? n3.some(function(n4) {
      H(n4, l4);
    }) : l4.push(n3)), l4;
  }
  function L(n3, l4, u4, t4) {
    var i4, r3, o3 = n3.key, e3 = n3.type, f4 = l4[u4];
    if (null === f4 && null == n3.key || f4 && o3 == f4.key && e3 == f4.type && 0 == (2 & f4.__u)) return u4;
    if (t4 > (null != f4 && 0 == (2 & f4.__u) ? 1 : 0)) for (i4 = u4 - 1, r3 = u4 + 1; i4 >= 0 || r3 < l4.length; ) {
      if (i4 >= 0) {
        if ((f4 = l4[i4]) && 0 == (2 & f4.__u) && o3 == f4.key && e3 == f4.type) return i4;
        i4--;
      }
      if (r3 < l4.length) {
        if ((f4 = l4[r3]) && 0 == (2 & f4.__u) && o3 == f4.key && e3 == f4.type) return r3;
        r3++;
      }
    }
    return -1;
  }
  function T(n3, l4, u4) {
    "-" == l4[0] ? n3.setProperty(l4, null == u4 ? "" : u4) : n3[l4] = null == u4 ? "" : "number" != typeof u4 || v.test(l4) ? u4 : u4 + "px";
  }
  function j(n3, l4, u4, t4, i4) {
    var r3;
    n: if ("style" == l4) if ("string" == typeof u4) n3.style.cssText = u4;
    else {
      if ("string" == typeof t4 && (n3.style.cssText = t4 = ""), t4) for (l4 in t4) u4 && l4 in u4 || T(n3.style, l4, "");
      if (u4) for (l4 in u4) t4 && u4[l4] == t4[l4] || T(n3.style, l4, u4[l4]);
    }
    else if ("o" == l4[0] && "n" == l4[1]) r3 = l4 != (l4 = l4.replace(f, "$1")), l4 = l4.toLowerCase() in n3 || "onFocusOut" == l4 || "onFocusIn" == l4 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + r3] = u4, u4 ? t4 ? u4.u = t4.u : (u4.u = c, n3.addEventListener(l4, r3 ? a : s, r3)) : n3.removeEventListener(l4, r3 ? a : s, r3);
    else {
      if ("http://www.w3.org/2000/svg" == i4) l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" != l4 && "height" != l4 && "href" != l4 && "list" != l4 && "form" != l4 && "tabIndex" != l4 && "download" != l4 && "rowSpan" != l4 && "colSpan" != l4 && "role" != l4 && "popover" != l4 && l4 in n3) try {
        n3[l4] = null == u4 ? "" : u4;
        break n;
      } catch (n4) {
      }
      "function" == typeof u4 || (null == u4 || false === u4 && "-" != l4[4] ? n3.removeAttribute(l4) : n3.setAttribute(l4, "popover" == l4 && 1 == u4 ? "" : u4));
    }
  }
  function F(n3) {
    return function(u4) {
      if (this.l) {
        var t4 = this.l[u4.type + n3];
        if (null == u4.t) u4.t = c++;
        else if (u4.t < t4.u) return;
        return t4(l.event ? l.event(u4) : u4);
      }
    };
  }
  function O(n3, u4, t4, i4, r3, o3, e3, f4, c3, s4) {
    var a3, h3, p3, y3, v4, _3, m3, b2, S2, C4, M3, $3, P5, A4, H3, L3, T5, j4 = u4.type;
    if (null != u4.constructor) return null;
    128 & t4.__u && (c3 = !!(32 & t4.__u), o3 = [f4 = u4.__e = t4.__e]), (a3 = l.__b) && a3(u4);
    n: if ("function" == typeof j4) try {
      if (b2 = u4.props, S2 = "prototype" in j4 && j4.prototype.render, C4 = (a3 = j4.contextType) && i4[a3.__c], M3 = a3 ? C4 ? C4.props.value : a3.__ : i4, t4.__c ? m3 = (h3 = u4.__c = t4.__c).__ = h3.__E : (S2 ? u4.__c = h3 = new j4(b2, M3) : (u4.__c = h3 = new x(b2, M3), h3.constructor = j4, h3.render = D), C4 && C4.sub(h3), h3.props = b2, h3.state || (h3.state = {}), h3.context = M3, h3.__n = i4, p3 = h3.__d = true, h3.__h = [], h3._sb = []), S2 && null == h3.__s && (h3.__s = h3.state), S2 && null != j4.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = d({}, h3.__s)), d(h3.__s, j4.getDerivedStateFromProps(b2, h3.__s))), y3 = h3.props, v4 = h3.state, h3.__v = u4, p3) S2 && null == j4.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), S2 && null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
      else {
        if (S2 && null == j4.getDerivedStateFromProps && b2 !== y3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(b2, M3), !h3.__e && null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(b2, h3.__s, M3) || u4.__v == t4.__v) {
          for (u4.__v != t4.__v && (h3.props = b2, h3.state = h3.__s, h3.__d = false), u4.__e = t4.__e, u4.__k = t4.__k, u4.__k.some(function(n4) {
            n4 && (n4.__ = u4);
          }), $3 = 0; $3 < h3._sb.length; $3++) h3.__h.push(h3._sb[$3]);
          h3._sb = [], h3.__h.length && e3.push(h3);
          break n;
        }
        null != h3.componentWillUpdate && h3.componentWillUpdate(b2, h3.__s, M3), S2 && null != h3.componentDidUpdate && h3.__h.push(function() {
          h3.componentDidUpdate(y3, v4, _3);
        });
      }
      if (h3.context = M3, h3.props = b2, h3.__P = n3, h3.__e = false, P5 = l.__r, A4 = 0, S2) {
        for (h3.state = h3.__s, h3.__d = false, P5 && P5(u4), a3 = h3.render(h3.props, h3.state, h3.context), H3 = 0; H3 < h3._sb.length; H3++) h3.__h.push(h3._sb[H3]);
        h3._sb = [];
      } else do {
        h3.__d = false, P5 && P5(u4), a3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
      } while (h3.__d && ++A4 < 25);
      h3.state = h3.__s, null != h3.getChildContext && (i4 = d(d({}, i4), h3.getChildContext())), S2 && !p3 && null != h3.getSnapshotBeforeUpdate && (_3 = h3.getSnapshotBeforeUpdate(y3, v4)), L3 = a3, null != a3 && a3.type === k && null == a3.key && (L3 = N(a3.props.children)), f4 = I(n3, w(L3) ? L3 : [L3], u4, t4, i4, r3, o3, e3, f4, c3, s4), h3.base = u4.__e, u4.__u &= -161, h3.__h.length && e3.push(h3), m3 && (h3.__E = h3.__ = null);
    } catch (n4) {
      if (u4.__v = null, c3 || null != o3) if (n4.then) {
        for (u4.__u |= c3 ? 160 : 128; f4 && 8 == f4.nodeType && f4.nextSibling; ) f4 = f4.nextSibling;
        o3[o3.indexOf(f4)] = null, u4.__e = f4;
      } else for (T5 = o3.length; T5--; ) g(o3[T5]);
      else u4.__e = t4.__e, u4.__k = t4.__k;
      l.__e(n4, u4, t4);
    }
    else null == o3 && u4.__v == t4.__v ? (u4.__k = t4.__k, u4.__e = t4.__e) : f4 = u4.__e = V(t4.__e, u4, t4, i4, r3, o3, e3, c3, s4);
    return (a3 = l.diffed) && a3(u4), 128 & u4.__u ? void 0 : f4;
  }
  function z(n3, u4, t4) {
    for (var i4 = 0; i4 < t4.length; i4++) q(t4[i4], t4[++i4], t4[++i4]);
    l.__c && l.__c(u4, n3), n3.some(function(u5) {
      try {
        n3 = u5.__h, u5.__h = [], n3.some(function(n4) {
          n4.call(u5);
        });
      } catch (n4) {
        l.__e(n4, u5.__v);
      }
    });
  }
  function N(n3) {
    return "object" != typeof n3 || null == n3 || n3.__b && n3.__b > 0 ? n3 : w(n3) ? n3.map(N) : d({}, n3);
  }
  function V(u4, t4, i4, r3, o3, e3, f4, c3, s4) {
    var a3, h3, y3, v4, d3, _3, m3, b2 = i4.props, k3 = t4.props, x3 = t4.type;
    if ("svg" == x3 ? o3 = "http://www.w3.org/2000/svg" : "math" == x3 ? o3 = "http://www.w3.org/1998/Math/MathML" : o3 || (o3 = "http://www.w3.org/1999/xhtml"), null != e3) {
      for (a3 = 0; a3 < e3.length; a3++) if ((d3 = e3[a3]) && "setAttribute" in d3 == !!x3 && (x3 ? d3.localName == x3 : 3 == d3.nodeType)) {
        u4 = d3, e3[a3] = null;
        break;
      }
    }
    if (null == u4) {
      if (null == x3) return document.createTextNode(k3);
      u4 = document.createElementNS(o3, x3, k3.is && k3), c3 && (l.__m && l.__m(t4, e3), c3 = false), e3 = null;
    }
    if (null == x3) b2 === k3 || c3 && u4.data == k3 || (u4.data = k3);
    else {
      if (e3 = e3 && n.call(u4.childNodes), b2 = i4.props || p, !c3 && null != e3) for (b2 = {}, a3 = 0; a3 < u4.attributes.length; a3++) b2[(d3 = u4.attributes[a3]).name] = d3.value;
      for (a3 in b2) if (d3 = b2[a3], "children" == a3) ;
      else if ("dangerouslySetInnerHTML" == a3) y3 = d3;
      else if (!(a3 in k3)) {
        if ("value" == a3 && "defaultValue" in k3 || "checked" == a3 && "defaultChecked" in k3) continue;
        j(u4, a3, null, d3, o3);
      }
      for (a3 in k3) d3 = k3[a3], "children" == a3 ? v4 = d3 : "dangerouslySetInnerHTML" == a3 ? h3 = d3 : "value" == a3 ? _3 = d3 : "checked" == a3 ? m3 = d3 : c3 && "function" != typeof d3 || b2[a3] === d3 || j(u4, a3, d3, b2[a3], o3);
      if (h3) c3 || y3 && (h3.__html == y3.__html || h3.__html == u4.innerHTML) || (u4.innerHTML = h3.__html), t4.__k = [];
      else if (y3 && (u4.innerHTML = ""), I("template" == t4.type ? u4.content : u4, w(v4) ? v4 : [v4], t4, i4, r3, "foreignObject" == x3 ? "http://www.w3.org/1999/xhtml" : o3, e3, f4, e3 ? e3[0] : i4.__k && S(i4, 0), c3, s4), null != e3) for (a3 = e3.length; a3--; ) g(e3[a3]);
      c3 || (a3 = "value", "progress" == x3 && null == _3 ? u4.removeAttribute("value") : null != _3 && (_3 !== u4[a3] || "progress" == x3 && !_3 || "option" == x3 && _3 != b2[a3]) && j(u4, a3, _3, b2[a3], o3), a3 = "checked", null != m3 && m3 != u4[a3] && j(u4, a3, m3, b2[a3], o3));
    }
    return u4;
  }
  function q(n3, u4, t4) {
    try {
      if ("function" == typeof n3) {
        var i4 = "function" == typeof n3.__u;
        i4 && n3.__u(), i4 && null == u4 || (n3.__u = n3(u4));
      } else n3.current = u4;
    } catch (n4) {
      l.__e(n4, t4);
    }
  }
  function B(n3, u4, t4) {
    var i4, r3;
    if (l.unmount && l.unmount(n3), (i4 = n3.ref) && (i4.current && i4.current != n3.__e || q(i4, null, u4)), null != (i4 = n3.__c)) {
      if (i4.componentWillUnmount) try {
        i4.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u4);
      }
      i4.base = i4.__P = null;
    }
    if (i4 = n3.__k) for (r3 = 0; r3 < i4.length; r3++) i4[r3] && B(i4[r3], u4, t4 || "function" != typeof n3.type);
    t4 || g(n3.__e), n3.__c = n3.__ = n3.__e = void 0;
  }
  function D(n3, l4, u4) {
    return this.constructor(n3, u4);
  }
  function E(u4, t4, i4) {
    var r3, o3, e3, f4;
    t4 == document && (t4 = document.documentElement), l.__ && l.__(u4, t4), o3 = (r3 = "function" == typeof i4) ? null : i4 && i4.__k || t4.__k, e3 = [], f4 = [], O(t4, u4 = (!r3 && i4 || t4).__k = _(k, null, [u4]), o3 || p, p, t4.namespaceURI, !r3 && i4 ? [i4] : o3 ? null : t4.firstChild ? n.call(t4.childNodes) : null, e3, !r3 && i4 ? i4 : o3 ? o3.__e : t4.firstChild, r3, f4), z(e3, u4, f4);
  }
  function K(n3) {
    function l4(n4) {
      var u4, t4;
      return this.getChildContext || (u4 = /* @__PURE__ */ new Set(), (t4 = {})[l4.__c] = this, this.getChildContext = function() {
        return t4;
      }, this.componentWillUnmount = function() {
        u4 = null;
      }, this.shouldComponentUpdate = function(n5) {
        this.props.value != n5.value && u4.forEach(function(n6) {
          n6.__e = true, M(n6);
        });
      }, this.sub = function(n5) {
        u4.add(n5);
        var l5 = n5.componentWillUnmount;
        n5.componentWillUnmount = function() {
          u4 && u4.delete(n5), l5 && l5.call(n5);
        };
      }), n4.children;
    }
    return l4.__c = "__cC" + h++, l4.__ = n3, l4.Provider = l4.__l = (l4.Consumer = function(n4, l5) {
      return n4.children(l5);
    }).contextType = l4, l4;
  }
  n = y.slice, l = { __e: function(n3, l4, u4, t4) {
    for (var i4, r3, o3; l4 = l4.__; ) if ((i4 = l4.__c) && !i4.__) try {
      if ((r3 = i4.constructor) && null != r3.getDerivedStateFromError && (i4.setState(r3.getDerivedStateFromError(n3)), o3 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n3, t4 || {}), o3 = i4.__d), o3) return i4.__E = i4;
    } catch (l5) {
      n3 = l5;
    }
    throw n3;
  } }, u = 0, t = function(n3) {
    return null != n3 && null == n3.constructor;
  }, x.prototype.setState = function(n3, l4) {
    var u4;
    u4 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d({}, this.state), "function" == typeof n3 && (n3 = n3(d({}, u4), this.props)), n3 && d(u4, n3), null != n3 && this.__v && (l4 && this._sb.push(l4), M(this));
  }, x.prototype.forceUpdate = function(n3) {
    this.__v && (this.__e = true, n3 && this.__h.push(n3), M(this));
  }, x.prototype.render = k, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }, $.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = F(false), a = F(true), h = 0;

  // node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
  var f2 = 0;
  var i2 = Array.isArray;
  function u2(e3, t4, n3, o3, i4, u4) {
    t4 || (t4 = {});
    var a3, c3, p3 = t4;
    if ("ref" in p3) for (c3 in p3 = {}, t4) "ref" == c3 ? a3 = t4[c3] : p3[c3] = t4[c3];
    var l4 = { type: e3, props: p3, key: n3, ref: a3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --f2, __i: -1, __u: 0, __source: i4, __self: u4 };
    if ("function" == typeof e3 && (a3 = e3.defaultProps)) for (c3 in a3) void 0 === p3[c3] && (p3[c3] = a3[c3]);
    return l.vnode && l.vnode(l4), l4;
  }

  // node_modules/preact/hooks/dist/hooks.module.js
  var t2;
  var r2;
  var u3;
  var i3;
  var o2 = 0;
  var f3 = [];
  var c2 = l;
  var e2 = c2.__b;
  var a2 = c2.__r;
  var v2 = c2.diffed;
  var l2 = c2.__c;
  var m2 = c2.unmount;
  var s2 = c2.__;
  function p2(n3, t4) {
    c2.__h && c2.__h(r2, n3, o2 || t4), o2 = 0;
    var u4 = r2.__H || (r2.__H = { __: [], __h: [] });
    return n3 >= u4.__.length && u4.__.push({}), u4.__[n3];
  }
  function d2(n3) {
    return o2 = 1, h2(D2, n3);
  }
  function h2(n3, u4, i4) {
    var o3 = p2(t2++, 2);
    if (o3.t = n3, !o3.__c && (o3.__ = [i4 ? i4(u4) : D2(void 0, u4), function(n4) {
      var t4 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t4, n4);
      t4 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
    }], o3.__c = r2, !r2.__f)) {
      var f4 = function(n4, t4, r3) {
        if (!o3.__c.__H) return true;
        var u5 = o3.__c.__H.__.filter(function(n5) {
          return !!n5.__c;
        });
        if (u5.every(function(n5) {
          return !n5.__N;
        })) return !c3 || c3.call(this, n4, t4, r3);
        var i5 = o3.__c.props !== n4;
        return u5.forEach(function(n5) {
          if (n5.__N) {
            var t5 = n5.__[0];
            n5.__ = n5.__N, n5.__N = void 0, t5 !== n5.__[0] && (i5 = true);
          }
        }), c3 && c3.call(this, n4, t4, r3) || i5;
      };
      r2.__f = true;
      var c3 = r2.shouldComponentUpdate, e3 = r2.componentWillUpdate;
      r2.componentWillUpdate = function(n4, t4, r3) {
        if (this.__e) {
          var u5 = c3;
          c3 = void 0, f4(n4, t4, r3), c3 = u5;
        }
        e3 && e3.call(this, n4, t4, r3);
      }, r2.shouldComponentUpdate = f4;
    }
    return o3.__N || o3.__;
  }
  function y2(n3, u4) {
    var i4 = p2(t2++, 3);
    !c2.__s && C2(i4.__H, u4) && (i4.__ = n3, i4.u = u4, r2.__H.__h.push(i4));
  }
  function _2(n3, u4) {
    var i4 = p2(t2++, 4);
    !c2.__s && C2(i4.__H, u4) && (i4.__ = n3, i4.u = u4, r2.__h.push(i4));
  }
  function A2(n3) {
    return o2 = 5, T2(function() {
      return { current: n3 };
    }, []);
  }
  function T2(n3, r3) {
    var u4 = p2(t2++, 7);
    return C2(u4.__H, r3) && (u4.__ = n3(), u4.__H = r3, u4.__h = n3), u4.__;
  }
  function q2(n3, t4) {
    return o2 = 8, T2(function() {
      return n3;
    }, t4);
  }
  function x2(n3) {
    var u4 = r2.context[n3.__c], i4 = p2(t2++, 9);
    return i4.c = n3, u4 ? (null == i4.__ && (i4.__ = true, u4.sub(r2)), u4.props.value) : n3.__;
  }
  function j2() {
    for (var n3; n3 = f3.shift(); ) if (n3.__P && n3.__H) try {
      n3.__H.__h.forEach(z2), n3.__H.__h.forEach(B2), n3.__H.__h = [];
    } catch (t4) {
      n3.__H.__h = [], c2.__e(t4, n3.__v);
    }
  }
  c2.__b = function(n3) {
    r2 = null, e2 && e2(n3);
  }, c2.__ = function(n3, t4) {
    n3 && t4.__k && t4.__k.__m && (n3.__m = t4.__k.__m), s2 && s2(n3, t4);
  }, c2.__r = function(n3) {
    a2 && a2(n3), t2 = 0;
    var i4 = (r2 = n3.__c).__H;
    i4 && (u3 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n4) {
      n4.__N && (n4.__ = n4.__N), n4.u = n4.__N = void 0;
    })) : (i4.__h.forEach(z2), i4.__h.forEach(B2), i4.__h = [], t2 = 0)), u3 = r2;
  }, c2.diffed = function(n3) {
    v2 && v2(n3);
    var t4 = n3.__c;
    t4 && t4.__H && (t4.__H.__h.length && (1 !== f3.push(t4) && i3 === c2.requestAnimationFrame || ((i3 = c2.requestAnimationFrame) || w2)(j2)), t4.__H.__.forEach(function(n4) {
      n4.u && (n4.__H = n4.u), n4.u = void 0;
    })), u3 = r2 = null;
  }, c2.__c = function(n3, t4) {
    t4.some(function(n4) {
      try {
        n4.__h.forEach(z2), n4.__h = n4.__h.filter(function(n5) {
          return !n5.__ || B2(n5);
        });
      } catch (r3) {
        t4.some(function(n5) {
          n5.__h && (n5.__h = []);
        }), t4 = [], c2.__e(r3, n4.__v);
      }
    }), l2 && l2(n3, t4);
  }, c2.unmount = function(n3) {
    m2 && m2(n3);
    var t4, r3 = n3.__c;
    r3 && r3.__H && (r3.__H.__.forEach(function(n4) {
      try {
        z2(n4);
      } catch (n5) {
        t4 = n5;
      }
    }), r3.__H = void 0, t4 && c2.__e(t4, r3.__v));
  };
  var k2 = "function" == typeof requestAnimationFrame;
  function w2(n3) {
    var t4, r3 = function() {
      clearTimeout(u4), k2 && cancelAnimationFrame(t4), setTimeout(n3);
    }, u4 = setTimeout(r3, 100);
    k2 && (t4 = requestAnimationFrame(r3));
  }
  function z2(n3) {
    var t4 = r2, u4 = n3.__c;
    "function" == typeof u4 && (n3.__c = void 0, u4()), r2 = t4;
  }
  function B2(n3) {
    var t4 = r2;
    n3.__c = n3.__(), r2 = t4;
  }
  function C2(n3, t4) {
    return !n3 || n3.length !== t4.length || t4.some(function(t5, r3) {
      return t5 !== n3[r3];
    });
  }
  function D2(n3, t4) {
    return "function" == typeof t4 ? t4(n3) : t4;
  }

  // node_modules/@bpmn-io/form-js-viewer/dist/index.es.js
  var import_isEqual = __toESM(require_isEqual());

  // node_modules/luxon/src/errors.js
  var LuxonError = class extends Error {
  };
  var InvalidDateTimeError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  };
  var InvalidIntervalError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  };
  var InvalidDurationError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  };
  var ConflictingSpecificationError = class extends LuxonError {
  };
  var InvalidUnitError = class extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  };
  var InvalidArgumentError = class extends LuxonError {
  };
  var ZoneIsAbstractError = class extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  };

  // node_modules/luxon/src/impl/formats.js
  var n2 = "numeric";
  var s3 = "short";
  var l3 = "long";
  var DATE_SHORT = {
    year: n2,
    month: n2,
    day: n2
  };
  var DATE_MED = {
    year: n2,
    month: s3,
    day: n2
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n2,
    month: s3,
    day: n2,
    weekday: s3
  };
  var DATE_FULL = {
    year: n2,
    month: l3,
    day: n2
  };
  var DATE_HUGE = {
    year: n2,
    month: l3,
    day: n2,
    weekday: l3
  };
  var TIME_SIMPLE = {
    hour: n2,
    minute: n2
  };
  var TIME_WITH_SECONDS = {
    hour: n2,
    minute: n2,
    second: n2
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: s3
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: l3
  };
  var TIME_24_SIMPLE = {
    hour: n2,
    minute: n2,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23",
    timeZoneName: s3
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23",
    timeZoneName: l3
  };
  var DATETIME_SHORT = {
    year: n2,
    month: n2,
    day: n2,
    hour: n2,
    minute: n2
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n2,
    month: n2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2
  };
  var DATETIME_MED = {
    year: n2,
    month: s3,
    day: n2,
    hour: n2,
    minute: n2
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n2,
    month: s3,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n2,
    month: s3,
    day: n2,
    weekday: s3,
    hour: n2,
    minute: n2
  };
  var DATETIME_FULL = {
    year: n2,
    month: l3,
    day: n2,
    hour: n2,
    minute: n2,
    timeZoneName: s3
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n2,
    month: l3,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: s3
  };
  var DATETIME_HUGE = {
    year: n2,
    month: l3,
    day: n2,
    weekday: l3,
    hour: n2,
    minute: n2,
    timeZoneName: l3
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n2,
    month: l3,
    day: n2,
    weekday: l3,
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: l3
  };

  // node_modules/luxon/src/zone.js
  var Zone = class {
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get type() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
    get name() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The IANA name of this zone.
     * Defaults to `name` if not overwritten by a subclass.
     * @abstract
     * @type {string}
     */
    get ianaName() {
      return this.name;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
    get isUniversal() {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's value as a string
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is equal to another zone
     * @abstract
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is valid.
     * @abstract
     * @type {boolean}
     */
    get isValid() {
      throw new ZoneIsAbstractError();
    }
  };

  // node_modules/luxon/src/zones/systemZone.js
  var singleton = null;
  var SystemZone = class _SystemZone extends Zone {
    /**
     * Get a singleton instance of the local zone
     * @return {SystemZone}
     */
    static get instance() {
      if (singleton === null) {
        singleton = new _SystemZone();
      }
      return singleton;
    }
    /** @override **/
    get type() {
      return "system";
    }
    /** @override **/
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName(ts, { format, locale }) {
      return parseZoneInfo(ts, format, locale);
    }
    /** @override **/
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    /** @override **/
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    /** @override **/
    equals(otherZone) {
      return otherZone.type === "system";
    }
    /** @override **/
    get isValid() {
      return true;
    }
  };

  // node_modules/luxon/src/zones/IANAZone.js
  var dtfCache = /* @__PURE__ */ new Map();
  function makeDTF(zoneName) {
    let dtf = dtfCache.get(zoneName);
    if (dtf === void 0) {
      dtf = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zoneName,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
      dtfCache.set(zoneName, dtf);
    }
    return dtf;
  }
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  function hackyOffset(dtf, date3) {
    const formatted = dtf.format(date3).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  }
  function partsOffset(dtf, date3) {
    const formatted = dtf.formatToParts(date3);
    const filled = [];
    for (let i4 = 0; i4 < formatted.length; i4++) {
      const { type: type3, value } = formatted[i4];
      const pos = typeToPos[type3];
      if (type3 === "era") {
        filled[pos] = value;
      } else if (!isUndefined2(pos)) {
        filled[pos] = parseInt(value, 10);
      }
    }
    return filled;
  }
  var ianaZoneCache = /* @__PURE__ */ new Map();
  var IANAZone = class _IANAZone extends Zone {
    /**
     * @param {string} name - Zone name
     * @return {IANAZone}
     */
    static create(name2) {
      let zone = ianaZoneCache.get(name2);
      if (zone === void 0) {
        ianaZoneCache.set(name2, zone = new _IANAZone(name2));
      }
      return zone;
    }
    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCache() {
      ianaZoneCache.clear();
      dtfCache.clear();
    }
    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
     * @return {boolean}
     */
    static isValidSpecifier(s4) {
      return this.isValidZone(s4);
    }
    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
        return true;
      } catch (e3) {
        return false;
      }
    }
    constructor(name2) {
      super();
      this.zoneName = name2;
      this.valid = _IANAZone.isValidZone(name2);
    }
    /**
     * The type of zone. `iana` for all instances of `IANAZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "iana";
    }
    /**
     * The name of this zone (i.e. the IANA zone name).
     * @override
     * @type {string}
     */
    get name() {
      return this.zoneName;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns false for all IANA zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return false;
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, { format, locale }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @override
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      if (!this.valid) return NaN;
      const date3 = new Date(ts);
      if (isNaN(date3)) return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date3) : hackyOffset(dtf, date3);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0
      });
      let asTS = +date3;
      const over = asTS % 1e3;
      asTS -= over >= 0 ? over : 1e3 + over;
      return (asUTC - asTS) / (60 * 1e3);
    }
    /**
     * Return whether this Zone is equal to another zone
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    /**
     * Return whether this Zone is valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return this.valid;
    }
  };

  // node_modules/luxon/src/impl/locale.js
  var intlLFCache = {};
  function getCachedLF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  }
  var intlDTCache = /* @__PURE__ */ new Map();
  function getCachedDTF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache.get(key);
    if (dtf === void 0) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache.set(key, dtf);
    }
    return dtf;
  }
  var intlNumCache = /* @__PURE__ */ new Map();
  function getCachedINF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache.get(key);
    if (inf === void 0) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache.set(key, inf);
    }
    return inf;
  }
  var intlRelCache = /* @__PURE__ */ new Map();
  function getCachedRTF(locString, opts = {}) {
    const { base: base2, ...cacheKeyOpts } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache.get(key);
    if (inf === void 0) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache.set(key, inf);
    }
    return inf;
  }
  var sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  }
  var intlResolvedOptionsCache = /* @__PURE__ */ new Map();
  function getCachedIntResolvedOptions(locString) {
    let opts = intlResolvedOptionsCache.get(locString);
    if (opts === void 0) {
      opts = new Intl.DateTimeFormat(locString).resolvedOptions();
      intlResolvedOptionsCache.set(locString, opts);
    }
    return opts;
  }
  var weekInfoCache = /* @__PURE__ */ new Map();
  function getCachedWeekInfo(locString) {
    let data = weekInfoCache.get(locString);
    if (!data) {
      const locale = new Intl.Locale(locString);
      data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
      if (!("minimalDays" in data)) {
        data = { ...fallbackWeekSettings, ...data };
      }
      weekInfoCache.set(locString, data);
    }
    return data;
  }
  function parseLocaleString(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options2;
      let selectedStr;
      try {
        options2 = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e3) {
        const smaller = localeStr.substring(0, uIndex);
        options2 = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const { numberingSystem, calendar } = options2;
      return [selectedStr, numberingSystem, calendar];
    }
  }
  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  }
  function mapMonths(f4) {
    const ms = [];
    for (let i4 = 1; i4 <= 12; i4++) {
      const dt = DateTime.utc(2009, i4, 1);
      ms.push(f4(dt));
    }
    return ms;
  }
  function mapWeekdays(f4) {
    const ms = [];
    for (let i4 = 1; i4 <= 7; i4++) {
      const dt = DateTime.utc(2016, 11, 13 + i4);
      ms.push(f4(dt));
    }
    return ms;
  }
  function listStuff(loc, length, englishFn, intlFn) {
    const mode3 = loc.listingMode();
    if (mode3 === "error") {
      return null;
    } else if (mode3 === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  }
  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || getCachedIntResolvedOptions(loc.locale).numberingSystem === "latn";
    }
  }
  var PolyNumberFormatter = class {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const { padTo, floor, ...otherOpts } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = { useGrouping: false, ...opts };
        if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i4) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i4) : i4;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i4) : roundTo(i4, 3);
        return padStart(fixed, this.padTo);
      }
    }
  };
  var PolyDateFormatter = class {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = void 0;
      let z4 = void 0;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z4 = offsetZ;
          this.dt = dt;
        } else {
          z4 = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z4 = dt.zone.name;
      } else {
        z4 = "UTC";
        this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
      const intlOpts = { ...this.opts };
      intlOpts.timeZone = intlOpts.timeZone || z4;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({ value }) => value).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  };
  var PolyRelFormatter = class {
    constructor(intl, isEnglish, opts) {
      this.opts = { style: "long", ...opts };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  };
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };
  var Locale = class _Locale {
    static fromOpts(opts) {
      return _Locale.create(
        opts.locale,
        opts.numberingSystem,
        opts.outputCalendar,
        opts.weekSettings,
        opts.defaultToEN
      );
    }
    static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache.clear();
      intlNumCache.clear();
      intlRelCache.clear();
      intlResolvedOptionsCache.clear();
      weekInfoCache.clear();
    }
    static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
      return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = { format: {}, standalone: {} };
      this.monthsCache = { format: {}, standalone: {} };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return _Locale.create(
          alts.locale || this.specifiedLocale,
          alts.numberingSystem || this.numberingSystem,
          alts.outputCalendar || this.outputCalendar,
          validateWeekSettings(alts.weekSettings) || this.weekSettings,
          alts.defaultToEN || false
        );
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({ ...alts, defaultToEN: true });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({ ...alts, defaultToEN: false });
    }
    months(length, format = false) {
      return listStuff(this, length, months, () => {
        const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length];
      });
    }
    weekdays(length, format = false) {
      return listStuff(this, length, weekdays, () => {
        const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays(
            (dt) => this.extract(dt, intl, "weekday")
          );
        }
        return this.weekdaysCache[formatStr][length];
      });
    }
    meridiems() {
      return listStuff(
        this,
        void 0,
        () => meridiems,
        () => {
          if (!this.meridiemCache) {
            const intl = { hour: "numeric", hourCycle: "h12" };
            this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
              (dt) => this.extract(dt, intl, "dayperiod")
            );
          }
          return this.meridiemCache;
        }
      );
    }
    eras(length) {
      return listStuff(this, length, eras, () => {
        const intl = { era: length };
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
            (dt) => this.extract(dt, intl, "era")
          );
        }
        return this.eraCache[length];
      });
    }
    extract(dt, intlOpts, field) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || getCachedIntResolvedOptions(this.intl).locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other2) {
      return this.locale === other2.locale && this.numberingSystem === other2.numberingSystem && this.outputCalendar === other2.outputCalendar;
    }
    toString() {
      return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
    }
  };

  // node_modules/luxon/src/zones/fixedOffsetZone.js
  var singleton2 = null;
  var FixedOffsetZone = class _FixedOffsetZone extends Zone {
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    static get utcInstance() {
      if (singleton2 === null) {
        singleton2 = new _FixedOffsetZone(0);
      }
      return singleton2;
    }
    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    static instance(offset2) {
      return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
    }
    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    static parseSpecifier(s4) {
      if (s4) {
        const r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r3) {
          return new _FixedOffsetZone(signedOffset(r3[1], r3[2]));
        }
      }
      return null;
    }
    constructor(offset2) {
      super();
      this.fixed = offset2;
    }
    /**
     * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "fixed";
    }
    /**
     * The name of this zone.
     * All fixed zones' names always start with "UTC" (plus optional offset)
     * @override
     * @type {string}
     */
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    /**
     * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
     *
     * @override
     * @type {string}
     */
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    /**
     * Returns the offset's common name at the specified timestamp.
     *
     * For fixed offset zones this equals to the zone name.
     * @override
     */
    offsetName() {
      return this.name;
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns true for all fixed offset zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return true;
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     *
     * For fixed offset zones, this is constant and does not depend on a timestamp.
     * @override
     * @return {number}
     */
    offset() {
      return this.fixed;
    }
    /**
     * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    /**
     * Return whether this Zone is valid:
     * All fixed offset zones are valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return true;
    }
  };

  // node_modules/luxon/src/zones/invalidZone.js
  var InvalidZone = class extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    /** @override **/
    get type() {
      return "invalid";
    }
    /** @override **/
    get name() {
      return this.zoneName;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName() {
      return null;
    }
    /** @override **/
    formatOffset() {
      return "";
    }
    /** @override **/
    offset() {
      return NaN;
    }
    /** @override **/
    equals() {
      return false;
    }
    /** @override **/
    get isValid() {
      return false;
    }
  };

  // node_modules/luxon/src/impl/zoneUtil.js
  function normalizeZone(input, defaultZone2) {
    let offset2;
    if (isUndefined2(input) || input === null) {
      return defaultZone2;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString2(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default") return defaultZone2;
      else if (lowered === "local" || lowered === "system") return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
      else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber2(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
      return input;
    } else {
      return new InvalidZone(input);
    }
  }

  // node_modules/luxon/src/impl/digits.js
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  function parseDigits(str) {
    let value = parseInt(str, 10);
    if (isNaN(value)) {
      value = "";
      for (let i4 = 0; i4 < str.length; i4++) {
        const code = str.charCodeAt(i4);
        if (str[i4].search(numberingSystems.hanidec) !== -1) {
          value += hanidecChars.indexOf(str[i4]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value += code - min;
            }
          }
        }
      }
      return parseInt(value, 10);
    } else {
      return value;
    }
  }
  var digitRegexCache = /* @__PURE__ */ new Map();
  function resetDigitRegexCache() {
    digitRegexCache.clear();
  }
  function digitRegex({ numberingSystem }, append = "") {
    const ns = numberingSystem || "latn";
    let appendCache = digitRegexCache.get(ns);
    if (appendCache === void 0) {
      appendCache = /* @__PURE__ */ new Map();
      digitRegexCache.set(ns, appendCache);
    }
    let regex = appendCache.get(append);
    if (regex === void 0) {
      regex = new RegExp(`${numberingSystems[ns]}${append}`);
      appendCache.set(append, regex);
    }
    return regex;
  }

  // node_modules/luxon/src/settings.js
  var now = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;
  var Settings = class {
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    static get now() {
      return now;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    static set now(n3) {
      now = n3;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * Use the value "system" to reset this value to the system's time zone.
     * @type {string}
     */
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    /**
     * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
     * The default value is the system's time zone (the one set on the machine that runs this code).
     * @type {Zone}
     */
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultLocale() {
      return defaultLocale;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    /**
     * @typedef {Object} WeekSettings
     * @property {number} firstDay
     * @property {number} minimalDays
     * @property {number[]} weekend
     */
    /**
     * @return {WeekSettings|null}
     */
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    /**
     * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
     * how many days are required in the first week of a year.
     * Does not affect existing instances.
     *
     * @param {WeekSettings|null} weekSettings
     */
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    /**
     * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     */
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    /**
     * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
     * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
     * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
     * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
     * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
     */
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static set throwOnInvalid(t4) {
      throwOnInvalid = t4;
    }
    /**
     * Reset Luxon's global caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
      DateTime.resetCache();
      resetDigitRegexCache();
    }
  };

  // node_modules/luxon/src/impl/invalid.js
  var Invalid = class {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  };

  // node_modules/luxon/src/impl/conversions.js
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  function unitOutOfRange(unit, value) {
    return new Invalid(
      "unit out of range",
      `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
    );
  }
  function dayOfWeek(year, month, day) {
    const d3 = new Date(Date.UTC(year, month - 1, day));
    if (year < 100 && year >= 0) {
      d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
    }
    const js = d3.getUTCDay();
    return js === 0 ? 7 : js;
  }
  function computeOrdinal(year, month, day) {
    return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  }
  function uncomputeOrdinal(year, ordinal) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i4) => i4 < ordinal), day = ordinal - table[month0];
    return { month: month0 + 1, day };
  }
  function isoWeekdayToLocal(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  }
  function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
    let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
  }
  function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const { month, day } = uncomputeOrdinal(year, ordinal);
    return { year, month, day, ...timeObject(weekData) };
  }
  function gregorianToOrdinal(gregData) {
    const { year, month, day } = gregData;
    const ordinal = computeOrdinal(year, month, day);
    return { year, ordinal, ...timeObject(gregData) };
  }
  function ordinalToGregorian(ordinalData) {
    const { year, ordinal } = ordinalData;
    const { month, day } = uncomputeOrdinal(year, ordinal);
    return { year, month, day, ...timeObject(ordinalData) };
  }
  function usesLocalWeekValues(obj, loc) {
    const hasLocaleWeekData = !isUndefined2(obj.localWeekday) || !isUndefined2(obj.localWeekNumber) || !isUndefined2(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined2(obj.weekday) || !isUndefined2(obj.weekNumber) || !isUndefined2(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError(
          "Cannot mix locale-based week fields with ISO-based week fields"
        );
      }
      if (!isUndefined2(obj.localWeekday)) obj.weekday = obj.localWeekday;
      if (!isUndefined2(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined2(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return { minDaysInFirstWeek: 4, startOfWeek: 1 };
    }
  }
  function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
      obj.weekNumber,
      1,
      weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
    ), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else return false;
  }
  function hasInvalidOrdinalData(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else return false;
  }
  function hasInvalidGregorianData(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else return false;
  }
  function hasInvalidTimeData(obj) {
    const { hour, minute, second, millisecond } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else return false;
  }

  // node_modules/luxon/src/impl/util.js
  function isUndefined2(o3) {
    return typeof o3 === "undefined";
  }
  function isNumber2(o3) {
    return typeof o3 === "number";
  }
  function isInteger(o3) {
    return typeof o3 === "number" && o3 % 1 === 0;
  }
  function isString2(o3) {
    return typeof o3 === "string";
  }
  function isDate(o3) {
    return Object.prototype.toString.call(o3) === "[object Date]";
  }
  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e3) {
      return false;
    }
  }
  function hasLocaleWeekInfo() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
    } catch (e3) {
      return false;
    }
  }
  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }
  function bestBy(arr, by, compare2) {
    if (arr.length === 0) {
      return void 0;
    }
    return arr.reduce((best, next) => {
      const pair2 = [by(next), next];
      if (!best) {
        return pair2;
      } else if (compare2(best[0], pair2[0]) === best[0]) {
        return best;
      } else {
        return pair2;
      }
    }, null)[1];
  }
  function pick(obj, keys) {
    return keys.reduce((a3, k3) => {
      a3[k3] = obj[k3];
      return a3;
    }, {});
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function validateWeekSettings(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v4) => !integerBetween(v4, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  }
  function integerBetween(thing, bottom, top2) {
    return isInteger(thing) && thing >= bottom && thing <= top2;
  }
  function floorMod(x3, n3) {
    return x3 - n3 * Math.floor(x3 / n3);
  }
  function padStart(input, n3 = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n3, "0");
    } else {
      padded = ("" + input).padStart(n3, "0");
    }
    return padded;
  }
  function parseInteger(string2) {
    if (isUndefined2(string2) || string2 === null || string2 === "") {
      return void 0;
    } else {
      return parseInt(string2, 10);
    }
  }
  function parseFloating(string2) {
    if (isUndefined2(string2) || string2 === null || string2 === "") {
      return void 0;
    } else {
      return parseFloat(string2);
    }
  }
  function parseMillis(fraction) {
    if (isUndefined2(fraction) || fraction === null || fraction === "") {
      return void 0;
    } else {
      const f4 = parseFloat("0." + fraction) * 1e3;
      return Math.floor(f4);
    }
  }
  function roundTo(number2, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number2 * factor) / factor;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function daysInMonth(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }
  function objToLocalTS(obj) {
    let d3 = Date.UTC(
      obj.year,
      obj.month - 1,
      obj.day,
      obj.hour,
      obj.minute,
      obj.second,
      obj.millisecond
    );
    if (obj.year < 100 && obj.year >= 0) {
      d3 = new Date(d3);
      d3.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d3;
  }
  function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  }
  function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  }
  function untruncateYear(year) {
    if (year > 99) {
      return year;
    } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
  }
  function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
    const date3 = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = { timeZoneName: offsetFormat, ...intlOpts };
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date3).find((m3) => m3.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  }
  function signedOffset(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }
  function asNumber(value) {
    const numericValue = Number(value);
    if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value}`);
    return numericValue;
  }
  function normalizeObject(obj, normalizer) {
    const normalized = {};
    for (const u4 in obj) {
      if (hasOwnProperty(obj, u4)) {
        const v4 = obj[u4];
        if (v4 === void 0 || v4 === null) continue;
        normalized[normalizer(u4)] = asNumber(v4);
      }
    }
    return normalized;
  }
  function formatOffset(offset2, format) {
    const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
    switch (format) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  }
  function timeObject(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  }

  // node_modules/luxon/src/impl/english.js
  var monthsLong = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthsShort = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  function months(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }
  var weekdaysLong = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
  ];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  function weekdays(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  function eras(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  }
  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }
  function weekdayForDateTime(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  }
  function monthForDateTime(dt, length) {
    return months(length)[dt.month - 1];
  }
  function eraForDateTime(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  }
  function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
        default:
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  }

  // node_modules/luxon/src/impl/formatter.js
  function stringifyTokens(splits, tokenToString) {
    let s4 = "";
    for (const token of splits) {
      if (token.literal) {
        s4 += token.val;
      } else {
        s4 += tokenToString(token.val);
      }
    }
    return s4;
  }
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };
  var Formatter = class _Formatter {
    static create(locale, opts = {}) {
      return new _Formatter(locale, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i4 = 0; i4 < fmt.length; i4++) {
        const c3 = fmt.charAt(i4);
        if (c3 === "'") {
          if (currentFull.length > 0) {
            splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c3;
        } else if (c3 === current) {
          currentFull += c3;
        } else {
          if (currentFull.length > 0) {
            splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
          }
          currentFull = c3;
          current = c3;
        }
      }
      if (currentFull.length > 0) {
        splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }
    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n3, p3 = 0) {
      if (this.opts.forceSimple) {
        return padStart(n3, p3);
      }
      const opts = { ...this.opts };
      if (p3 > 0) {
        opts.padTo = p3;
      }
      return this.loc.numberFormatter(opts).format(n3);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string2(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string2(
        standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
        "weekday"
      ), maybeMacro = (token) => {
        const formatOpts = _Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string2({ era: length }, "era"), tokenToString = (token) => {
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          // zone
          case "z":
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          // months - standalone
          case "L":
            return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          // months - format
          case "M":
            return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          // years
          case "y":
            return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
          // eras
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1e3));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
      return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
        (found, { literal: literal2, val }) => literal2 ? found : found.concat(val),
        []
      ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t4) => t4));
      return stringifyTokens(tokens, tokenToString(collapsed));
    }
  };

  // node_modules/luxon/src/impl/regexParser.js
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  function combineRegexes(...regexes) {
    const full = regexes.reduce((f4, r3) => f4 + r3.source, "");
    return RegExp(`^${full}$`);
  }
  function combineExtractors(...extractors) {
    return (m3) => extractors.reduce(
      ([mergedVals, mergedZone, cursor2], ex) => {
        const [val, zone, next] = ex(m3, cursor2);
        return [{ ...mergedVals, ...val }, zone || mergedZone, next];
      },
      [{}, null, 1]
    ).slice(0, 2);
  }
  function parse2(s4, ...patterns) {
    if (s4 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns) {
      const m3 = regex.exec(s4);
      if (m3) {
        return extractor(m3);
      }
    }
    return [null, null];
  }
  function simpleParse(...keys) {
    return (match2, cursor2) => {
      const ret = {};
      let i4;
      for (i4 = 0; i4 < keys.length; i4++) {
        ret[keys[i4]] = parseInteger(match2[cursor2 + i4]);
      }
      return [ret, null, cursor2 + i4];
    };
  }
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(
    `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
  );
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  function int(match2, pos, fallback) {
    const m3 = match2[pos];
    return isUndefined2(m3) ? fallback : parseInteger(m3);
  }
  function extractISOYmd(match2, cursor2) {
    const item = {
      year: int(match2, cursor2),
      month: int(match2, cursor2 + 1, 1),
      day: int(match2, cursor2 + 2, 1)
    };
    return [item, null, cursor2 + 3];
  }
  function extractISOTime(match2, cursor2) {
    const item = {
      hours: int(match2, cursor2, 0),
      minutes: int(match2, cursor2 + 1, 0),
      seconds: int(match2, cursor2 + 2, 0),
      milliseconds: parseMillis(match2[cursor2 + 3])
    };
    return [item, null, cursor2 + 4];
  }
  function extractISOOffset(match2, cursor2) {
    const local = !match2[cursor2] && !match2[cursor2 + 1], fullOffset = signedOffset(match2[cursor2 + 1], match2[cursor2 + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor2 + 3];
  }
  function extractIANAZone(match2, cursor2) {
    const zone = match2[cursor2] ? IANAZone.create(match2[cursor2]) : null;
    return [{}, zone, cursor2 + 1];
  }
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  function extractISODuration(match2) {
    const [s4, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s4[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
    return [
      {
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }
    ];
  }
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr) result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  }
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  function extractRFC2822(match2) {
    const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr
    ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset2;
    if (obsOffset) {
      offset2 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset2 = 0;
    } else {
      offset2 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset2)];
  }
  function preprocessRFC2822(s4) {
    return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  }
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  function extractRFC1123Or850(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  function extractASCII(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOWeekTimeAndOffset = combineExtractors(
    extractISOWeekData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOOrdinalDateAndTime = combineExtractors(
    extractISOOrdinalData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOTimeAndOffset = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseISODate(s4) {
    return parse2(
      s4,
      [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
      [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
      [isoTimeCombinedRegex, extractISOTimeAndOffset]
    );
  }
  function parseRFC2822Date(s4) {
    return parse2(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
  }
  function parseHTTPDate(s4) {
    return parse2(
      s4,
      [rfc1123, extractRFC1123Or850],
      [rfc850, extractRFC1123Or850],
      [ascii, extractASCII]
    );
  }
  function parseISODuration(s4) {
    return parse2(s4, [isoDuration, extractISODuration]);
  }
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  function parseISOTimeOnly(s4) {
    return parse2(s4, [isoTimeOnly, extractISOTimeOnly]);
  }
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseSQL(s4) {
    return parse2(
      s4,
      [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
    );
  }

  // node_modules/luxon/src/duration.js
  var INVALID2 = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1e3
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1e3
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1e3
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var orderedUnits = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ];
  var reverseUnits = orderedUnits.slice(0).reverse();
  function clone(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  }
  function durationToMillis(matrix, vals) {
    let sum3 = vals.milliseconds ?? 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum3 += vals[unit] * matrix[unit]["milliseconds"];
      }
    }
    return sum3;
  }
  function normalizeValues(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits.reduceRight((previous, current) => {
      if (!isUndefined2(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits.reduce((previous, current) => {
      if (!isUndefined2(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }
  function removeZeroes(vals) {
    const newVals = {};
    for (const [key, value] of Object.entries(vals)) {
      if (value !== 0) {
        newVals[key] = value;
      }
    }
    return newVals;
  }
  var Duration = class _Duration {
    /**
     * @private
     */
    constructor(config2) {
      const accurate = config2.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config2.matrix) {
        matrix = config2.matrix;
      }
      this.values = config2.values;
      this.loc = config2.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config2.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    /**
     * Create Duration from a number of milliseconds.
     * @param {number} count of milliseconds
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    static fromMillis(count, opts) {
      return _Duration.fromObject({ milliseconds: count }, opts);
    }
    /**
     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
     * If this object is empty then a zero milliseconds duration is returned.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.years
     * @param {number} obj.quarters
     * @param {number} obj.months
     * @param {number} obj.weeks
     * @param {number} obj.days
     * @param {number} obj.hours
     * @param {number} obj.minutes
     * @param {number} obj.seconds
     * @param {number} obj.milliseconds
     * @param {Object} [opts=[]] - options for creating this Duration
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the custom conversion system to use
     * @return {Duration}
     */
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(
          `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
        );
      }
      return new _Duration({
        values: normalizeObject(obj, _Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    /**
     * Create a Duration from DurationLike.
     *
     * @param {Object | number | Duration} durationLike
     * One of:
     * - object with keys like 'years' and 'hours'.
     * - number representing milliseconds
     * - Duration instance
     * @return {Duration}
     */
    static fromDurationLike(durationLike) {
      if (isNumber2(durationLike)) {
        return _Duration.fromMillis(durationLike);
      } else if (_Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return _Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(
          `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
        );
      }
    }
    /**
     * Create a Duration from an ISO 8601 duration string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the preset conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
     * @return {Duration}
     */
    static fromISO(text2, opts) {
      const [parsed] = parseISODuration(text2);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create a Duration from an ISO 8601 time string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @return {Duration}
     */
    static fromISOTime(text2, opts) {
      const [parsed] = parseISOTimeOnly(text2);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create an invalid Duration.
     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Duration}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid2);
      } else {
        return new _Duration({ invalid: invalid2 });
      }
    }
    /**
     * @private
     */
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized) throw new InvalidUnitError(unit);
      return normalized;
    }
    /**
     * Check if an object is a Duration. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDuration(o3) {
      return o3 && o3.isLuxonDuration || false;
    }
    /**
     * Get  the locale of a Duration, such 'en-GB'
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
     * * `S` for milliseconds
     * * `s` for seconds
     * * `m` for minutes
     * * `h` for hours
     * * `d` for days
     * * `w` for weeks
     * * `M` for months
     * * `y` for years
     * Notes:
     * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
     * * Tokens can be escaped by wrapping with single quotes.
     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
     * @param {string} fmt - the format string
     * @param {Object} opts - options
     * @param {boolean} [opts.floor=true] - floor numerical values
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID2;
    }
    /**
     * Returns a string representation of a Duration with all units included.
     * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
     * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
     * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
     * @example
     * ```js
     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
     * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
     * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
     * ```
     */
    toHuman(opts = {}) {
      if (!this.isValid) return INVALID2;
      const l4 = orderedUnits.map((unit) => {
        const val = this.values[unit];
        if (isUndefined2(val)) {
          return null;
        }
        return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
      }).filter((n3) => n3);
      return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l4);
    }
    /**
     * Returns a JavaScript object with this Duration's values.
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
     * @return {Object}
     */
    toObject() {
      if (!this.isValid) return {};
      return { ...this.values };
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
     * @return {string}
     */
    toISO() {
      if (!this.isValid) return null;
      let s4 = "P";
      if (this.years !== 0) s4 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0) s4 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0) s4 += this.weeks + "W";
      if (this.days !== 0) s4 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s4 += "T";
      if (this.hours !== 0) s4 += this.hours + "H";
      if (this.minutes !== 0) s4 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
      if (s4 === "P") s4 += "T0S";
      return s4;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
     * @return {string}
     */
    toISOTime(opts = {}) {
      if (!this.isValid) return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 864e5) return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
      return dateTime.toISOTime(opts);
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
     * @return {string}
     */
    toString() {
      return this.toISO();
    }
    /**
     * Returns a string representation of this Duration appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns an milliseconds value of this Duration.
     * @return {number}
     */
    toMillis() {
      if (!this.isValid) return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    /**
     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    plus(duration4) {
      if (!this.isValid) return this;
      const dur = _Duration.fromDurationLike(duration4), result = {};
      for (const k3 of orderedUnits) {
        if (hasOwnProperty(dur.values, k3) || hasOwnProperty(this.values, k3)) {
          result[k3] = dur.get(k3) + this.get(k3);
        }
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    minus(duration4) {
      if (!this.isValid) return this;
      const dur = _Duration.fromDurationLike(duration4);
      return this.plus(dur.negate());
    }
    /**
     * Scale this Duration by the specified amount. Return a newly-constructed Duration.
     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
     * @return {Duration}
     */
    mapUnits(fn4) {
      if (!this.isValid) return this;
      const result = {};
      for (const k3 of Object.keys(this.values)) {
        result[k3] = asNumber(fn4(this.values[k3], k3));
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
     * @return {number}
     */
    get(unit) {
      return this[_Duration.normalizeUnit(unit)];
    }
    /**
     * "Set" the values of specified units. Return a newly-constructed Duration.
     * @param {Object} values - a mapping of units to numbers
     * @example dur.set({ years: 2017 })
     * @example dur.set({ hours: 8, minutes: 30 })
     * @return {Duration}
     */
    set(values2) {
      if (!this.isValid) return this;
      const mixed = { ...this.values, ...normalizeObject(values2, _Duration.normalizeUnit) };
      return clone(this, { values: mixed });
    }
    /**
     * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
     * @example dur.reconfigure({ locale: 'en-GB' })
     * @return {Duration}
     */
    reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
      const loc = this.loc.clone({ locale, numberingSystem });
      const opts = { loc, matrix, conversionAccuracy };
      return clone(this, opts);
    }
    /**
     * Return the length of the duration in the specified unit.
     * @param {string} unit - a unit such as 'minutes' or 'days'
     * @example Duration.fromObject({years: 1}).as('days') //=> 365
     * @example Duration.fromObject({years: 1}).as('months') //=> 12
     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
     * @return {number}
     */
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    /**
     * Reduce this Duration to its canonical representation in its current units.
     * Assuming the overall value of the Duration is positive, this means:
     * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
     * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
     *   the overall value would be negative, see third example)
     * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
     *
     * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
     * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
     * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
     * @return {Duration}
     */
    normalize() {
      if (!this.isValid) return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone(this, { values: vals }, true);
    }
    /**
     * Rescale units to its largest representation
     * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
     * @return {Duration}
     */
    rescale() {
      if (!this.isValid) return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone(this, { values: vals }, true);
    }
    /**
     * Convert this Duration into its representation in a different set of units.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
     * @return {Duration}
     */
    shiftTo(...units) {
      if (!this.isValid) return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u4) => _Duration.normalizeUnit(u4));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k3 of orderedUnits) {
        if (units.indexOf(k3) >= 0) {
          lastUnit = k3;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k3] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber2(vals[k3])) {
            own += vals[k3];
          }
          const i4 = Math.trunc(own);
          built[k3] = i4;
          accumulated[k3] = (own * 1e3 - i4 * 1e3) / 1e3;
        } else if (isNumber2(vals[k3])) {
          accumulated[k3] = vals[k3];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone(this, { values: built }, true);
    }
    /**
     * Shift this Duration to all available units.
     * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
     * @return {Duration}
     */
    shiftToAll() {
      if (!this.isValid) return this;
      return this.shiftTo(
        "years",
        "months",
        "weeks",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      );
    }
    /**
     * Return the negative of this Duration.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
     * @return {Duration}
     */
    negate() {
      if (!this.isValid) return this;
      const negated = {};
      for (const k3 of Object.keys(this.values)) {
        negated[k3] = this.values[k3] === 0 ? 0 : -this.values[k3];
      }
      return clone(this, { values: negated }, true);
    }
    /**
     * Get the years.
     * @type {number}
     */
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Equality check
     * Two Durations are equal iff they have the same units and the same values for each unit.
     * @param {Duration} other
     * @return {boolean}
     */
    equals(other2) {
      if (!this.isValid || !other2.isValid) {
        return false;
      }
      if (!this.loc.equals(other2.loc)) {
        return false;
      }
      function eq(v1, v22) {
        if (v1 === void 0 || v1 === 0) return v22 === void 0 || v22 === 0;
        return v1 === v22;
      }
      for (const u4 of orderedUnits) {
        if (!eq(this.values[u4], other2.values[u4])) {
          return false;
        }
      }
      return true;
    }
  };

  // node_modules/luxon/src/interval.js
  var INVALID3 = "Invalid Interval";
  function validateStartEnd(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid(
        "end before start",
        `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
      );
    } else {
      return null;
    }
  }
  var Interval = class _Interval {
    /**
     * @private
     */
    constructor(config2) {
      this.s = config2.start;
      this.e = config2.end;
      this.invalid = config2.invalid || null;
      this.isLuxonInterval = true;
    }
    /**
     * Create an invalid Interval.
     * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Interval}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid2);
      } else {
        return new _Interval({ invalid: invalid2 });
      }
    }
    /**
     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
     * @param {DateTime|Date|Object} start
     * @param {DateTime|Date|Object} end
     * @return {Interval}
     */
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new _Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    /**
     * Create an Interval from a start DateTime and a Duration to extend to.
     * @param {DateTime|Date|Object} start
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static after(start, duration4) {
      const dur = Duration.fromDurationLike(duration4), dt = friendlyDateTime(start);
      return _Interval.fromDateTimes(dt, dt.plus(dur));
    }
    /**
     * Create an Interval from an end DateTime and a Duration to extend backwards to.
     * @param {DateTime|Date|Object} end
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static before(end, duration4) {
      const dur = Duration.fromDurationLike(duration4), dt = friendlyDateTime(end);
      return _Interval.fromDateTimes(dt.minus(dur), dt);
    }
    /**
     * Create an Interval from an ISO 8601 string.
     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
     * @param {string} text - the ISO string to parse
     * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {Interval}
     */
    static fromISO(text2, opts) {
      const [s4, e3] = (text2 || "").split("/", 2);
      if (s4 && e3) {
        let start, startIsValid;
        try {
          start = DateTime.fromISO(s4, opts);
          startIsValid = start.isValid;
        } catch (e4) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e3, opts);
          endIsValid = end.isValid;
        } catch (e4) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return _Interval.fromDateTimes(start, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e3, opts);
          if (dur.isValid) {
            return _Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s4, opts);
          if (dur.isValid) {
            return _Interval.before(end, dur);
          }
        }
      }
      return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
    /**
     * Check if an object is an Interval. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isInterval(o3) {
      return o3 && o3.isLuxonInterval || false;
    }
    /**
     * Returns the start of the Interval
     * @type {DateTime}
     */
    get start() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */
    get end() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns the last DateTime included in the interval (since end is not part of the interval)
     * @type {DateTime}
     */
    get lastDateTime() {
      return this.isValid ? this.e ? this.e.minus(1) : null : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
    get isValid() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Returns the length of the Interval in the specified unit.
     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
     * @return {number}
     */
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    /**
     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
     * @param {string} [unit='milliseconds'] - the unit of time to count.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
     * @return {number}
     */
    count(unit = "milliseconds", opts) {
      if (!this.isValid) return NaN;
      const start = this.start.startOf(unit, opts);
      let end;
      if (opts?.useLocaleWeeks) {
        end = this.end.reconfigure({ locale: start.locale });
      } else {
        end = this.end;
      }
      end = end.startOf(unit, opts);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    /**
     * Returns whether this Interval's start and end are both in the same unit of time
     * @param {string} unit - the unit of time to check sameness on
     * @return {boolean}
     */
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    /**
     * Return whether this Interval has the same start and end DateTimes.
     * @return {boolean}
     */
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    /**
     * Return whether this Interval's start is after the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isAfter(dateTime) {
      if (!this.isValid) return false;
      return this.s > dateTime;
    }
    /**
     * Return whether this Interval's end is before the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isBefore(dateTime) {
      if (!this.isValid) return false;
      return this.e <= dateTime;
    }
    /**
     * Return whether this Interval contains the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    contains(dateTime) {
      if (!this.isValid) return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    /**
     * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
     * @param {Object} values - the values to set
     * @param {DateTime} values.start - the starting DateTime
     * @param {DateTime} values.end - the ending DateTime
     * @return {Interval}
     */
    set({ start, end } = {}) {
      if (!this.isValid) return this;
      return _Interval.fromDateTimes(start || this.s, end || this.e);
    }
    /**
     * Split this Interval at each of the specified DateTimes
     * @param {...DateTime} dateTimes - the unit of time to count.
     * @return {Array}
     */
    splitAt(...dateTimes) {
      if (!this.isValid) return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d3) => this.contains(d3)).sort((a3, b2) => a3.toMillis() - b2.toMillis()), results = [];
      let { s: s4 } = this, i4 = 0;
      while (s4 < this.e) {
        const added = sorted[i4] || this.e, next = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s4, next));
        s4 = next;
        i4 += 1;
      }
      return results;
    }
    /**
     * Split this Interval into smaller Intervals, each of the specified length.
     * Left over time is grouped into a smaller interval
     * @param {Duration|Object|number} duration - The length of each resulting interval.
     * @return {Array}
     */
    splitBy(duration4) {
      const dur = Duration.fromDurationLike(duration4);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let { s: s4 } = this, idx = 1, next;
      const results = [];
      while (s4 < this.e) {
        const added = this.start.plus(dur.mapUnits((x3) => x3 * idx));
        next = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s4, next));
        s4 = next;
        idx += 1;
      }
      return results;
    }
    /**
     * Split this Interval into the specified number of smaller intervals.
     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
     * @return {Array}
     */
    divideEqually(numberOfParts) {
      if (!this.isValid) return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    /**
     * Return whether this Interval overlaps with the specified Interval
     * @param {Interval} other
     * @return {boolean}
     */
    overlaps(other2) {
      return this.e > other2.s && this.s < other2.e;
    }
    /**
     * Return whether this Interval's end is adjacent to the specified Interval's start.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsStart(other2) {
      if (!this.isValid) return false;
      return +this.e === +other2.s;
    }
    /**
     * Return whether this Interval's start is adjacent to the specified Interval's end.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsEnd(other2) {
      if (!this.isValid) return false;
      return +other2.e === +this.s;
    }
    /**
     * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
     * @param {Interval} other
     * @return {boolean}
     */
    engulfs(other2) {
      if (!this.isValid) return false;
      return this.s <= other2.s && this.e >= other2.e;
    }
    /**
     * Return whether this Interval has the same start and end as the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    equals(other2) {
      if (!this.isValid || !other2.isValid) {
        return false;
      }
      return this.s.equals(other2.s) && this.e.equals(other2.e);
    }
    /**
     * Return an Interval representing the intersection of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
     * Returns null if the intersection is empty, meaning, the intervals don't intersect.
     * @param {Interval} other
     * @return {Interval}
     */
    intersection(other2) {
      if (!this.isValid) return this;
      const s4 = this.s > other2.s ? this.s : other2.s, e3 = this.e < other2.e ? this.e : other2.e;
      if (s4 >= e3) {
        return null;
      } else {
        return _Interval.fromDateTimes(s4, e3);
      }
    }
    /**
     * Return an Interval representing the union of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
     * @param {Interval} other
     * @return {Interval}
     */
    union(other2) {
      if (!this.isValid) return this;
      const s4 = this.s < other2.s ? this.s : other2.s, e3 = this.e > other2.e ? this.e : other2.e;
      return _Interval.fromDateTimes(s4, e3);
    }
    /**
     * Merge an array of Intervals into an equivalent minimal set of Intervals.
     * Combines overlapping and adjacent Intervals.
     * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
     * and ending with the latest.
     *
     * @param {Array} intervals
     * @return {Array}
     */
    static merge(intervals) {
      const [found, final] = intervals.sort((a3, b2) => a3.s - b2.s).reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
      if (final) {
        found.push(final);
      }
      return found;
    }
    /**
     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static xor(intervals) {
      let start = null, currentCount = 0;
      const results = [], ends = intervals.map((i4) => [
        { time: i4.s, type: "s" },
        { time: i4.e, type: "e" }
      ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b2) => a3.time - b2.time);
      for (const i4 of arr) {
        currentCount += i4.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start = i4.time;
        } else {
          if (start && +start !== +i4.time) {
            results.push(_Interval.fromDateTimes(start, i4.time));
          }
          start = null;
        }
      }
      return _Interval.merge(results);
    }
    /**
     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
     * @param {...Interval} intervals
     * @return {Array}
     */
    difference(...intervals) {
      return _Interval.xor([this].concat(intervals)).map((i4) => this.intersection(i4)).filter((i4) => i4 && !i4.isEmpty());
    }
    /**
     * Returns a string representation of this Interval appropriate for debugging.
     * @return {string}
     */
    toString() {
      if (!this.isValid) return INVALID3;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    /**
     * Returns a string representation of this Interval appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns a localized string representing this Interval. Accepts the same options as the
     * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
     * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
     * is browser-specific, but in general it will return an appropriate representation of the
     * Interval in the assigned locale. Defaults to the system's locale if no locale has been
     * specified.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
     * Intl.DateTimeFormat constructor options.
     * @param {Object} opts - Options to override the configuration of the start DateTime.
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID3;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Interval.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISO(opts) {
      if (!this.isValid) return INVALID3;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of date of this Interval.
     * The time components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {string}
     */
    toISODate() {
      if (!this.isValid) return INVALID3;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of time of this Interval.
     * The date components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISOTime(opts) {
      if (!this.isValid) return INVALID3;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    /**
     * Returns a string representation of this Interval formatted according to the specified format
     * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
     * formatting tool.
     * @param {string} dateFormat - The format string. This string formats the start and end time.
     * See {@link DateTime#toFormat} for details.
     * @param {Object} opts - Options.
     * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
     * representations.
     * @return {string}
     */
    toFormat(dateFormat, { separator = " \u2013 " } = {}) {
      if (!this.isValid) return INVALID3;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    /**
     * Return a Duration representing the time spanned by this interval.
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
     * @return {Duration}
     */
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    /**
     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
     * @param {function} mapFn
     * @return {Interval}
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
     */
    mapEndpoints(mapFn) {
      return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  };

  // node_modules/luxon/src/info.js
  var Info = class {
    /**
     * Return whether the specified zone contains a DST.
     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
     * @return {boolean}
     */
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime.now().setZone(zone).set({ month: 12 });
      return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
    }
    /**
     * Return whether the specified zone is a valid IANA specifier.
     * @param {string} zone - Zone to check
     * @return {boolean}
     */
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    /**
     * Converts the input into a {@link Zone} instance.
     *
     * * If `input` is already a Zone instance, it is returned unchanged.
     * * If `input` is a string containing a valid time zone name, a Zone instance
     *   with that name is returned.
     * * If `input` is a string that doesn't refer to a known time zone, a Zone
     *   instance with {@link Zone#isValid} == false is returned.
     * * If `input is a number, a Zone instance with the specified fixed offset
     *   in minutes is returned.
     * * If `input` is `null` or `undefined`, the default zone is returned.
     * @param {string|Zone|number} [input] - the value to be converted
     * @return {Zone}
     */
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }
    /**
     * Get the weekday on which the week starts according to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
     */
    static getStartOfWeek({ locale = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale)).getStartOfWeek();
    }
    /**
     * Get the minimum number of days necessary in a week before it is considered part of the next year according
     * to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number}
     */
    static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
    }
    /**
     * Get the weekdays, which are considered the weekend according to the given locale
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
     */
    static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale)).getWeekendDays().slice();
    }
    /**
     * Return an array of standalone month names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @example Info.months()[0] //=> 'January'
     * @example Info.months('short')[0] //=> 'Jan'
     * @example Info.months('numeric')[0] //=> '1'
     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
     * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
     * @return {Array}
     */
    static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }
    /**
     * Return an array of format month names.
     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
     * changes the string.
     * See {@link Info#months}
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @return {Array}
     */
    static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }
    /**
     * Return an array of standalone week names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @example Info.weekdays()[0] //=> 'Monday'
     * @example Info.weekdays('short')[0] //=> 'Mon'
     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
     * @return {Array}
     */
    static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }
    /**
     * Return an array of format week names.
     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
     * changes the string.
     * See {@link Info#weekdays}
     * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale=null] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @return {Array}
     */
    static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }
    /**
     * Return an array of meridiems.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.meridiems() //=> [ 'AM', 'PM' ]
     * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
     * @return {Array}
     */
    static meridiems({ locale = null } = {}) {
      return Locale.create(locale).meridiems();
    }
    /**
     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
     * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.eras() //=> [ 'BC', 'AD' ]
     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
     * @return {Array}
     */
    static eras(length = "short", { locale = null } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }
    /**
     * Return the set of available features in this environment.
     * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
     * Keys:
     * * `relative`: whether this environment supports relative time formatting
     * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
     * @example Info.features() //=> { relative: false, localeWeek: true }
     * @return {Object}
     */
    static features() {
      return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
    }
  };

  // node_modules/luxon/src/impl/diff.js
  function dayDiff(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  }
  function highOrderDiffs(cursor2, later, units) {
    const differs = [
      ["years", (a3, b2) => b2.year - a3.year],
      ["quarters", (a3, b2) => b2.quarter - a3.quarter + (b2.year - a3.year) * 4],
      ["months", (a3, b2) => b2.month - a3.month + (b2.year - a3.year) * 12],
      [
        "weeks",
        (a3, b2) => {
          const days = dayDiff(a3, b2);
          return (days - days % 7) / 7;
        }
      ],
      ["days", dayDiff]
    ];
    const results = {};
    const earlier = cursor2;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor2, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor2 = earlier.plus(results);
          if (cursor2 > later) {
            highWater = cursor2;
            results[unit]--;
            cursor2 = earlier.plus(results);
          }
        } else {
          cursor2 = highWater;
        }
      }
    }
    return [cursor2, results, highWater, lowestOrder];
  }
  function diff_default(earlier, later, units, opts) {
    let [cursor2, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor2;
    const lowerOrderUnits = units.filter(
      (u4) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u4) >= 0
    );
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor2.plus({ [lowestOrder]: 1 });
      }
      if (highWater !== cursor2) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor2);
      }
    }
    const duration4 = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration4);
    } else {
      return duration4;
    }
  }

  // node_modules/luxon/src/impl/tokenParser.js
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  function intUnit(regex, post = (i4) => i4) {
    return { regex, deser: ([s4]) => post(parseDigits(s4)) };
  }
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  function fixListRegex(s4) {
    return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  }
  function stripInsensitivities(s4) {
    return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  }
  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s4]) => strings.findIndex((i4) => stripInsensitivities(s4) === stripInsensitivities(i4)) + startIndex
      };
    }
  }
  function offset(regex, groups) {
    return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
  }
  function simple(regex) {
    return { regex, deser: ([s4]) => s4 };
  }
  function escapeToken(value) {
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function unitForToken(token, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal2 = (t4) => ({ regex: RegExp(escapeToken(t4.val)), deser: ([s4]) => s4, literal: true }), unitate = (t4) => {
      if (token.literal) {
        return literal2(t4);
      }
      switch (t4.val) {
        // era
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        // this special-case "token" represents a place where a macro-token expanded into a white-space literal
        // in this case we accept any non-newline white-space
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal2(t4);
      }
    };
    const unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token;
    return unit;
  }
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  function tokenForPart(part, formatOpts, resolvedOpts) {
    const { type: type3, value } = part;
    if (type3 === "literal") {
      const isSpace2 = /^\s+$/.test(value);
      return {
        literal: !isSpace2,
        val: isSpace2 ? " " : value
      };
    }
    const style = formatOpts[type3];
    let actualType = type3;
    if (type3 === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return void 0;
  }
  function buildRegex(units) {
    const re2 = units.map((u4) => u4.regex).reduce((f4, r3) => `${f4}(${r3.source})`, "");
    return [`^${re2}$`, units];
  }
  function match(input, regex, handlers2) {
    const matches4 = input.match(regex);
    if (matches4) {
      const all = {};
      let matchIndex = 1;
      for (const i4 in handlers2) {
        if (hasOwnProperty(handlers2, i4)) {
          const h3 = handlers2[i4], groups = h3.groups ? h3.groups + 1 : 1;
          if (!h3.literal && h3.token) {
            all[h3.token.val[0]] = h3.deser(matches4.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches4, all];
    } else {
      return [matches4, {}];
    }
  }
  function dateTimeFromMatches(matches4) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined2(matches4.z)) {
      zone = IANAZone.create(matches4.z);
    }
    if (!isUndefined2(matches4.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches4.Z);
      }
      specificOffset = matches4.Z;
    }
    if (!isUndefined2(matches4.q)) {
      matches4.M = (matches4.q - 1) * 3 + 1;
    }
    if (!isUndefined2(matches4.h)) {
      if (matches4.h < 12 && matches4.a === 1) {
        matches4.h += 12;
      } else if (matches4.h === 12 && matches4.a === 0) {
        matches4.h = 0;
      }
    }
    if (matches4.G === 0 && matches4.y) {
      matches4.y = -matches4.y;
    }
    if (!isUndefined2(matches4.u)) {
      matches4.S = parseMillis(matches4.u);
    }
    const vals = Object.keys(matches4).reduce((r3, k3) => {
      const f4 = toField(k3);
      if (f4) {
        r3[f4] = matches4[k3];
      }
      return r3;
    }, {});
    return [vals, zone, specificOffset];
  }
  var dummyDateTimeCache = null;
  function getDummyDateTime() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  }
  function maybeExpandMacroToken(token, locale) {
    if (token.literal) {
      return token;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);
    if (tokens == null || tokens.includes(void 0)) {
      return token;
    }
    return tokens;
  }
  function expandMacroTokens(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t4) => maybeExpandMacroToken(t4, locale)));
  }
  var TokenParser = class {
    constructor(locale, format) {
      this.locale = locale;
      this.format = format;
      this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
      this.units = this.tokens.map((t4) => unitForToken(t4, locale));
      this.disqualifyingUnit = this.units.find((t4) => t4.invalidReason);
      if (!this.disqualifyingUnit) {
        const [regexString, handlers2] = buildRegex(this.units);
        this.regex = RegExp(regexString, "i");
        this.handlers = handlers2;
      }
    }
    explainFromTokens(input) {
      if (!this.isValid) {
        return { input, tokens: this.tokens, invalidReason: this.invalidReason };
      } else {
        const [rawMatches, matches4] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches4 ? dateTimeFromMatches(matches4) : [null, null, void 0];
        if (hasOwnProperty(matches4, "a") && hasOwnProperty(matches4, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return {
          input,
          tokens: this.tokens,
          regex: this.regex,
          rawMatches,
          matches: matches4,
          result,
          zone,
          specificOffset
        };
      }
    }
    get isValid() {
      return !this.disqualifyingUnit;
    }
    get invalidReason() {
      return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
    }
  };
  function explainFromTokens(locale, input, format) {
    const parser5 = new TokenParser(locale, format);
    return parser5.explainFromTokens(input);
  }
  function parseFromTokens(locale, input, format) {
    const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
    return [result, zone, specificOffset, invalidReason];
  }
  function formatOptsToTokens(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p3) => tokenForPart(p3, formatOpts, resolvedOpts));
  }

  // node_modules/luxon/src/datetime.js
  var INVALID4 = "Invalid DateTime";
  var MAX_DATE = 864e13;
  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  }
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }
  function possiblyCachedLocalWeekData(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(
        dt.c,
        dt.loc.getMinDaysInFirstWeek(),
        dt.loc.getStartOfWeek()
      );
    }
    return dt.localWeekData;
  }
  function clone2(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({ ...current, ...alts, old: current });
  }
  function fixOffset(localTS, o3, tz) {
    let utcGuess = localTS - o3 * 60 * 1e3;
    const o22 = tz.offset(utcGuess);
    if (o3 === o22) {
      return [utcGuess, o3];
    }
    utcGuess -= (o22 - o3) * 60 * 1e3;
    const o32 = tz.offset(utcGuess);
    if (o22 === o32) {
      return [utcGuess, o22];
    }
    return [localTS - Math.min(o22, o32) * 60 * 1e3, Math.max(o22, o32)];
  }
  function tsToObj(ts, offset2) {
    ts += offset2 * 60 * 1e3;
    const d3 = new Date(ts);
    return {
      year: d3.getUTCFullYear(),
      month: d3.getUTCMonth() + 1,
      day: d3.getUTCDate(),
      hour: d3.getUTCHours(),
      minute: d3.getUTCMinutes(),
      second: d3.getUTCSeconds(),
      millisecond: d3.getUTCMilliseconds()
    };
  }
  function objToTS(obj, offset2, zone) {
    return fixOffset(objToLocalTS(obj), offset2, zone);
  }
  function adjustTime(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c3);
    let [ts, o3] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o3 = inst.zone.offset(ts);
    }
    return { ts, o: o3 };
  }
  function parseDataToDateTime(parsed, parsedZone, opts, format, text2, specificOffset) {
    const { setZone, zone } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(
        new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format}`)
      );
    }
  }
  function toTechFormat(dt, format, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format) : null;
  }
  function toISODate(o3, extended) {
    const longFormat = o3.c.year > 9999 || o3.c.year < 0;
    let c3 = "";
    if (longFormat && o3.c.year >= 0) c3 += "+";
    c3 += padStart(o3.c.year, longFormat ? 6 : 4);
    if (extended) {
      c3 += "-";
      c3 += padStart(o3.c.month);
      c3 += "-";
      c3 += padStart(o3.c.day);
    } else {
      c3 += padStart(o3.c.month);
      c3 += padStart(o3.c.day);
    }
    return c3;
  }
  function toISOTime(o3, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c3 = padStart(o3.c.hour);
    if (extended) {
      c3 += ":";
      c3 += padStart(o3.c.minute);
      if (o3.c.millisecond !== 0 || o3.c.second !== 0 || !suppressSeconds) {
        c3 += ":";
      }
    } else {
      c3 += padStart(o3.c.minute);
    }
    if (o3.c.millisecond !== 0 || o3.c.second !== 0 || !suppressSeconds) {
      c3 += padStart(o3.c.second);
      if (o3.c.millisecond !== 0 || !suppressMilliseconds) {
        c3 += ".";
        c3 += padStart(o3.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o3.isOffsetFixed && o3.offset === 0 && !extendedZone) {
        c3 += "Z";
      } else if (o3.o < 0) {
        c3 += "-";
        c3 += padStart(Math.trunc(-o3.o / 60));
        c3 += ":";
        c3 += padStart(Math.trunc(-o3.o % 60));
      } else {
        c3 += "+";
        c3 += padStart(Math.trunc(o3.o / 60));
        c3 += ":";
        c3 += padStart(Math.trunc(o3.o % 60));
      }
    }
    if (extendedZone) {
      c3 += "[" + o3.zone.ianaName + "]";
    }
    return c3;
  }
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  function normalizeUnit(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  function normalizeUnitWithLocalWeeks(unit) {
    switch (unit.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit);
    }
  }
  function guessOffsetForZone(zone) {
    if (zoneOffsetTs === void 0) {
      zoneOffsetTs = Settings.now();
    }
    if (zone.type !== "iana") {
      return zone.offset(zoneOffsetTs);
    }
    const zoneName = zone.name;
    let offsetGuess = zoneOffsetGuessCache.get(zoneName);
    if (offsetGuess === void 0) {
      offsetGuess = zone.offset(zoneOffsetTs);
      zoneOffsetGuessCache.set(zoneName, offsetGuess);
    }
    return offsetGuess;
  }
  function quickDT(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    }
    const loc = Locale.fromObject(opts);
    let ts, o3;
    if (!isUndefined2(obj.year)) {
      for (const u4 of orderedUnits2) {
        if (isUndefined2(obj[u4])) {
          obj[u4] = defaultUnitValues[u4];
        }
      }
      const invalid2 = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid2) {
        return DateTime.invalid(invalid2);
      }
      const offsetProvis = guessOffsetForZone(zone);
      [ts, o3] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = Settings.now();
    }
    return new DateTime({ ts, zone, loc, o: o3 });
  }
  function diffRelative(start, end, opts) {
    const round2 = isUndefined2(opts.round) ? true : opts.round, format = (c3, unit) => {
      c3 = roundTo(c3, round2 || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c3, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  }
  function lastOpts(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  }
  var zoneOffsetTs;
  var zoneOffsetGuessCache = /* @__PURE__ */ new Map();
  var DateTime = class _DateTime {
    /**
     * @access private
     */
    constructor(config2) {
      const zone = config2.zone || Settings.defaultZone;
      let invalid2 = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined2(config2.ts) ? Settings.now() : config2.ts;
      let c3 = null, o3 = null;
      if (!invalid2) {
        const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
        if (unchanged) {
          [c3, o3] = [config2.old.c, config2.old.o];
        } else {
          const ot = isNumber2(config2.o) && !config2.old ? config2.o : zone.offset(this.ts);
          c3 = tsToObj(this.ts, ot);
          invalid2 = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
          c3 = invalid2 ? null : c3;
          o3 = invalid2 ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config2.loc || Locale.create();
      this.invalid = invalid2;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c3;
      this.o = o3;
      this.isLuxonDateTime = true;
    }
    // CONSTRUCT
    /**
     * Create a DateTime for the current instant, in the system's time zone.
     *
     * Use Settings to override these default values if needed.
     * @example DateTime.now().toISO() //~> now in the ISO format
     * @return {DateTime}
     */
    static now() {
      return new _DateTime({});
    }
    /**
     * Create a local DateTime
     * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month, 1-indexed
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @example DateTime.local()                                  //~> now
     * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
     * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
     * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
     * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
     * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
     * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
     * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
     * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
     * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
     * @return {DateTime}
     */
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
      return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
    }
    /**
     * Create a DateTime in UTC
     * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @param {Object} options - configuration options for the DateTime
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.utc()                                              //~> now
     * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
     * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
     * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
     * @return {DateTime}
     */
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
    }
    /**
     * Create a DateTime from a JavaScript Date object. Uses the default zone.
     * @param {Date} date - a JavaScript Date object
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @return {DateTime}
     */
    static fromJSDate(date3, options2 = {}) {
      const ts = isDate(date3) ? date3.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return _DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options2.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new _DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options2)
      });
    }
    /**
     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} milliseconds - a number of milliseconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromMillis(milliseconds, options2 = {}) {
      if (!isNumber2(milliseconds)) {
        throw new InvalidArgumentError(
          `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
        );
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return _DateTime.invalid("Timestamp out of range");
      } else {
        return new _DateTime({
          ts: milliseconds,
          zone: normalizeZone(options2.zone, Settings.defaultZone),
          loc: Locale.fromObject(options2)
        });
      }
    }
    /**
     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} seconds - a number of seconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromSeconds(seconds, options2 = {}) {
      if (!isNumber2(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new _DateTime({
          ts: seconds * 1e3,
          zone: normalizeZone(options2.zone, Settings.defaultZone),
          loc: Locale.fromObject(options2)
        });
      }
    }
    /**
     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.year - a year, such as 1987
     * @param {number} obj.month - a month, 1-12
     * @param {number} obj.day - a day of the month, 1-31, depending on the month
     * @param {number} obj.ordinal - day of the year, 1-365 or 366
     * @param {number} obj.weekYear - an ISO week year
     * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
     * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
     * @param {number} obj.localWeekYear - a week year, according to the locale
     * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
     * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
     * @param {number} obj.hour - hour of the day, 0-23
     * @param {number} obj.minute - minute of the hour, 0-59
     * @param {number} obj.second - second of the minute, 0-59
     * @param {number} obj.millisecond - millisecond of the second, 0-999
     * @param {Object} opts - options for creating this DateTime
     * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
     * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
     * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
     * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
     * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
     * @return {DateTime}
     */
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits2;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u4 of units) {
        const v4 = normalized[u4];
        if (!isUndefined2(v4)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u4] = defaultValues[u4];
        } else {
          normalized[u4] = objNow[u4];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid2 = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid2) {
        return _DateTime.invalid(invalid2);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return _DateTime.invalid(
          "mismatched weekday",
          `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
        );
      }
      if (!inst.isValid) {
        return _DateTime.invalid(inst.invalid);
      }
      return inst;
    }
    /**
     * Create a DateTime from an ISO 8601 string
     * @param {string} text - the ISO string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromISO('2016-05-25T09:08:34.123')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
     * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
     * @example DateTime.fromISO('2016-W05-4')
     * @return {DateTime}
     */
    static fromISO(text2, opts = {}) {
      const [vals, parsedZone] = parseISODate(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
    }
    /**
     * Create a DateTime from an RFC 2822 string
     * @param {string} text - the RFC 2822 string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
     * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
     * @return {DateTime}
     */
    static fromRFC2822(text2, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
    }
    /**
     * Create a DateTime from an HTTP header date
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @param {string} text - the HTTP header date
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
     * @return {DateTime}
     */
    static fromHTTP(text2, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    /**
     * Create a DateTime from an input string and format string.
     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromFormat(text2, fmt, opts = {}) {
      if (isUndefined2(text2) || isUndefined2(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid2] = parseFromTokens(localeToUse, text2, fmt);
      if (invalid2) {
        return _DateTime.invalid(invalid2);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
      }
    }
    /**
     * @deprecated use fromFormat instead
     */
    static fromString(text2, fmt, opts = {}) {
      return _DateTime.fromFormat(text2, fmt, opts);
    }
    /**
     * Create a DateTime from a SQL date, time, or datetime
     * Defaults to en-US if no locale has been specified, regardless of the system's locale
     * @param {string} text - the string to parse
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @example DateTime.fromSQL('2017-05-15')
     * @example DateTime.fromSQL('2017-05-15 09:12:34')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
     * @example DateTime.fromSQL('09:12:34.342')
     * @return {DateTime}
     */
    static fromSQL(text2, opts = {}) {
      const [vals, parsedZone] = parseSQL(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
    }
    /**
     * Create an invalid DateTime.
     * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {DateTime}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid2);
      } else {
        return new _DateTime({ invalid: invalid2 });
      }
    }
    /**
     * Check if an object is an instance of DateTime. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDateTime(o3) {
      return o3 && o3.isLuxonDateTime || false;
    }
    /**
     * Produce the format string for a set of options
     * @param formatOpts
     * @param localeOpts
     * @returns {string}
     */
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t4) => t4 ? t4.val : null).join("");
    }
    /**
     * Produce the the fully expanded format token for the locale
     * Does NOT quote characters, so quoted tokens will not round trip correctly
     * @param fmt
     * @param localeOpts
     * @returns {string}
     */
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t4) => t4.val).join("");
    }
    static resetCache() {
      zoneOffsetTs = void 0;
      zoneOffsetGuessCache.clear();
    }
    // INFO
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
     * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
     * @return {number}
     */
    get(unit) {
      return this[unit];
    }
    /**
     * Returns whether the DateTime is valid. Invalid DateTimes occur when:
     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
     * * The DateTime was created by an operation on another invalid date
     * @type {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
    get zone() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    /**
     * Returns true if this date is on a weekend according to the locale, false otherwise
     * @returns {boolean}
     */
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    /**
     * Get the day of the week according to the locale.
     * 1 is the first day of the week and 7 is the last day of the week.
     * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
     * @returns {number}
     */
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    /**
     * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
     * because the week can start on different days of the week (see localWeekday) and because a different number of days
     * is required for a week to count as the first week of a year.
     * @returns {number}
     */
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
     * differently, see localWeekNumber.
     * @returns {number}
     */
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
    get monthShort() {
      return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
    get monthLong() {
      return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
      }
    }
    /**
     * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
     * in this DateTime's zone. During DST changes local time can be ambiguous, for example
     * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
     * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
     * @returns {DateTime[]}
     */
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 864e5;
      const minuteMs = 6e4;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o22 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o22) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o22 * minuteMs;
      const c1 = tsToObj(ts1, o1);
      const c22 = tsToObj(ts2, o22);
      if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
        return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
      }
      return [this];
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's local week year
     * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
     * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
     * @type {number}
     */
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(
        this.localWeekYear,
        this.loc.getMinDaysInFirstWeek(),
        this.loc.getStartOfWeek()
      ) : NaN;
    }
    /**
     * Returns the resolved Intl options for this DateTime.
     * This is useful in understanding the behavior of formatting methods
     * @param {Object} opts - the same options as toLocaleString
     * @return {Object}
     */
    resolvedLocaleOptions(opts = {}) {
      const { locale, numberingSystem, calendar } = Formatter.create(
        this.loc.clone(opts),
        opts
      ).resolvedOptions(this);
      return { locale, numberingSystem, outputCalendar: calendar };
    }
    // TRANSFORM
    /**
     * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
     *
     * Equivalent to {@link DateTime#setZone}('utc')
     * @param {number} [offset=0] - optionally, an offset from UTC in minutes
     * @param {Object} [opts={}] - options to pass to `setZone()`
     * @return {DateTime}
     */
    toUTC(offset2 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset2), opts);
    }
    /**
     * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
     *
     * Equivalent to `setZone('local')`
     * @return {DateTime}
     */
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    /**
     * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
     *
     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
     * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
     * @param {Object} opts - options
     * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
     * @return {DateTime}
     */
    setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return _DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone2(this, { ts: newTS, zone });
      }
    }
    /**
     * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
     * @param {Object} properties - the properties to set
     * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
     * @return {DateTime}
     */
    reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
      const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
      return clone2(this, { loc });
    }
    /**
     * "Set" the locale. Returns a newly-constructed DateTime.
     * Just a convenient alias for reconfigure({ locale })
     * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
     * @return {DateTime}
     */
    setLocale(locale) {
      return this.reconfigure({ locale });
    }
    /**
     * "Set" the values of specified units. Returns a newly-constructed DateTime.
     * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
     *
     * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
     * They cannot be mixed with ISO-week units like `weekday`.
     * @param {Object} values - a mapping of units to numbers
     * @example dt.set({ year: 2017 })
     * @example dt.set({ hour: 8, minute: 30 })
     * @example dt.set({ weekday: 5 })
     * @example dt.set({ year: 2005, ordinal: 234 })
     * @return {DateTime}
     */
    set(values2) {
      if (!this.isValid) return this;
      const normalized = normalizeObject(values2, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian(
          { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
          minDaysInFirstWeek,
          startOfWeek
        );
      } else if (!isUndefined2(normalized.ordinal)) {
        mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
      } else {
        mixed = { ...this.toObject(), ...normalized };
        if (isUndefined2(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o3] = objToTS(mixed, this.o, this.zone);
      return clone2(this, { ts, o: o3 });
    }
    /**
     * Add a period of time to this DateTime and return the resulting DateTime
     *
     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @example DateTime.now().plus(123) //~> in 123 milliseconds
     * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
     * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
     * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
     * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
     * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
     * @return {DateTime}
     */
    plus(duration4) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration4);
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * Subtract a period of time to this DateTime and return the resulting DateTime
     * See {@link DateTime#plus}
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     @return {DateTime}
     */
    minus(duration4) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration4).negate();
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * "Set" this DateTime to the beginning of a unit of time.
     * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
     * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
     * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
     * @return {DateTime}
     */
    startOf(unit, { useLocaleWeeks = false } = {}) {
      if (!this.isValid) return this;
      const o3 = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o3.month = 1;
        // falls through
        case "quarters":
        case "months":
          o3.day = 1;
        // falls through
        case "weeks":
        case "days":
          o3.hour = 0;
        // falls through
        case "hours":
          o3.minute = 0;
        // falls through
        case "minutes":
          o3.second = 0;
        // falls through
        case "seconds":
          o3.millisecond = 0;
          break;
        case "milliseconds":
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const { weekday } = this;
          if (weekday < startOfWeek) {
            o3.weekNumber = this.weekNumber - 1;
          }
          o3.weekday = startOfWeek;
        } else {
          o3.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q4 = Math.ceil(this.month / 3);
        o3.month = (q4 - 1) * 3 + 1;
      }
      return this.set(o3);
    }
    /**
     * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
     * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
     * @return {DateTime}
     */
    endOf(unit, opts) {
      return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
    }
    // OUTPUT
    /**
     * Returns a string representation of this DateTime formatted according to the specified format string.
     * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
     * Defaults to en-US if no locale has been specified, regardless of the system's locale.
     * @param {string} fmt - the format string
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
     * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
     * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
     * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID4;
    }
    /**
     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
     * of the DateTime in the assigned locale.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toLocaleString(); //=> 4/20/2017
     * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
     * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
     * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
     * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
     * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
     * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID4;
    }
    /**
     * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
     * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
     * @example DateTime.now().toLocaleParts(); //=> [
     *                                   //=>   { type: 'day', value: '25' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'month', value: '05' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'year', value: '1982' }
     *                                   //=> ]
     */
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
     * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
     * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
     * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
     * @return {string|null}
     */
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format === "extended";
      let c3 = toISODate(this, ext);
      c3 += "T";
      c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c3;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's date component
     * @param {Object} opts - options
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
     * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
     * @return {string|null}
     */
    toISODate({ format = "extended" } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format === "extended");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's week date
     * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
     * @return {string}
     */
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's time component
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
     * @return {string}
     */
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c3 = includePrefix ? "T" : "";
      return c3 + toISOTime(
        this,
        format === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      );
    }
    /**
     * Returns an RFC 2822-compatible string representation of this DateTime
     * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
     * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
     * @return {string}
     */
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
     * Specifically, the string conforms to RFC 1123.
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
     * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
     * @return {string}
     */
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Date
     * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
     * @return {string|null}
     */
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Time
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc().toSQL() //=> '05:15:16.345'
     * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
     * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
     * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
     * @return {string}
     */
    toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
     * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
     * @return {string}
     */
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    /**
     * Returns a string representation of this DateTime appropriate for debugging
     * @return {string}
     */
    toString() {
      return this.isValid ? this.toISO() : INVALID4;
    }
    /**
     * Returns a string representation of this DateTime appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Returns the epoch milliseconds of this DateTime.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    /**
     * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
     * @return {number}
     */
    toSeconds() {
      return this.isValid ? this.ts / 1e3 : NaN;
    }
    /**
     * Returns the epoch seconds (as a whole number) of this DateTime.
     * @return {number}
     */
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
    }
    /**
     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns a BSON serializable equivalent to this DateTime.
     * @return {Date}
     */
    toBSON() {
      return this.toJSDate();
    }
    /**
     * Returns a JavaScript object with this DateTime's year, month, day, and so on.
     * @param opts - options for generating the object
     * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
     * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
     * @return {Object}
     */
    toObject(opts = {}) {
      if (!this.isValid) return {};
      const base2 = { ...this.c };
      if (opts.includeConfig) {
        base2.outputCalendar = this.outputCalendar;
        base2.numberingSystem = this.loc.numberingSystem;
        base2.locale = this.loc.locale;
      }
      return base2;
    }
    /**
     * Returns a JavaScript Date equivalent to this DateTime.
     * @return {Date}
     */
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    // COMPARE
    /**
     * Return the difference between two DateTimes as a Duration.
     * @param {DateTime} otherDateTime - the DateTime to compare this one to
     * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example
     * var i1 = DateTime.fromISO('1982-05-25T09:45'),
     *     i2 = DateTime.fromISO('1983-10-14T10:30');
     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
     * @return {Duration}
     */
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    /**
     * Return the difference between this DateTime and right now.
     * See {@link DateTime#diff}
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(_DateTime.now(), unit, opts);
    }
    /**
     * Return an Interval spanning between this DateTime and another DateTime
     * @param {DateTime} otherDateTime - the other end point of the Interval
     * @return {Interval|DateTime}
     */
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    /**
     * Return whether this DateTime is in the same unit of time as another DateTime.
     * Higher-order units must also be identical for this function to return `true`.
     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
     * @param {DateTime} otherDateTime - the other DateTime
     * @param {string} unit - the unit of time to check sameness on
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
     * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
     * @return {boolean}
     */
    hasSame(otherDateTime, unit, opts) {
      if (!this.isValid) return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
      return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
    }
    /**
     * Equality check
     * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
     * To compare just the millisecond values, use `+dt1 === +dt2`.
     * @param {DateTime} other - the other DateTime
     * @return {boolean}
     */
    equals(other2) {
      return this.isValid && other2.isValid && this.valueOf() === other2.valueOf() && this.zone.equals(other2.zone) && this.loc.equals(other2.loc);
    }
    /**
     * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
     * platform supports Intl.RelativeTimeFormat. Rounds down by default.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
     * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
     * @param {boolean} [options.round=true] - whether to round the numbers in the output.
     * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
     * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
     * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
     * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
     * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
     * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
     */
    toRelative(options2 = {}) {
      if (!this.isValid) return null;
      const base2 = options2.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options2.padding ? this < base2 ? -options2.padding : options2.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options2.unit;
      if (Array.isArray(options2.unit)) {
        units = options2.unit;
        unit = void 0;
      }
      return diffRelative(base2, this.plus(padding), {
        ...options2,
        numeric: "always",
        units,
        unit
      });
    }
    /**
     * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
     * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
     * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
     */
    toRelativeCalendar(options2 = {}) {
      if (!this.isValid) return null;
      return diffRelative(options2.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
        ...options2,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    /**
     * Return the min of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
     * @return {DateTime} the min DateTime, or undefined if called with no argument
     */
    static min(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i4) => i4.valueOf(), Math.min);
    }
    /**
     * Return the max of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
     * @return {DateTime} the max DateTime, or undefined if called with no argument
     */
    static max(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i4) => i4.valueOf(), Math.max);
    }
    // MISC
    /**
     * Explain how a string would be parsed by fromFormat()
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see description)
     * @param {Object} options - options taken by fromFormat()
     * @return {Object}
     */
    static fromFormatExplain(text2, fmt, options2 = {}) {
      const { locale = null, numberingSystem = null } = options2, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text2, fmt);
    }
    /**
     * @deprecated use fromFormatExplain instead
     */
    static fromStringExplain(text2, fmt, options2 = {}) {
      return _DateTime.fromFormatExplain(text2, fmt, options2);
    }
    /**
     * Build a parser for `fmt` using the given locale. This parser can be passed
     * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
     * can be used to optimize cases where many dates need to be parsed in a
     * specific format.
     *
     * @param {String} fmt - the format the string is expected to be in (see
     * description)
     * @param {Object} options - options used to set locale and numberingSystem
     * for parser
     * @returns {TokenParser} - opaque object to be used
     */
    static buildFormatParser(fmt, options2 = {}) {
      const { locale = null, numberingSystem = null } = options2, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return new TokenParser(localeToUse, fmt);
    }
    /**
     * Create a DateTime from an input string and format parser.
     *
     * The format parser must have been created with the same locale as this call.
     *
     * @param {String} text - the string to parse
     * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
     * @param {Object} opts - options taken by fromFormat()
     * @returns {DateTime}
     */
    static fromFormatParser(text2, formatParser, opts = {}) {
      if (isUndefined2(text2) || isUndefined2(formatParser)) {
        throw new InvalidArgumentError(
          "fromFormatParser requires an input string and a format parser"
        );
      }
      const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      if (!localeToUse.equals(formatParser.locale)) {
        throw new InvalidArgumentError(
          `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
        );
      }
      const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text2);
      if (invalidReason) {
        return _DateTime.invalid(invalidReason);
      } else {
        return parseDataToDateTime(
          result,
          zone,
          opts,
          `format ${formatParser.format}`,
          text2,
          specificOffset
        );
      }
    }
    // FORMAT PRESETS
    /**
     * {@link DateTime#toLocaleString} format like 10/14/1983
     * @type {Object}
     */
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED() {
      return DATE_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
    static get DATE_FULL() {
      return DATE_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  };
  function friendlyDateTime(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(
        `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
      );
    }
  }

  // node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
      var date3 = new Date(givenDate.getTime());
      date3.setHours(0, 0, 0, 0);
      date3.setDate(date3.getDate() + 3 - (date3.getDay() + 6) % 7);
      var week1 = new Date(date3.getFullYear(), 0, 4);
      return 1 + Math.round(((date3.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: /* @__PURE__ */ new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // node_modules/flatpickr/dist/esm/l10n/default.js
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
      var s4 = nth % 100;
      if (s4 > 3 && s4 < 21)
        return "th";
      switch (s4 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default = english;

  // node_modules/flatpickr/dist/esm/utils/index.js
  var pad = function(number2, length) {
    if (length === void 0) {
      length = 2;
    }
    return ("000" + number2).slice(length * -1);
  };
  var int2 = function(bool) {
    return bool === true ? 1 : 0;
  };
  function debounce2(fn4, wait) {
    var t4;
    return function() {
      var _this = this;
      var args = arguments;
      clearTimeout(t4);
      t4 = setTimeout(function() {
        return fn4.apply(_this, args);
      }, wait);
    };
  }
  var arrayify = function(obj) {
    return obj instanceof Array ? obj : [obj];
  };

  // node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  function createElement(tag4, className, content2) {
    var e3 = window.document.createElement(tag4);
    className = className || "";
    content2 = content2 || "";
    e3.className = className;
    if (content2 !== void 0)
      e3.textContent = content2;
    return e3;
  }
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (var key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  function getEventTarget(event2) {
    try {
      if (typeof event2.composedPath === "function") {
        var path2 = event2.composedPath();
        return path2[0];
      }
      return event2.target;
    } catch (error2) {
      return event2.target;
    }
  }

  // node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing = function() {
    return void 0;
  };
  var monthToStr = function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  };
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int2(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_3, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1e3);
    },
    W: function(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date3 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date3.setDate(date3.getDate() - date3.getDay() + locale.firstDayOfWeek);
      return date3;
    },
    Y: function(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function(_3, ISODate) {
      return new Date(ISODate);
    },
    d: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_3, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function(dateObj, year) {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: function(date3) {
      return date3.toISOString();
    },
    D: function(date3, locale, options2) {
      return locale.weekdays.shorthand[formats.w(date3, locale, options2)];
    },
    F: function(date3, locale, options2) {
      return monthToStr(formats.n(date3, locale, options2) - 1, false, locale);
    },
    G: function(date3, locale, options2) {
      return pad(formats.h(date3, locale, options2));
    },
    H: function(date3) {
      return pad(date3.getHours());
    },
    J: function(date3, locale) {
      return locale.ordinal !== void 0 ? date3.getDate() + locale.ordinal(date3.getDate()) : date3.getDate();
    },
    K: function(date3, locale) {
      return locale.amPM[int2(date3.getHours() > 11)];
    },
    M: function(date3, locale) {
      return monthToStr(date3.getMonth(), true, locale);
    },
    S: function(date3) {
      return pad(date3.getSeconds());
    },
    U: function(date3) {
      return date3.getTime() / 1e3;
    },
    W: function(date3, _3, options2) {
      return options2.getWeek(date3);
    },
    Y: function(date3) {
      return pad(date3.getFullYear(), 4);
    },
    d: function(date3) {
      return pad(date3.getDate());
    },
    h: function(date3) {
      return date3.getHours() % 12 ? date3.getHours() % 12 : 12;
    },
    i: function(date3) {
      return pad(date3.getMinutes());
    },
    j: function(date3) {
      return date3.getDate();
    },
    l: function(date3, locale) {
      return locale.weekdays.longhand[date3.getDay()];
    },
    m: function(date3) {
      return pad(date3.getMonth() + 1);
    },
    n: function(date3) {
      return date3.getMonth() + 1;
    },
    s: function(date3) {
      return date3.getSeconds();
    },
    u: function(date3) {
      return date3.getTime();
    },
    w: function(date3) {
      return date3.getDay();
    },
    y: function(date3) {
      return String(date3.getFullYear()).substring(2);
    }
  };

  // node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter = function(_a2) {
    var _b = _a2.config, config2 = _b === void 0 ? defaults : _b, _c = _a2.l10n, l10n = _c === void 0 ? english : _c, _d = _a2.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;
      if (config2.formatDate !== void 0 && !isMobile) {
        return config2.formatDate(dateObj, frmt, locale);
      }
      return frmt.split("").map(function(c3, i4, arr) {
        return formats[c3] && arr[i4 - 1] !== "\\" ? formats[c3](dateObj, locale, config2) : c3 !== "\\" ? c3 : "";
      }).join("");
    };
  };
  var createDateParser = function(_a2) {
    var _b = _a2.config, config2 = _b === void 0 ? defaults : _b, _c = _a2.l10n, l10n = _c === void 0 ? english : _c;
    return function(date3, givenFormat, timeless, customLocale) {
      if (date3 !== 0 && !date3)
        return void 0;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date3;
      if (date3 instanceof Date)
        parsedDate = new Date(date3.getTime());
      else if (typeof date3 !== "string" && date3.toFixed !== void 0)
        parsedDate = new Date(date3);
      else if (typeof date3 === "string") {
        var format = givenFormat || (config2 || defaults).dateFormat;
        var datestr = String(date3).trim();
        if (datestr === "today") {
          parsedDate = /* @__PURE__ */ new Date();
          timeless = true;
        } else if (config2 && config2.parseDate) {
          parsedDate = config2.parseDate(date3, format);
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
          parsedDate = new Date(date3);
        } else {
          var matched = void 0, ops = [];
          for (var i4 = 0, matchIndex = 0, regexStr = ""; i4 < format.length; i4++) {
            var token = format[i4];
            var isBackSlash = token === "\\";
            var escaped = format[i4 - 1] === "\\" || isBackSlash;
            if (tokenRegex[token] && !escaped) {
              regexStr += tokenRegex[token];
              var match2 = new RegExp(regexStr).exec(date3);
              if (match2 && (matched = true)) {
                ops[token !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token],
                  val: match2[++matchIndex]
                });
              }
            } else if (!isBackSlash)
              regexStr += ".";
          }
          parsedDate = !config2 || !config2.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          ops.forEach(function(_a3) {
            var fn4 = _a3.fn, val = _a3.val;
            return parsedDate = fn4(parsedDate, val, locale) || parsedDate;
          });
          parsedDate = matched ? parsedDate : void 0;
        }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config2.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return void 0;
      }
      if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  };
  function compareDates(date1, date22, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date22.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date22.getTime();
  }
  var isBetween = function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };
  var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
  };
  var parseSeconds = function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
  };
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config2) {
    var hours = config2.defaultHour;
    var minutes = config2.defaultMinute;
    var seconds = config2.defaultSeconds;
    if (config2.minDate !== void 0) {
      var minHour = config2.minDate.getHours();
      var minMinutes = config2.minDate.getMinutes();
      var minSeconds = config2.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config2.minDate.getSeconds();
    }
    if (config2.maxDate !== void 0) {
      var maxHr = config2.maxDate.getHours();
      var maxMinutes = config2.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config2.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }

  // node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      var _loop_1 = function(source2) {
        if (source2) {
          Object.keys(source2).forEach(function(key) {
            return target[key] = source2[key];
          });
        }
      };
      for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
        var source = args_1[_a2];
        _loop_1(source);
      }
      return target;
    };
  }

  // node_modules/flatpickr/dist/esm/index.js
  var __assign = function() {
    __assign = Object.assign || function(t4) {
      for (var s4, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
        s4 = arguments[i4];
        for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
          t4[p3] = s4[p3];
      }
      return t4;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArrays = function() {
    for (var s4 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s4 += arguments[i4].length;
    for (var r3 = Array(s4), k3 = 0, i4 = 0; i4 < il; i4++)
      for (var a3 = arguments[i4], j4 = 0, jl = a3.length; j4 < jl; j4++, k3++)
        r3[k3] = a3[j4];
    return r3;
  };
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    var self2 = {
      config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
      l10n: default_default
    };
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind2;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2.onMouseOver = onMouseOver;
    self2._createElement = createElement;
    self2.createDay = createDay;
    self2.destroy = destroy;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.updateValue = updateValue2;
    self2.open = open;
    self2.redraw = redraw;
    self2.set = set3;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth: function(month, yr) {
          if (month === void 0) {
            month = self2.currentMonth;
          }
          if (yr === void 0) {
            yr = self2.currentYear;
          }
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    function init() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue2(false);
      }
      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    function getClosestActiveElement() {
      var _a2;
      return ((_a2 = self2.calendarContainer) === null || _a2 === void 0 ? void 0 : _a2.getRootNode()).activeElement || document.activeElement;
    }
    function bindToInstance(fn4) {
      return fn4.bind(self2);
    }
    function setCalendarWidth() {
      var config2 = self2.config;
      if (config2.weekNumbers === false && config2.showMonths === 1) {
        return;
      } else if (config2.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            var daysWidth = (self2.days.offsetWidth + 1) * config2.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    function updateTime(e3) {
      if (self2.selectedDates.length === 0) {
        var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
        var defaults3 = getDefaultHours(self2.config);
        defaultDate.setHours(defaults3.hours, defaults3.minutes, defaults3.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e3 !== void 0 && e3.type !== "blur") {
        timeWrapper(e3);
      }
      var prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue2();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int2(amPM === self2.l10n.amPM[1]);
    }
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
        var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
        var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
        var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
        if (currentTime > maxBound && currentTime < minBound) {
          var result = parseSeconds(minBound);
          hours = result[0];
          minutes = result[1];
          seconds = result[2];
        }
      } else {
        if (limitMaxHours) {
          var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
          hours = Math.min(hours, maxTime.getHours());
          if (hours === maxTime.getHours())
            minutes = Math.min(minutes, maxTime.getMinutes());
          if (minutes === maxTime.getMinutes())
            seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
          var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
          hours = Math.max(hours, minTime.getHours());
          if (hours === minTime.getHours() && minutes < minTime.getMinutes())
            minutes = minTime.getMinutes();
          if (minutes === minTime.getMinutes())
            seconds = Math.max(seconds, minTime.getSeconds());
        }
      }
      setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
      var date3 = dateObj || self2.latestSelectedDateObj;
      if (date3 && date3 instanceof Date) {
        setHours(date3.getHours(), date3.getMinutes(), date3.getSeconds());
      }
    }
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int2(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int2(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad(seconds);
    }
    function onYearInput(event2) {
      var eventTarget = getEventTarget(event2);
      var year = parseInt(eventTarget.value) + (event2.delta || 0);
      if (year / 1e3 > 1 || event2.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    function bind2(element2, event2, handler, options2) {
      if (event2 instanceof Array)
        return event2.forEach(function(ev) {
          return bind2(element2, ev, handler, options2);
        });
      if (element2 instanceof Array)
        return element2.forEach(function(el) {
          return bind2(el, event2, handler, options2);
        });
      element2.addEventListener(event2, handler, options2);
      self2._handlers.push({
        remove: function() {
          return element2.removeEventListener(event2, handler, options2);
        }
      });
    }
    function triggerChange() {
      triggerEvent("onChange");
    }
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function(evt) {
          Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
            return bind2(el, "click", self2[evt]);
          });
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      var debouncedResize = debounce2(onResize, 50);
      self2._debouncedChange = debounce2(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind2(self2.daysContainer, "mouseover", function(e3) {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget(e3));
        });
      bind2(self2._input, "keydown", onKeyDown);
      if (self2.calendarContainer !== void 0) {
        bind2(self2.calendarContainer, "keydown", onKeyDown);
      }
      if (!self2.config.inline && !self2.config.static)
        bind2(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind2(window.document, "touchstart", documentClick);
      else
        bind2(window.document, "mousedown", documentClick);
      bind2(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind2(self2._input, "focus", self2.open);
        bind2(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind2(self2.monthNav, "click", onMonthNavClick);
        bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind2(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        var selText = function(e3) {
          return getEventTarget(e3).select();
        };
        bind2(self2.timeContainer, ["increment"], updateTime);
        bind2(self2.timeContainer, "blur", updateTime, { capture: true });
        bind2(self2.timeContainer, "click", timeIncrement);
        bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind2(self2.secondElement, "focus", function() {
            return self2.secondElement && self2.secondElement.select();
          });
        if (self2.amPM !== void 0) {
          bind2(self2.amPM, "click", function(e3) {
            updateTime(e3);
          });
        }
      }
      if (self2.config.allowInput) {
        bind2(self2._input, "blur", onBlur);
      }
    }
    function jumpToDate(jumpDate, triggerChange2) {
      var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      var oldYear = self2.currentYear;
      var oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e3) {
        e3.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e3);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    function timeIncrement(e3) {
      var eventTarget = getEventTarget(e3);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e3, delta, inputElem) {
      var target = e3 && getEventTarget(e3);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event2 = createEvent("increment");
      event2.delta = delta;
      input && input.dispatchEvent(event2);
    }
    function build() {
      var fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          var _a2 = buildWeeks(), weekWrapper = _a2.weekWrapper, weekNumbers = _a2.weekNumbers;
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    function createDay(className, date3, _dayNumber, i4) {
      var dateIsEnabled = isEnabled(date3, true), dayElement = createElement("span", className, date3.getDate().toString());
      dayElement.dateObj = date3;
      dayElement.$i = i4;
      dayElement.setAttribute("aria-label", self2.formatDate(date3, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date3, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date3)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date3, self2.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date3, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date3) && !isDateSelected(date3))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i4 % 7 === 6) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date3) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (var m3 = startMonth; m3 != endMonth; m3 += delta) {
        var month = self2.daysContainer.children[m3];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;
        for (var i4 = startIndex; i4 != endIndex; i4 += delta) {
          var c3 = month.children[i4];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj))
            return c3;
        }
      }
      return void 0;
    }
    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;
      for (var m3 = givenMonth - self2.currentMonth; m3 != endMonth; m3 += loopDelta) {
        var month = self2.daysContainer.children[m3];
        var startIndex = givenMonth - self2.currentMonth === m3 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;
        for (var i4 = startIndex; i4 >= 0 && i4 < numMonthDays && i4 != (delta > 0 ? numMonthDays : -1); i4 += loopDelta) {
          var c3 = month.children[i4];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj) && Math.abs(current.$i - i4) >= Math.abs(delta))
            return focusOnDayElem(c3);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    function focusOnDay(current, offset2) {
      var activeElement = getClosestActiveElement();
      var dayFocused = isInView(activeElement || document.body);
      var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset2);
      }
    }
    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth2 = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
      }
      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode(self2.weekNumbers);
      var frag = document.createDocumentFragment();
      for (var i4 = 0; i4 < self2.config.showMonths; i4++) {
        var d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i4);
        frag.appendChild(buildMonthDays(d3.getFullYear(), d3.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      var shouldBuildMonth = function(month2) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
      };
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (var i4 = 0; i4 < 12; i4++) {
        if (!shouldBuildMonth(i4))
          continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i4).getMonth().toString();
        month.textContent = monthToStr(i4, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i4) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind2(self2.monthsDropdownContainer, "change", function(e3) {
          var target = getEventTarget(e3);
          var selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    function buildMonths() {
      clearNode(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (var m3 = self2.config.showMonths; m3--; ) {
        var month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    function buildMonthNav() {
      self2.monthNav = createElement("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: function() {
          return self2.__hidePrevMonthArrow;
        },
        set: function(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: function() {
          return self2.__hideNextMonthArrow;
        },
        set: function(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      var defaults3 = getDefaultHours(self2.config);
      self2.timeContainer = createElement("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults3.hours : military2ampm(defaults3.hours));
      self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults3.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults3.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int2((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self2.weekdayContainer);
      for (var i4 = self2.config.showMonths; i4--; ) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      var firstDayOfWeek = self2.l10n.firstDayOfWeek;
      var weekdays2 = __spreadArrays(self2.l10n.weekdays.shorthand);
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays2.length) {
        weekdays2 = __spreadArrays(weekdays2.splice(firstDayOfWeek, weekdays2.length), weekdays2.splice(0, firstDayOfWeek));
      }
      for (var i4 = self2.config.showMonths; i4--; ) {
        self2.weekdayContainer.children[i4].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays2.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }
      var delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }
      if (toInitial === void 0) {
        toInitial = true;
      }
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        var _a2 = getDefaultHours(self2.config), hours = _a2.hours, minutes = _a2.minutes, seconds = _a2.seconds;
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    function destroy() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (var i4 = self2._handlers.length; i4--; ) {
        self2._handlers[i4].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          var wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach(function(k3) {
        try {
          delete self2[k3];
        } catch (_3) {
        }
      });
    }
    function isCalendarElem(elem) {
      return self2.calendarContainer.contains(elem);
    }
    function documentClick(e3) {
      if (self2.isOpen && !self2.config.inline) {
        var eventTarget_1 = getEventTarget(e3);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput3 = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e3.path && e3.path.indexOf && (~e3.path.indexOf(self2.input) || ~e3.path.indexOf(self2.altInput));
        var lostFocus = !isInput3 && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
        var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
          return elem.contains(eventTarget_1);
        });
        if (lostFocus && isIgnored) {
          if (self2.config.allowInput) {
            self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
            self2.clear(false);
        }
      }
    }
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    function isEnabled(date3, timeless) {
      var _a2;
      if (timeless === void 0) {
        timeless = true;
      }
      var dateToCheck = self2.parseDate(date3, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      var bool = !!self2.config.enable, array = (_a2 = self2.config.enable) !== null && _a2 !== void 0 ? _a2 : self2.config.disable;
      for (var i4 = 0, d3 = void 0; i4 < array.length; i4++) {
        d3 = array[i4];
        if (typeof d3 === "function" && d3(dateToCheck))
          return bool;
        else if (d3 instanceof Date && dateToCheck !== void 0 && d3.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d3 === "string") {
          var parsed = self2.parseDate(d3, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d3 === "object" && dateToCheck !== void 0 && d3.from && d3.to && dateToCheck.getTime() >= d3.from.getTime() && dateToCheck.getTime() <= d3.to.getTime())
          return bool;
      }
      return !bool;
    }
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    function onBlur(e3) {
      var isInput3 = e3.target === self2._input;
      var valueChanged = self2._input.value.trimEnd() !== getDateStr();
      if (isInput3 && valueChanged && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
        self2.setDate(self2._input.value, true, e3.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    function onKeyDown(e3) {
      var eventTarget = getEventTarget(e3);
      var isInput3 = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      var allowInput = self2.config.allowInput;
      var allowKeydown = self2.isOpen && (!allowInput || !isInput3);
      var allowInlineKeydown = self2.config.inline && isInput3 && !allowInput;
      if (e3.keyCode === 13 && isInput3) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          self2.close();
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e3.keyCode) {
          case 13:
            if (isTimeObj) {
              e3.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e3);
            break;
          case 27:
            e3.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput3 && !self2.config.allowInput) {
              e3.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput3) {
              e3.preventDefault();
              var activeElement = getClosestActiveElement();
              if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                var delta_1 = e3.keyCode === 39 ? 1 : -1;
                if (!e3.ctrlKey)
                  focusOnDay(void 0, delta_1);
                else {
                  e3.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e3.preventDefault();
            var delta = e3.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e3.ctrlKey) {
                e3.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e3);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              var elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter(function(x3) {
                return x3;
              });
              var i4 = elems.indexOf(eventTarget);
              if (i4 !== -1) {
                var target = elems[i4 + (e3.shiftKey ? -1 : 1)];
                e3.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e3.shiftKey) {
              e3.preventDefault();
              self2._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e3.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue2();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue2();
            break;
        }
      }
      if (isInput3 || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e3);
      }
    }
    function onMouseOver(elem, cellClass) {
      if (cellClass === void 0) {
        cellClass = "flatpickr-day";
      }
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
        return;
      var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0, maxRange = 0;
      for (var t4 = rangeStartDate; t4 < rangeEndDate; t4 += duration.DAY) {
        if (!isEnabled(new Date(t4), true)) {
          containsDisabled = containsDisabled || t4 > rangeStartDate && t4 < rangeEndDate;
          if (t4 < initialDate && (!minRange || t4 > minRange))
            minRange = t4;
          else if (t4 > initialDate && (!maxRange || t4 < maxRange))
            maxRange = t4;
        }
      }
      var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
      hoverableCells.forEach(function(dayElem) {
        var date3 = dayElem.dateObj;
        var timestamp = date3.getTime();
        var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach(function(c3) {
            dayElem.classList.remove(c3);
          });
          return;
        } else if (containsDisabled && !outOfRange)
          return;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c3) {
          dayElem.classList.remove(c3);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      });
    }
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    function open(e3, positionElement) {
      if (positionElement === void 0) {
        positionElement = self2._positionElement;
      }
      if (self2.isMobile === true) {
        if (e3) {
          e3.preventDefault();
          var eventTarget = getEventTarget(e3);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      var wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e3 === void 0 || !self2.timeContainer.contains(e3.relatedTarget))) {
          setTimeout(function() {
            return self2.hourElement.select();
          }, 50);
        }
      }
    }
    function minMaxDateSetter(type3) {
      return function(date3) {
        var dateObj = self2.config["_" + type3 + "Date"] = self2.parseDate(date3, self2.config.dateFormat);
        var inverseDateObj = self2.config["_" + (type3 === "min" ? "max" : "min") + "Date"];
        if (dateObj !== void 0) {
          self2[type3 === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter(function(d3) {
            return isEnabled(d3);
          });
          if (!self2.selectedDates.length && type3 === "min")
            setHoursFromDate(dateObj);
          updateValue2();
        }
        if (self2.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self2.currentYearElement[type3] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type3);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    function parseConfig() {
      var boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      var formats2 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: function() {
          return self2.config._enable;
        },
        set: function(dates) {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: function() {
          return self2.config._disable;
        },
        set: function(dates) {
          self2.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }
      Object.defineProperty(self2.config, "minDate", {
        get: function() {
          return self2.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: function() {
          return self2.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });
      var minMaxTimeSetter = function(type3) {
        return function(val) {
          self2.config[type3 === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
        };
      };
      Object.defineProperty(self2.config, "minTime", {
        get: function() {
          return self2.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: function() {
          return self2.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats2, userConfig);
      for (var i4 = 0; i4 < boolOpts.length; i4++)
        self2.config[boolOpts[i4]] = self2.config[boolOpts[i4]] === true || self2.config[boolOpts[i4]] === "true";
      HOOKS.filter(function(hook) {
        return self2.config[hook] !== void 0;
      }).forEach(function(hook) {
        self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (var i4 = 0; i4 < self2.config.plugins.length; i4++) {
        var pluginConf = self2.config.plugins[i4](self2) || {};
        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
      self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
      tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
      tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
      tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
      tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
      tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
      var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter(self2);
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    }
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self2._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
        return acc + child.offsetHeight;
      }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;
      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self2.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = top2 + "px";
      if (!rightMost) {
        self2.calendarContainer.style.left = left + "px";
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = right + "px";
      } else {
        var doc2 = getDocumentStyleSheet();
        if (doc2 === void 0)
          return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc2.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self2.calendarContainer, "rightMost", false);
        toggleClass(self2.calendarContainer, "centerMost", true);
        doc2.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self2.calendarContainer.style.left = centerLeft + "px";
        self2.calendarContainer.style.right = "auto";
      }
    }
    function getDocumentStyleSheet() {
      var editableSheet = null;
      for (var i4 = 0; i4 < document.styleSheets.length; i4++) {
        var sheet = document.styleSheets[i4];
        if (!sheet.cssRules)
          continue;
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    function redraw() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    function selectDate(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      var isSelectable = function(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      };
      var t4 = findParent(getEventTarget(e3), isSelectable);
      if (t4 === void 0)
        return;
      var target = t4;
      var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort(function(a3, b2) {
            return a3.getTime() - b2.getTime();
          });
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        var isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue2();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        var single = self2.config.mode === "single" && !self2.config.enableTime;
        var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      positionElement: [updatePositionElement],
      clickOpens: [
        function() {
          if (self2.config.clickOpens === true) {
            bind2(self2._input, "focus", self2.open);
            bind2(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set3(option, value) {
      if (option !== null && typeof option === "object") {
        Object.assign(self2.config, option);
        for (var key in option) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach(function(x3) {
              return x3();
            });
        }
      } else {
        self2.config[option] = value;
        if (CALLBACKS[option] !== void 0)
          CALLBACKS[option].forEach(function(x3) {
            return x3();
          });
        else if (HOOKS.indexOf(option) > -1)
          self2.config[option] = arrayify(value);
      }
      self2.redraw();
      updateValue2(true);
    }
    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map(function(d3) {
          return self2.parseDate(d3, format);
        });
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map(function(date3) {
              return self2.parseDate(date3, format);
            });
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date3) {
              return self2.parseDate(date3, format);
            });
            break;
          default:
            break;
        }
      } else
        self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d3) {
        return d3 instanceof Date && isEnabled(d3, false);
      });
      if (self2.config.mode === "range")
        self2.selectedDates.sort(function(a3, b2) {
          return a3.getTime() - b2.getTime();
        });
    }
    function setDate(date3, triggerChange2, format) {
      if (triggerChange2 === void 0) {
        triggerChange2 = false;
      }
      if (format === void 0) {
        format = self2.config.dateFormat;
      }
      if (date3 !== 0 && !date3 || date3 instanceof Array && date3.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date3, format);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue2(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    function parseDateRules(arr) {
      return arr.slice().map(function(rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter(function(x3) {
        return x3;
      });
    }
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
      var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      updatePositionElement();
    }
    function updatePositionElement() {
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    function setupMobile() {
      var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a2) {
      }
      bind2(self2.mobileInput, "change", function(e3) {
        self2.setDate(getEventTarget(e3).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    function toggle(e3) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e3);
    }
    function triggerEvent(event2, data) {
      if (self2.config === void 0)
        return;
      var hooks = self2.config[event2];
      if (hooks !== void 0 && hooks.length > 0) {
        for (var i4 = 0; hooks[i4] && i4 < hooks.length; i4++)
          hooks[i4](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event2 === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    function createEvent(name2) {
      var e3 = document.createEvent("Event");
      e3.initEvent(name2, true, true);
      return e3;
    }
    function isDateSelected(date3) {
      for (var i4 = 0; i4 < self2.selectedDates.length; i4++) {
        var selectedDate = self2.selectedDates[i4];
        if (selectedDate instanceof Date && compareDates(selectedDate, date3) === 0)
          return "" + i4;
      }
      return false;
    }
    function isDateInRange(date3) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates(date3, self2.selectedDates[0]) >= 0 && compareDates(date3, self2.selectedDates[1]) <= 0;
    }
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach(function(yearElement, i4) {
        var d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i4);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i4].textContent = monthToStr(d3.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d3.getMonth().toString();
        }
        yearElement.value = d3.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    function getDateStr(specificFormat) {
      var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
      return self2.selectedDates.map(function(dObj) {
        return self2.formatDate(dObj, format);
      }).filter(function(d3, i4, arr) {
        return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d3) === i4;
      }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    function updateValue2(triggerChange2) {
      if (triggerChange2 === void 0) {
        triggerChange2 = true;
      }
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e3) {
      var eventTarget = getEventTarget(e3);
      var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      var isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    function timeWrapper(e3) {
      e3.preventDefault();
      var isKeyDown = e3.type === "keydown", eventTarget = getEventTarget(e3), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown ? e3.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min) {
          newValue = max + newValue + int2(!isHourElem) + (int2(isHourElem) && int2(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max) {
          newValue = input === self2.hourElement ? newValue - max - int2(!self2.amPM) : min;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    init();
    return self2;
  }
  function _flatpickr(nodeList, config2) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x3) {
      return x3 instanceof HTMLElement;
    });
    var instances = [];
    for (var i4 = 0; i4 < nodes.length; i4++) {
      var node = nodes[i4];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config2 || {});
        instances.push(node._flatpickr);
      } catch (e3) {
        console.error(e3);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
      return _flatpickr(this, config2);
    };
    HTMLElement.prototype.flatpickr = function(config2) {
      return _flatpickr([this], config2);
    };
  }
  var flatpickr = function(selector, config2) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config2);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config2);
    } else {
      return _flatpickr(selector, config2);
    }
  };
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: __assign({}, default_default),
    default: __assign({}, default_default)
  };
  flatpickr.localize = function(l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = function(config2) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config2);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config2) {
      return _flatpickr(this, config2);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  var esm_default = flatpickr;

  // node_modules/preact/compat/dist/compat.module.js
  function g3(n3, t4) {
    for (var e3 in t4) n3[e3] = t4[e3];
    return n3;
  }
  function E2(n3, t4) {
    for (var e3 in n3) if ("__source" !== e3 && !(e3 in t4)) return true;
    for (var r3 in t4) if ("__source" !== r3 && n3[r3] !== t4[r3]) return true;
    return false;
  }
  function N2(n3, t4) {
    this.props = n3, this.context = t4;
  }
  (N2.prototype = new x()).isPureReactComponent = true, N2.prototype.shouldComponentUpdate = function(n3, t4) {
    return E2(this.props, n3) || E2(this.state, t4);
  };
  var T3 = l.__b;
  l.__b = function(n3) {
    n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), T3 && T3(n3);
  };
  var A3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function D3(n3) {
    function t4(t5) {
      var e3 = g3({}, t5);
      return delete e3.ref, n3(e3, t5.ref || null);
    }
    return t4.$$typeof = A3, t4.render = t4, t4.prototype.isReactComponent = t4.__f = true, t4.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t4;
  }
  var F3 = l.__e;
  l.__e = function(n3, t4, e3, r3) {
    if (n3.then) {
      for (var u4, o3 = t4; o3 = o3.__; ) if ((u4 = o3.__c) && u4.__c) return null == t4.__e && (t4.__e = e3.__e, t4.__k = e3.__k), u4.__c(n3, t4);
    }
    F3(n3, t4, e3, r3);
  };
  var U = l.unmount;
  function V2(n3, t4, e3) {
    return n3 && (n3.__c && n3.__c.__H && (n3.__c.__H.__.forEach(function(n4) {
      "function" == typeof n4.__c && n4.__c();
    }), n3.__c.__H = null), null != (n3 = g3({}, n3)).__c && (n3.__c.__P === e3 && (n3.__c.__P = t4), n3.__c.__e = true, n3.__c = null), n3.__k = n3.__k && n3.__k.map(function(n4) {
      return V2(n4, t4, e3);
    })), n3;
  }
  function W(n3, t4, e3) {
    return n3 && e3 && (n3.__v = null, n3.__k = n3.__k && n3.__k.map(function(n4) {
      return W(n4, t4, e3);
    }), n3.__c && n3.__c.__P === t4 && (n3.__e && e3.appendChild(n3.__e), n3.__c.__e = true, n3.__c.__P = e3)), n3;
  }
  function P4() {
    this.__u = 0, this.o = null, this.__b = null;
  }
  function j3(n3) {
    var t4 = n3.__.__c;
    return t4 && t4.__a && t4.__a(n3);
  }
  function B3() {
    this.i = null, this.l = null;
  }
  l.unmount = function(n3) {
    var t4 = n3.__c;
    t4 && t4.__R && t4.__R(), t4 && 32 & n3.__u && (n3.type = null), U && U(n3);
  }, (P4.prototype = new x()).__c = function(n3, t4) {
    var e3 = t4.__c, r3 = this;
    null == r3.o && (r3.o = []), r3.o.push(e3);
    var u4 = j3(r3.__v), o3 = false, i4 = function() {
      o3 || (o3 = true, e3.__R = null, u4 ? u4(c3) : c3());
    };
    e3.__R = i4;
    var c3 = function() {
      if (!--r3.__u) {
        if (r3.state.__a) {
          var n4 = r3.state.__a;
          r3.__v.__k[0] = W(n4, n4.__c.__P, n4.__c.__O);
        }
        var t5;
        for (r3.setState({ __a: r3.__b = null }); t5 = r3.o.pop(); ) t5.forceUpdate();
      }
    };
    r3.__u++ || 32 & t4.__u || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n3.then(i4, i4);
  }, P4.prototype.componentWillUnmount = function() {
    this.o = [];
  }, P4.prototype.render = function(n3, e3) {
    if (this.__b) {
      if (this.__v.__k) {
        var r3 = document.createElement("div"), o3 = this.__v.__k[0].__c;
        this.__v.__k[0] = V2(this.__b, r3, o3.__O = o3.__P);
      }
      this.__b = null;
    }
    var i4 = e3.__a && _(k, null, n3.fallback);
    return i4 && (i4.__u &= -33), [_(k, null, e3.__a ? null : n3.children), i4];
  };
  var H2 = function(n3, t4, e3) {
    if (++e3[1] === e3[0] && n3.l.delete(t4), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.l.size)) for (e3 = n3.i; e3; ) {
      for (; e3.length > 3; ) e3.pop()();
      if (e3[1] < e3[0]) break;
      n3.i = e3 = e3[2];
    }
  };
  function Z(n3) {
    return this.getChildContext = function() {
      return n3.context;
    }, n3.children;
  }
  function Y(n3) {
    var e3 = this, r3 = n3.h;
    e3.componentWillUnmount = function() {
      E(null, e3.v), e3.v = null, e3.h = null;
    }, e3.h && e3.h !== r3 && e3.componentWillUnmount(), e3.v || (e3.h = r3, e3.v = { nodeType: 1, parentNode: r3, childNodes: [], contains: function() {
      return true;
    }, appendChild: function(n4) {
      this.childNodes.push(n4), e3.h.appendChild(n4);
    }, insertBefore: function(n4, t4) {
      this.childNodes.push(n4), e3.h.insertBefore(n4, t4);
    }, removeChild: function(n4) {
      this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1), e3.h.removeChild(n4);
    } }), E(_(Z, { context: e3.context }, n3.__v), e3.v);
  }
  function $2(n3, e3) {
    var r3 = _(Y, { __v: n3, h: e3 });
    return r3.containerInfo = e3, r3;
  }
  (B3.prototype = new x()).__a = function(n3) {
    var t4 = this, e3 = j3(t4.__v), r3 = t4.l.get(n3);
    return r3[0]++, function(u4) {
      var o3 = function() {
        t4.props.revealOrder ? (r3.push(u4), H2(t4, n3, r3)) : u4();
      };
      e3 ? e3(o3) : o3();
    };
  }, B3.prototype.render = function(n3) {
    this.i = null, this.l = /* @__PURE__ */ new Map();
    var t4 = H(n3.children);
    n3.revealOrder && "b" === n3.revealOrder[0] && t4.reverse();
    for (var e3 = t4.length; e3--; ) this.l.set(t4[e3], this.i = [1, 0, this.i]);
    return n3.children;
  }, B3.prototype.componentDidUpdate = B3.prototype.componentDidMount = function() {
    var n3 = this;
    this.l.forEach(function(t4, e3) {
      H2(n3, e3, t4);
    });
  };
  var q3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
  var G2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
  var J2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
  var K2 = /[A-Z0-9]/g;
  var Q = "undefined" != typeof document;
  var X = function(n3) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n3);
  };
  x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t4) {
    Object.defineProperty(x.prototype, t4, { configurable: true, get: function() {
      return this["UNSAFE_" + t4];
    }, set: function(n3) {
      Object.defineProperty(this, t4, { configurable: true, writable: true, value: n3 });
    } });
  });
  var en = l.event;
  function rn() {
  }
  function un() {
    return this.cancelBubble;
  }
  function on() {
    return this.defaultPrevented;
  }
  l.event = function(n3) {
    return en && (n3 = en(n3)), n3.persist = rn, n3.isPropagationStopped = un, n3.isDefaultPrevented = on, n3.nativeEvent = n3;
  };
  var cn;
  var ln = { enumerable: false, configurable: true, get: function() {
    return this.class;
  } };
  var fn = l.vnode;
  l.vnode = function(n3) {
    "string" == typeof n3.type && function(n4) {
      var t4 = n4.props, e3 = n4.type, u4 = {}, o3 = -1 === e3.indexOf("-");
      for (var i4 in t4) {
        var c3 = t4[i4];
        if (!("value" === i4 && "defaultValue" in t4 && null == c3 || Q && "children" === i4 && "noscript" === e3 || "class" === i4 || "className" === i4)) {
          var l4 = i4.toLowerCase();
          "defaultValue" === i4 && "value" in t4 && null == t4.value ? i4 = "value" : "download" === i4 && true === c3 ? c3 = "" : "translate" === l4 && "no" === c3 ? c3 = false : "o" === l4[0] && "n" === l4[1] ? "ondoubleclick" === l4 ? i4 = "ondblclick" : "onchange" !== l4 || "input" !== e3 && "textarea" !== e3 || X(t4.type) ? "onfocus" === l4 ? i4 = "onfocusin" : "onblur" === l4 ? i4 = "onfocusout" : J2.test(i4) && (i4 = l4) : l4 = i4 = "oninput" : o3 && G2.test(i4) ? i4 = i4.replace(K2, "-$&").toLowerCase() : null === c3 && (c3 = void 0), "oninput" === l4 && u4[i4 = l4] && (i4 = "oninputCapture"), u4[i4] = c3;
        }
      }
      "select" == e3 && u4.multiple && Array.isArray(u4.value) && (u4.value = H(t4.children).forEach(function(n5) {
        n5.props.selected = -1 != u4.value.indexOf(n5.props.value);
      })), "select" == e3 && null != u4.defaultValue && (u4.value = H(t4.children).forEach(function(n5) {
        n5.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n5.props.value) : u4.defaultValue == n5.props.value;
      })), t4.class && !t4.className ? (u4.class = t4.class, Object.defineProperty(u4, "className", ln)) : (t4.className && !t4.class || t4.class && t4.className) && (u4.class = u4.className = t4.className), n4.props = u4;
    }(n3), n3.$$typeof = q3, fn && fn(n3);
  };
  var an = l.__r;
  l.__r = function(n3) {
    an && an(n3), cn = n3.__c;
  };
  var sn = l.diffed;
  l.diffed = function(n3) {
    sn && sn(n3);
    var t4 = n3.props, e3 = n3.__e;
    null != e3 && "textarea" === n3.type && "value" in t4 && t4.value !== e3.value && (e3.value = null == t4.value ? "" : t4.value), cn = null;
  };

  // node_modules/dompurify/dist/purify.es.mjs
  var {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  var {
    freeze,
    seal,
    create
  } = Object;
  var {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x3) {
      return x3;
    };
  }
  if (!seal) {
    seal = function seal2(x3) {
      return x3;
    };
  }
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return new Func(...args);
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var arraySplice = unapply(Array.prototype.splice);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      if (thisArg instanceof RegExp) {
        thisArg.lastIndex = 0;
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set3, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set3, null);
    }
    let l4 = array.length;
    while (l4--) {
      let element = array[l4];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l4] = lcElement;
          }
          element = lcElement;
        }
      }
      set3[element] = true;
    }
    return set3;
  }
  function cleanArray(array) {
    for (let index2 = 0; index2 < array.length; index2++) {
      const isPropertyExist = objectHasOwnProperty(array, index2);
      if (!isPropertyExist) {
        array[index2] = null;
      }
    }
    return array;
  }
  function clone3(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone3(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var text = freeze(["#text"]);
  var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);
  var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  var NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12
    // Deprecated
  };
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html3) {
          return html3;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_3) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  var _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.2.5";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element: Element3,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2;
    const ElementPrototype = Element3.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove2 = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone3(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone3(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone3(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone3(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone3(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone3(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        getParentNode(node).removeChild(node);
      } catch (_3) {
        remove2(node);
      }
    };
    const _removeAttribute = function _removeAttribute2(name2, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name2),
          from: element
        });
      } catch (_3) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name2);
      if (name2 === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_3) {
          }
        } else {
          try {
            element.setAttribute(name2, "");
          } catch (_3) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc2 = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches4 = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches4 && matches4[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc2 = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_3) {
        }
      }
      if (!doc2 || !doc2.documentElement) {
        doc2 = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_3) {
        }
      }
      const body = doc2.body || doc2.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc2.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node2 === "function" && value instanceof Node2;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content2 = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i4 = childCount - 1; i4 >= 0; --i4) {
              const childClone = cloneNode(childNodes[i4], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content2 = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content2 = stringReplace(content2, expr, " ");
        });
        if (currentNode.textContent !== content2) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content2;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l4 = attributes.length;
      while (l4--) {
        const attr = attributes[l4];
        const {
          name: name2,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name2);
        let value = name2 === "value" ? attrValue : stringTrim(attrValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name2, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
          _removeAttribute(name2, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name2, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name2, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name2, value);
          } else {
            currentNode.setAttribute(name2, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_3) {
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag4, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag4);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();

  // node_modules/@bpmn-io/form-js-viewer/dist/index.es.js
  var import_lodash = __toESM(require_lodash());

  // node_modules/didi/dist/index.js
  var CLASS_PATTERN = /^class[ {]/;
  function isClass(fn4) {
    return CLASS_PATTERN.test(fn4.toString());
  }
  function isArray2(obj) {
    return Array.isArray(obj);
  }
  function hasOwnProp(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function annotate(...args) {
    if (args.length === 1 && isArray2(args[0])) {
      args = args[0];
    }
    args = [...args];
    const fn4 = args.pop();
    fn4.$inject = args;
    return fn4;
  }
  var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
  var FN_ARGS = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m;
  var FN_ARG = /\/\*([^*]*)\*\//m;
  function parseAnnotations(fn4) {
    if (typeof fn4 !== "function") {
      throw new Error(`Cannot annotate "${fn4}". Expected a function!`);
    }
    const match2 = fn4.toString().match(isClass(fn4) ? CONSTRUCTOR_ARGS : FN_ARGS);
    if (!match2) {
      return [];
    }
    const args = match2[1] || match2[2];
    return args && args.split(",").map((arg) => {
      const argMatch = arg.match(FN_ARG);
      return (argMatch && argMatch[1] || arg).trim();
    }) || [];
  }
  function Injector(modules, _parent) {
    const parent = _parent || /** @type InjectorContext */
    {
      get: function(name2, strict) {
        currentlyResolving.push(name2);
        if (strict === false) {
          return null;
        } else {
          throw error2(`No provider for "${name2}"!`);
        }
      }
    };
    const currentlyResolving = [];
    const providers = this._providers = Object.create(parent._providers || null);
    const instances = this._instances = /* @__PURE__ */ Object.create(null);
    const self2 = instances.injector = this;
    const error2 = function(msg) {
      const stack = currentlyResolving.join(" -> ");
      currentlyResolving.length = 0;
      return new Error(stack ? `${msg} (Resolving: ${stack})` : msg);
    };
    function get3(name2, strict) {
      if (!providers[name2] && name2.includes(".")) {
        const parts = name2.split(".");
        let pivot = get3(
          /** @type { string } */
          parts.shift()
        );
        while (parts.length) {
          pivot = pivot[
            /** @type { string } */
            parts.shift()
          ];
        }
        return pivot;
      }
      if (hasOwnProp(instances, name2)) {
        return instances[name2];
      }
      if (hasOwnProp(providers, name2)) {
        if (currentlyResolving.indexOf(name2) !== -1) {
          currentlyResolving.push(name2);
          throw error2("Cannot resolve circular dependency!");
        }
        currentlyResolving.push(name2);
        instances[name2] = providers[name2][0](providers[name2][1]);
        currentlyResolving.pop();
        return instances[name2];
      }
      return parent.get(name2, strict);
    }
    function fnDef(fn4, locals) {
      if (typeof locals === "undefined") {
        locals = {};
      }
      if (typeof fn4 !== "function") {
        if (isArray2(fn4)) {
          fn4 = annotate(fn4.slice());
        } else {
          throw error2(`Cannot invoke "${fn4}". Expected a function!`);
        }
      }
      const inject = fn4.$inject || parseAnnotations(fn4);
      const dependencies = inject.map((dep) => {
        if (hasOwnProp(locals, dep)) {
          return locals[dep];
        } else {
          return get3(dep);
        }
      });
      return {
        fn: fn4,
        dependencies
      };
    }
    function instantiate(type3) {
      const {
        fn: fn4,
        dependencies
      } = fnDef(type3);
      const Constructor = Function.prototype.bind.call(fn4, null, ...dependencies);
      return new Constructor();
    }
    function invoke(func, context, locals) {
      const {
        fn: fn4,
        dependencies
      } = fnDef(func, locals);
      return fn4.apply(context, dependencies);
    }
    function createPrivateInjectorFactory(childInjector) {
      return annotate((key) => childInjector.get(key));
    }
    function createChild(modules2, forceNewInstances) {
      if (forceNewInstances && forceNewInstances.length) {
        const fromParentModule = /* @__PURE__ */ Object.create(null);
        const matchedScopes = /* @__PURE__ */ Object.create(null);
        const privateInjectorsCache = [];
        const privateChildInjectors = [];
        const privateChildFactories = [];
        let provider;
        let cacheIdx;
        let privateChildInjector;
        let privateChildInjectorFactory;
        for (let name2 in providers) {
          provider = providers[name2];
          if (forceNewInstances.indexOf(name2) !== -1) {
            if (provider[2] === "private") {
              cacheIdx = privateInjectorsCache.indexOf(provider[3]);
              if (cacheIdx === -1) {
                privateChildInjector = provider[3].createChild([], forceNewInstances);
                privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
                privateInjectorsCache.push(provider[3]);
                privateChildInjectors.push(privateChildInjector);
                privateChildFactories.push(privateChildInjectorFactory);
                fromParentModule[name2] = [privateChildInjectorFactory, name2, "private", privateChildInjector];
              } else {
                fromParentModule[name2] = [privateChildFactories[cacheIdx], name2, "private", privateChildInjectors[cacheIdx]];
              }
            } else {
              fromParentModule[name2] = [provider[2], provider[1]];
            }
            matchedScopes[name2] = true;
          }
          if ((provider[2] === "factory" || provider[2] === "type") && provider[1].$scope) {
            forceNewInstances.forEach((scope) => {
              if (provider[1].$scope.indexOf(scope) !== -1) {
                fromParentModule[name2] = [provider[2], provider[1]];
                matchedScopes[scope] = true;
              }
            });
          }
        }
        forceNewInstances.forEach((scope) => {
          if (!matchedScopes[scope]) {
            throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
          }
        });
        modules2.unshift(fromParentModule);
      }
      return new Injector(modules2, self2);
    }
    const factoryMap = {
      factory: invoke,
      type: instantiate,
      value: function(value) {
        return value;
      }
    };
    function createInitializer(moduleDefinition, injector) {
      const initializers = moduleDefinition.__init__ || [];
      return function() {
        initializers.forEach((initializer) => {
          if (typeof initializer === "string") {
            injector.get(initializer);
          } else {
            injector.invoke(initializer);
          }
        });
      };
    }
    function loadModule(moduleDefinition) {
      const moduleExports = moduleDefinition.__exports__;
      if (moduleExports) {
        const nestedModules = moduleDefinition.__modules__;
        const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule2, key) => {
          if (key !== "__exports__" && key !== "__modules__" && key !== "__init__" && key !== "__depends__") {
            clonedModule2[key] = moduleDefinition[key];
          }
          return clonedModule2;
        }, /* @__PURE__ */ Object.create(null));
        const childModules = (nestedModules || []).concat(clonedModule);
        const privateInjector = createChild(childModules);
        const getFromPrivateInjector = annotate(function(key) {
          return privateInjector.get(key);
        });
        moduleExports.forEach(function(key) {
          providers[key] = [getFromPrivateInjector, key, "private", privateInjector];
        });
        const initializers = (moduleDefinition.__init__ || []).slice();
        initializers.unshift(function() {
          privateInjector.init();
        });
        moduleDefinition = Object.assign({}, moduleDefinition, {
          __init__: initializers
        });
        return createInitializer(moduleDefinition, privateInjector);
      }
      Object.keys(moduleDefinition).forEach(function(key) {
        if (key === "__init__" || key === "__depends__") {
          return;
        }
        const typeDeclaration = (
          /** @type { TypedDeclaration } */
          moduleDefinition[key]
        );
        if (typeDeclaration[2] === "private") {
          providers[key] = typeDeclaration;
          return;
        }
        const type3 = typeDeclaration[0];
        const value = typeDeclaration[1];
        providers[key] = [factoryMap[type3], arrayUnwrap(type3, value), type3];
      });
      return createInitializer(moduleDefinition, self2);
    }
    function resolveDependencies(moduleDefinitions, moduleDefinition) {
      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
        return moduleDefinitions;
      }
      moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);
      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
        return moduleDefinitions;
      }
      return moduleDefinitions.concat(moduleDefinition);
    }
    function bootstrap(moduleDefinitions) {
      const initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);
      let initialized = false;
      return function() {
        if (initialized) {
          return;
        }
        initialized = true;
        initializers.forEach((initializer) => initializer());
      };
    }
    this.get = get3;
    this.invoke = invoke;
    this.instantiate = instantiate;
    this.createChild = createChild;
    this.init = bootstrap(modules);
  }
  function arrayUnwrap(type3, value) {
    if (type3 !== "value" && isArray2(value)) {
      value = annotate(value.slice());
    }
    return value;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    /**
    Create a new node prop type.
    */
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
    add(match2) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match2 != "function")
        match2 = NodeType.match(match2);
      return (type3) => {
        let result = match2(type3);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.isolate = new NodeProp({ deserialize: (value) => {
    if (value && value != "rtl" && value != "ltr" && value != "auto")
      throw new RangeError("Invalid value for isolate: " + value);
    return value || "auto";
  } });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var MountedTree = class {
    constructor(tree, overlay, parser5) {
      this.tree = tree;
      this.overlay = overlay;
      this.parser = parser5;
    }
    /**
    @internal
    */
    static get(tree) {
      return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
  };
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class _NodeType {
    /**
    @internal
    */
    constructor(name2, props, id2, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id2;
      this.flags = flags;
    }
    /**
    Define a node type.
    */
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type3 = new _NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type3);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type3;
    }
    /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
    prop(prop) {
      return this.props[prop.id];
    }
    /**
    True when this is the top node of a grammar.
    */
    get isTop() {
      return (this.flags & 1) > 0;
    }
    /**
    True when this node is produced by a skip rule.
    */
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    /**
    Indicates whether this is an error node.
    */
    get isError() {
      return (this.flags & 4) > 0;
    }
    /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
    static match(map3) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map3)
        for (let name2 of prop.split(" "))
          direct[name2] = map3[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i4 = -1; i4 < (groups ? groups.length : 0); i4++) {
          let found = direct[i4 < 0 ? node.name : groups[i4]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType(
    "",
    /* @__PURE__ */ Object.create(null),
    0,
    8
    /* NodeFlag.Anonymous */
  );
  var NodeSet = class _NodeSet {
    /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
    constructor(types2) {
      this.types = types2;
      for (let i4 = 0; i4 < types2.length; i4++)
        if (types2[i4].id != i4)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
    extend(...props) {
      let newTypes = [];
      for (let type3 of this.types) {
        let newProps = null;
        for (let source of props) {
          let add2 = source(type3);
          if (add2) {
            if (!newProps)
              newProps = Object.assign({}, type3.props);
            newProps[add2[0].id] = add2[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type3.name, newProps, type3.id, type3.flags) : type3);
      }
      return new _NodeSet(newTypes);
    }
  };
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class _Tree {
    /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
    constructor(type3, children, positions, length, props) {
      this.type = type3;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    /**
    @internal
    */
    toString() {
      let mounted = MountedTree.get(this);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
    cursor(mode3 = 0) {
      return new TreeCursor(this.topNode, mode3);
    }
    /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
    cursorAt(pos, side = 0, mode3 = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor2 = new TreeCursor(scope);
      cursor2.moveTo(pos, side);
      CachedNode.set(this, cursor2._tree);
      return cursor2;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
    resolveStack(pos, side = 0) {
      return stackIterator(this, pos, side);
    }
    /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      let mode3 = spec.mode || 0, anon = (mode3 & IterMode.IncludeAnonymous) > 0;
      for (let c3 = this.cursor(mode3 | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c3.from <= to && c3.to >= from && (!anon && c3.type.isAnonymous || enter(c3) !== false)) {
          if (c3.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && (anon || !c3.type.isAnonymous))
            leave(c3);
          if (c3.nextSibling())
            break;
          if (!c3.parent())
            return;
          entered = true;
        }
      }
    }
    /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
    get propValues() {
      let result = [];
      if (this.props)
        for (let id2 in this.props)
          result.push([+id2, this.props[id2]]);
      return result;
    }
    /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
    }
    /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class _FlatBufferCursor {
    constructor(buffer, index2) {
      this.buffer = buffer;
      this.index = index2;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new _FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class _TreeBuffer {
    /**
    Create a tree buffer.
    */
    constructor(buffer, length, set3) {
      this.buffer = buffer;
      this.length = length;
      this.set = set3;
    }
    /**
    @internal
    */
    get type() {
      return NodeType.none;
    }
    /**
    @internal
    */
    toString() {
      let result = [];
      for (let index2 = 0; index2 < this.buffer.length; ) {
        result.push(this.childString(index2));
        index2 = this.buffer[index2 + 3];
      }
      return result.join(",");
    }
    /**
    @internal
    */
    childString(index2) {
      let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
      let type3 = this.set.types[id2], result = type3.name;
      if (/\W/.test(result) && !type3.isError)
        result = JSON.stringify(result);
      index2 += 4;
      if (endIndex == index2)
        return result;
      let children = [];
      while (index2 < endIndex) {
        children.push(this.childString(index2));
        index2 = this.buffer[index2 + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    /**
    @internal
    */
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick2 = -1;
      for (let i4 = startIndex; i4 != endIndex; i4 = buffer[i4 + 3]) {
        if (checkSide(side, pos, buffer[i4 + 1], buffer[i4 + 2])) {
          pick2 = i4;
          if (dir > 0)
            break;
        }
      }
      return pick2;
    }
    /**
    @internal
    */
    slice(startI, endI, from) {
      let b2 = this.buffer;
      let copy = new Uint16Array(endI - startI), len = 0;
      for (let i4 = startI, j4 = 0; i4 < endI; ) {
        copy[j4++] = b2[i4++];
        copy[j4++] = b2[i4++] - from;
        let to = copy[j4++] = b2[i4++] - from;
        copy[j4++] = b2[i4++] - startI;
        len = Math.max(len, to);
      }
      return new _TreeBuffer(copy, len, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode3 = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode3)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode3);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var BaseNode = class {
    cursor(mode3 = 0) {
      return new TreeCursor(this, mode3);
    }
    getChild(type3, before3 = null, after = null) {
      let r3 = getChildren(this, type3, before3, after);
      return r3.length ? r3[0] : null;
    }
    getChildren(type3, before3 = null, after = null) {
      return getChildren(this, type3, before3, after);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
      return matchNodeContext(this.parent, context);
    }
    enterUnfinishedNodesBefore(pos) {
      let scan = this.childBefore(pos), node = this;
      while (scan) {
        let last2 = scan.lastChild;
        if (!last2 || last2.to != scan.to)
          break;
        if (last2.type.isError && last2.from == last2.to) {
          node = scan;
          scan = last2.prevSibling;
        } else {
          scan = last2;
        }
      }
      return node;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  };
  var TreeNode = class _TreeNode extends BaseNode {
    constructor(_tree, from, index2, _parent) {
      super();
      this._tree = _tree;
      this.from = from;
      this.index = index2;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i4, dir, pos, side, mode3 = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent._tree, e3 = dir > 0 ? children.length : -1; i4 != e3; i4 += dir) {
          let next = children[i4], start = positions[i4] + parent.from;
          if (!checkSide(side, pos, start, start + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode3 & IterMode.ExcludeBuffers)
              continue;
            let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index2 > -1)
              return new BufferNode(new BufferContext(parent, next, i4, start), null, index2);
          } else if (mode3 & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode3 & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
              return new _TreeNode(mounted.tree, start, i4, parent);
            let inner = new _TreeNode(next, start, i4, parent);
            return mode3 & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode3 & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i4 = parent.index + dir;
        else
          i4 = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(
        0,
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    get lastChild() {
      return this.nextChild(
        this._tree.children.length - 1,
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    childAfter(pos) {
      return this.nextChild(
        0,
        1,
        pos,
        2
        /* Side.After */
      );
    }
    childBefore(pos) {
      return this.nextChild(
        this._tree.children.length - 1,
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    enter(pos, side, mode3 = 0) {
      let mounted;
      if (!(mode3 & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode3);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(
        this.index + 1,
        1,
        0,
        4
        /* Side.DontCare */
      ) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(
        this.index - 1,
        -1,
        0,
        4
        /* Side.DontCare */
      ) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    /**
    @internal
    */
    toString() {
      return this._tree.toString();
    }
  };
  function getChildren(node, type3, before3, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before3 != null)
      for (let found = false; !found; ) {
        found = cur2.type.is(before3);
        if (!cur2.nextSibling())
          return result;
      }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type3))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i4 = context.length - 1) {
    for (let p3 = node; i4 >= 0; p3 = p3.parent) {
      if (!p3)
        return false;
      if (!p3.type.isAnonymous) {
        if (context[i4] && context[i4] != p3.name)
          return false;
        i4--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index2, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index2;
      this.start = start;
    }
  };
  var BufferNode = class _BufferNode extends BaseNode {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index2) {
      super();
      this.context = context;
      this._parent = _parent;
      this.index = index2;
      this.type = context.buffer.set.types[context.buffer.buffer[index2]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
    }
    get firstChild() {
      return this.child(
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    get lastChild() {
      return this.child(
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    childAfter(pos) {
      return this.child(
        1,
        pos,
        2
        /* Side.After */
      );
    }
    childBefore(pos) {
      return this.child(
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    enter(pos, side, mode3 = 0) {
      if (mode3 & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(
        this.context.index + dir,
        dir,
        0,
        4
        /* Side.DontCare */
      );
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new _BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new _BufferNode(this.context, this._parent, buffer.findChild(
        parentStart,
        this.index,
        -1,
        0,
        4
        /* Side.DontCare */
      ));
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1];
        children.push(buffer.slice(startI, endI, from));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    /**
    @internal
    */
    toString() {
      return this.context.buffer.childString(this.index);
    }
  };
  function iterStack(heads) {
    if (!heads.length)
      return null;
    let pick2 = 0, picked = heads[0];
    for (let i4 = 1; i4 < heads.length; i4++) {
      let node = heads[i4];
      if (node.from > picked.from || node.to < picked.to) {
        picked = node;
        pick2 = i4;
      }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
      newHeads[pick2] = next;
    else
      newHeads.splice(pick2, 1);
    return new StackIterator(newHeads, picked);
  }
  var StackIterator = class {
    constructor(heads, node) {
      this.heads = heads;
      this.node = node;
    }
    get next() {
      return iterStack(this.heads);
    }
  };
  function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
      if (scan.index < 0) {
        let parent = scan.parent;
        (layers || (layers = [inner])).push(parent.resolve(pos, side));
        scan = parent;
      } else {
        let mount = MountedTree.get(scan.tree);
        if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
          let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
          (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
        }
      }
    }
    return layers ? iterStack(layers) : inner;
  }
  var TreeCursor = class {
    /**
    Shorthand for `.type.name`.
    */
    get name() {
      return this.type.name;
    }
    /**
    @internal
    */
    constructor(node, mode3 = 0) {
      this.mode = mode3;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n3 = node._parent; n3; n3 = n3._parent)
          this.stack.unshift(n3.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index2, type3) {
      this.index = index2;
      let { start, buffer } = this.buffer;
      this.type = type3 || buffer.set.types[buffer.buffer[index2]];
      this.from = start + buffer.buffer[index2 + 1];
      this.to = start + buffer.buffer[index2 + 2];
      return true;
    }
    /**
    @internal
    */
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    /**
    @internal
    */
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /**
    @internal
    */
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index2 < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index2);
    }
    /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
    firstChild() {
      return this.enterChild(
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    /**
    Move the cursor to this node's last child.
    */
    lastChild() {
      return this.enterChild(
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    /**
    Move the cursor to the first child that ends after `pos`.
    */
    childAfter(pos) {
      return this.enterChild(
        1,
        pos,
        2
        /* Side.After */
      );
    }
    /**
    Move to the last child that starts before `pos`.
    */
    childBefore(pos) {
      return this.enterChild(
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
    enter(pos, side, mode3 = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode3));
      return mode3 & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /**
    Move to the node's parent node, if this isn't the top node.
    */
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    /**
    @internal
    */
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d3 = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d3 < 0 ? 0 : this.stack[d3] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(
            parentStart,
            this.index,
            -1,
            0,
            4
            /* Side.DontCare */
          ));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d3 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d3] + 3]))
          return this.yieldBuf(after);
      }
      return d3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    /**
    Move to this node's next sibling, if any.
    */
    nextSibling() {
      return this.sibling(1);
    }
    /**
    Move to this node's previous sibling, if any.
    */
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index2, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i4 = 0; i4 < this.index; i4++)
            if (buffer.buffer.buffer[i4 + 3] < this.index)
              return false;
        }
        ({ index: index2, parent } = buffer);
      } else {
        ({ index: index2, _parent: parent } = this._tree);
      }
      for (; parent; { index: index2, _parent: parent } = parent) {
        if (index2 > -1)
          for (let i4 = index2 + dir, e3 = dir < 0 ? -1 : parent._tree.children.length; i4 != e3; i4 += dir) {
            let child = parent._tree.children[i4];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(
        dir,
        0,
        4
        /* Side.DontCare */
      ))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
    next(enter = true) {
      return this.move(1, enter);
    }
    /**
    Move to the next node in a last-to-first pre-order traversal. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
    prev(enter = true) {
      return this.move(-1, enter);
    }
    /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan: for (let index2 = this.index, d3 = this.stack.length; d3 >= 0; ) {
          for (let c3 = cache; c3; c3 = c3._parent)
            if (c3.index == index2) {
              if (index2 == this.index)
                return c3;
              result = c3;
              depth = d3 + 1;
              break scan;
            }
          index2 = this.stack[--d3];
        }
      }
      for (let i4 = depth; i4 < this.stack.length; i4++)
        result = new BufferNode(this.buffer, result, this.stack[i4]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (!depth)
            return;
          if (this.nextSibling())
            break;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    /**
    Test whether the current node matches a given contexta sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node.parent, context);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i4 = context.length - 1, d3 = this.stack.length - 1; i4 >= 0; d3--) {
        if (d3 < 0)
          return matchNodeContext(this._tree, context, i4);
        let type3 = types2[buffer.buffer[this.stack[d3]]];
        if (!type3.isAnonymous) {
          if (context[i4] && context[i4] != type3.name)
            return false;
          i4--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
      let { id: id2, start, end, size } = cursor2;
      let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
      while (size < 0) {
        cursor2.next();
        if (size == -1) {
          let node2 = reused[id2];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id2;
          return;
        } else if (size == -4) {
          lookAhead = id2;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type3 = types2[id2], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor2.pos - buffer2.size, index2 = data2.length;
        while (cursor2.pos > endPos)
          index2 = copyToBuffer(buffer2.start, data2, index2);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor2.pos - size;
        cursor2.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id2 >= minRepeatType ? id2 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor2.pos > endPos) {
          if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
            if (cursor2.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor2.end;
            }
            cursor2.next();
          } else if (depth > 2500) {
            takeFlatNode(start, endPos, localChildren, localPositions);
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type3, contextAtStart);
          node = balanceRange(type3, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type3, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children2, positions2) {
      let nodes = [];
      let nodeCount = 0, stopAt = -1;
      while (cursor2.pos > minPos) {
        let { id: id2, start, end, size } = cursor2;
        if (size > 4) {
          cursor2.next();
        } else if (stopAt > -1 && start < stopAt) {
          break;
        } else {
          if (stopAt < 0)
            stopAt = end - maxBufferLength;
          nodes.push(id2, start, end);
          nodeCount++;
          cursor2.next();
        }
      }
      if (nodeCount) {
        let buffer2 = new Uint16Array(nodeCount * 4);
        let start = nodes[nodes.length - 2];
        for (let i4 = nodes.length - 3, j4 = 0; i4 >= 0; i4 -= 3) {
          buffer2[j4++] = nodes[i4];
          buffer2[j4++] = nodes[i4 + 1] - start;
          buffer2[j4++] = nodes[i4 + 2] - start;
          buffer2[j4++] = j4;
        }
        children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
        positions2.push(start - parentStart);
      }
    }
    function makeBalanced(type3, contextHash2) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last2, lookAheadProp;
        if (lastI >= 0 && (last2 = children2[lastI]) instanceof Tree) {
          if (!lastI && last2.type == type3 && last2.length == length2)
            return last2;
          if (lookAheadProp = last2.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last2.length + lookAheadProp;
        }
        return makeTree(type3, children2, positions2, length2, lookAhead2, contextHash2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i4, from, to, type3, lookAhead2, contextHash2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i4) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type3], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
      positions2.push(from - base2);
    }
    function makeTree(type3, children2, positions2, length2, lookAhead2, contextHash2, props) {
      if (contextHash2) {
        let pair2 = [NodeProp.contextHash, contextHash2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type3, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor2.fork();
      let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart2;
        size += nodeSize2;
        skip += localSkipped;
      }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index2) {
      let { id: id2, start, end, size } = cursor2;
      cursor2.next();
      if (size >= 0 && id2 < minRepeatType) {
        let startIndex = index2;
        if (size > 4) {
          let endPos = cursor2.pos - (size - 4);
          while (cursor2.pos > endPos)
            index2 = copyToBuffer(bufferStart, buffer2, index2);
        }
        buffer2[--index2] = startIndex;
        buffer2[--index2] = end - bufferStart;
        buffer2[--index2] = start - bufferStart;
        buffer2[--index2] = id2;
      } else if (size == -3) {
        contextHash = id2;
      } else if (size == -4) {
        lookAhead = id2;
      }
      return index2;
    }
    let children = [], positions = [];
    while (cursor2.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i4 = from; i4 < to; i4++)
      total += nodeSize(balanceType, children[i4]);
    let maxChild = Math.ceil(
      total * 1.5 / 8
      /* Balance.BranchFactor */
    );
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset2) {
      for (let i4 = from2; i4 < to2; ) {
        let groupFrom = i4, groupStart = positions2[i4], groupSize = nodeSize(balanceType, children2[i4]);
        i4++;
        for (; i4 < to2; i4++) {
          let nextSize = nodeSize(balanceType, children2[i4]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i4 == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset2);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i4 - 1] + children2[i4 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i4, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset2 - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class _TreeFragment {
    /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
    constructor(from, to, tree, offset2, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset2;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
    get openStart() {
      return (this.open & 1) > 0;
    }
    /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
    get openEnd() {
      return (this.open & 2) > 0;
    }
    /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
    static addTree(tree, fragments = [], partial = false) {
      let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f4 of fragments)
        if (f4.to > tree.length)
          result.push(f4);
      return result;
    }
    /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r3) => new Range(r3.from, r3.to)) : [new Range(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    /**
    Run a full parse, returning the resulting tree.
    */
    parse(input, fragments, ranges) {
      let parse4 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse4.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  function parseMixed(nest) {
    return (parse4, input, fragments, ranges) => new MixedParse(parse4, nest, input, fragments, ranges);
  }
  var InnerParse = class {
    constructor(parser5, parse4, overlay, target, from) {
      this.parser = parser5;
      this.parse = parse4;
      this.overlay = overlay;
      this.target = target;
      this.from = from;
    }
  };
  function checkRanges(ranges) {
    if (!ranges.length || ranges.some((r3) => r3.from >= r3.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
  }
  var ActiveOverlay = class {
    constructor(parser5, predicate, mounts, index2, start, target, prev) {
      this.parser = parser5;
      this.predicate = predicate;
      this.mounts = mounts;
      this.index = index2;
      this.start = start;
      this.target = target;
      this.prev = prev;
      this.depth = 0;
      this.ranges = [];
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });
  var MixedParse = class {
    constructor(base2, nest, input, fragments, ranges) {
      this.nest = nest;
      this.input = input;
      this.fragments = fragments;
      this.ranges = ranges;
      this.inner = [];
      this.innerDone = 0;
      this.baseTree = null;
      this.stoppedAt = null;
      this.baseParse = base2;
    }
    advance() {
      if (this.baseParse) {
        let done2 = this.baseParse.advance();
        if (!done2)
          return null;
        this.baseParse = null;
        this.baseTree = done2;
        this.startInner();
        if (this.stoppedAt != null)
          for (let inner2 of this.inner)
            inner2.parse.stopAt(this.stoppedAt);
      }
      if (this.innerDone == this.inner.length) {
        let result = this.baseTree;
        if (this.stoppedAt != null)
          result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
        return result;
      }
      let inner = this.inner[this.innerDone], done = inner.parse.advance();
      if (done) {
        this.innerDone++;
        let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
        props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
        inner.target.props = props;
      }
      return null;
    }
    get parsedPos() {
      if (this.baseParse)
        return 0;
      let pos = this.input.length;
      for (let i4 = this.innerDone; i4 < this.inner.length; i4++) {
        if (this.inner[i4].from < pos)
          pos = Math.min(pos, this.inner[i4].parse.parsedPos);
      }
      return pos;
    }
    stopAt(pos) {
      this.stoppedAt = pos;
      if (this.baseParse)
        this.baseParse.stopAt(pos);
      else
        for (let i4 = this.innerDone; i4 < this.inner.length; i4++)
          this.inner[i4].parse.stopAt(pos);
    }
    startInner() {
      let fragmentCursor = new FragmentCursor(this.fragments);
      let overlay = null;
      let covered = null;
      let cursor2 = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
      scan: for (let nest, isCovered; ; ) {
        let enter = true, range;
        if (this.stoppedAt != null && cursor2.from >= this.stoppedAt) {
          enter = false;
        } else if (fragmentCursor.hasNode(cursor2)) {
          if (overlay) {
            let match2 = overlay.mounts.find((m3) => m3.frag.from <= cursor2.from && m3.frag.to >= cursor2.to && m3.mount.overlay);
            if (match2)
              for (let r3 of match2.mount.overlay) {
                let from = r3.from + match2.pos, to = r3.to + match2.pos;
                if (from >= cursor2.from && to <= cursor2.to && !overlay.ranges.some((r4) => r4.from < to && r4.to > from))
                  overlay.ranges.push({ from, to });
              }
          }
          enter = false;
        } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
          enter = isCovered != 2;
        } else if (!cursor2.type.isAnonymous && (nest = this.nest(cursor2, this.input)) && (cursor2.from < cursor2.to || !nest.overlay)) {
          if (!cursor2.tree)
            materialize(cursor2);
          let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser);
          if (typeof nest.overlay == "function") {
            overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor2.from, cursor2.tree, overlay);
          } else {
            let ranges = punchRanges(this.ranges, nest.overlay || (cursor2.from < cursor2.to ? [new Range(cursor2.from, cursor2.to)] : []));
            if (ranges.length)
              checkRanges(ranges);
            if (ranges.length || !nest.overlay)
              this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map((r3) => new Range(r3.from - cursor2.from, r3.to - cursor2.from)) : null, cursor2.tree, ranges.length ? ranges[0].from : cursor2.from));
            if (!nest.overlay)
              enter = false;
            else if (ranges.length)
              covered = { ranges, depth: 0, prev: covered };
          }
        } else if (overlay && (range = overlay.predicate(cursor2))) {
          if (range === true)
            range = new Range(cursor2.from, cursor2.to);
          if (range.from < range.to) {
            let last2 = overlay.ranges.length - 1;
            if (last2 >= 0 && overlay.ranges[last2].to == range.from)
              overlay.ranges[last2] = { from: overlay.ranges[last2].from, to: range.to };
            else
              overlay.ranges.push(range);
          }
        }
        if (enter && cursor2.firstChild()) {
          if (overlay)
            overlay.depth++;
          if (covered)
            covered.depth++;
        } else {
          for (; ; ) {
            if (cursor2.nextSibling())
              break;
            if (!cursor2.parent())
              break scan;
            if (overlay && !--overlay.depth) {
              let ranges = punchRanges(this.ranges, overlay.ranges);
              if (ranges.length) {
                checkRanges(ranges);
                this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r3) => new Range(r3.from - overlay.start, r3.to - overlay.start)), overlay.target, ranges[0].from));
              }
              overlay = overlay.prev;
            }
            if (covered && !--covered.depth)
              covered = covered.prev;
          }
        }
      }
    }
  };
  function checkCover(covered, from, to) {
    for (let range of covered) {
      if (range.from >= to)
        break;
      if (range.to > from)
        return range.from <= from && range.to >= to ? 2 : 1;
    }
    return 0;
  }
  function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
      let from = buf.buffer[startI + 1];
      nodes.push(buf.slice(startI, endI, from));
      positions.push(from - off);
    }
  }
  function materialize(cursor2) {
    let { node } = cursor2, stack = [];
    let buffer = node.context.buffer;
    do {
      stack.push(cursor2.index);
      cursor2.parent();
    } while (!cursor2.tree);
    let base2 = cursor2.tree, i4 = base2.children.indexOf(buffer);
    let buf = base2.children[i4], b2 = buf.buffer, newStack = [i4];
    function split(startI, endI, type3, innerOffset, length, stackPos) {
      let targetI = stack[stackPos];
      let children = [], positions = [];
      sliceBuf(buf, startI, targetI, children, positions, innerOffset);
      let from = b2[targetI + 1], to = b2[targetI + 2];
      newStack.push(children.length);
      let child = stackPos ? split(targetI + 4, b2[targetI + 3], buf.set.types[b2[targetI]], from, to - from, stackPos - 1) : node.toTree();
      children.push(child);
      positions.push(from - innerOffset);
      sliceBuf(buf, b2[targetI + 3], endI, children, positions, innerOffset);
      return new Tree(type3, children, positions, length);
    }
    base2.children[i4] = split(0, b2.length, NodeType.none, 0, buf.length, stack.length - 1);
    for (let index2 of newStack) {
      let tree = cursor2.tree.children[index2], pos = cursor2.tree.positions[index2];
      cursor2.yield(new TreeNode(tree, pos + cursor2.from, index2, cursor2._tree));
    }
  }
  var StructureCursor = class {
    constructor(root, offset2) {
      this.offset = offset2;
      this.done = false;
      this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
      let { cursor: cursor2 } = this, p3 = pos - this.offset;
      while (!this.done && cursor2.from < p3) {
        if (cursor2.to >= pos && cursor2.enter(p3, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
        else if (!cursor2.next(false))
          this.done = true;
      }
    }
    hasNode(cursor2) {
      this.moveTo(cursor2.from);
      if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
        for (let tree = this.cursor.tree; ; ) {
          if (tree == cursor2.tree)
            return true;
          if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
            tree = tree.children[0];
          else
            break;
        }
      }
      return false;
    }
  };
  var FragmentCursor = class {
    constructor(fragments) {
      var _a2;
      this.fragments = fragments;
      this.curTo = 0;
      this.fragI = 0;
      if (fragments.length) {
        let first = this.curFrag = fragments[0];
        this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
        this.inner = new StructureCursor(first.tree, -first.offset);
      } else {
        this.curFrag = this.inner = null;
      }
    }
    hasNode(node) {
      while (this.curFrag && node.from >= this.curTo)
        this.nextFrag();
      return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
      var _a2;
      this.fragI++;
      if (this.fragI == this.fragments.length) {
        this.curFrag = this.inner = null;
      } else {
        let frag = this.curFrag = this.fragments[this.fragI];
        this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
        this.inner = new StructureCursor(frag.tree, -frag.offset);
      }
    }
    findMounts(pos, parser5) {
      var _a2;
      let result = [];
      if (this.inner) {
        this.inner.cursor.moveTo(pos, 1);
        for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
          let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
          if (mount && mount.parser == parser5) {
            for (let i4 = this.fragI; i4 < this.fragments.length; i4++) {
              let frag = this.fragments[i4];
              if (frag.from >= pos2.to)
                break;
              if (frag.tree == this.curFrag.tree)
                result.push({
                  frag,
                  pos: pos2.from - frag.offset,
                  mount
                });
            }
          }
        }
      }
      return result;
    }
  };
  function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i4 = 1, j4 = 0; i4 < outer.length; i4++) {
      let gapFrom = outer[i4 - 1].to, gapTo = outer[i4].from;
      for (; j4 < current.length; j4++) {
        let r3 = current[j4];
        if (r3.from >= gapTo)
          break;
        if (r3.to <= gapFrom)
          continue;
        if (!copy)
          current = copy = ranges.slice();
        if (r3.from < gapFrom) {
          copy[j4] = new Range(r3.from, gapFrom);
          if (r3.to > gapTo)
            copy.splice(j4 + 1, 0, new Range(gapTo, r3.to));
        } else if (r3.to > gapTo) {
          copy[j4--] = new Range(gapTo, r3.to);
        } else {
          copy.splice(j4--, 1);
        }
      }
    }
    return current;
  }
  function findCoverChanges(a3, b2, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (; ; ) {
      let nextA = iA == a3.length ? 1e9 : inA ? a3[iA].to : a3[iA].from;
      let nextB = iB == b2.length ? 1e9 : inB ? b2[iB].to : b2[iB].from;
      if (inA != inB) {
        let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
        if (start < end)
          result.push(new Range(start, end));
      }
      pos = Math.min(nextA, nextB);
      if (pos == 1e9)
        break;
      if (nextA == pos) {
        if (!inA)
          inA = true;
        else {
          inA = false;
          iA++;
        }
      }
      if (nextB == pos) {
        if (!inB)
          inB = true;
        else {
          inB = false;
          iB++;
        }
      }
    }
    return result;
  }
  function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
      let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
      let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
      if (mount.overlay) {
        let overlay = mount.overlay.map((r3) => new Range(r3.from + pos, r3.to + pos));
        let changes = findCoverChanges(ranges, overlay, from, to);
        for (let i4 = 0, pos2 = from; ; i4++) {
          let last2 = i4 == changes.length, end = last2 ? to : changes[i4].from;
          if (end > pos2)
            result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
          if (last2)
            break;
          pos2 = changes[i4].to;
        }
      } else {
        result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
      }
    }
    return result;
  }

  // node_modules/@lezer/lr/dist/index.js
  var Stack = class _Stack {
    /**
    @internal
    */
    constructor(p3, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p3;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score2;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    /**
    @internal
    */
    toString() {
      return `[${this.stack.filter((_3, i4) => i4 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /**
    @internal
    */
    static start(p3, state, pos = 0) {
      let cx = p3.parser.context;
      return new _Stack(p3, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /**
    The stack's current [context](#lr.ContextTracker) value, if
    any. Its type will depend on the context tracker's type
    parameter, or it will be `null` if there is no context
    tracker.
    */
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /**
    @internal
    */
    pushState(state, start) {
      this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    // Apply a reduce action
    /**
    @internal
    */
    reduce(action) {
      var _a2;
      let depth = action >> 19, type3 = action & 65535;
      let { parser: parser5 } = this.p;
      let lookaheadRecord = this.reducePos < this.pos - 25;
      if (lookaheadRecord)
        this.setLookAhead(this.pos);
      let dPrec = parser5.dynamicPrecedence(type3);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser5.getGoto(this.state, type3, true), this.reducePos);
        if (type3 < parser5.minRepeatTerm)
          this.storeNode(type3, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
        this.reduceContext(type3, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
      if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type3]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
        if (start == this.p.lastBigReductionStart) {
          this.p.bigReductionCount++;
          this.p.lastBigReductionSize = size;
        } else if (this.p.lastBigReductionSize < size) {
          this.p.bigReductionCount = 1;
          this.p.lastBigReductionStart = start;
          this.p.lastBigReductionSize = size;
        }
      }
      let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
      if (type3 < parser5.minRepeatTerm || action & 131072) {
        let pos = parser5.stateFlag(
          this.state,
          1
          /* StateFlag.Skipped */
        ) ? this.pos : this.reducePos;
        this.storeNode(type3, start, pos, count + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser5.getGoto(baseStateID, type3, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type3, start);
    }
    // Shift a value into the buffer
    /**
    @internal
    */
    storeNode(term, start, end, size = 4, mustSink = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur2 = this, top2 = this.buffer.length;
        if (top2 == 0 && cur2.parent) {
          top2 = cur2.bufferBase - cur2.parent.bufferBase;
          cur2 = cur2.parent;
        }
        if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
          if (start == end)
            return;
          if (cur2.buffer[top2 - 2] >= start) {
            cur2.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!mustSink || this.pos == end) {
        this.buffer.push(term, start, end, size);
      } else {
        let index2 = this.buffer.length;
        if (index2 > 0 && this.buffer[index2 - 4] != 0) {
          let mustMove = false;
          for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
            if (this.buffer[scan - 1] >= 0) {
              mustMove = true;
              break;
            }
          }
          if (mustMove)
            while (index2 > 0 && this.buffer[index2 - 2] > end) {
              this.buffer[index2] = this.buffer[index2 - 4];
              this.buffer[index2 + 1] = this.buffer[index2 - 3];
              this.buffer[index2 + 2] = this.buffer[index2 - 2];
              this.buffer[index2 + 3] = this.buffer[index2 - 1];
              index2 -= 4;
              if (size > 4)
                size -= 4;
            }
        }
        this.buffer[index2] = term;
        this.buffer[index2 + 1] = start;
        this.buffer[index2 + 2] = end;
        this.buffer[index2 + 3] = size;
      }
    }
    // Apply a shift action
    /**
    @internal
    */
    shift(action, type3, start, end) {
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        let nextState = action, { parser: parser5 } = this.p;
        if (end > this.pos || type3 <= parser5.maxNode) {
          this.pos = end;
          if (!parser5.stateFlag(
            nextState,
            1
            /* StateFlag.Skipped */
          ))
            this.reducePos = end;
        }
        this.pushState(nextState, start);
        this.shiftContext(type3, start);
        if (type3 <= parser5.maxNode)
          this.buffer.push(type3, start, end, 4);
      } else {
        this.pos = end;
        this.shiftContext(type3, start);
        if (type3 <= this.p.parser.maxNode)
          this.buffer.push(type3, start, end, 4);
      }
    }
    // Apply an action
    /**
    @internal
    */
    apply(action, next, nextStart, nextEnd) {
      if (action & 65536)
        this.reduce(action);
      else
        this.shift(action, next, nextStart, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /**
    @internal
    */
    useNode(value, next) {
      let index2 = this.p.reused.length - 1;
      if (index2 < 0 || this.p.reused[index2] != value) {
        this.p.reused.push(value);
        index2++;
      }
      let start = this.pos;
      this.reducePos = this.pos = start + value.length;
      this.pushState(next, start);
      this.buffer.push(
        index2,
        start,
        this.reducePos,
        -1
        /* size == -1 means this is a reused value */
      );
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /**
    @internal
    */
    split() {
      let parent = this;
      let off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
        off -= 4;
      let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /**
    @internal
    */
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    /**
    Check if the given term would be able to be shifted (optionally
    after some reductions) on this stack. This can be useful for
    external tokenizers that want to make sure they only provide a
    given token when it applies.
    */
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action = this.p.parser.stateSlot(
          sim.state,
          4
          /* ParseState.DefaultReduce */
        ) || this.p.parser.hasAction(sim.state, term);
        if (action == 0)
          return false;
        if ((action & 65536) == 0)
          return true;
        sim.reduce(action);
      }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /**
    @internal
    */
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i4 = 0, s4; i4 < nextStates.length; i4 += 2) {
          if ((s4 = nextStates[i4 + 1]) != this.state && this.p.parser.hasAction(s4, next))
            best.push(nextStates[i4], s4);
        }
        if (this.stack.length < 120)
          for (let i4 = 0; best.length < 4 << 1 && i4 < nextStates.length; i4 += 2) {
            let s4 = nextStates[i4 + 1];
            if (!best.some((v4, i5) => i5 & 1 && v4 == s4))
              best.push(nextStates[i4], s4);
          }
        nextStates = best;
      }
      let result = [];
      for (let i4 = 0; i4 < nextStates.length && result.length < 4; i4 += 2) {
        let s4 = nextStates[i4 + 1];
        if (s4 == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s4, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i4], this.pos);
        stack.reducePos = this.pos;
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /**
    @internal
    */
    forceReduce() {
      let { parser: parser5 } = this.p;
      let reduce2 = parser5.stateSlot(
        this.state,
        5
        /* ParseState.ForcedReduce */
      );
      if ((reduce2 & 65536) == 0)
        return false;
      if (!parser5.validAction(this.state, reduce2)) {
        let depth = reduce2 >> 19, term = reduce2 & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser5.getGoto(this.stack[target], term, false) < 0) {
          let backup = this.findForcedReduction();
          if (backup == null)
            return false;
          reduce2 = backup;
        }
        this.storeNode(0, this.pos, this.pos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce2);
      return true;
    }
    /**
    Try to scan through the automaton to find some kind of reduction
    that can be applied. Used when the regular ForcedReduce field
    isn't a valid action. @internal
    */
    findForcedReduction() {
      let { parser: parser5 } = this.p, seen = [];
      let explore = (state, depth) => {
        if (seen.includes(state))
          return;
        seen.push(state);
        return parser5.allActions(state, (action) => {
          if (action & (262144 | 131072)) ;
          else if (action & 65536) {
            let rDepth = (action >> 19) - depth;
            if (rDepth > 1) {
              let term = action & 65535, target = this.stack.length - rDepth * 3;
              if (target >= 0 && parser5.getGoto(this.stack[target], term, false) >= 0)
                return rDepth << 19 | 65536 | term;
            }
          } else {
            let found = explore(action, depth + 1);
            if (found != null)
              return found;
          }
        });
      };
      return explore(this.state, 0);
    }
    /**
    @internal
    */
    forceAll() {
      while (!this.p.parser.stateFlag(
        this.state,
        2
        /* StateFlag.Accepting */
      )) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    /**
    Check whether this state has no further actions (assumed to be a direct descendant of the
    top state, since any other states must be able to continue
    somehow). @internal
    */
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let { parser: parser5 } = this.p;
      return parser5.data[parser5.stateSlot(
        this.state,
        1
        /* ParseState.Actions */
      )] == 65535 && !parser5.stateSlot(
        this.state,
        4
        /* ParseState.DefaultReduce */
      );
    }
    /**
    Restart the stack (put it back in its start state). Only safe
    when this.stack.length == 3 (state is directly below the top
    state). @internal
    */
    restart() {
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    /**
    @internal
    */
    sameState(other2) {
      if (this.state != other2.state || this.stack.length != other2.stack.length)
        return false;
      for (let i4 = 0; i4 < this.stack.length; i4 += 3)
        if (this.stack[i4] != other2.stack[i4])
          return false;
      return true;
    }
    /**
    Get the parser used by this stack.
    */
    get parser() {
      return this.p.parser;
    }
    /**
    Test whether a given dialect (by numeric ID, as exported from
    the terms file) is enabled.
    */
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /**
    @internal
    */
    emitContext() {
      let last2 = this.buffer.length - 1;
      if (last2 < 0 || this.buffer[last2] != -3)
        this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
    }
    /**
    @internal
    */
    emitLookAhead() {
      let last2 = this.buffer.length - 1;
      if (last2 < 0 || this.buffer[last2] != -4)
        this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    /**
    @internal
    */
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    /**
    @internal
    */
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  var SimulatedStack = class {
    constructor(start) {
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
    reduce(action) {
      let term = action & 65535, depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class _StackBufferCursor {
    constructor(stack, pos, index2) {
      this.stack = stack;
      this.pos = pos;
      this.index = index2;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new _StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  function decodeArray(input, Type2 = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array)
        array[out++] = value;
      else
        array = new Type2(value);
    }
    return array;
  }
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    /**
    @internal
    */
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    /**
    @internal
    */
    resolveOffset(offset2, assoc) {
      let range = this.range, index2 = this.rangeIndex;
      let pos = this.pos + offset2;
      while (pos < range.from) {
        if (!index2)
          return null;
        let next = this.ranges[--index2];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index2 == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index2];
        pos += next.from - range.to;
        range = next;
      }
      return pos;
    }
    /**
    @internal
    */
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range of this.ranges)
        if (range.to > pos)
          return Math.max(pos, range.from);
      return this.end;
    }
    /**
    Look at a code unit near the stream position. `.peek(0)` equals
    `.next`, `.peek(-1)` gives you the previous character, and so
    on.
    
    Note that looking around during tokenizing creates dependencies
    on potentially far-away content, which may reduce the
    effectiveness incremental parsingwhen looking forwardor even
    cause invalid reparses when looking backward more than 25 code
    units, since the library does not track lookbehind.
    */
    peek(offset2) {
      let idx = this.chunkOff + offset2, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset2;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset2, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i4 = this.rangeIndex, range = this.range;
          while (range.to <= pos)
            range = this.ranges[++i4];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range.to)
            this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    /**
    Accept a token. By default, the end of the token is set to the
    current stream position, but you can pass an offset (relative to
    the stream position) to change that.
    */
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    /**
    Accept a token ending at a specific given position.
    */
    acceptTokenTo(token, endPos) {
      this.token.value = token;
      this.token.end = endPos;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let { chunk: chunk2, chunkPos } = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk2;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /**
    Move the stream forward N (defaults to 1) code units. Returns
    the new value of [`next`](#lr.InputStream.next).
    */
    advance(n3 = 1) {
      this.chunkOff += n3;
      while (this.pos + n3 >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n3 -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n3;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    /**
    @internal
    */
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    /**
    @internal
    */
    read(from, to) {
      if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
      if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
      if (from >= this.range.from && to <= this.range.to)
        return this.input.read(from, to);
      let result = "";
      for (let r3 of this.ranges) {
        if (r3.from >= to)
          break;
        if (r3.to > from)
          result += this.input.read(Math.max(r3.from, from), Math.min(r3.to, to));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id2) {
      this.data = data;
      this.id = id2;
    }
    token(input, stack) {
      let { parser: parser5 } = stack.p;
      readToken(this.data, input, stack, this.id, parser5.data, parser5.tokenPrecTable);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var LocalTokenGroup = class {
    constructor(data, precTable, elseToken) {
      this.precTable = precTable;
      this.elseToken = elseToken;
      this.data = typeof data == "string" ? decodeArray(data) : data;
    }
    token(input, stack) {
      let start = input.pos, skipped = 0;
      for (; ; ) {
        let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
        readToken(this.data, input, stack, 0, this.data, this.precTable);
        if (input.token.value > -1)
          break;
        if (this.elseToken == null)
          return;
        if (!atEof)
          skipped++;
        if (nextPos == null)
          break;
        input.reset(nextPos, input.token);
      }
      if (skipped) {
        input.reset(start, input.token);
        input.acceptToken(this.elseToken, skipped);
      }
    }
  };
  LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var ExternalTokenizer = class {
    /**
    Create a tokenizer. The first argument is the function that,
    given an input stream, scans for the types of tokens it
    recognizes at the stream's position, and calls
    [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    one.
    */
    constructor(token, options2 = {}) {
      this.token = token;
      this.contextual = !!options2.contextual;
      this.fallback = !!options2.fallback;
      this.extend = !!options2.extend;
    }
  };
  function readToken(data, input, stack, group, precTable, precOffset) {
    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
    scan: for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i4 = state + 3; i4 < accEnd; i4 += 2)
        if ((data[i4 + 1] & groupMask) > 0) {
          let term = data[i4];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index2 = accEnd + mid + (mid << 1);
        let from = data[index2], to = data[index2 + 1] || 65536;
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index2 + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
  }
  function findOffset(data, start, term) {
    for (let i4 = start, next; (next = data[i4]) != 65535; i4++)
      if (next == term)
        return i4 - start;
    return -1;
  }
  function overrides(token, prev, tableData, tableOffset) {
    let iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  function cutAt(tree, pos, side) {
    let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
    cursor2.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
            return side < 0 ? Math.max(0, Math.min(
              cursor2.to - 1,
              pos - 25
              /* Lookahead.Margin */
            )) : Math.min(tree.length, Math.max(
              cursor2.from + 1,
              pos + 25
              /* Lookahead.Margin */
            ));
          if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
            break;
          if (!cursor2.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor2 = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last2 = this.trees.length - 1;
        if (last2 < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last2], index2 = this.index[last2];
        if (index2 == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index2];
        let start = this.start[last2] + top2.positions[index2];
        if (start > pos) {
          this.nextStart = start;
          return null;
        }
        if (next instanceof Tree) {
          if (start == pos) {
            if (start < this.safeFrom)
              return null;
            let end = start + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last2]++;
          if (start + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start);
            this.index.push(0);
          }
        } else {
          this.index[last2]++;
          this.nextStart = start + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser5, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser5.tokenizers.map((_3) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main = null;
      let { parser: parser5 } = stack.p, { tokenizers } = parser5;
      let mask = parser5.stateSlot(
        stack.state,
        3
        /* ParseState.TokenizerMask */
      );
      let context = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i4 = 0; i4 < tokenizers.length; i4++) {
        if ((1 << i4 & mask) == 0)
          continue;
        let tokenizer = tokenizers[i4], token = this.tokens[i4];
        if (main && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main = new CachedToken(), { pos, p: p3 } = stack;
      main.start = pos;
      main.end = Math.min(pos + 1, p3.stream.end);
      main.value = pos == p3.stream.end ? p3.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start, token), stack);
      if (token.value > -1) {
        let { parser: parser5 } = stack.p;
        for (let i4 = 0; i4 < parser5.specialized.length; i4++)
          if (parser5.specialized[i4] == token.value) {
            let result = parser5.specializers[i4](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start + 1);
      }
    }
    putAction(action, token, end, index2) {
      for (let i4 = 0; i4 < index2; i4 += 3)
        if (this.actions[i4] == action)
          return index2;
      this.actions[index2++] = action;
      this.actions[index2++] = token;
      this.actions[index2++] = end;
      return index2;
    }
    addActions(stack, token, end, index2) {
      let { state } = stack, { parser: parser5 } = stack.p, { data } = parser5;
      for (let set3 = 0; set3 < 2; set3++) {
        for (let i4 = parser5.stateSlot(
          state,
          set3 ? 2 : 1
          /* ParseState.Actions */
        ); ; i4 += 3) {
          if (data[i4] == 65535) {
            if (data[i4 + 1] == 1) {
              i4 = pair(data, i4 + 2);
            } else {
              if (index2 == 0 && data[i4 + 1] == 2)
                index2 = this.putAction(pair(data, i4 + 2), token, end, index2);
              break;
            }
          }
          if (data[i4] == token)
            index2 = this.putAction(pair(data, i4 + 1), token, end, index2);
        }
      }
      return index2;
    }
  };
  var Parse = class {
    constructor(parser5, input, fragments, ranges) {
      this.parser = parser5;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.lastBigReductionStart = -1;
      this.lastBigReductionSize = 0;
      this.bigReductionCount = 0;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser5, this.stream);
      this.topTerm = parser5.top[1];
      let { from } = ranges[0];
      this.stacks = [Stack.start(this, parser5.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser5.bufferLength * 4 ? new FragmentCursor2(fragments, parser5.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      if (this.bigReductionCount > 300 && stacks.length == 1) {
        let [s4] = stacks;
        while (s4.forceReduce() && s4.stack.length && s4.stack[s4.stack.length - 2] >= this.lastBigReductionStart) {
        }
        this.bigReductionCount = this.lastBigReductionSize = 0;
      }
      for (let i4 = 0; i4 < stacks.length; i4++) {
        let stack = stacks[i4];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished) {
          if (verbose)
            console.log("Finish with " + this.stackID(finished));
          return this.stackToTree(finished);
        }
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished) {
          if (verbose)
            console.log("Force-finish " + this.stackID(finished));
          return this.stackToTree(finished.forceAll());
        }
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a3, b2) => b2.score - a3.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s4) => s4.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer: for (let i4 = 0; i4 < newStacks.length - 1; i4++) {
          let stack = newStacks[i4];
          for (let j4 = i4 + 1; j4 < newStacks.length; j4++) {
            let other2 = newStacks[j4];
            if (stack.sameState(other2) || stack.buffer.length > 500 && other2.buffer.length > 500) {
              if ((stack.score - other2.score || stack.buffer.length - other2.buffer.length) > 0) {
                newStacks.splice(j4--, 1);
              } else {
                newStacks.splice(i4--, 1);
                continue outer;
              }
            }
          }
        }
        if (newStacks.length > 12)
          newStacks.splice(
            12,
            newStacks.length - 12
            /* Rec.MaxStackCount */
          );
      }
      this.minStackPos = newStacks[0].pos;
      for (let i4 = 1; i4 < newStacks.length; i4++)
        if (newStacks[i4].pos < this.minStackPos)
          this.minStackPos = newStacks[i4].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
      let start = stack.pos, { parser: parser5 } = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start); cached; ) {
          let match2 = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser5.getGoto(stack.state, cached.type.id) : -1;
          if (match2 > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match2);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser5.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser5.stateSlot(
        stack.state,
        4
        /* ParseState.DefaultReduce */
      );
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser5.getName(
            defaultReduce & 65535
            /* Action.ValueMask */
          )})`);
        return true;
      }
      if (stack.stack.length >= 8400) {
        while (stack.stack.length > 6e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i4 = 0; i4 < actions.length; ) {
        let action = actions[i4++], term = actions[i4++], end = actions[i4++];
        let last2 = i4 == actions.length || !split;
        let localStack = last2 ? stack : stack.split();
        let main = this.tokens.mainToken;
        localStack.apply(action, term, main ? main.start : localStack.pos, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser5.getName(
            action & 65535
            /* Action.ValueMask */
          )}`} for ${parser5.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
        if (last2)
          return true;
        else if (localStack.pos > start)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i4 = 0; i4 < stacks.length; i4++) {
        let stack = stacks[i4], token = tokens[i4 << 1], tokenEnd = tokens[(i4 << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j4 = 0; force.forceReduce() && j4 < 10; j4++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
      if (!id2)
        stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
      return id2 + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i4 = 0; i4 < newStacks.length; i4++) {
      let other2 = newStacks[i4];
      if (other2.pos == stack.pos && other2.sameState(stack)) {
        if (newStacks[i4].score < stack.score)
          newStacks[i4] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var id = (x3) => x3;
  var ContextTracker = class {
    /**
    Define a context tracker.
    */
    constructor(spec) {
      this.start = spec.start;
      this.shift = spec.shift || id;
      this.reduce = spec.reduce || id;
      this.reuse = spec.reuse || id;
      this.hash = spec.hash || (() => 0);
      this.strict = spec.strict !== false;
    }
  };
  var LRParser = class _LRParser extends Parser {
    /**
    @internal
    */
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i4 = 0; i4 < spec.repeatNodeCount; i4++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r3) => spec.topRules[r3][1]);
      let nodeProps = [];
      for (let i4 = 0; i4 < nodeNames.length; i4++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i4 = 1; i4 < propSpec.length; ) {
            let next = propSpec[i4++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i4++]);
            } else {
              let value = propSpec[i4 + -next];
              for (let j4 = -next; j4 > 0; j4--)
                setProp(propSpec[i4++], prop, value);
              i4++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i4) => NodeType.define({
        name: i4 >= this.minRepeatTerm ? void 0 : name2,
        id: i4,
        props: nodeProps[i4],
        top: topTerms.indexOf(i4) > -1,
        error: i4 == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i4) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i4 = 0; i4 < this.specializerSpecs.length; i4++)
        this.specialized[i4] = this.specializerSpecs[i4].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse4 = new Parse(this, input, fragments, ranges);
      for (let w3 of this.wrappers)
        parse4 = w3(parse4, input, fragments, ranges);
      return parse4;
    }
    /**
    Get a goto table entry @internal
    */
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last2 = groupTag & 1;
        let target = table[pos++];
        if (last2 && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last2)
          return -1;
      }
    }
    /**
    Check if this state has an action for a given terminal @internal
    */
    hasAction(state, terminal) {
      let data = this.data;
      for (let set3 = 0; set3 < 2; set3++) {
        for (let i4 = this.stateSlot(
          state,
          set3 ? 2 : 1
          /* ParseState.Actions */
        ), next; ; i4 += 3) {
          if ((next = data[i4]) == 65535) {
            if (data[i4 + 1] == 1)
              next = data[i4 = pair(data, i4 + 2)];
            else if (data[i4 + 1] == 2)
              return pair(data, i4 + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i4 + 1);
        }
      }
      return 0;
    }
    /**
    @internal
    */
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    /**
    @internal
    */
    stateFlag(state, flag) {
      return (this.stateSlot(
        state,
        0
        /* ParseState.Flags */
      ) & flag) > 0;
    }
    /**
    @internal
    */
    validAction(state, action) {
      return !!this.allActions(state, (a3) => a3 == action ? true : null);
    }
    /**
    @internal
    */
    allActions(state, action) {
      let deflt = this.stateSlot(
        state,
        4
        /* ParseState.DefaultReduce */
      );
      let result = deflt ? action(deflt) : void 0;
      for (let i4 = this.stateSlot(
        state,
        1
        /* ParseState.Actions */
      ); result == null; i4 += 3) {
        if (this.data[i4] == 65535) {
          if (this.data[i4 + 1] == 1)
            i4 = pair(this.data, i4 + 2);
          else
            break;
        }
        result = action(pair(this.data, i4 + 1));
      }
      return result;
    }
    /**
    Get the states that can follow this one through shift actions or
    goto jumps. @internal
    */
    nextStates(state) {
      let result = [];
      for (let i4 = this.stateSlot(
        state,
        1
        /* ParseState.Actions */
      ); ; i4 += 3) {
        if (this.data[i4] == 65535) {
          if (this.data[i4 + 1] == 1)
            i4 = pair(this.data, i4 + 2);
          else
            break;
        }
        if ((this.data[i4 + 2] & 65536 >> 16) == 0) {
          let value = this.data[i4 + 1];
          if (!result.some((v4, i5) => i5 & 1 && v4 == value))
            result.push(this.data[i4], value);
        }
      }
      return result;
    }
    /**
    Configure the parser. Returns a new parser instance that has the
    given settings modified. Settings not provided in `config` are
    kept from the original parser.
    */
    configure(config2) {
      let copy = Object.assign(Object.create(_LRParser.prototype), this);
      if (config2.props)
        copy.nodeSet = this.nodeSet.extend(...config2.props);
      if (config2.top) {
        let info = this.topRules[config2.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config2.top}`);
        copy.top = info;
      }
      if (config2.tokenizers)
        copy.tokenizers = this.tokenizers.map((t4) => {
          let found = config2.tokenizers.find((r3) => r3.from == t4);
          return found ? found.to : t4;
        });
      if (config2.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s4, i4) => {
          let found = config2.specializers.find((r3) => r3.from == s4.external);
          if (!found)
            return s4;
          let spec = Object.assign(Object.assign({}, s4), { external: found.to });
          copy.specializers[i4] = getSpecializer(spec);
          return spec;
        });
      }
      if (config2.contextTracker)
        copy.context = config2.contextTracker;
      if (config2.dialect)
        copy.dialect = this.parseDialect(config2.dialect);
      if (config2.strict != null)
        copy.strict = config2.strict;
      if (config2.wrap)
        copy.wrappers = copy.wrappers.concat(config2.wrap);
      if (config2.bufferLength != null)
        copy.bufferLength = config2.bufferLength;
      return copy;
    }
    /**
    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    are registered for this parser.
    */
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    /**
    Returns the name associated with a given term. This will only
    work for all terms when the parser was generated with the
    `--names` option. By default, only the names of tagged terms are
    stored.
    */
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /**
    The eof term id is always allocated directly after the node
    types. @internal
    */
    get eofTerm() {
      return this.maxNode + 1;
    }
    /**
    The type of top node produced by the parser.
    */
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    /**
    @internal
    */
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    /**
    @internal
    */
    parseDialect(dialect) {
      let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id2 = values2.indexOf(part);
          if (id2 >= 0)
            flags[id2] = true;
        }
      let disabled = null;
      for (let i4 = 0; i4 < values2.length; i4++)
        if (!flags[i4]) {
          for (let j4 = this.dialects[values2[i4]], id2; (id2 = this.data[j4++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    /**
    Used by the output of the parser generator. Not available to
    user code. @hide
    */
    static deserialize(spec) {
      return new _LRParser(spec);
    }
  };
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
        stack.state,
        2
        /* StateFlag.Accepting */
      ) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value, stack) => spec.external(value, stack) << 1 | mask;
    }
    return spec.get;
  }

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class _Tag {
    /**
    @internal
    */
    constructor(name2, set3, base2, modified) {
      this.name = name2;
      this.set = set3;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    toString() {
      let { name: name2 } = this;
      for (let mod of this.modified)
        if (mod.name)
          name2 = `${mod.name}(${name2})`;
      return name2;
    }
    static define(nameOrParent, parent) {
      let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
      if (nameOrParent instanceof _Tag)
        parent = nameOrParent;
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag4 = new _Tag(name2, [], null, []);
      tag4.set.push(tag4);
      if (parent)
        for (let t4 of parent.set)
          tag4.set.push(t4);
      return tag4;
    }
    /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
    static defineModifier(name2) {
      let mod = new Modifier(name2);
      return (tag4) => {
        if (tag4.modified.indexOf(mod) > -1)
          return tag4;
        return Modifier.get(tag4.base || tag4, tag4.modified.concat(mod).sort((a3, b2) => a3.id - b2.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class _Modifier {
    constructor(name2) {
      this.name = name2;
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t4) => t4.base == base2 && sameArray(mods, t4.modified));
      if (exists)
        return exists;
      let set3 = [], tag4 = new Tag(base2.name, set3, base2, mods);
      for (let m3 of mods)
        m3.instances.push(tag4);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config2 of configs)
            set3.push(_Modifier.get(parent, config2));
      return tag4;
    }
  };
  function sameArray(a3, b2) {
    return a3.length == b2.length && a3.every((x3, i4) => x3 == b2[i4]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i4 = 0; i4 < array.length; i4++) {
      for (let j4 = 0, e3 = sets.length; j4 < e3; j4++) {
        sets.push(sets[j4].concat(array[i4]));
      }
    }
    return sets.sort((a3, b2) => b2.length - a3.length);
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode3 = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode3 = 1;
              break;
            }
            let m3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m3)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m3[0] == "*" ? "" : m3[0][0] == '"' ? JSON.parse(m3[0]) : m3[0]);
            pos += m3[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode3 = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last2 = pieces.length - 1, inner = pieces[last2];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode3, last2 > 0 ? pieces.slice(0, last2) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode3, context, next) {
      this.tags = tags2;
      this.mode = mode3;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other2) {
      if (!other2 || other2.depth < this.depth) {
        this.next = other2;
        return this;
      }
      other2.next = this.sort(other2.next);
      return other2;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options2) {
    let map3 = /* @__PURE__ */ Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map3[style.tag.id] = style.class;
      else
        for (let tag4 of style.tag)
          map3[tag4.id] = style.class;
    }
    let { scope, all = null } = options2 || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag4 of tags3) {
          for (let sub of tag4.set) {
            let tagClass = map3[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor2, from, to, inheritedClass, highlighters) {
      let { type: type3, from: start, to: end } = cursor2;
      if (start >= to || end <= from)
        return;
      if (type3.isTop)
        highlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(type3));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor2) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(Math.max(from, start), cls);
      if (rule.opaque)
        return;
      let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(mounted.tree.type));
        let hasChild2 = cursor2.firstChild();
        for (let i4 = 0, pos = start; ; i4++) {
          let next = i4 < mounted.overlay.length ? mounted.overlay[i4] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
          if (rangeFrom2 < rangeTo2 && hasChild2) {
            while (cursor2.from < rangeTo2) {
              this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
              if (cursor2.to >= nextPos || !cursor2.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
            this.startSpan(Math.min(to, pos), cls);
          }
        }
        if (hasChild2)
          cursor2.parent();
      } else if (cursor2.firstChild()) {
        if (mounted)
          inheritedClass = "";
        do {
          if (cursor2.to <= from)
            continue;
          if (cursor2.from >= to)
            break;
          this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor2.to), cls);
        } while (cursor2.nextSibling());
        cursor2.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t3 = Tag.define;
  var comment = t3();
  var name = t3();
  var typeName = t3(name);
  var propertyName = t3(name);
  var literal = t3();
  var string = t3(literal);
  var number = t3(literal);
  var content = t3();
  var heading = t3(content);
  var keyword = t3();
  var operator = t3();
  var punctuation = t3();
  var bracket = t3(punctuation);
  var meta = t3();
  var tags = {
    /**
    A comment.
    */
    comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t3(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t3(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t3(comment),
    /**
    Any kind of identifier.
    */
    name,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t3(name),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t3(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t3(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t3(name),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t3(name),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t3(name),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t3(name),
    /**
    A literal value.
    */
    literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t3(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t3(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t3(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t3(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    float: t3(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t3(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t3(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t3(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t3(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t3(literal),
    /**
    A language keyword.
    */
    keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t3(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    null: t3(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t3(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t3(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t3(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t3(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t3(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t3(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t3(keyword),
    /**
    An operator.
    */
    operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t3(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t3(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t3(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t3(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t3(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t3(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t3(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t3(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t3(operator),
    /**
    Program or markup punctuation.
    */
    punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t3(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t3(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t3(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t3(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t3(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t3(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t3(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t3(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t3(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t3(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t3(heading),
    /**
    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
    */
    contentSeparator: t3(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t3(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t3(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t3(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t3(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t3(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t3(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t3(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t3(),
    /**
    Deleted text.
    */
    deleted: t3(),
    /**
    Changed text.
    */
    changed: t3(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t3(),
    /**
    Metadata or meta-instruction.
    */
    meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t3(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t3(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t3(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier("definition"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier("constant"),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    function: Tag.defineModifier("function"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier("standard"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier("local"),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier("special")
  };
  for (let name2 in tags) {
    let val = tags[name2];
    if (val instanceof Tag)
      val.name = name2;
  }
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/lezer-feel/dist/index.js
  var propertyIdentifier = 121;
  var identifier = 122;
  var nameIdentifier = 123;
  var insertSemi = 124;
  var expression0 = 128;
  var ForExpression = 4;
  var forExpressionStart = 131;
  var ForInExpression = 7;
  var Name = 8;
  var Identifier = 9;
  var AdditionalIdentifier = 10;
  var forExpressionBodyStart = 139;
  var IfExpression = 19;
  var ifExpressionStart = 140;
  var QuantifiedExpression = 23;
  var quantifiedExpressionStart = 141;
  var QuantifiedInExpression = 27;
  var PositiveUnaryTest = 37;
  var ArithmeticExpression = 41;
  var arithmeticPlusStart = 145;
  var arithmeticTimesStart = 146;
  var arithmeticExpStart = 147;
  var arithmeticUnaryStart = 148;
  var VariableName = 47;
  var PathExpression = 68;
  var pathExpressionStart = 154;
  var FilterExpression = 70;
  var filterExpressionStart = 155;
  var FunctionInvocation = 72;
  var functionInvocationStart = 156;
  var ParameterName = 76;
  var nil = 161;
  var NumericLiteral = 79;
  var StringLiteral = 80;
  var BooleanLiteral = 81;
  var listStart = 167;
  var List = 89;
  var FunctionDefinition = 90;
  var functionDefinitionStart = 169;
  var Context = 97;
  var contextStart = 171;
  var ContextEntry = 98;
  var PropertyName = 100;
  var PropertyIdentifier = 101;
  var LOG_PARSE = typeof process != "undefined" && process.env && /\bfparse(:dbg)?\b/.test(process.env.LOG);
  var LOG_PARSE_DEBUG = typeof process != "undefined" && process.env && /\bfparse:dbg\b/.test(process.env.LOG);
  var LOG_VARS = typeof process != "undefined" && process.env && /\bcontext\b/.test(process.env.LOG);
  var spaceChars = [
    9,
    11,
    12,
    32,
    133,
    160,
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8232,
    8233,
    8239,
    8287,
    12288
  ];
  var newlineChars = chars("\n\r");
  var asterix = "*".charCodeAt(0);
  var additionalNameChars = chars("'./-+*^");
  function chars(str) {
    return Array.from(str).map((s4) => s4.charCodeAt(0));
  }
  function isStartChar(ch) {
    return ch === 63 || ch >= 65 && ch <= 90 || ch === 95 || ch >= 97 && ch <= 122 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 767 || ch >= 880 && ch <= 893 || ch >= 895 && ch <= 8191 || ch >= 8204 && ch <= 8205 || ch >= 8304 && ch <= 8591 || ch >= 11264 && ch <= 12271 || ch >= 12289 && ch <= 55295 || ch >= 63744 && ch <= 64975 || ch >= 65008 && ch <= 65533 || ch >= 55296 && ch <= 56319 || ch >= 56320 && ch <= 57343;
  }
  function isAdditional(ch) {
    return additionalNameChars.includes(ch);
  }
  function isPartChar(ch) {
    return ch >= 48 && ch <= 57 || ch === 183 || ch >= 768 && ch <= 879 || ch >= 8255 && ch <= 8256;
  }
  function isSpace(ch) {
    return spaceChars.includes(ch);
  }
  function indent(str, spaces) {
    return spaces.concat(
      str.split(/\n/g).join("\n" + spaces)
    );
  }
  function parseAdditionalSymbol(input, offset2 = 0) {
    const next = input.peek(offset2);
    if (next === asterix && input.peek(offset2 + 1) === asterix) {
      return {
        offset: 2,
        token: "**"
      };
    }
    if (isAdditional(next)) {
      return {
        offset: 1,
        token: String.fromCharCode(next)
      };
    }
    return null;
  }
  function parseIdentifier(input, offset2 = 0, namePart = false) {
    for (let inside2 = false, chars4 = [], i4 = 0; ; i4++) {
      const next = input.peek(offset2 + i4);
      if (isStartChar(next) || (inside2 || namePart) && isPartChar(next)) {
        if (!inside2) {
          inside2 = true;
        }
        chars4.push(next);
      } else {
        if (chars4.length) {
          return {
            token: String.fromCharCode(...chars4),
            offset: i4
          };
        }
        return null;
      }
    }
  }
  function parseSpaces(input, offset2) {
    for (let inside2 = false, i4 = 0; ; i4++) {
      let next = input.peek(offset2 + i4);
      if (isSpace(next)) {
        if (!inside2) {
          inside2 = true;
        }
      } else {
        if (inside2) {
          return {
            token: " ",
            offset: i4
          };
        }
        return null;
      }
    }
  }
  function parseName(input, variables) {
    const contextKeys = variables.contextKeys();
    const start = variables.tokens;
    for (let i4 = 0, tokens = [], nextMatch = null; ; ) {
      const namePart = start.length + tokens.length > 0;
      const maybeSpace = tokens.length > 0;
      const match2 = parseIdentifier(input, i4, namePart) || namePart && parseAdditionalSymbol(input, i4) || maybeSpace && parseSpaces(input, i4);
      if (!match2) {
        return nextMatch;
      }
      const {
        token,
        offset: offset2
      } = match2;
      i4 += offset2;
      if (token === " ") {
        continue;
      }
      tokens = [...tokens, token];
      const name2 = [...start, ...tokens].join(" ");
      if (contextKeys.some((el) => el === name2)) {
        const token2 = tokens[0];
        nextMatch = {
          token: token2,
          offset: token2.length,
          term: nameIdentifier
        };
      }
      if (contextKeys.some((el) => el.startsWith(name2))) {
        continue;
      }
      if (dateTimeIdentifiers.some((el) => el === name2)) {
        const token2 = tokens[0];
        nextMatch = {
          token: token2,
          offset: token2.length,
          term: identifier
        };
      }
      if (dateTimeIdentifiers.some((el) => el.startsWith(name2))) {
        continue;
      }
      return nextMatch;
    }
  }
  var identifiersMap = {
    [identifier]: "identifier",
    [nameIdentifier]: "nameIdentifier"
  };
  var identifiers = new ExternalTokenizer((input, stack) => {
    LOG_PARSE_DEBUG && console.log("%s: T <identifier | nameIdentifier>", input.pos);
    const nameMatch = parseName(input, stack.context);
    const start = stack.context.tokens;
    const match2 = nameMatch || parseIdentifier(input, 0, start.length > 0);
    if (match2) {
      input.advance(match2.offset);
      input.acceptToken(nameMatch ? nameMatch.term : identifier);
      LOG_PARSE && console.log("%s: MATCH <%s> <%s>", input.pos, nameMatch ? identifiersMap[nameMatch.term] : "identifier", match2.token);
    }
  }, { contextual: true });
  var propertyIdentifiers = new ExternalTokenizer((input, stack) => {
    LOG_PARSE_DEBUG && console.log("%s: T <propertyIdentifier>", input.pos);
    const start = stack.context.tokens;
    const match2 = parseIdentifier(input, 0, start.length > 0);
    if (match2) {
      input.advance(match2.offset);
      input.acceptToken(propertyIdentifier);
      LOG_PARSE && console.log("%s: MATCH <propertyIdentifier> <%s>", input.pos, match2.token);
    }
  });
  var insertSemicolon = new ExternalTokenizer((input, stack) => {
    LOG_PARSE_DEBUG && console.log("%s: T <insertSemi>", input.pos);
    let offset2;
    let insert2 = false;
    for (offset2 = 0; ; offset2++) {
      const char = input.peek(offset2);
      if (spaceChars.includes(char)) {
        continue;
      }
      if (newlineChars.includes(char)) {
        insert2 = true;
      }
      break;
    }
    if (insert2) {
      const identifier2 = parseIdentifier(input, offset2 + 1);
      const spaces = parseSpaces(input, offset2 + 1);
      if (spaces || identifier2 && /^(then|else|return|satisfies)$/.test(identifier2.token)) {
        return;
      }
      LOG_PARSE && console.log("%s: MATCH <insertSemi>", input.pos);
      input.acceptToken(insertSemi);
    }
  });
  var prefixedContextStarts = {
    [functionInvocationStart]: "FunctionInvocation",
    [filterExpressionStart]: "FilterExpression",
    [pathExpressionStart]: "PathExpression"
  };
  var contextStarts = {
    [contextStart]: "Context",
    [functionDefinitionStart]: "FunctionDefinition",
    [forExpressionStart]: "ForExpression",
    [listStart]: "List",
    [ifExpressionStart]: "IfExpression",
    [quantifiedExpressionStart]: "QuantifiedExpression"
  };
  var contextEnds = {
    [Context]: "Context",
    [FunctionDefinition]: "FunctionDefinition",
    [ForExpression]: "ForExpression",
    [List]: "List",
    [IfExpression]: "IfExpression",
    [QuantifiedExpression]: "QuantifiedExpression",
    [PathExpression]: "PathExpression",
    [FunctionInvocation]: "FunctionInvocation",
    [FilterExpression]: "FilterExpression",
    [ArithmeticExpression]: "ArithmeticExpression"
  };
  var ValueProducer = class _ValueProducer {
    /**
     * @param { Function } fn
     */
    constructor(fn4) {
      this.fn = fn4;
    }
    get(variables) {
      return this.fn(variables);
    }
    /**
     * @param { Function } fn
     *
     * @return { ValueProducer }
     */
    static of(fn4) {
      return new _ValueProducer(fn4);
    }
  };
  var dateTimeLiterals = {
    "date and time": 1,
    "date": 1,
    "time": 1,
    "duration": 1
  };
  var dateTimeIdentifiers = Object.keys(dateTimeLiterals);
  var VariableContext = class {
    /**
     * Creates a new context from a JavaScript object.
     *
     * @param {any} [value]
     */
    constructor(value = {}) {
      this.value = value;
    }
    /**
     * Return all defined keys of the context.
     *
     * @returns {Array<string>} the keys of the context
     */
    getKeys() {
      return Object.keys(this.value);
    }
    /**
     * Returns the value of the given key.
     *
     * If the value represents a context itself, it should be wrapped in a
     * context class.
     *
     * @param {String} key
     * @returns {VariableContext|ValueProducer|null}
     */
    get(key) {
      const result = this.value[key];
      const constructor = (
        /** @type { typeof VariableContext } */
        this.constructor
      );
      if (constructor.isAtomic(result)) {
        return result;
      }
      return constructor.of(result);
    }
    /**
     * Creates a new context with the given key added.
     *
     * @param {String} key
     * @param {any} value
     *
     * @returns {VariableContext} new context with the given key added
     */
    set(key, value) {
      const constructor = (
        /** @type { typeof VariableContext } */
        this.constructor
      );
      return constructor.of({
        ...this.value,
        [key]: value
      });
    }
    /**
     * Non-destructively merge another context into this one,
     * and return the result.
     *
     * @param {ContextValue} other
     *
     * @return {VariableContext}
     */
    merge(other2) {
      const constructor = (
        /** @type { typeof VariableContext } */
        this.constructor
      );
      return new constructor(
        constructor.__merge(this.value, other2)
      );
    }
    /**
     * Wether the given value is atomic. Non-atomic values need to be wrapped in a
     * context Class.
     *
     * @param {any} value
     * @returns {Boolean}
     */
    static isAtomic(value) {
      return !value || value instanceof this || value instanceof ValueProducer || typeof value !== "object";
    }
    /**
     * Takes any number of Contexts and merges them into a single context.
     *
     * @param { ...VariableContext } contexts
     * @returns { VariableContext }
     */
    static of(...contexts) {
      return contexts.reduce((context, otherContext) => {
        return context.merge(otherContext);
      }, new this({}));
    }
    /**
     * Returns the raw representation of the given context.
     *
     * @param {VariableContext | any} context
     *
     * @return {any}
     */
    static __unwrap(context) {
      if (!context) {
        return {};
      }
      if (context instanceof this) {
        return context.value;
      }
      if (typeof context !== "object") {
        return {};
      }
      return { ...context };
    }
    /**
     * Non-destructively merges two contexts (or their values)
     * with each other, returning the result.
     *
     * @param {ContextValue} context
     * @param {ContextValue} other
     *
     * @return {any}
     */
    static __merge(context, other2) {
      return reduce(this.__unwrap(other2), (merged, value, key) => {
        if (value instanceof ValueProducer) {
          return {
            ...merged,
            [key]: value
          };
        }
        value = this.__unwrap(value);
        if (has(merged, key)) {
          value = this.__merge(this.__unwrap(merged[key]), value);
        }
        return {
          ...merged,
          [key]: value
        };
      }, this.__unwrap(context));
    }
  };
  var Variables = class _Variables {
    /**
     * @param { {
     *   name?: string,
     *   tokens?: string[],
     *   children?: Variables[],
     *   parent: Variables | null
     *   context: VariableContext,
     *   value?: any,
     *   raw?: any
     * } } options
     */
    constructor({
      name: name2 = "Expressions",
      tokens = [],
      children = [],
      parent = null,
      context,
      value,
      raw
    }) {
      this.name = name2;
      this.tokens = tokens;
      this.children = children;
      this.parent = parent;
      this.context = context;
      this.value = value;
      this.raw = raw;
    }
    enterScope(name2) {
      const childScope = this.of({
        name: name2,
        parent: this
      });
      LOG_VARS && console.log("[%s] enter", childScope.path, childScope.context);
      return childScope;
    }
    exitScope(str) {
      if (!this.parent) {
        LOG_VARS && console.log("[%s] NO exit %o\n%s", this.path, this.context, indent(str, "  "));
        return this;
      }
      LOG_VARS && console.log("[%s] exit %o\n%s", this.path, this.context, indent(str, "  "));
      return this.parent.pushChild(this);
    }
    token(part) {
      LOG_VARS && console.log("[%s] token <%s> + <%s>", this.path, this.tokens.join(" "), part);
      return this.assign({
        tokens: [...this.tokens, part]
      });
    }
    literal(value) {
      LOG_VARS && console.log("[%s] literal %o", this.path, value);
      return this.pushChild(this.of({
        name: "Literal",
        value
      }));
    }
    /**
     * Return computed scope value
     *
     * @return {any}
     */
    computedValue() {
      for (let scope = this; ; scope = last(scope.children)) {
        if (!scope) {
          return null;
        }
        if (scope.value) {
          return scope.value;
        }
      }
    }
    contextKeys() {
      return this.context.getKeys().map(normalizeContextKey);
    }
    get path() {
      return this.parent?.path?.concat(" > ", this.name) || this.name;
    }
    /**
     * Return value of variable.
     *
     * @param { string } variable
     * @return { any } value
     */
    get(variable) {
      const names = [variable, variable && normalizeContextKey(variable)];
      const contextKey = this.context.getKeys().find(
        (key) => names.includes(normalizeContextKey(key))
      );
      if (typeof contextKey === "undefined") {
        return void 0;
      }
      const val = this.context.get(contextKey);
      if (val instanceof ValueProducer) {
        return val.get(this);
      } else {
        return val;
      }
    }
    resolveName() {
      const variable = this.tokens.join(" ");
      const tokens = [];
      const parentScope = this.assign({
        tokens
      });
      const variableScope = this.of({
        name: "VariableName",
        parent: parentScope,
        value: this.get(variable),
        raw: variable
      });
      LOG_VARS && console.log("[%s] resolve name <%s=%s>", variableScope.path, variable, this.get(variable));
      return parentScope.pushChild(variableScope);
    }
    pushChild(child) {
      if (!child) {
        return this;
      }
      const parent = this.assign({
        children: [...this.children, child]
      });
      child.parent = parent;
      return parent;
    }
    pushChildren(children) {
      let parent = this;
      for (const child of children) {
        parent = parent.pushChild(child);
      }
      return parent;
    }
    declareName() {
      if (this.tokens.length === 0) {
        throw Error("no tokens to declare name");
      }
      const variableName = this.tokens.join(" ");
      LOG_VARS && console.log("[%s] declareName <%s>", this.path, variableName);
      return this.assign({
        tokens: []
      }).pushChild(
        this.of({
          name: "Name",
          value: variableName
        })
      );
    }
    define(name2, value) {
      if (typeof name2 !== "string") {
        LOG_VARS && console.log("[%s] no define <%s=%s>", this.path, name2, value);
        return this;
      }
      LOG_VARS && console.log("[%s] define <%s=%s>", this.path, name2, value);
      const context = this.context.set(name2, value);
      return this.assign({
        context
      });
    }
    /**
     * @param { Record<string, any> } [options]
     *
     * @return { Variables }
     */
    assign(options2 = {}) {
      return _Variables.of({
        ...this,
        ...options2
      });
    }
    /**
     * @param { Record<string, any> } [options]
     *
     * @return { Variables }
     */
    of(options2 = {}) {
      const defaultOptions = {
        context: this.context,
        parent: this.parent
      };
      return _Variables.of({
        ...defaultOptions,
        ...options2
      });
    }
    /**
     * @param { {
     *   name?: string,
     *   tokens?: string[],
     *   children?: Variables[],
     *   parent?: Variables | null
     *   context: VariableContext,
     *   value?: any,
     *   raw?: any
     * } } options
     *
     * @return {Variables}
     */
    static of(options2) {
      const {
        name: name2,
        tokens = [],
        children = [],
        parent = null,
        context,
        value,
        raw
      } = options2;
      if (!context) {
        throw new Error("must provide <context>");
      }
      return new _Variables({
        name: name2,
        tokens: [...tokens],
        children: [...children],
        context,
        parent,
        value,
        raw
      });
    }
  };
  function normalizeContextKey(name2) {
    return name2.replace(/\s*([./\-'+]|\*\*?)\s*/g, " $1 ").replace(/\s{2,}/g, " ").trim();
  }
  function wrap(variables, scopeName, code) {
    const parts = variables.children.filter((c3) => c3.name !== scopeName);
    const children = variables.children.filter((c3) => c3.name === scopeName);
    const namePart = parts[0];
    const valuePart = parts[Math.max(1, parts.length - 1)];
    const name2 = namePart?.computedValue();
    const value = valuePart?.computedValue() || null;
    return variables.assign({
      children
    }).enterScope(scopeName).pushChildren(parts).exitScope(code).define(name2, value);
  }
  function trackVariables(context = {}, Context2 = VariableContext) {
    const start = Variables.of({
      context: Context2.of(context)
    });
    return new ContextTracker({
      start,
      reduce(variables, term, stack, input) {
        if (term === IfExpression) {
          const [thenPart, elsePart] = variables.children.slice(-2);
          variables = variables.assign({
            value: Context2.of(
              thenPart?.computedValue(),
              elsePart?.computedValue()
            )
          });
        }
        if (term === List) {
          variables = variables.assign({
            value: Context2.of(
              ...variables.children.map(
                (c3) => c3?.computedValue()
              )
            )
          });
        }
        if (term === FilterExpression) {
          const [sourcePart, _3] = variables.children.slice(-2);
          variables = variables.assign({
            value: sourcePart?.computedValue()
          });
        }
        if (term === FunctionInvocation) {
          const [
            name2,
            ...args
          ] = variables.children;
          if (name2?.raw === "get value") {
            variables = getContextValue(variables, args);
          }
        }
        const start2 = contextStarts[term];
        if (start2) {
          return variables.enterScope(start2);
        }
        const prefixedStart = prefixedContextStarts[term];
        if (prefixedStart) {
          const {
            children: currentChildren,
            context: currentContext2
          } = variables;
          const children = currentChildren.slice(0, -1);
          const lastChild = last(currentChildren);
          let newContext = null;
          if (term === pathExpressionStart) {
            newContext = Context2.of(lastChild?.computedValue());
          }
          if (term === filterExpressionStart) {
            newContext = Context2.of(
              currentContext2,
              lastChild?.computedValue()
            ).set("item", lastChild?.computedValue());
          }
          return variables.assign({ children }).enterScope(prefixedStart).pushChild(lastChild).assign({ context: newContext || currentContext2 });
        }
        const code = input.read(input.pos, stack.pos);
        const end = contextEnds[term];
        if (end) {
          return variables.exitScope(code);
        }
        if (term === ContextEntry) {
          const parts = variables.children.filter((c3) => c3.name !== "ContextEntry");
          const name2 = parts[0];
          const value = last(parts);
          return wrap(variables, "ContextEntry", code).assign(
            {
              value: Context2.of(variables.value).set(name2?.computedValue(), value?.computedValue())
            }
          );
        }
        if (term === ForInExpression || term === QuantifiedInExpression) {
          return wrap(variables, "InExpression", code);
        }
        if (term === forExpressionBodyStart) {
          return variables.define(
            "partial",
            ValueProducer.of((variables2) => {
              return last(variables2.children)?.computedValue();
            })
          );
        }
        if (term === ParameterName) {
          const name2 = last(variables.children).computedValue();
          return variables.define(name2, 1);
        }
        if (term === arithmeticPlusStart || term === arithmeticTimesStart || term === arithmeticExpStart) {
          const children = variables.children.slice(0, -1);
          const lastChild = last(variables.children);
          return variables.assign({
            children
          }).enterScope("ArithmeticExpression").pushChild(lastChild);
        }
        if (term === arithmeticUnaryStart) {
          return variables.enterScope("ArithmeticExpression");
        }
        if (term === Identifier || term === AdditionalIdentifier || term === PropertyIdentifier) {
          return variables.token(code);
        }
        if (term === StringLiteral) {
          return variables.literal(code.replace(/^"|"$/g, ""));
        }
        if (term === BooleanLiteral) {
          return variables.literal(code === "true" ? true : false);
        }
        if (term === NumericLiteral) {
          return variables.literal(parseFloat(code));
        }
        if (term === nil) {
          return variables.literal(null);
        }
        if (term === VariableName) {
          return variables.resolveName();
        }
        if (term === Name || term === PropertyName) {
          return variables.declareName();
        }
        if (term === expression0 || term === PositiveUnaryTest) {
          if (variables.tokens.length > 0) {
            throw new Error("uncleared name");
          }
        }
        if (term === expression0) {
          let parent = variables;
          while (parent.parent) {
            parent = parent.exitScope(code);
          }
          return parent;
        }
        return variables;
      }
    });
  }
  var variableTracker = trackVariables({});
  function getContextValue(variables, args) {
    if (!args.length) {
      return variables.assign({
        value: null
      });
    }
    if (args[0].name === "Name") {
      args = extractNamedArgs(args, ["m", "key"]);
    }
    if (args.length !== 2) {
      return variables.assign({
        value: null
      });
    }
    const [
      context,
      key
    ] = args;
    const keyValue = key?.computedValue();
    const contextValue = context?.computedValue();
    if (!contextValue || typeof contextValue !== "object" || typeof keyValue !== "string") {
      return variables.assign({
        value: null
      });
    }
    return variables.assign({
      value: [normalizeContextKey(keyValue), keyValue].reduce((value, keyValue2) => {
        return contextValue.get(keyValue2) || value;
      }, null)
    });
  }
  function extractNamedArgs(args, argNames) {
    const context = {};
    for (let i4 = 0; i4 < args.length; i4 += 2) {
      const [name2, value] = args.slice(i4, i4 + 2);
      context[name2.value] = value;
    }
    return argNames.map((name2) => context[name2]);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  var feelHighlighting = styleTags({
    StringLiteral: tags.string,
    NumericLiteral: tags.number,
    BooleanLiteral: tags.bool,
    "AtLiteral!": tags.special(tags.string),
    CompareOp: tags.compareOperator,
    ArithOp: tags.arithmeticOperator,
    "for if then else some every satisfies between return": tags.controlKeyword,
    "in instance of and or": tags.operatorKeyword,
    function: tags.definitionKeyword,
    as: tags.keyword,
    "Type/...": tags.typeName,
    Wildcard: tags.special(tags.variableName),
    null: tags.null,
    LineComment: tags.lineComment,
    BlockComment: tags.blockComment,
    'VariableName! "?"': tags.variableName,
    "DateTimeConstructor! SpecialFunctionName!": tags.function(tags.special(tags.variableName)),
    "List Interval": tags.list,
    Context: tags.definition(tags.literal),
    "Name!": tags.definition(tags.variableName),
    "Key/Name! ContextEntryType/Name!": tags.definition(tags.propertyName),
    "PathExpression/VariableName!": tags.function(tags.propertyName),
    "FormalParameter/ParameterName!": tags.function(tags.definition(tags.variableName)),
    "( )": tags.paren,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace,
    ".": tags.derefOperator,
    ", ;": tags.separator,
    "..": tags.punctuation
  });
  var spec_identifier = { __proto__: null, for: 10, in: 32, return: 36, if: 40, then: 42, else: 44, some: 48, every: 50, satisfies: 56, or: 60, and: 64, between: 72, instance: 86, of: 89, days: 101, time: 103, duration: 105, years: 107, months: 109, date: 111, list: 117, context: 123, function: 130, null: 156, true: 330, false: 330, "?": 170, external: 186, not: 211 };
  var parser = LRParser.deserialize({
    version: 14,
    states: "C|O`QYOOO`QYOOO$sQYOOOOQU'#Ce'#CeO$}QYO'#C`O&WQYO'#FQOOQQ'#Ff'#FfO&bQYO'#FfO`QYO'#DVOOQU'#En'#EnO(UQ^O'#D]OOQU'#D^'#D^OOQU'#D]'#D]OOQO'#Fn'#FnO*RQWO'#DvOOQQ'#D}'#D}OOQQ'#EO'#EOOOQQ'#EP'#EPO*WOWO'#ESO*RQWO'#EQOOQQ'#EQ'#EQOOQQ'#Ft'#FtOOQQ'#Fr'#FrOOQQ'#Fy'#FyOOQQ'#EU'#EUO`QYO'#EWOOQQ'#FS'#FSO*]Q^O'#FSO,SQYO'#EXO,ZQWO'#EYOOQP'#F}'#F}O,`QXO'#EaOOQQ'#Fz'#FzOOQQ'#FR'#FRQOQWOOOOQQ'#FT'#FTOOQQ'#F^'#F^O`QYO'#CoOOQQ'#F_'#F_O$}QYO'#CsO,kQYO'#DwOOQQ'#Fs'#FsO,pQYO'#EROOQO'#ER'#ERO`QYO'#EVO`QYO'#EUOOQO'#F{'#F{Q,xQWOOO,}QYO'#DRO-tQWO'#FbOOQO'#DT'#DTO.PQYO'#FfO.WQWOOO.}QYO'#CdO/[QYO'#FVOOQQ'#Cc'#CcO/aQYO'#FUOOQQ'#Cb'#CbO/iQYO,58zO`QYO,59iOOQQ'#Fc'#FcOOQQ'#Fd'#FdOOQQ'#Fe'#FeO`QYO,59qO`QYO,59qO`QYO,59qOOQQ'#Fl'#FlO/nQYO,5:^OOQQ'#Fm'#FmO`QYO,5:`O`QYO,59eO`QYO,59gO`QYO,59iO1jQYO,59iO1qQYO,59rOOQQ,5:i,5:iO1vQYO,59qOOQU-E8l-E8lO3jQYO'#FoOOQQ,5:b,5:bOOQQ,5:n,5:nOOQQ,5:l,5:lO3qQYO,5:rOOQQ,5;n,5;nO3{QYO,5:qO4YQWO,5:sO4_QYO,5:tOOQP'#Ee'#EeO5UQXO'#EdOOQO'#Ec'#EcO5]QWO'#EbO5bQWO'#GOO5jQWO,5:{O5oQYO,59ZO/[QYO'#FaOOQQ'#Cw'#CwO5vQYO'#F`OOQQ'#Cv'#CvO6OQYO,59_O6TQYO,5:cO6YQYO,5:mO3tQYO,5:qO6_QYO,5:pO`QYO'#EwQ,xQWOOO`QYO'#EmO7UQWO,5;|O`QYOOOOQR'#Cf'#CfOOQQ'#Ej'#EjO8OQYO,59OO`QYO,5;qOOQQ'#FY'#FYO$}QYO'#EkO8`QYO,5;pO`QYO1G.fOOQQ'#F]'#F]O9VQYO1G/TO;|QYO1G/]O<WQYO1G/]O<bQYO1G/]OOQQ1G/x1G/xO>UQYO1G/zO>]QYO1G/PO?fQYO1G/RO@oQYO1G/TO`QYO1G/TOOQQ1G/T1G/TOAVQYO1G/^OAtQ^O'#CdOCWQYO'#FqOOQO'#Dz'#DzOCbQWO'#DyOCgQWO'#FpOOQO'#Dx'#DxOOQO'#D{'#D{OCoQWO,5<ZOOQQ1G0^1G0^O`QYO1G0]O`QYO'#EsOCtQWO,5<]OOQQ1G0_1G0_ODPQWO'#E[OD[QWO'#F|OOQO'#EZ'#EZODdQWO1G0`OOQP'#Eu'#EuODiQXO,5;OO`QYO,5:|ODpQXO'#EvODxQWO,5<jOOQQ1G0g1G0gO`QYO1G.uO`QYO,5;{O$}QYO'#ElOEQQYO,5;zO`QYO1G.yOEYQYO1G/}OOQO1G0X1G0XOOQO,5;c,5;cOOQO-E8u-E8uOOQO,5;X,5;XOOQO-E8k-E8kOE_QWOOOOQQ-E8h-E8hOEdQYO'#CmOOQQ1G1]1G1]OOQQ,5;V,5;VOOQQ-E8i-E8iOEqQYO7+$QOOQQ7+%f7+%fO`QYO7+$oOFhQYO,5:rOFuQWO7+$oOFzQYO'#D[OOQQ'#DZ'#DZOHnQYO'#D_OHsQYO'#D_OHxQYO'#D_OH}Q`O'#DgOISQ`O'#DjOIXQ`O'#DnOOQQ7+$x7+$xO`QYO,5:eO$}QYO'#ErOI^QWO,5<[OOQQ1G1u1G1uOJdQYO7+%wOJqQYO,5;_OOQO-E8q-E8qOAVQYO,5:vO$}QYO'#EtOKOQWO,5<hOKWQYO7+%zOOQP-E8s-E8sOK_QYO1G0hOOQO,5;b,5;bOOQO-E8t-E8tOKiQYO7+$aOKpQYO1G1gOOQQ,5;W,5;WOOQQ-E8j-E8jOKzQYO7+$eOOQO7+%i7+%iO`QYO,59XOLqQYO<<HZOOQQ<<HZ<<HZO/nQYO'#EoOMzQYO,59vO! nQYO,59yO! sQYO,59yO! xQYO,59yO! }QYO,5:RO$}QYO,5:UO!!lQbO,5:YO!!sQYO1G0POOQO,5;^,5;^OOQO-E8p-E8pO!!}QYO<<IcOOQQ<<Ic<<IcOOQO1G0b1G0bOOQO,5;`,5;`OOQO-E8r-E8rO!%|QYO'#E^OOQQ<<If<<IfO`QYO<<IfO`QYO<<G{O!&sQYO1G.sOOQQ,5;Z,5;ZOOQQ-E8m-E8mO!&}QYO1G/eOOQQ1G/e1G/eO!'SQbO'#D]O!'eQ`O'#D[O!'pQ`O1G/mO!'uQWO'#DmO!'zQ`O'#FhOOQO'#Dl'#DlO!(SQ`O1G/pOOQO'#Dq'#DqO!(XQ`O'#FjOOQO'#Dp'#DpO!(aQ`O1G/tOOQQAN?QAN?QO!(fQYOAN=gOOQQ7+%P7+%PO!)]Q`O,59vOOQQ7+%X7+%XO! }QYO,5:XO$}QYO'#EpO!)hQ`O,5<SOOQQ7+%[7+%[O! }QYO'#EqO!)pQ`O,5<UO!)xQ`O7+%`OOQO1G/s1G/sOOQO,5;[,5;[OOQO-E8n-E8nOOQO,5;],5;]OOQO-E8o-E8oOAVQYO<<HzOOQQAN>fAN>fO/nQYO'#EoO! }QYO<<HzO!)}Q`O7+%`O!*SQ`O1G/tO!!lQbO,5:YO!*XQ`O'#Dn",
    stateData: "!*h~O#rOS#sOSPOSQOS~OTsOZVO[UOdtOhvOivOr}Os}OviO!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~OTsO[UOdtOhvOivOr}Os}OviO!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~OZ!TO#]!UO~P#SO#nRO#oRO~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO!i!fO#z!dOv$bX~O#l#tX$s#tX~P%VO$i!mOT$YXZ$YX[$YXd$YXh$YXi$YXr$YXs$YXv$YX!T$YX!U$YX!V$YX!X$YX!c$YX!g$YX!i$YX!p$YX!w$YX#S$YX#n$YX#o$YX$Z$YX$j$YX$k$YX$l$YX~O#nRO#oROZ!PX[!PX]!PX^!PX_!PX`!PXn!PXp!PXr!PXs!PXt!PXv!PX{!PX!i!PX#l!PX#p!PX#z!PX$s!PX$O!PXx!PX#}!PX!g!PXe!PXb!PX#R!PXf!PXl!PX~Ov!pO~O$j`O~O#p!uOZ#vX[#vX]#vX^#vX_#vX`#vXn#vXp#vXr#vXs#vXt#vXv#vX{#vX!i#vX#l#vX#z#vX$s#vX$O#vXx#vX#}#vX!g#vXe#vXb#vX#R#vXf#vXl#vX~O!g$eP~P`Ov!xO~O#m!yO$j`O#R$rP~Op#VO~Op#WOv!uX~O$s#ZO~O#luX$OuX$suXxuX#}uX!guXeuXbuX#RuXfuXluX~P%VO$O#]O#l$UXx$UX~O#l#[X~P&bOv#_O~OZ#`O[#`O]#`O^#`O_#`O#nRO#oRO#z#`O#{#`O$]WX~O`WXxWX$OWX~P.]O`#dO~O$O#eOb#xX~Ob#hO~O#nRO#oRO$ZZO~OTsOZVO[UOdtOhvOivOr}Os}O!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~Ov#rO~P/yO|#tO~O{!lO!i!fO#z!dOZya[ya]ya^ya_ya`yanyapyaryasyatyav$bX#lya$sya$Oyaxya#}ya!gyaeyabya#Ryafyalya~Ox$eP~P`Ox#}O#}$OO~P%VO#}$OO$O$PO!g$eX~P%VO!g$RO~O#nRO#oROx$pP~OZ#`O[#`O]#`O^#`O_#`O#m!yO#z#`O#{#`O~O$]#WX~P4jO$]$YO~O$O$ZO#R$rX~O#R$]O~Oe$^O~P%VO$O$`Ol$SX~Ol$bO~O!W$cO~O!T$dO~O#l!xa$s!xa$O!xax!xa#}!xa!g!xae!xab!xa#R!xaf!xal!xa~P%VO$O#]O#l$Uax$Ua~OZ#`O[#`O]#`O^#`O_#`O#nRO#oRO#z#`O#{#`O~O`Wa$]WaxWa$OWa~P7aO$O#eOb#xa~OZ!^O[!^O]!_O^!_O_!`O{!lO!i!fO#z!dOv$bX~O`qinqipqirqisqitqi#lqi$sqi$Oqixqi#}qi!gqieqibqi#Rqifqilqi~P8hO_!`O{!lO!i!fO#z!dOZyi[yi`yinyipyiryisyityiv$bX#lyi$syi$Oyixyi#}yi!gyieyibyi#Ryifyilyi~O]!_O^!_O~P:`O]yi^yi~P:`O{!lO!i!fO#z!dOZyi[yi]yi^yi_yi`yinyipyiryisyityiv$bX#lyi$syi$Oyixyi#}yi!gyieyibyi#Ryifyilyi~O!g$pO~P%VO`!kOp!iOr!]Os!]Ot!jOnmi#lmi$smi$Omixmi#}mi!gmiemibmi#Rmifmilmi~P8hO`!kOr!]Os!]Ot!jOnoipoi#loi$soi$Ooixoi#}oi!goieoiboi#Roifoiloi~P8hO`!kOn!hOp$qOr!]Os!]Ot!jO~P8hO!S$vO!V$wO!X$xO![$yO!_$zO!c${O#nRO#oRO$ZZO~OZ#bX[#bX]#bX^#bX_#bX`#bXn#bXp#bXr#bXs#bXt#bXv#bXx#bX{#bX!i#bX#n#bX#o#bX#p#bX#z#bX$O#bX~P.]O$O$POx$eX~P%VO$]$}O~O$O%OOx$dX~Ox%QO~O$O$PO!g$eax$ea~O$]%UOx#OX$O#OX~O$O%VOx$pX~Ox%XO~O$]#Wa~P4jO#m!yO$j`O~O$O$ZO#R$ra~O$O$`Ol$Sa~O!U%cO~OxrO~O#}%dObaX$OaX~P%VO#lSq$sSq$OSqxSq#}Sq!gSqeSqbSq#RSqfSqlSq~P%VOx#}O#}$OO$OuX~P%VOx%fO~O#z%gOZ!OX[!OX]!OX^!OX_!OX`!OXn!OXp!OXr!OXs!OXt!OXv!OX{!OX!i!OX#l!OX$s!OX$O!OXx!OX#}!OX!g!OXe!OXb!OX#R!OXf!OXl!OX~Op%iO~Op%jO~Op%kO~O!]%lO~O!]%mO~O!]%nO~O$O%OOx$da~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO#z!dOv$bX~Ox%sO!g%sO!i%rO~PIfO!g#ga$O#gax#ga~P%VO$O%VOx$pa~O#P%yO~P`O#R#Ui$O#Ui~P%VOf%zO~P%VOl$Ti$O$Ti~P%VO#lgq$sgq$Ogqxgq#}gq!ggqegqbgq#Rgqfgqlgq~P%VO`qynqypqyrqysqytqy#lqy$sqy$Oqyxqy#}qy!gqyeqybqy#Rqyfqylqy~P8hO#z%gOZ!Oa[!Oa]!Oa^!Oa_!Oa`!Oan!Oap!Oar!Oas!Oat!Oav!Oa{!Oa!i!Oa#l!Oa$s!Oa$O!Oax!Oa#}!Oa!g!Oae!Oab!Oa#R!Oaf!Oal!Oa~O!T&OO~O!W&OO~O!T&PO~O!S$vO!V$wO!X$xO![$yO!_$zO!c&uO#nRO#oRO$ZZO~O!Y$^P~P! }Ox!mi$O!mi~P%VOT$aXZ$aX[$aX]!yy^!yy_!yy`!yyd$aXh$aXi$aXn!yyp!yyr$aXs$aXt!yyv$aX{!yy!T$aX!U$aX!V$aX!X$aX!c$aX!g$aX!i$aX!p$aX!w$aX#S$aX#l!yy#n$aX#o$aX#z!yy$Z$aX$i$aX$j$aX$k$aX$l$aX$s!yy$O!yyx!yy#}!yye!yyb!yy#R!yyf!yyl!yy~O#l#QX$s#QX$O#QXx#QX#}#QX!g#QXe#QXb#QX#R#QXf#QXl#QX~P%VObai$Oai~P%VO!U&_O~O#nRO#oRO!Y!PX#z!PX$O!PX~O#z&pO!Y!OX$O!OX~O!Y&aO~O$]&bO~O$O&cO!Y$[X~O!Y&eO~O$O&fO!Y$^X~O!Y&hO~O#lc!R$sc!R$Oc!Rxc!R#}c!R!gc!Rec!Rbc!R#Rc!Rfc!Rlc!R~P%VO#z&pO!Y!Oa$O!Oa~O$O&cO!Y$[a~O$O&fO!Y$^a~O$_&nO~O$_&qO~O!Y&rO~O!]&tO~O$Z~QP_^$i]#z~",
    goto: "E|$sPPPP$tP%m%p%v&Y'sPPPPPP'|P$tPPP$tPP(P(SP$tP$tP$tPPP(YP(eP$t$tPP(n)T)`*m)TPPPPPPP)TPP)TP+r+u)TP+{,R$tP$tP$t,Y-R-U-[-RP-d.]-d-d/]0UP$t0}$t1v1v2o2rP2xPP1v3O3U/X3YPP3bP3e3l3r3x4O5Z5e5k5q5w6O6U6[6bPPPPPPPP6h6q8x9q:j:mPP:qPP:w:z;s<l<o<s<x=g>V>vP?oP?rP?v@iA[BTBZB^$tBdBdPPPPC]8xDUD}EQEy!mjOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR![SQ!YSR$m#eS!WS#eS#Qw$`W#w!p!x%O%VT&T%m&c#WXOPQWYilu|}!]!a!b!c!e!g!h!i!j!k#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%l%n%y%z&Q&b&f&n&p&q&tb!VSw!x#e$`%O%V%m&cU#a!V#b#uR#u!pU#a!V#b#uT$W!z$XR$l#cR#UwQ#SwR%`$`U!RQ#_#rQ#s!kR$g#]QrQQ$i#_R$s#rQ$|#tQ%t%UQ&S%lU&X%n&f&tQ&i&bT&o&n&qc$u#t%U%l%n&b&f&n&q&t!lkOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ#m!eU$t#t%U&nS%|%g&p]&R%l%n&b&f&q&t#V[OPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%l%n%y%z&b&f&n&p&q&tR&W%mQ&U%mR&j&cQ&[%nR&s&tS&Y%n&tR&l&f!m]OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#|!pQ#y!pR%p%OS#x!p%OT$S!x%V!meOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!leOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ!rbT!{o$Z!mcOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mdOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mhOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mpOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR$V!xQ$T!xR%u%VQ%x%XR&]%yQ!}oR%[$ZT!|o$ZS!zo$ZT$W!z$XRrQS#b!V#uR$j#bQ#f!YR$n#fQ$a#SR%a$aQ#^!RR$h#^!vYOPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%y%z&nS!oY&Q_&Q%l%n&b&f&p&q&tQ%h$tS%}%h&`R&`&RQ&d&UR&k&dQ&g&YR&m&gQ%P#yR%q%PS$Q!v#vR%T$QQ%W$TR%v%WQ$X!zR%Y$XQ$[!}R%]$[Q#[!PR$f#[QrOQ!PPR$e#ZUTOP#ZW!QQ!k#]#_Q!nWQ!tiQ!vlQ#PuQ#X|Q#Y}Q#i!]Q#j!aQ#k!bQ#l!cQ#n!gQ#o!hQ#p!iQ#q!jQ#v!pQ$k#cQ$o#gQ$r#rQ%R$OQ%S$PQ%Z$YQ%^$^Q%_$_Q%b$bQ%e$qQ%o$}S%w%X%yQ%{%dR&^%z!mqOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mSOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR!ZST!XS#eQ#c!WR$_#QR#g![!muOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mwOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#TwT#Rw$`V!SQ#_#r!X!aT!Q!t!v#P#X#Y#i#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!Z!bT!Q!t!v#P#X#Y#i#j#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!]!cT!Q!t!v#P#X#Y#i#j#k#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!mWOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR&V%mT&Z%n&t!a!eT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!a!gT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!m^OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ!q^R!scR#z!pQ!wlR#{!p!mfOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mlOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mmOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR$U!x!moOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#Oo",
    nodeNames: "\u26A0 LineComment BlockComment Expression ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression InstanceOfExpression instance of Type QualifiedName VariableName BacktickIdentifier SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier Expressions UnaryTests Wildcard not",
    maxTerm: 173,
    context: variableTracker,
    nodeProps: [
      ["group", -17, 4, 19, 23, 29, 31, 33, 41, 42, 68, 70, 72, 85, 86, 88, 89, 90, 97, "Expr", 47, "Expr Expr", -5, 78, 79, 80, 81, 82, "Expr Literal"],
      ["closedBy", 38, ")", 71, "]", 96, "}"],
      ["openedBy", 40, "(", 69, "[", 95, "{"]
    ],
    propSources: [feelHighlighting],
    skippedNodes: [0, 1, 2],
    repeatNodeCount: 14,
    tokenData: ".Z~RvXY#iYZ$^Z[#i]^$^pq#iqr$crs$nwx&fxy&kyz&pz{&u{|'S|}'X}!O'^!O!P'k!P!Q(u!Q![*p![!]+X!]!^+^!^!_+c!_!`$i!`!a+r!b!c+|!}#O,R#P#Q,W#Q#R&}#S#T,]#o#p.P#q#r.U$f$g#i#BY#BZ#i$IS$I_#i$I|$I}$^$I}$JO$^$JT$JU#i$KV$KW#i&FU&FV#i?HT?HU#i~#nY#r~XY#iZ[#ipq#i$f$g#i#BY#BZ#i$IS$I_#i$JT$JU#i$KV$KW#i&FU&FV#i?HT?HU#i~$cO#s~~$fP!_!`$i~$nOr~~$sW$j~OY$nZr$nrs%]s#O$n#O#P%b#P;'S$n;'S;=`&`<%lO$n~%bO$j~~%eRO;'S$n;'S;=`%n;=`O$n~%sX$j~OY$nZr$nrs%]s#O$n#O#P%b#P;'S$n;'S;=`&`;=`<%l$n<%lO$n~&cP;=`<%l$n~&kO#{~~&pOv~~&uOx~~&zP^~z{&}~'SO_~~'XO[~~'^O$O~R'cPZP!`!a'fQ'kO$_Q~'pQ#z~!O!P'v!Q!['{~'{O#}~~(QR$i~!Q!['{!g!h(Z#X#Y(Z~(^R{|(g}!O(g!Q![(m~(jP!Q![(m~(rP$i~!Q![(m~(zQ]~z{)Q!P!Q*X~)TTOz)Qz{)d{;'S)Q;'S;=`*R<%lO)Q~)gVOz)Qz{)d{!P)Q!P!Q)|!Q;'S)Q;'S;=`*R<%lO)Q~*ROQ~~*UP;=`<%l)Q~*^SP~OY*XZ;'S*X;'S;=`*j<%lO*X~*mP;=`<%l*X~*uS$i~!O!P+R!Q![*p!g!h(Z#X#Y(Z~+UP!Q!['{~+^O$]~~+cO$s~R+jP!]QsP!_!`+mP+rOsPR+yP!YQsP!_!`+m~,RO$l~~,WO!i~~,]O!g~~,`WOY,]Z#O,]#O#P,x#P#S,]#S#T-t#T;'S,];'S;=`-y<%lO,]~,{RO;'S,];'S;=`-U;=`O,]~-XXOY,]Z#O,]#O#P,x#P#S,]#S#T-t#T;'S,];'S;=`-y;=`<%l,]<%lO,]~-yO$Z~~-|P;=`<%l,]~.UO#S~~.ZO#R~",
    tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],
    topRules: { "Expression": [0, 3], "Expressions": [1, 102], "UnaryTests": [2, 103] },
    dialects: { camunda: 2544 },
    dynamicPrecedences: { "31": -1, "68": 1, "72": -1, "74": -1 },
    specialized: [{ term: 122, get: (value) => spec_identifier[value] || -1 }],
    tokenPrec: 2546
  });

  // node_modules/feelin/dist/index.esm.js
  function isContext(e3) {
    return Object.getPrototypeOf(e3) === Object.prototype;
  }
  function isDateTime(obj) {
    return DateTime.isDateTime(obj);
  }
  function isDuration(obj) {
    return Duration.isDuration(obj);
  }
  function isArray3(e3) {
    return Array.isArray(e3);
  }
  function isBoolean(e3) {
    return typeof e3 === "boolean";
  }
  function getType(e3) {
    if (e3 === null || e3 === void 0) {
      return "nil";
    }
    if (isBoolean(e3)) {
      return "boolean";
    }
    if (isNumber3(e3)) {
      return "number";
    }
    if (isString3(e3)) {
      return "string";
    }
    if (isContext(e3)) {
      return "context";
    }
    if (isArray3(e3)) {
      return "list";
    }
    if (isDuration(e3)) {
      return "duration";
    }
    if (isDateTime(e3)) {
      if (e3.year === 1900 && e3.month === 1 && e3.day === 1) {
        return "time";
      }
      if (e3.hour === 0 && e3.minute === 0 && e3.second === 0 && e3.millisecond === 0 && e3.zone === FixedOffsetZone.utcInstance) {
        return "date";
      }
      return "date time";
    }
    if (e3 instanceof Range2) {
      return "range";
    }
    if (e3 instanceof FunctionWrapper) {
      return "function";
    }
    return "literal";
  }
  function isType(el, type3) {
    return getType(el) === type3;
  }
  function typeCast(obj, type3) {
    if (isDateTime(obj)) {
      if (type3 === "time") {
        return obj.set({
          year: 1900,
          month: 1,
          day: 1
        });
      }
      if (type3 === "date") {
        return obj.setZone("utc", { keepLocalTime: true }).startOf("day");
      }
      if (type3 === "date time") {
        return obj;
      }
    }
    return null;
  }
  var Range2 = class {
    constructor(props) {
      Object.assign(this, props);
    }
  };
  function isNumber3(obj) {
    return typeof obj === "number";
  }
  function isString3(obj) {
    return typeof obj === "string";
  }
  function equals(a3, b2, strict = false) {
    if (a3 === null && b2 !== null || a3 !== null && b2 === null) {
      return false;
    }
    if (isArray3(a3) && a3.length < 2) {
      a3 = a3[0];
    }
    if (isArray3(b2) && b2.length < 2) {
      b2 = b2[0];
    }
    const aType = getType(a3);
    const bType = getType(b2);
    const temporalTypes = ["date time", "time", "date"];
    if (temporalTypes.includes(aType)) {
      if (!temporalTypes.includes(bType)) {
        return null;
      }
      if (aType === "time" && bType !== "time") {
        return null;
      }
      if (bType === "time" && aType !== "time") {
        return null;
      }
      if (strict || a3.zone === SystemZone.instance || b2.zone === SystemZone.instance) {
        return a3.equals(b2);
      } else {
        return a3.toUTC().valueOf() === b2.toUTC().valueOf();
      }
    }
    if (aType !== bType) {
      return null;
    }
    if (aType === "nil") {
      return true;
    }
    if (aType === "list") {
      if (a3.length !== b2.length) {
        return false;
      }
      return a3.every((element, idx) => equals(element, b2[idx]));
    }
    if (aType === "duration") {
      if (Math.abs(a3.as("days")) > 180) {
        return Math.trunc(a3.minus(b2).as("months")) === 0;
      } else {
        return Math.trunc(a3.minus(b2).as("seconds")) === 0;
      }
    }
    if (aType === "context") {
      const aEntries = Object.entries(a3);
      const bEntries = Object.entries(b2);
      if (aEntries.length !== bEntries.length) {
        return false;
      }
      return aEntries.every(([key, value]) => key in b2 && equals(value, b2[key]));
    }
    if (aType === "range") {
      return [
        [a3.start, b2.start],
        [a3.end, b2.end],
        [a3["start included"], b2["start included"]],
        [a3["end included"], b2["end included"]]
      ].every(([a4, b3]) => a4 === b3);
    }
    if (a3 == b2) {
      return true;
    }
    return aType === bType ? false : null;
  }
  var FunctionWrapper = class {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(fn4, parameterNames) {
      this.fn = fn4;
      this.parameterNames = parameterNames;
    }
    invoke(contextOrArgs) {
      let params;
      if (isArray3(contextOrArgs)) {
        params = contextOrArgs;
        if (params.length > this.parameterNames.length) {
          const lastParam = this.parameterNames[this.parameterNames.length - 1];
          if (!lastParam || !lastParam.startsWith("...")) {
            return null;
          }
        }
      } else {
        if (Object.keys(contextOrArgs).some((key) => !this.parameterNames.includes(key) && !this.parameterNames.includes(`...${key}`))) {
          return null;
        }
        params = this.parameterNames.reduce((params2, name2) => {
          if (name2.startsWith("...")) {
            name2 = name2.slice(3);
            const value = contextOrArgs[name2];
            if (!value) {
              return params2;
            } else {
              return [...params2, ...isArray3(value) ? value : [value]];
            }
          }
          return [...params2, contextOrArgs[name2]];
        }, []);
      }
      return this.fn.call(null, ...params);
    }
  };
  function parseParameterNames(fn4) {
    if (Array.isArray(fn4.$args)) {
      return fn4.$args;
    }
    const code = fn4.toString();
    const match2 = /^(?:[^(]*\s*)?\(([^)]+)?\)/.exec(code);
    if (!match2) {
      throw new Error("failed to parse params: " + code);
    }
    const [_3, params] = match2;
    if (!params) {
      return [];
    }
    return params.split(",").map((p3) => p3.trim());
  }
  function notImplemented(thing) {
    return new Error(`not implemented: ${thing}`);
  }
  function isNotImplemented(err) {
    return /^not implemented/.test(err.message);
  }
  function getFromContext(name2, context) {
    if (["nil", "boolean", "number", "string"].includes(getType(context))) {
      return void 0;
    }
    if (name2 in context) {
      return context[name2];
    }
    const normalizedName = normalizeContextKey(name2);
    if (normalizedName in context) {
      return context[normalizedName];
    }
    const entry = Object.entries(context).find(([key]) => normalizedName === normalizeContextKey(key));
    if (entry) {
      return entry[1];
    }
    return void 0;
  }
  function duration2(opts) {
    if (typeof opts === "number") {
      return Duration.fromMillis(opts);
    }
    return Duration.fromISO(opts);
  }
  function date(str = null, time = null, zone = null) {
    if (time) {
      if (str) {
        throw new Error("<str> and <time> provided");
      }
      return date(`1900-01-01T${time}`, null);
    }
    if (typeof str === "string") {
      if (str.startsWith("-")) {
        throw notImplemented("negative date");
      }
      if (!str.includes("T")) {
        return date(str + "T00:00:00", null, zone || FixedOffsetZone.utcInstance);
      }
      if (str.includes("@")) {
        if (zone) {
          throw new Error("<zone> already provided");
        }
        const [datePart, zonePart] = str.split("@");
        return date(datePart, null, Info.normalizeZone(zonePart));
      }
      return DateTime.fromISO(str.toUpperCase(), {
        setZone: true,
        zone
      });
    }
    return DateTime.now();
  }
  var builtins = {
    // 10.3.4.1 Conversion functions
    "number": fn2(function(from, groupingSeparator, decimalSeparator) {
      if (arguments.length !== 3) {
        return null;
      }
      if (groupingSeparator) {
        from = from.split(groupingSeparator).join("");
      }
      if (decimalSeparator && decimalSeparator !== ".") {
        from = from.split(".").join("#").split(decimalSeparator).join(".");
      }
      const number2 = +from;
      if (isNaN(number2)) {
        return null;
      }
      return number2;
    }, ["string", "string?", "string?"], ["from", "grouping separator", "decimal separator"]),
    "string": fn2(function(from) {
      if (from === null) {
        return null;
      }
      return toString(from);
    }, ["any"]),
    // date(from) => date string
    // date(from) => date and time
    // date(year, month, day)
    "date": fn2(function(year, month, day, from) {
      if (!from && !isNumber3(year)) {
        from = year;
        year = null;
      }
      let d3;
      if (isString3(from)) {
        d3 = date(from);
      }
      if (isDateTime(from)) {
        d3 = from;
      }
      if (year) {
        if (!isNumber3(month) || !isNumber3(day)) {
          return null;
        }
        d3 = date().setZone("utc").set({
          year,
          month,
          day
        });
      }
      return d3 && ifValid(d3.setZone("utc").startOf("day")) || null;
    }, ["any?", "number?", "number?", "any?"]),
    // date and time(from) => date time string
    // date and time(date, time)
    "date and time": fn2(function(d3, time, from) {
      let dt;
      if (isDateTime(d3) && isDateTime(time)) {
        const dLocal = d3.toLocal();
        dt = time.set({
          year: dLocal.year,
          month: dLocal.month,
          day: dLocal.day
        });
      }
      if (isString3(d3)) {
        from = d3;
        d3 = null;
      }
      if (isString3(from)) {
        dt = date(from, null, from.includes("@") ? null : SystemZone.instance);
      }
      return dt && ifValid(dt) || null;
    }, ["any?", "time?", "string?"], ["date", "time", "from"]),
    // time(from) => time string
    // time(from) => time, date and time
    // time(hour, minute, second, offset?) => ...
    "time": fn2(function(hour, minute, second, offset2, from) {
      let t4;
      if (offset2) {
        throw notImplemented("time(..., offset)");
      }
      if (isString3(hour) || isDateTime(hour)) {
        from = hour;
        hour = null;
      }
      if (isString3(from) && from) {
        t4 = date(null, from);
      }
      if (isDateTime(from)) {
        t4 = from.set({
          year: 1900,
          month: 1,
          day: 1
        });
      }
      if (isNumber3(hour)) {
        if (!isNumber3(minute) || !isNumber3(second)) {
          return null;
        }
        t4 = date().set({
          hour,
          minute,
          second
        }).set({
          year: 1900,
          month: 1,
          day: 1,
          millisecond: 0
        });
      }
      return t4 && ifValid(t4) || null;
    }, ["any?", "number?", "number?", "any?", "any?"]),
    "duration": fn2(function(from) {
      return ifValid(duration2(from));
    }, ["string"]),
    "years and months duration": fn2(function(from, to) {
      return ifValid(to.diff(from, ["years", "months"]));
    }, ["date", "date"]),
    "@": fn2(function(string2) {
      let t4;
      if (/^-?P/.test(string2)) {
        t4 = duration2(string2);
      } else if (/^[\d]{1,2}:[\d]{1,2}:[\d]{1,2}/.test(string2)) {
        t4 = date(null, string2);
      } else {
        t4 = date(string2);
      }
      return t4 && ifValid(t4) || null;
    }, ["string"]),
    "now": fn2(function() {
      return date();
    }, []),
    "today": fn2(function() {
      return date().startOf("day");
    }, []),
    // 10.3.4.2 Boolean function
    "not": fn2(function(bool) {
      return isType(bool, "boolean") ? !bool : null;
    }, ["any"]),
    // 10.3.4.3 String functions
    "substring": fn2(function(string2, start, length) {
      const _start = start < 0 ? string2.length + start : start - 1;
      const arr = Array.from(string2);
      return (typeof length !== "undefined" ? arr.slice(_start, _start + length) : arr.slice(_start)).join("");
    }, ["string", "number", "number?"], ["string", "start position", "length"]),
    "string length": fn2(function(string2) {
      return countSymbols(string2);
    }, ["string"]),
    "upper case": fn2(function(string2) {
      return string2.toUpperCase();
    }, ["string"]),
    "lower case": fn2(function(string2) {
      return string2.toLowerCase();
    }, ["string"]),
    "substring before": fn2(function(string2, match2) {
      const index2 = string2.indexOf(match2);
      if (index2 === -1) {
        return "";
      }
      return string2.substring(0, index2);
    }, ["string", "string"]),
    "substring after": fn2(function(string2, match2) {
      const index2 = string2.indexOf(match2);
      if (index2 === -1) {
        return "";
      }
      return string2.substring(index2 + match2.length);
    }, ["string", "string"]),
    "replace": fn2(function(input, pattern, replacement, flags) {
      const regexp = createRegexp(pattern, flags || "", "g");
      return regexp && input.replace(regexp, replacement.replace(/\$0/g, "$$&"));
    }, ["string", "string", "string", "string?"]),
    "contains": fn2(function(string2, match2) {
      return string2.includes(match2);
    }, ["string", "string"]),
    "matches": fn2(function(input, pattern, flags) {
      const regexp = createRegexp(pattern, flags || "", "");
      return regexp && regexp.test(input);
    }, ["string", "string", "string?"]),
    "starts with": fn2(function(string2, match2) {
      return string2.startsWith(match2);
    }, ["string", "string"]),
    "ends with": fn2(function(string2, match2) {
      return string2.endsWith(match2);
    }, ["string", "string"]),
    "split": fn2(function(string2, delimiter) {
      const regexp = createRegexp(delimiter, "", "");
      return regexp && string2.split(regexp);
    }, ["string", "string"]),
    "string join": fn2(function(list2, delimiter) {
      if (list2.some((e3) => !isString3(e3) && e3 !== null)) {
        return null;
      }
      return list2.filter((l4) => l4 !== null).join(delimiter || "");
    }, ["list", "string?"]),
    // 10.3.4.4 List functions
    "list contains": fn2(function(list2, element) {
      return list2.some((el) => matches(el, element));
    }, ["list", "any?"]),
    // list replace(list, position, newItem)
    // list replace(list, match, newItem)
    "list replace": fn2(function(list2, position, newItem, match2) {
      const matcher = position || match2;
      if (!["number", "function"].includes(getType(matcher))) {
        return null;
      }
      return listReplace(list2, position || match2, newItem);
    }, ["list", "any?", "any", "function?"]),
    "count": fn2(function(list2) {
      return list2.length;
    }, ["list"]),
    "min": listFn(function(...list2) {
      return list2.reduce((min, el) => min === null ? el : Math.min(min, el), null);
    }, "number"),
    "max": listFn(function(...list2) {
      return list2.reduce((max, el) => max === null ? el : Math.max(max, el), null);
    }, "number"),
    "sum": listFn(function(...list2) {
      return sum(list2);
    }, "number"),
    "mean": listFn(function(...list2) {
      const s4 = sum(list2);
      return s4 === null ? s4 : s4 / list2.length;
    }, "number"),
    "all": listFn(function(...list2) {
      let nonBool = false;
      for (const o3 of list2) {
        if (o3 === false) {
          return false;
        }
        if (typeof o3 !== "boolean") {
          nonBool = true;
        }
      }
      return nonBool ? null : true;
    }, "any?"),
    "any": listFn(function(...list2) {
      let nonBool = false;
      for (const o3 of list2) {
        if (o3 === true) {
          return true;
        }
        if (typeof o3 !== "boolean") {
          nonBool = true;
        }
      }
      return nonBool ? null : false;
    }, "any?"),
    "sublist": fn2(function(list2, start, length) {
      const _start = start < 0 ? list2.length + start : start - 1;
      return typeof length !== "undefined" ? list2.slice(_start, _start + length) : list2.slice(_start);
    }, ["list", "number", "number?"]),
    "append": fn2(function(list2, ...items) {
      return list2.concat(items);
    }, ["list", "any?"]),
    "concatenate": fn2(function(...args) {
      return args.reduce((result, arg) => {
        return result.concat(arg);
      }, []);
    }, ["any"]),
    "insert before": fn2(function(list2, position, newItem) {
      return list2.slice(0, position - 1).concat([newItem], list2.slice(position - 1));
    }, ["list", "number", "any?"]),
    "remove": fn2(function(list2, position) {
      return list2.slice(0, position - 1).concat(list2.slice(position));
    }, ["list", "number"]),
    "reverse": fn2(function(list2) {
      return list2.slice().reverse();
    }, ["list"]),
    "index of": fn2(function(list2, match2) {
      return list2.reduce(function(result, element, index2) {
        if (matches(element, match2)) {
          result.push(index2 + 1);
        }
        return result;
      }, []);
    }, ["list", "any"]),
    "union": listFn(function(...lists) {
      return lists.reduce((result, list2) => {
        return list2.reduce((result2, e3) => {
          if (!result2.some((r3) => equals(e3, r3))) {
            result2.push(e3);
          }
          return result2;
        }, result);
      }, []);
    }, "list"),
    "distinct values": fn2(function(list2) {
      return list2.reduce((result, e3) => {
        if (!result.some((r3) => equals(e3, r3))) {
          result.push(e3);
        }
        return result;
      }, []);
    }, ["list"]),
    "flatten": fn2(function(list2) {
      return flatten(list2);
    }, ["list"]),
    "product": listFn(function(...list2) {
      if (list2.length === 0) {
        return null;
      }
      return list2.reduce((result, n3) => {
        return result * n3;
      }, 1);
    }, "number"),
    "median": listFn(function(...list2) {
      if (list2.length === 0) {
        return null;
      }
      return median(list2);
    }, "number"),
    "stddev": listFn(function(...list2) {
      if (list2.length < 2) {
        return null;
      }
      return stddev(list2);
    }, "number"),
    "mode": listFn(function(...list2) {
      return mode(list2);
    }, "number"),
    // 10.3.4.5 Numeric functions
    "decimal": fn2(function(n3, scale) {
      if (!scale) {
        return bankersRound(n3);
      }
      const offset2 = Math.pow(10, scale);
      return bankersRound(n3 * offset2) / offset2;
    }, ["number", "number"]),
    "floor": fn2(function(n3, scale = 0) {
      if (scale === null) {
        return null;
      }
      const adjust = Math.pow(10, scale);
      return Math.floor(n3 * adjust) / adjust;
    }, ["number", "number?"]),
    "ceiling": fn2(function(n3, scale = 0) {
      if (scale === null) {
        return null;
      }
      const adjust = Math.pow(10, scale);
      return Math.ceil(n3 * adjust) / adjust;
    }, ["number", "number?"]),
    "abs": fn2(function(n3) {
      if (typeof n3 !== "number") {
        return null;
      }
      return Math.abs(n3);
    }, ["number"]),
    // eslint-disable-next-line
    "round up": fn2(function(n3, scale) {
      throw notImplemented("round up");
    }, ["number", "number"]),
    // eslint-disable-next-line
    "round down": fn2(function(n3, scale) {
      throw notImplemented("round down");
    }, ["number", "number"]),
    // eslint-disable-next-line
    "round half up": fn2(function(n3, scale) {
      throw notImplemented("round half up");
    }, ["number", "number"]),
    // eslint-disable-next-line
    "round half down": fn2(function(n3, scale) {
      throw notImplemented("round half down");
    }, ["number", "number"]),
    "modulo": fn2(function(dividend, divisor) {
      if (!divisor) {
        return null;
      }
      const adjust = 1e9;
      return Math.round((dividend % divisor + divisor) % divisor * adjust) / adjust;
    }, ["number", "number"]),
    "sqrt": fn2(function(number2) {
      if (number2 < 0) {
        return null;
      }
      return Math.sqrt(number2);
    }, ["number"]),
    "log": fn2(function(number2) {
      if (number2 <= 0) {
        return null;
      }
      return Math.log(number2);
    }, ["number"]),
    "exp": fn2(function(number2) {
      return Math.exp(number2);
    }, ["number"]),
    "odd": fn2(function(number2) {
      return Math.abs(number2) % 2 === 1;
    }, ["number"]),
    "even": fn2(function(number2) {
      return Math.abs(number2) % 2 === 0;
    }, ["number"]),
    // 10.3.4.6 Date and time functions
    "is": fn2(function(value1, value2) {
      if (typeof value1 === "undefined" || typeof value2 === "undefined") {
        return false;
      }
      return equals(value1, value2, true);
    }, ["any?", "any?"]),
    // 10.3.4.7 Range Functions
    "before": fn2(function(a3, b2) {
      return before(a3, b2);
    }, ["any", "any"]),
    "after": fn2(function(a3, b2) {
      return before(b2, a3);
    }, ["any", "any"]),
    "meets": fn2(function(a3, b2) {
      return meetsRange(a3, b2);
    }, ["range", "range"]),
    "met by": fn2(function(a3, b2) {
      return meetsRange(b2, a3);
    }, ["range", "range"]),
    "overlaps": fn2(function(range1, range2) {
      return !before(range1, range2) && !before(range2, range1);
    }, ["range", "range"]),
    "overlaps before": fn2(function() {
      throw notImplemented("overlaps before");
    }, ["any?"]),
    "overlaps after": fn2(function() {
      throw notImplemented("overlaps after");
    }, ["any?"]),
    "finishes": fn2(function() {
      throw notImplemented("finishes");
    }, ["any?"]),
    "finished by": fn2(function() {
      throw notImplemented("finished by");
    }, ["any?"]),
    "includes": fn2(function() {
      throw notImplemented("includes");
    }, ["any?"]),
    "during": fn2(function() {
      throw notImplemented("during");
    }, ["any?"]),
    "starts": fn2(function() {
      throw notImplemented("starts");
    }, ["any?"]),
    "started by": fn2(function() {
      throw notImplemented("started by");
    }, ["any?"]),
    "coincides": fn2(function() {
      throw notImplemented("coincides");
    }, ["any?"]),
    // 10.3.4.8 Temporal built-in functions
    "day of year": fn2(function(date3) {
      return date3.ordinal;
    }, ["date time"]),
    "day of week": fn2(function(date3) {
      return date3.weekdayLong;
    }, ["date time"]),
    "month of year": fn2(function(date3) {
      return date3.monthLong;
    }, ["date time"]),
    "week of year": fn2(function(date3) {
      return date3.weekNumber;
    }, ["date time"]),
    // 10.3.4.9 Sort
    "sort": fn2(function(list2, precedes) {
      return Array.from(list2).sort((a3, b2) => precedes.invoke([a3, b2]) ? -1 : 1);
    }, ["list", "function"]),
    // 10.3.4.10 Context function
    "get value": fn2(function(m3, key) {
      const value = getFromContext(key, m3);
      return value != void 0 ? value : null;
    }, ["context", "string"]),
    "get entries": fn2(function(m3) {
      if (arguments.length !== 1) {
        return null;
      }
      if (Array.isArray(m3)) {
        return null;
      }
      return Object.entries(m3).map(([key, value]) => ({ key, value }));
    }, ["context"]),
    "context": listFn(function(...entries2) {
      const context = entries2.reduce((context2, entry) => {
        if (context2 === FALSE || !["key", "value"].every((e3) => e3 in entry)) {
          return FALSE;
        }
        const key = entry.key;
        if (key === null) {
          return FALSE;
        }
        if (key in context2) {
          return FALSE;
        }
        return Object.assign(Object.assign({}, context2), { [entry.key]: entry.value });
      }, {});
      if (context === FALSE) {
        return null;
      }
      return context;
    }, "context"),
    "context merge": listFn(function(...contexts) {
      return Object.assign({}, ...contexts);
    }, "context"),
    "context put": fn2(function(context, keys, value, key) {
      if (typeof keys === "undefined" && typeof key === "undefined") {
        return null;
      }
      return contextPut(context, keys || [key], value);
    }, ["context", "list?", "any", "string?"], ["context", "keys", "value", "key"])
  };
  function contextPut(context, keys, value) {
    const [key, ...remainingKeys] = keys;
    if (getType(key) !== "string") {
      return null;
    }
    if (getType(context) === "nil") {
      return null;
    }
    if (remainingKeys.length) {
      value = contextPut(context[key], remainingKeys, value);
      if (value === null) {
        return null;
      }
    }
    return Object.assign(Object.assign({}, context), { [key]: value });
  }
  function matches(a3, b2) {
    return a3 === b2;
  }
  var FALSE = {};
  function createArgTester(arg) {
    const optional = arg.endsWith("?");
    const type3 = optional ? arg.substring(0, arg.length - 1) : arg;
    return function(obj) {
      const arr = Array.isArray(obj);
      if (type3 === "list") {
        if (arr || optional && typeof obj === "undefined") {
          return obj;
        } else {
          return obj === null ? FALSE : [obj];
        }
      }
      if (type3 !== "any" && arr && obj.length === 1) {
        obj = obj[0];
      }
      const objType = getType(obj);
      if (type3 === "any" || type3 === objType) {
        return optional ? obj : typeof obj !== "undefined" ? obj : FALSE;
      }
      if (objType === "nil") {
        return optional ? obj : FALSE;
      }
      return typeCast(obj, type3) || FALSE;
    };
  }
  function createArgsValidator(argDefinitions) {
    const tests = argDefinitions.map(createArgTester);
    return function(args) {
      while (args.length < argDefinitions.length) {
        args.push(void 0);
      }
      return args.reduce((result, arg, index2) => {
        if (result === false) {
          return result;
        }
        const test = tests[index2];
        const conversion = test ? test(arg) : arg;
        if (conversion === FALSE) {
          return false;
        }
        result.push(conversion);
        return result;
      }, []);
    };
  }
  function listFn(fnDefinition, type3, parameterNames = null) {
    const tester = createArgTester(type3);
    const wrappedFn = function(...args) {
      if (args.length === 0) {
        return null;
      }
      if (Array.isArray(args[0]) && args.length === 1) {
        args = args[0];
      }
      if (!args.every((arg) => tester(arg) !== FALSE)) {
        return null;
      }
      return fnDefinition(...args);
    };
    wrappedFn.$args = parameterNames || parseParameterNames(fnDefinition);
    return wrappedFn;
  }
  function fn2(fnDefinition, argDefinitions, parameterNames = null) {
    const checkArgs = createArgsValidator(argDefinitions);
    parameterNames = parameterNames || parseParameterNames(fnDefinition);
    const wrappedFn = function(...args) {
      const convertedArgs = checkArgs(args);
      if (!convertedArgs) {
        return null;
      }
      return fnDefinition(...convertedArgs);
    };
    wrappedFn.$args = parameterNames;
    return wrappedFn;
  }
  function meetsRange(a3, b2) {
    return [
      a3.end === b2.start,
      a3["end included"] === true,
      b2["start included"] === true
    ].every((v4) => v4);
  }
  function before(a3, b2) {
    if (a3 instanceof Range2 && b2 instanceof Range2) {
      return a3.end < b2.start || (!a3["end included"] || !b2["start included"]) && a3.end == b2.start;
    }
    if (a3 instanceof Range2) {
      return a3.end < b2 || !a3["end included"] && a3.end === b2;
    }
    if (b2 instanceof Range2) {
      return b2.start > a3 || !b2["start included"] && b2.start === a3;
    }
    return a3 < b2;
  }
  function sum(list2) {
    return list2.reduce((sum3, el) => sum3 === null ? el : sum3 + el, null);
  }
  function flatten([x3, ...xs]) {
    return x3 !== void 0 ? [...Array.isArray(x3) ? flatten(x3) : [x3], ...flatten(xs)] : [];
  }
  function toKeyString(key) {
    if (typeof key === "string" && /\W/.test(key)) {
      return toString(key, true);
    }
    return key;
  }
  function toDeepString(obj) {
    return toString(obj, true);
  }
  function escapeStr(str) {
    return str.replace(/("|\\)/g, "\\$1");
  }
  function toString(obj, wrap2 = false) {
    var _a2, _b, _c, _d;
    const type3 = getType(obj);
    if (type3 === "nil") {
      return "null";
    }
    if (type3 === "string") {
      return wrap2 ? `"${escapeStr(obj)}"` : obj;
    }
    if (type3 === "boolean" || type3 === "number") {
      return String(obj);
    }
    if (type3 === "list") {
      return "[" + obj.map(toDeepString).join(", ") + "]";
    }
    if (type3 === "context") {
      return "{" + Object.entries(obj).map(([key, value]) => {
        return toKeyString(key) + ": " + toDeepString(value);
      }).join(", ") + "}";
    }
    if (type3 === "duration") {
      return obj.shiftTo("years", "months", "days", "hours", "minutes", "seconds").normalize().toISO();
    }
    if (type3 === "date time") {
      if (obj.zone === SystemZone.instance) {
        return obj.toISO({ suppressMilliseconds: true, includeOffset: false });
      }
      if ((_a2 = obj.zone) === null || _a2 === void 0 ? void 0 : _a2.zoneName) {
        return obj.toISO({ suppressMilliseconds: true, includeOffset: false }) + "@" + ((_b = obj.zone) === null || _b === void 0 ? void 0 : _b.zoneName);
      }
      return obj.toISO({ suppressMilliseconds: true });
    }
    if (type3 === "date") {
      return obj.toISODate();
    }
    if (type3 === "range") {
      return "<range>";
    }
    if (type3 === "time") {
      if (obj.zone === SystemZone.instance) {
        return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false });
      }
      if ((_c = obj.zone) === null || _c === void 0 ? void 0 : _c.zoneName) {
        return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false }) + "@" + ((_d = obj.zone) === null || _d === void 0 ? void 0 : _d.zoneName);
      }
      return obj.toISOTime({ suppressMilliseconds: true });
    }
    if (type3 === "function") {
      return "<function>";
    }
    throw notImplemented("string(" + type3 + ")");
  }
  function countSymbols(str) {
    return str.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  function bankersRound(n3) {
    const floored = Math.floor(n3);
    const decimalPart = n3 - floored;
    if (decimalPart === 0.5) {
      return floored % 2 === 0 ? floored : floored + 1;
    }
    return Math.round(n3);
  }
  function stddev(array) {
    const n3 = array.length;
    const mean = array.reduce((a3, b2) => a3 + b2) / n3;
    return Math.sqrt(array.map((x3) => Math.pow(x3 - mean, 2)).reduce((a3, b2) => a3 + b2) / (n3 - 1));
  }
  function listReplace(list2, matcher, newItem) {
    if (isNumber3(matcher)) {
      return [...list2.slice(0, matcher - 1), newItem, ...list2.slice(matcher)];
    }
    return list2.map((item, _idx) => {
      if (matcher.invoke([item, newItem])) {
        return newItem;
      } else {
        return item;
      }
    });
  }
  function median(array) {
    const n3 = array.length;
    const sorted = array.slice().sort();
    const mid = n3 / 2 - 1;
    const index2 = Math.ceil(mid);
    if (mid === index2) {
      return (sorted[index2] + sorted[index2 + 1]) / 2;
    }
    return sorted[index2];
  }
  function mode(array) {
    if (array.length < 2) {
      return array;
    }
    const buckets = {};
    for (const n3 of array) {
      buckets[n3] = (buckets[n3] || 0) + 1;
    }
    const sorted = Object.entries(buckets).sort((a3, b2) => b2[1] - a3[1]);
    return sorted.filter((s4) => s4[1] === sorted[0][1]).map((e3) => +e3[0]);
  }
  function ifValid(o3) {
    return o3.isValid ? o3 : null;
  }
  function buildFlags(flags, defaultFlags) {
    const unsupportedFlags = flags.replace(/[smix]/g, "");
    if (unsupportedFlags) {
      throw new Error("illegal flags: " + unsupportedFlags);
    }
    if (/x/.test(flags)) {
      throw notImplemented("matches <x> flag");
    }
    return flags + defaultFlags;
  }
  function createRegexp(pattern, flags, defaultFlags = "") {
    try {
      return new RegExp(pattern, "u" + buildFlags(flags, defaultFlags));
    } catch (_err) {
      if (isNotImplemented(_err)) {
        throw _err;
      }
    }
    return null;
  }
  function parseExpression(expression, context = {}, dialect) {
    return parser.configure({
      top: "Expression",
      contextTracker: trackVariables(context),
      dialect
    }).parse(expression);
  }
  function parseUnaryTests(expression, context = {}, dialect) {
    return parser.configure({
      top: "UnaryTests",
      contextTracker: trackVariables(context),
      dialect
    }).parse(expression);
  }
  var SyntaxError2 = class extends Error {
    constructor(message, details) {
      super(message);
      Object.assign(this, details);
    }
  };
  var Interpreter = class {
    _buildExecutionTree(tree, input) {
      const root = { args: [], nodeInput: input };
      const stack = [root];
      tree.iterate({
        enter(nodeRef) {
          const { isError, isSkipped } = nodeRef.type;
          const { from, to } = nodeRef;
          if (isError) {
            const { from: from2, to: to2, message } = lintError(nodeRef);
            throw new SyntaxError2(message, {
              input: input.slice(from2, to2),
              position: {
                from: from2,
                to: to2
              }
            });
          }
          if (isSkipped) {
            return false;
          }
          const nodeInput = input.slice(from, to);
          stack.push({
            nodeInput,
            args: []
          });
        },
        leave(nodeRef) {
          if (nodeRef.type.isSkipped) {
            return;
          }
          const { nodeInput, args } = stack.pop();
          const parent = stack[stack.length - 1];
          const expr = evalNode(nodeRef, nodeInput, args);
          parent.args.push(expr);
        }
      });
      return root.args[root.args.length - 1];
    }
    evaluate(expression, context = {}, dialect) {
      const parseTree = parseExpression(expression, context, dialect);
      const root = this._buildExecutionTree(parseTree, expression);
      return {
        parseTree,
        root
      };
    }
    unaryTest(expression, context = {}, dialect) {
      const parseTree = parseUnaryTests(expression, context, dialect);
      const root = this._buildExecutionTree(parseTree, expression);
      return {
        parseTree,
        root
      };
    }
  };
  var interpreter = new Interpreter();
  function unaryTest(expression, context = {}, dialect) {
    const value = context["?"] !== void 0 ? context["?"] : null;
    const { root } = interpreter.unaryTest(expression, context, dialect);
    const test = root(context);
    return test(value);
  }
  function evaluate(expression, context = {}, dialect) {
    const { root } = interpreter.evaluate(expression, context, dialect);
    return root(context);
  }
  function evalNode(node, input, args) {
    switch (node.name) {
      case "ArithOp":
        return (context) => {
          const nullable = (op, types2 = ["number"]) => (a3, b2) => {
            const left = a3(context);
            const right = b2(context);
            if (isArray3(left)) {
              return null;
            }
            if (isArray3(right)) {
              return null;
            }
            const leftType = getType(left);
            const rightType = getType(right);
            const temporal = ["date", "time", "date time", "duration"];
            if (temporal.includes(leftType)) {
              if (!temporal.includes(rightType)) {
                return null;
              }
            } else if (leftType !== rightType || !types2.includes(leftType)) {
              return null;
            }
            return op(left, right);
          };
          switch (input) {
            case "+":
              return nullable((a3, b2) => {
                if (isDuration(a3) && !isDuration(b2)) {
                  const tmp = a3;
                  a3 = b2;
                  b2 = tmp;
                }
                if (isType(a3, "time") && isDuration(b2)) {
                  return a3.plus(b2).set({
                    year: 1900,
                    month: 1,
                    day: 1
                  });
                } else if (isDateTime(a3) && isDateTime(b2)) {
                  return null;
                } else if (isDateTime(a3) && isDuration(b2)) {
                  return a3.plus(b2);
                } else if (isDuration(a3) && isDuration(b2)) {
                  return a3.plus(b2);
                }
                return a3 + b2;
              }, ["string", "number", "date", "time", "duration", "date time"]);
            case "-":
              return nullable((a3, b2) => {
                if (isType(a3, "time") && isDuration(b2)) {
                  return a3.minus(b2).set({
                    year: 1900,
                    month: 1,
                    day: 1
                  });
                } else if (isDateTime(a3) && isDateTime(b2)) {
                  return a3.diff(b2);
                } else if (isDateTime(a3) && isDuration(b2)) {
                  return a3.minus(b2);
                } else if (isDuration(a3) && isDuration(b2)) {
                  return a3.minus(b2);
                }
                return a3 - b2;
              }, ["number", "date", "time", "duration", "date time"]);
            case "*":
              return nullable((a3, b2) => a3 * b2);
            case "/":
              return nullable((a3, b2) => !b2 ? null : a3 / b2);
            case "**":
            case "^":
              return nullable((a3, b2) => Math.pow(a3, b2));
          }
        };
      case "CompareOp":
        return tag(() => {
          switch (input) {
            case ">":
              return (b2) => createRange(b2, null, false, false);
            case ">=":
              return (b2) => createRange(b2, null, true, false);
            case "<":
              return (b2) => createRange(null, b2, false, false);
            case "<=":
              return (b2) => createRange(null, b2, false, true);
            case "=":
              return (b2) => (a3) => equals(a3, b2);
            case "!=":
              return (b2) => (a3) => !equals(a3, b2);
          }
        }, Test("boolean"));
      case "BacktickIdentifier":
        return input.replace(/`/g, "");
      case "Wildcard":
        return (_context) => true;
      case "null":
        return (_context) => {
          return null;
        };
      case "Disjunction":
        return tag((context) => {
          const left = args[0](context);
          const right = args[2](context);
          const matrix = [
            [true, true, true],
            [true, false, true],
            [true, null, true],
            [false, true, true],
            [false, false, false],
            [false, null, null],
            [null, true, true],
            [null, false, null],
            [null, null, null]
          ];
          const a3 = typeof left === "boolean" ? left : null;
          const b2 = typeof right === "boolean" ? right : null;
          return matrix.find((el) => el[0] === a3 && el[1] === b2)[2];
        }, Test("boolean"));
      case "Conjunction":
        return tag((context) => {
          const left = args[0](context);
          const right = args[2](context);
          const matrix = [
            [true, true, true],
            [true, false, false],
            [true, null, null],
            [false, true, false],
            [false, false, false],
            [false, null, false],
            [null, true, null],
            [null, false, false],
            [null, null, null]
          ];
          const a3 = typeof left === "boolean" ? left : null;
          const b2 = typeof right === "boolean" ? right : null;
          return matrix.find((el) => el[0] === a3 && el[1] === b2)[2];
        }, Test("boolean"));
      case "Context":
        return (context) => {
          return args.slice(1, -1).reduce((obj, arg) => {
            const [key, value] = arg(Object.assign(Object.assign({}, context), obj));
            return Object.assign(Object.assign({}, obj), { [key]: value });
          }, {});
        };
      case "FunctionBody":
        return args[0];
      case "FormalParameters":
        return args;
      case "FormalParameter":
        return args[0];
      case "ParameterName":
        return args.join(" ");
      case "FunctionDefinition":
        return (context) => {
          const parameterNames = args[2];
          const fnBody = args[4];
          return wrapFunction((...args2) => {
            const fnContext = parameterNames.reduce((context2, name2, idx) => {
              context2[name2] = args2[idx];
              return context2;
            }, Object.assign({}, context));
            return fnBody(fnContext);
          }, parameterNames);
        };
      case "ContextEntry":
        return (context) => {
          const key = typeof args[0] === "function" ? args[0](context) : args[0];
          const value = args[1](context);
          return [key, value];
        };
      case "Key":
        return args[0];
      case "Identifier":
        return input;
      case "SpecialFunctionName":
        return (context) => getBuiltin(input);
      // preserve spaces in name, but compact multiple
      // spaces into one (token)
      case "Name":
        return input.replace(/\s{2,}/g, " ");
      case "VariableName":
        return (context) => {
          const name2 = args.join(" ");
          const contextValue = getFromContext(name2, context);
          return typeof contextValue !== "undefined" ? contextValue : getBuiltin(name2) || null;
        };
      case "QualifiedName":
        return (context) => {
          return args.reduce((context2, arg) => arg(context2), context);
        };
      case "?":
        return (context) => getFromContext("?", context);
      // expression
      // expression ".." expression
      case "IterationContext":
        return (context) => {
          const a3 = args[0](context);
          const b2 = args[1] && args[1](context);
          return b2 ? createRange(a3, b2) : a3;
        };
      case "Type":
        return args[0];
      // (x in [ [1,2], [3,4] ]), (y in x)
      case "InExpressions":
        return (context) => {
          const isValidContexts = (contexts) => {
            if (contexts === null || contexts.some((arr) => getType(arr) === "nil")) {
              return false;
            }
            return true;
          };
          const join = (aContexts, bContextProducer) => {
            return [].concat(...aContexts.map((aContext) => {
              const bContexts = bContextProducer(Object.assign(Object.assign({}, context), aContext));
              if (!isValidContexts(bContexts)) {
                return null;
              }
              return bContexts.map((bContext) => {
                return Object.assign(Object.assign({}, aContext), bContext);
              });
            }));
          };
          const cartesian = (aContexts, bContextProducer, ...otherContextProducers) => {
            if (!isValidContexts(aContexts)) {
              return null;
            }
            if (!bContextProducer) {
              return aContexts;
            }
            return cartesian(join(aContexts, bContextProducer), ...otherContextProducers);
          };
          const cartesianProduct2 = (contextProducers) => {
            const [aContextProducer, ...otherContextProducers] = contextProducers;
            const aContexts = aContextProducer(context);
            return cartesian(aContexts, ...otherContextProducers);
          };
          const product = cartesianProduct2(args);
          return product && product.map((p3) => {
            return Object.assign(Object.assign({}, context), p3);
          });
        };
      // Name kw<"in"> Expr
      case "InExpression":
        return (context) => {
          return extractValue(context, args[0], args[2]);
        };
      case "SpecialType":
        throw notImplemented("SpecialType");
      case "InstanceOfExpression":
        return tag((context) => {
          const a3 = args[0](context);
          const b2 = args[3](context);
          return a3 instanceof b2;
        }, Test("boolean"));
      case "every":
        return tag((context) => {
          return (_contexts, _condition) => {
            const contexts = _contexts(context);
            if (getType(contexts) !== "list") {
              return contexts;
            }
            return contexts.every((ctx) => isTruthy(_condition(ctx)));
          };
        }, Test("boolean"));
      case "some":
        return tag((context) => {
          return (_contexts, _condition) => {
            const contexts = _contexts(context);
            if (getType(contexts) !== "list") {
              return contexts;
            }
            return contexts.some((ctx) => isTruthy(_condition(ctx)));
          };
        }, Test("boolean"));
      case "NumericLiteral":
        return tag((_context) => input.includes(".") ? parseFloat(input) : parseInt(input), "number");
      case "BooleanLiteral":
        return tag((_context) => input === "true" ? true : false, "boolean");
      case "StringLiteral":
        return tag((_context) => parseString(input), "string");
      case "PositionalParameters":
        return (context) => args.map((arg) => arg(context));
      case "NamedParameter":
        return (context) => {
          const name2 = args[0];
          const value = args[1](context);
          return [name2, value];
        };
      case "NamedParameters":
        return (context) => args.reduce((args2, arg) => {
          const [name2, value] = arg(context);
          args2[name2] = value;
          return args2;
        }, {});
      case "DateTimeConstructor":
        return (context) => {
          return getBuiltin(input);
        };
      case "DateTimeLiteral":
        return (context) => {
          if (args.length === 1) {
            return args[0](context);
          } else {
            const wrappedFn = wrapFunction(args[0](context));
            if (!wrappedFn) {
              return null;
            }
            const contextOrArgs = args[2](context);
            return wrappedFn.invoke(contextOrArgs);
          }
        };
      case "AtLiteral":
        return (context) => {
          const wrappedFn = wrapFunction(getBuiltin("@"));
          if (!wrappedFn) {
            return null;
          }
          return wrappedFn.invoke([args[0](context)]);
        };
      case "FunctionInvocation":
        return (context) => {
          const wrappedFn = wrapFunction(args[0](context));
          if (!wrappedFn) {
            return null;
          }
          const contextOrArgs = args[2](context);
          return wrappedFn.invoke(contextOrArgs);
        };
      case "IfExpression":
        return function() {
          const ifCondition = args[1];
          const thenValue = args[3];
          const elseValue = args[5];
          const type3 = coalecenseTypes(thenValue, elseValue);
          return tag((context) => {
            if (isTruthy(ifCondition(context))) {
              return thenValue(context);
            } else {
              return elseValue ? elseValue(context) : null;
            }
          }, type3);
        }();
      case "Parameters":
        return args.length === 3 ? args[1] : (_context) => [];
      case "Comparison":
        return (context) => {
          const operator2 = args[1];
          if (operator2 === "in") {
            return compareIn(args[0](context), (args[3] || args[2])(context));
          }
          if (operator2 === "between") {
            const start = args[2](context);
            const end = args[4](context);
            if (start === null || end === null) {
              return null;
            }
            return createRange(start, end).includes(args[0](context));
          }
          const left = args[0](context);
          const right = args[2](context);
          const test = operator2()(right);
          return compareValue(test, left);
        };
      case "QuantifiedExpression":
        return (context) => {
          const testFn = args[0](context);
          const contexts = args[1];
          const condition = args[3];
          return testFn(contexts, condition);
        };
      // DMN 1.2 - 10.3.2.14
      // kw<"for"> commaSep1<InExpression<IterationContext>> kw<"return"> expression
      case "ForExpression":
        return (context) => {
          const extractor = args[args.length - 1];
          const iterationContexts = args[1](context);
          if (getType(iterationContexts) !== "list") {
            return iterationContexts;
          }
          const partial = [];
          for (const ctx of iterationContexts) {
            partial.push(extractor(Object.assign(Object.assign({}, ctx), { partial })));
          }
          return partial;
        };
      case "ArithmeticExpression":
        return function() {
          if (args.length === 3) {
            const [a3, op, b2] = args;
            return tag((context) => {
              return op(context)(a3, b2);
            }, coalecenseTypes(a3, b2));
          }
          if (args.length === 2) {
            const [op, value] = args;
            return tag((context) => {
              return op(context)(() => 0, value);
            }, value.type);
          }
        }();
      case "PositiveUnaryTest":
        return args[0];
      case "ParenthesizedExpression":
        return args[1];
      case "PathExpression":
        return (context) => {
          const pathTarget = args[0](context);
          const pathProp = args[1];
          if (isArray3(pathTarget)) {
            return pathTarget.map(pathProp);
          } else {
            return pathProp(pathTarget);
          }
        };
      // expression !filter "[" expression "]"
      case "FilterExpression":
        return (context) => {
          const target = args[0](context);
          const filterFn = args[2];
          const filterTarget = isArray3(target) ? target : [target];
          if (target === null) {
            return null;
          }
          if (typeof filterFn.type === "undefined") {
            try {
              const value = filterFn(context);
              if (isNumber3(value)) {
                filterFn.type = "number";
              }
            } catch (_err) {
            }
          }
          if (filterFn.type === "number") {
            const idx = filterFn(context);
            const value = filterTarget[idx < 0 ? filterTarget.length + idx : idx - 1];
            if (typeof value === "undefined") {
              return null;
            } else {
              return value;
            }
          }
          if (filterFn.type === "boolean") {
            if (filterFn(context)) {
              return filterTarget;
            } else {
              return [];
            }
          }
          if (filterFn.type === "string") {
            const value = filterFn(context);
            return filterTarget.filter((el) => el === value);
          }
          return filterTarget.map((el) => {
            const iterationContext = Object.assign(Object.assign(Object.assign({}, context), { item: el }), el);
            let result = filterFn(iterationContext);
            if (typeof result === "function") {
              result = result(el);
            }
            if (result instanceof Range2) {
              result = result.includes(el);
            }
            if (result === true) {
              return el;
            }
            return result;
          }).filter(isTruthy);
        };
      case "SimplePositiveUnaryTest":
        return tag((context) => {
          if (args.length === 1) {
            return args[0](context);
          }
          return args[0](context)(args[1](context));
        }, "test");
      case "List":
        return (context) => {
          return args.slice(1, -1).map((arg) => arg(context));
        };
      case "Interval":
        return tag((context) => {
          const left = args[1](context);
          const right = args[2](context);
          const startIncluded = left !== null && args[0] === "[";
          const endIncluded = right !== null && args[3] === "]";
          return createRange(left, right, startIncluded, endIncluded);
        }, Test("boolean"));
      case "PositiveUnaryTests":
      case "Expressions":
        return (context) => {
          return args.map((a3) => a3(context));
        };
      case "Expression":
        return (context) => {
          return args[0](context);
        };
      case "UnaryTests":
        return (context) => {
          return (value = null) => {
            const negate = args[0] === "not";
            const tests = negate ? args.slice(2, -1) : args;
            const matches4 = tests.map((test) => test(context)).flat(1).map((test) => {
              if (isArray3(test)) {
                return test.includes(value);
              }
              if (test === null) {
                return null;
              }
              if (typeof test === "boolean") {
                return test;
              }
              return compareValue(test, value);
            }).reduce(combineResult, void 0);
            return matches4 === null ? null : negate ? !matches4 : matches4;
          };
        };
      default:
        return node.name;
    }
  }
  function getBuiltin(name2, _context) {
    return getFromContext(name2, builtins);
  }
  function extractValue(context, prop, _target) {
    const target = _target(context);
    if (["list", "range"].includes(getType(target))) {
      return target.map((t4) => ({ [prop]: t4 }));
    }
    return null;
  }
  function compareIn(value, tests) {
    if (!isArray3(tests)) {
      if (getType(tests) === "nil") {
        return null;
      }
      tests = [tests];
    }
    return tests.some((test) => compareValue(test, value));
  }
  function compareValue(test, value) {
    if (typeof test === "function") {
      return test(value);
    }
    if (test instanceof Range2) {
      return test.includes(value);
    }
    return equals(test, value);
  }
  var chars2 = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
  function isTyped(type3, values2) {
    return values2.some((e3) => getType(e3) === type3) && values2.every((e3) => e3 === null || getType(e3) === type3);
  }
  var nullRange = new Range2({
    start: null,
    end: null,
    "start included": false,
    "end included": false,
    map() {
      return [];
    },
    includes() {
      return null;
    }
  });
  function createRange(start, end, startIncluded = true, endIncluded = true) {
    if (isTyped("string", [start, end])) {
      return createStringRange(start, end, startIncluded, endIncluded);
    }
    if (isTyped("number", [start, end])) {
      return createNumberRange(start, end, startIncluded, endIncluded);
    }
    if (isTyped("duration", [start, end])) {
      return createDurationRange(start, end, startIncluded, endIncluded);
    }
    if (isTyped("time", [start, end])) {
      return createDateTimeRange(start, end, startIncluded, endIncluded);
    }
    if (isTyped("date time", [start, end])) {
      return createDateTimeRange(start, end, startIncluded, endIncluded);
    }
    if (isTyped("date", [start, end])) {
      return createDateTimeRange(start, end, startIncluded, endIncluded);
    }
    if (start === null && end === null) {
      return nullRange;
    }
    throw new Error(`unsupported range: ${start}..${end}`);
  }
  function noopMap() {
    return () => {
      throw new Error("unsupported range operation: map");
    };
  }
  function valuesMap(values2) {
    return (fn4) => values2.map(fn4);
  }
  function valuesIncludes(values2) {
    return (value) => values2.includes(value);
  }
  function numberMap(start, end, startIncluded, endIncluded) {
    const direction = start > end ? -1 : 1;
    return (fn4) => {
      const result = [];
      for (let i4 = start; ; i4 += direction) {
        if (i4 === 0 && !startIncluded) {
          continue;
        }
        if (i4 === end && !endIncluded) {
          break;
        }
        result.push(fn4(i4));
        if (i4 === end) {
          break;
        }
      }
      return result;
    };
  }
  function includesStart(n3, inclusive) {
    if (inclusive) {
      return (value) => n3 <= value;
    } else {
      return (value) => n3 < value;
    }
  }
  function includesEnd(n3, inclusive) {
    if (inclusive) {
      return (value) => n3 >= value;
    } else {
      return (value) => n3 > value;
    }
  }
  function anyIncludes(start, end, startIncluded, endIncluded, conversion = (v4) => v4) {
    let tests = [];
    if (start === null && end === null) {
      return () => null;
    }
    if (start !== null && end !== null) {
      if (start > end) {
        tests = [
          includesStart(end, endIncluded),
          includesEnd(start, startIncluded)
        ];
      } else {
        tests = [
          includesStart(start, startIncluded),
          includesEnd(end, endIncluded)
        ];
      }
    } else if (end !== null) {
      tests = [
        includesEnd(end, endIncluded)
      ];
    } else if (start !== null) {
      tests = [
        includesStart(start, startIncluded)
      ];
    }
    return (value) => value === null ? null : tests.every((t4) => t4(conversion(value)));
  }
  function createStringRange(start, end, startIncluded = true, endIncluded = true) {
    if (start !== null && !chars2.includes(start)) {
      throw new Error("illegal range start: " + start);
    }
    if (end !== null && !chars2.includes(end)) {
      throw new Error("illegal range end: " + end);
    }
    let values2;
    if (start !== null && end !== null) {
      let startIdx = chars2.indexOf(start);
      let endIdx = chars2.indexOf(end);
      const direction = startIdx > endIdx ? -1 : 1;
      if (startIncluded === false) {
        startIdx += direction;
      }
      if (endIncluded === false) {
        endIdx -= direction;
      }
      values2 = chars2.slice(startIdx, endIdx + 1);
    }
    const map3 = values2 ? valuesMap(values2) : noopMap();
    const includes = values2 ? valuesIncludes(values2) : anyIncludes(start, end, startIncluded, endIncluded);
    return new Range2({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function createNumberRange(start, end, startIncluded, endIncluded) {
    const map3 = start !== null && end !== null ? numberMap(start, end, startIncluded, endIncluded) : noopMap();
    const includes = anyIncludes(start, end, startIncluded, endIncluded);
    return new Range2({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function createDurationRange(start, end, startIncluded, endIncluded) {
    const toMillis = (d3) => d3 ? Duration.fromDurationLike(d3).toMillis() : null;
    const map3 = noopMap();
    const includes = anyIncludes(toMillis(start), toMillis(end), startIncluded, endIncluded, toMillis);
    return new Range2({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function createDateTimeRange(start, end, startIncluded, endIncluded) {
    const map3 = noopMap();
    const includes = anyIncludes(start, end, startIncluded, endIncluded);
    return new Range2({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function coalecenseTypes(a3, b2) {
    if (!b2) {
      return a3.type;
    }
    if (a3.type === b2.type) {
      return a3.type;
    }
    return "any";
  }
  function tag(fn4, type3) {
    return Object.assign(fn4, {
      type: type3,
      toString() {
        return `TaggedFunction[${type3}] ${Function.prototype.toString.call(fn4)}`;
      }
    });
  }
  function combineResult(result, match2) {
    if (!result) {
      return match2;
    }
    return result;
  }
  function isTruthy(obj) {
    return obj !== false && obj !== null;
  }
  function Test(type3) {
    return `Test<${type3}>`;
  }
  function wrapFunction(fn4, parameterNames = null) {
    if (!fn4) {
      return null;
    }
    if (fn4 instanceof FunctionWrapper) {
      return fn4;
    }
    if (fn4 instanceof Range2) {
      return new FunctionWrapper((value) => fn4.includes(value), ["value"]);
    }
    if (typeof fn4 !== "function") {
      return null;
    }
    return new FunctionWrapper(fn4, parameterNames || parseParameterNames(fn4));
  }
  function parseString(str) {
    if (str.startsWith('"')) {
      str = str.slice(1);
    }
    if (str.endsWith('"')) {
      str = str.slice(0, -1);
    }
    return str.replace(/(\\")|(\\\\)|(\\n)|(\\r)|(\\t)|(\\u[a-fA-F0-9]{5,6})|((?:\\u[a-fA-F0-9]{1,4})+)/ig, function(substring, ...groups) {
      const [quotes, backslash, newline2, carriageReturn, tab, codePoint, charCodes] = groups;
      if (quotes) {
        return '"';
      }
      if (newline2) {
        return "\n";
      }
      if (carriageReturn) {
        return "\r";
      }
      if (tab) {
        return "	";
      }
      if (backslash) {
        return "\\";
      }
      const escapePattern = /\\u([a-fA-F0-9]+)/ig;
      if (codePoint) {
        const codePointMatch = escapePattern.exec(codePoint);
        return String.fromCodePoint(parseInt(codePointMatch[1], 16));
      }
      if (charCodes) {
        const chars4 = [];
        let charCodeMatch;
        while ((charCodeMatch = escapePattern.exec(substring)) !== null) {
          chars4.push(parseInt(charCodeMatch[1], 16));
        }
        return String.fromCharCode(...chars4);
      }
      throw new Error("illegal match");
    });
  }
  function lintError(nodeRef) {
    const node = nodeRef.node;
    const parent = node.parent;
    if (node.from !== node.to) {
      return {
        from: node.from,
        to: node.to,
        message: `Unrecognized token in <${parent.name}>`
      };
    }
    const next = findNext(node);
    if (next) {
      return {
        from: node.from,
        to: next.to,
        message: `Unrecognized token <${next.name}> in <${parent.name}>`
      };
    } else {
      const unfinished = parent.enterUnfinishedNodesBefore(nodeRef.to);
      return {
        from: node.from,
        to: node.to,
        message: `Incomplete <${(unfinished || parent).name}>`
      };
    }
  }
  function findNext(nodeRef) {
    const node = nodeRef.node;
    let next, parent = node;
    do {
      next = parent.nextSibling;
      if (next) {
        return next;
      }
      parent = parent.parent;
    } while (parent);
    return null;
  }

  // node_modules/feelers/node_modules/feelin/dist/index.esm.js
  function isContext2(e3) {
    return Object.getPrototypeOf(e3) === Object.prototype;
  }
  function isDateTime2(obj) {
    return DateTime.isDateTime(obj);
  }
  function isDuration2(obj) {
    return Duration.isDuration(obj);
  }
  function isArray4(e3) {
    return Array.isArray(e3);
  }
  function isBoolean2(e3) {
    return typeof e3 === "boolean";
  }
  function getType2(e3) {
    if (e3 === null || e3 === void 0) {
      return "nil";
    }
    if (isBoolean2(e3)) {
      return "boolean";
    }
    if (isNumber4(e3)) {
      return "number";
    }
    if (isString4(e3)) {
      return "string";
    }
    if (isContext2(e3)) {
      return "context";
    }
    if (isArray4(e3)) {
      return "list";
    }
    if (isDuration2(e3)) {
      return "duration";
    }
    if (isDateTime2(e3)) {
      if (e3.year === 1900 && e3.month === 1 && e3.day === 1) {
        return "time";
      }
      if (e3.hour === 0 && e3.minute === 0 && e3.second === 0 && e3.millisecond === 0 && e3.zone === FixedOffsetZone.utcInstance) {
        return "date";
      }
      return "date time";
    }
    if (e3 instanceof Range3) {
      return "range";
    }
    if (e3 instanceof FunctionWrapper2) {
      return "function";
    }
    return "literal";
  }
  function isType2(el, type3) {
    return getType2(el) === type3;
  }
  function typeCast2(obj, type3) {
    if (isDateTime2(obj)) {
      if (type3 === "time") {
        return obj.set({
          year: 1900,
          month: 1,
          day: 1
        });
      }
      if (type3 === "date") {
        return obj.setZone("utc", { keepLocalTime: true }).startOf("day");
      }
      if (type3 === "date time") {
        return obj;
      }
    }
    return null;
  }
  var Range3 = class {
    constructor(props) {
      Object.assign(this, props);
    }
  };
  function isNumber4(obj) {
    return typeof obj === "number";
  }
  function isString4(obj) {
    return typeof obj === "string";
  }
  function equals2(a3, b2, strict = false) {
    if (a3 === null && b2 !== null || a3 !== null && b2 === null) {
      return false;
    }
    if (isArray4(a3) && a3.length < 2) {
      a3 = a3[0];
    }
    if (isArray4(b2) && b2.length < 2) {
      b2 = b2[0];
    }
    const aType = getType2(a3);
    const bType = getType2(b2);
    const temporalTypes = ["date time", "time", "date"];
    if (temporalTypes.includes(aType)) {
      if (!temporalTypes.includes(bType)) {
        return null;
      }
      if (aType === "time" && bType !== "time") {
        return null;
      }
      if (bType === "time" && aType !== "time") {
        return null;
      }
      if (strict || a3.zone === SystemZone.instance || b2.zone === SystemZone.instance) {
        return a3.equals(b2);
      } else {
        return a3.toUTC().valueOf() === b2.toUTC().valueOf();
      }
    }
    if (aType !== bType) {
      return null;
    }
    if (aType === "nil") {
      return true;
    }
    if (aType === "list") {
      if (a3.length !== b2.length) {
        return false;
      }
      return a3.every((element, idx) => equals2(element, b2[idx]));
    }
    if (aType === "duration") {
      if (Math.abs(a3.as("days")) > 180) {
        return Math.trunc(a3.minus(b2).as("months")) === 0;
      } else {
        return Math.trunc(a3.minus(b2).as("seconds")) === 0;
      }
    }
    if (aType === "context") {
      const aEntries = Object.entries(a3);
      const bEntries = Object.entries(b2);
      if (aEntries.length !== bEntries.length) {
        return false;
      }
      return aEntries.every(([key, value]) => key in b2 && equals2(value, b2[key]));
    }
    if (aType === "range") {
      return [
        [a3.start, b2.start],
        [a3.end, b2.end],
        [a3["start included"], b2["start included"]],
        [a3["end included"], b2["end included"]]
      ].every(([a4, b3]) => a4 === b3);
    }
    if (a3 == b2) {
      return true;
    }
    return aType === bType ? false : null;
  }
  var FunctionWrapper2 = class {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(fn4, parameterNames) {
      this.fn = fn4;
      this.parameterNames = parameterNames;
    }
    invoke(contextOrArgs) {
      let params;
      if (isArray4(contextOrArgs)) {
        params = contextOrArgs;
        if (params.length > this.parameterNames.length) {
          const lastParam = this.parameterNames[this.parameterNames.length - 1];
          if (!lastParam || !lastParam.startsWith("...")) {
            return null;
          }
        }
      } else {
        if (Object.keys(contextOrArgs).some((key) => !this.parameterNames.includes(key) && !this.parameterNames.includes(`...${key}`))) {
          return null;
        }
        params = this.parameterNames.reduce((params2, name2) => {
          if (name2.startsWith("...")) {
            name2 = name2.slice(3);
            const value = contextOrArgs[name2];
            if (!value) {
              return params2;
            } else {
              return [...params2, ...isArray4(value) ? value : [value]];
            }
          }
          return [...params2, contextOrArgs[name2]];
        }, []);
      }
      return this.fn.call(null, ...params);
    }
  };
  function parseParameterNames2(fn4) {
    if (Array.isArray(fn4.$args)) {
      return fn4.$args;
    }
    const code = fn4.toString();
    const match2 = /^(?:[^(]*\s*)?\(([^)]+)?\)/.exec(code);
    if (!match2) {
      throw new Error("failed to parse params: " + code);
    }
    const [_3, params] = match2;
    if (!params) {
      return [];
    }
    return params.split(",").map((p3) => p3.trim());
  }
  function notImplemented2(thing) {
    return new Error(`not implemented: ${thing}`);
  }
  function getFromContext2(name2, context) {
    if (["nil", "boolean", "number", "string"].includes(getType2(context))) {
      return void 0;
    }
    if (name2 in context) {
      return context[name2];
    }
    const normalizedName = normalizeContextKey(name2);
    if (normalizedName in context) {
      return context[normalizedName];
    }
    const entry = Object.entries(context).find(([key]) => normalizedName === normalizeContextKey(key));
    if (entry) {
      return entry[1];
    }
    return void 0;
  }
  function duration3(opts) {
    if (typeof opts === "number") {
      return Duration.fromMillis(opts);
    }
    return Duration.fromISO(opts);
  }
  function date2(str = null, time = null, zone = null) {
    if (time) {
      if (str) {
        throw new Error("<str> and <time> provided");
      }
      return date2(`1900-01-01T${time}`, null);
    }
    if (typeof str === "string") {
      if (str.startsWith("-")) {
        throw notImplemented2("negative date");
      }
      if (!str.includes("T")) {
        return date2(str + "T00:00:00", null, zone || FixedOffsetZone.utcInstance);
      }
      if (str.includes("@")) {
        if (zone) {
          throw new Error("<zone> already provided");
        }
        const [datePart, zonePart] = str.split("@");
        return date2(datePart, null, Info.normalizeZone(zonePart));
      }
      return DateTime.fromISO(str.toUpperCase(), {
        setZone: true,
        zone
      });
    }
    return DateTime.now();
  }
  var builtins2 = {
    // 10.3.4.1 Conversion functions
    "number": fn3(function(from, groupingSeparator, decimalSeparator) {
      if (arguments.length !== 3) {
        return null;
      }
      if (groupingSeparator) {
        from = from.split(groupingSeparator).join("");
      }
      if (decimalSeparator && decimalSeparator !== ".") {
        from = from.split(".").join("#").split(decimalSeparator).join(".");
      }
      const number2 = +from;
      if (isNaN(number2)) {
        return null;
      }
      return number2;
    }, ["string", "string?", "string?"], ["from", "grouping separator", "decimal separator"]),
    "string": fn3(function(from) {
      if (from === null) {
        return null;
      }
      return toString2(from);
    }, ["any"]),
    // date(from) => date string
    // date(from) => date and time
    // date(year, month, day)
    "date": fn3(function(year, month, day, from) {
      if (!from && !isNumber4(year)) {
        from = year;
        year = null;
      }
      let d3;
      if (isString4(from)) {
        d3 = date2(from);
      }
      if (isDateTime2(from)) {
        d3 = from;
      }
      if (year) {
        d3 = date2().setZone("utc").set({
          year,
          month,
          day
        });
      }
      return d3 && ifValid2(d3.setZone("utc").startOf("day")) || null;
    }, ["any?", "number?", "number?", "any?"]),
    // date and time(from) => date time string
    // date and time(date, time)
    "date and time": fn3(function(d3, time, from) {
      let dt;
      if (isDateTime2(d3) && isDateTime2(time)) {
        const dLocal = d3.toLocal();
        dt = time.set({
          year: dLocal.year,
          month: dLocal.month,
          day: dLocal.day
        });
      }
      if (isString4(d3)) {
        from = d3;
        d3 = null;
      }
      if (isString4(from)) {
        dt = date2(from, null, from.includes("@") ? null : SystemZone.instance);
      }
      return dt && ifValid2(dt) || null;
    }, ["any?", "time?", "string?"], ["date", "time", "from"]),
    // time(from) => time string
    // time(from) => time, date and time
    // time(hour, minute, second, offset?) => ...
    "time": fn3(function(hour, minute, second, offset2, from) {
      let t4;
      if (offset2) {
        throw notImplemented2("time(..., offset)");
      }
      if (isString4(hour) || isDateTime2(hour)) {
        from = hour;
        hour = null;
      }
      if (isString4(from)) {
        t4 = date2(null, from);
      }
      if (isDateTime2(from)) {
        t4 = from.set({
          year: 1900,
          month: 1,
          day: 1
        });
      }
      if (isNumber4(hour)) {
        t4 = date2().set({
          hour,
          minute,
          second
        }).set({
          year: 1900,
          month: 1,
          day: 1,
          millisecond: 0
        });
      }
      return t4 && ifValid2(t4) || null;
    }, ["any?", "number?", "number?", "any?", "any?"]),
    "duration": fn3(function(from) {
      return ifValid2(duration3(from));
    }, ["string"]),
    "years and months duration": fn3(function(from, to) {
      return ifValid2(to.diff(from, ["years", "months"]));
    }, ["date", "date"]),
    "@": fn3(function(string2) {
      let t4;
      if (/^-?P/.test(string2)) {
        t4 = duration3(string2);
      } else if (/^[\d]{1,2}:[\d]{1,2}:[\d]{1,2}/.test(string2)) {
        t4 = date2(null, string2);
      } else {
        t4 = date2(string2);
      }
      return t4 && ifValid2(t4) || null;
    }, ["string"]),
    "now": fn3(function() {
      return date2();
    }, []),
    "today": fn3(function() {
      return date2().startOf("day");
    }, []),
    // 10.3.4.2 Boolean function
    "not": fn3(function(bool) {
      return isType2(bool, "boolean") ? !bool : null;
    }, ["any"]),
    // 10.3.4.3 String functions
    "substring": fn3(function(string2, start, length) {
      const _start = start < 0 ? string2.length + start : start - 1;
      const arr = Array.from(string2);
      return (typeof length !== "undefined" ? arr.slice(_start, _start + length) : arr.slice(_start)).join("");
    }, ["string", "number", "number?"], ["string", "start position", "length"]),
    "string length": fn3(function(string2) {
      return countSymbols2(string2);
    }, ["string"]),
    "upper case": fn3(function(string2) {
      return string2.toUpperCase();
    }, ["string"]),
    "lower case": fn3(function(string2) {
      return string2.toLowerCase();
    }, ["string"]),
    "substring before": fn3(function(string2, match2) {
      const index2 = string2.indexOf(match2);
      if (index2 === -1) {
        return "";
      }
      return string2.substring(0, index2);
    }, ["string", "string"]),
    "substring after": fn3(function(string2, match2) {
      const index2 = string2.indexOf(match2);
      if (index2 === -1) {
        return "";
      }
      return string2.substring(index2 + match2.length);
    }, ["string", "string"]),
    "replace": fn3(function(input, pattern, replacement, flags) {
      return input.replace(new RegExp(pattern, "ug" + (flags || "").replace(/[x]/g, "")), replacement.replace(/\$0/g, "$$&"));
    }, ["string", "string", "string", "string?"]),
    "contains": fn3(function(string2, match2) {
      return string2.includes(match2);
    }, ["string", "string"]),
    // eslint-disable-next-line
    "matches": fn3(function(input, pattern, flags) {
      throw notImplemented2("matches");
    }, ["string", "string", "string?"]),
    "starts with": fn3(function(string2, match2) {
      return string2.startsWith(match2);
    }, ["string", "string"]),
    "ends with": fn3(function(string2, match2) {
      return string2.endsWith(match2);
    }, ["string", "string"]),
    "split": fn3(function(string2, delimiter) {
      return string2.split(new RegExp(delimiter, "u"));
    }, ["string", "string"]),
    "string join": fn3(function(list2, delimiter) {
      if (list2.some((e3) => !isString4(e3) && e3 !== null)) {
        return null;
      }
      return list2.filter((l4) => l4 !== null).join(delimiter || "");
    }, ["list", "string?"]),
    // 10.3.4.4 List functions
    "list contains": fn3(function(list2, element) {
      return list2.some((el) => matches2(el, element));
    }, ["list", "any?"]),
    // list replace(list, position, newItem)
    // list replace(list, match, newItem)
    "list replace": fn3(function(list2, position, newItem, match2) {
      const matcher = position || match2;
      if (!["number", "function"].includes(getType2(matcher))) {
        return null;
      }
      return listReplace2(list2, position || match2, newItem);
    }, ["list", "any?", "any", "function?"]),
    "count": fn3(function(list2) {
      return list2.length;
    }, ["list"]),
    "min": listFn2(function(...list2) {
      return list2.reduce((min, el) => min === null ? el : Math.min(min, el), null);
    }, "number"),
    "max": listFn2(function(...list2) {
      return list2.reduce((max, el) => max === null ? el : Math.max(max, el), null);
    }, "number"),
    "sum": listFn2(function(...list2) {
      return sum2(list2);
    }, "number"),
    "mean": listFn2(function(...list2) {
      const s4 = sum2(list2);
      return s4 === null ? s4 : s4 / list2.length;
    }, "number"),
    "all": listFn2(function(...list2) {
      let nonBool = false;
      for (const o3 of list2) {
        if (o3 === false) {
          return false;
        }
        if (typeof o3 !== "boolean") {
          nonBool = true;
        }
      }
      return nonBool ? null : true;
    }, "any?"),
    "any": listFn2(function(...list2) {
      let nonBool = false;
      for (const o3 of list2) {
        if (o3 === true) {
          return true;
        }
        if (typeof o3 !== "boolean") {
          nonBool = true;
        }
      }
      return nonBool ? null : false;
    }, "any?"),
    "sublist": fn3(function(list2, start, length) {
      const _start = start < 0 ? list2.length + start : start - 1;
      return typeof length !== "undefined" ? list2.slice(_start, _start + length) : list2.slice(_start);
    }, ["list", "number", "number?"]),
    "append": fn3(function(list2, ...items) {
      return list2.concat(items);
    }, ["list", "any?"]),
    "concatenate": fn3(function(...args) {
      return args.reduce((result, arg) => {
        return result.concat(arg);
      }, []);
    }, ["any"]),
    "insert before": fn3(function(list2, position, newItem) {
      return list2.slice(0, position - 1).concat([newItem], list2.slice(position - 1));
    }, ["list", "number", "any?"]),
    "remove": fn3(function(list2, position) {
      return list2.slice(0, position - 1).concat(list2.slice(position));
    }, ["list", "number"]),
    "reverse": fn3(function(list2) {
      return list2.slice().reverse();
    }, ["list"]),
    "index of": fn3(function(list2, match2) {
      return list2.reduce(function(result, element, index2) {
        if (matches2(element, match2)) {
          result.push(index2 + 1);
        }
        return result;
      }, []);
    }, ["list", "any"]),
    "union": listFn2(function(...lists) {
      return lists.reduce((result, list2) => {
        return list2.reduce((result2, e3) => {
          if (!result2.some((r3) => equals2(e3, r3))) {
            result2.push(e3);
          }
          return result2;
        }, result);
      }, []);
    }, "list"),
    "distinct values": fn3(function(list2) {
      return list2.reduce((result, e3) => {
        if (!result.some((r3) => equals2(e3, r3))) {
          result.push(e3);
        }
        return result;
      }, []);
    }, ["list"]),
    "flatten": fn3(function(list2) {
      return flatten2(list2);
    }, ["list"]),
    "product": listFn2(function(...list2) {
      if (list2.length === 0) {
        return null;
      }
      return list2.reduce((result, n3) => {
        return result * n3;
      }, 1);
    }, "number"),
    "median": listFn2(function(...list2) {
      if (list2.length === 0) {
        return null;
      }
      return median2(list2);
    }, "number"),
    "stddev": listFn2(function(...list2) {
      if (list2.length < 2) {
        return null;
      }
      return stddev2(list2);
    }, "number"),
    "mode": listFn2(function(...list2) {
      return mode2(list2);
    }, "number"),
    // 10.3.4.5 Numeric functions
    "decimal": fn3(function(n3, scale) {
      if (!scale) {
        return bankersRound2(n3);
      }
      const offset2 = Math.pow(10, scale);
      return bankersRound2(n3 * offset2) / offset2;
    }, ["number", "number"]),
    "floor": fn3(function(n3, scale = 0) {
      if (scale === null) {
        return null;
      }
      const adjust = Math.pow(10, scale);
      return Math.floor(n3 * adjust) / adjust;
    }, ["number", "number?"]),
    "ceiling": fn3(function(n3, scale = 0) {
      if (scale === null) {
        return null;
      }
      const adjust = Math.pow(10, scale);
      return Math.ceil(n3 * adjust) / adjust;
    }, ["number", "number?"]),
    "abs": fn3(function(n3) {
      if (typeof n3 !== "number") {
        return null;
      }
      return Math.abs(n3);
    }, ["number"]),
    // eslint-disable-next-line
    "round up": fn3(function(n3, scale) {
      throw notImplemented2("round up");
    }, ["number", "number"]),
    // eslint-disable-next-line
    "round down": fn3(function(n3, scale) {
      throw notImplemented2("round down");
    }, ["number", "number"]),
    // eslint-disable-next-line
    "round half up": fn3(function(n3, scale) {
      throw notImplemented2("round half up");
    }, ["number", "number"]),
    // eslint-disable-next-line
    "round half down": fn3(function(n3, scale) {
      throw notImplemented2("round half down");
    }, ["number", "number"]),
    "modulo": fn3(function(dividend, divisor) {
      if (!divisor) {
        return null;
      }
      const adjust = 1e9;
      return Math.round((dividend % divisor + divisor) % divisor * adjust) / adjust;
    }, ["number", "number"]),
    "sqrt": fn3(function(number2) {
      if (number2 < 0) {
        return null;
      }
      return Math.sqrt(number2);
    }, ["number"]),
    "log": fn3(function(number2) {
      if (number2 <= 0) {
        return null;
      }
      return Math.log(number2);
    }, ["number"]),
    "exp": fn3(function(number2) {
      return Math.exp(number2);
    }, ["number"]),
    "odd": fn3(function(number2) {
      return Math.abs(number2) % 2 === 1;
    }, ["number"]),
    "even": fn3(function(number2) {
      return Math.abs(number2) % 2 === 0;
    }, ["number"]),
    // 10.3.4.6 Date and time functions
    "is": fn3(function(value1, value2) {
      if (typeof value1 === "undefined" || typeof value2 === "undefined") {
        return false;
      }
      return equals2(value1, value2, true);
    }, ["any?", "any?"]),
    // 10.3.4.7 Range Functions
    "before": fn3(function(a3, b2) {
      return before2(a3, b2);
    }, ["any", "any"]),
    "after": fn3(function(a3, b2) {
      return before2(b2, a3);
    }, ["any", "any"]),
    "meets": fn3(function(a3, b2) {
      return meetsRange2(a3, b2);
    }, ["range", "range"]),
    "met by": fn3(function(a3, b2) {
      return meetsRange2(b2, a3);
    }, ["range", "range"]),
    "overlaps": fn3(function(range1, range2) {
      return !before2(range1, range2) && !before2(range2, range1);
    }, ["range", "range"]),
    "overlaps before": fn3(function() {
      throw notImplemented2("overlaps before");
    }, ["any?"]),
    "overlaps after": fn3(function() {
      throw notImplemented2("overlaps after");
    }, ["any?"]),
    "finishes": fn3(function() {
      throw notImplemented2("finishes");
    }, ["any?"]),
    "finished by": fn3(function() {
      throw notImplemented2("finished by");
    }, ["any?"]),
    "includes": fn3(function() {
      throw notImplemented2("includes");
    }, ["any?"]),
    "during": fn3(function() {
      throw notImplemented2("during");
    }, ["any?"]),
    "starts": fn3(function() {
      throw notImplemented2("starts");
    }, ["any?"]),
    "started by": fn3(function() {
      throw notImplemented2("started by");
    }, ["any?"]),
    "coincides": fn3(function() {
      throw notImplemented2("coincides");
    }, ["any?"]),
    // 10.3.4.8 Temporal built-in functions
    "day of year": fn3(function(date3) {
      return date3.ordinal;
    }, ["date time"]),
    "day of week": fn3(function(date3) {
      return date3.weekdayLong;
    }, ["date time"]),
    "month of year": fn3(function(date3) {
      return date3.monthLong;
    }, ["date time"]),
    "week of year": fn3(function(date3) {
      return date3.weekNumber;
    }, ["date time"]),
    // 10.3.4.9 Sort
    "sort": fn3(function(list2, precedes) {
      return Array.from(list2).sort((a3, b2) => precedes.invoke([a3, b2]) ? -1 : 1);
    }, ["list", "function"]),
    // 10.3.4.10 Context function
    "get value": fn3(function(m3, key) {
      const value = getFromContext2(key, m3);
      return value != void 0 ? value : null;
    }, ["context", "string"]),
    "get entries": fn3(function(m3) {
      if (arguments.length !== 1) {
        return null;
      }
      if (Array.isArray(m3)) {
        return null;
      }
      return Object.entries(m3).map(([key, value]) => ({ key, value }));
    }, ["context"]),
    "context": listFn2(function(...entries2) {
      const context = entries2.reduce((context2, entry) => {
        if (context2 === FALSE2 || !["key", "value"].every((e3) => e3 in entry)) {
          return FALSE2;
        }
        const key = entry.key;
        if (key === null) {
          return FALSE2;
        }
        if (key in context2) {
          return FALSE2;
        }
        return Object.assign(Object.assign({}, context2), { [entry.key]: entry.value });
      }, {});
      if (context === FALSE2) {
        return null;
      }
      return context;
    }, "context"),
    "context merge": listFn2(function(...contexts) {
      return Object.assign({}, ...contexts);
    }, "context"),
    "context put": fn3(function(context, keys, value, key) {
      if (typeof keys === "undefined" && typeof key === "undefined") {
        return null;
      }
      return contextPut2(context, keys || [key], value);
    }, ["context", "list?", "any", "string?"], ["context", "keys", "value", "key"])
  };
  function contextPut2(context, keys, value) {
    const [key, ...remainingKeys] = keys;
    if (getType2(key) !== "string") {
      return null;
    }
    if (getType2(context) === "nil") {
      return null;
    }
    if (remainingKeys.length) {
      value = contextPut2(context[key], remainingKeys, value);
      if (value === null) {
        return null;
      }
    }
    return Object.assign(Object.assign({}, context), { [key]: value });
  }
  function matches2(a3, b2) {
    return a3 === b2;
  }
  var FALSE2 = {};
  function createArgTester2(arg) {
    const optional = arg.endsWith("?");
    const type3 = optional ? arg.substring(0, arg.length - 1) : arg;
    return function(obj) {
      const arr = Array.isArray(obj);
      if (type3 === "list") {
        if (arr || optional && typeof obj === "undefined") {
          return obj;
        } else {
          return obj === null ? FALSE2 : [obj];
        }
      }
      if (type3 !== "any" && arr && obj.length === 1) {
        obj = obj[0];
      }
      const objType = getType2(obj);
      if (type3 === "any" || type3 === objType) {
        return optional ? obj : typeof obj !== "undefined" ? obj : FALSE2;
      }
      if (objType === "nil") {
        return optional ? obj : FALSE2;
      }
      return typeCast2(obj, type3) || FALSE2;
    };
  }
  function createArgsValidator2(argDefinitions) {
    const tests = argDefinitions.map(createArgTester2);
    return function(args) {
      while (args.length < argDefinitions.length) {
        args.push(void 0);
      }
      return args.reduce((result, arg, index2) => {
        if (result === false) {
          return result;
        }
        const test = tests[index2];
        const conversion = test ? test(arg) : arg;
        if (conversion === FALSE2) {
          return false;
        }
        result.push(conversion);
        return result;
      }, []);
    };
  }
  function listFn2(fnDefinition, type3, parameterNames = null) {
    const tester = createArgTester2(type3);
    const wrappedFn = function(...args) {
      if (args.length === 0) {
        return null;
      }
      if (Array.isArray(args[0]) && args.length === 1) {
        args = args[0];
      }
      if (!args.every((arg) => tester(arg) !== FALSE2)) {
        return null;
      }
      return fnDefinition(...args);
    };
    wrappedFn.$args = parameterNames || parseParameterNames2(fnDefinition);
    return wrappedFn;
  }
  function fn3(fnDefinition, argDefinitions, parameterNames = null) {
    const checkArgs = createArgsValidator2(argDefinitions);
    parameterNames = parameterNames || parseParameterNames2(fnDefinition);
    const wrappedFn = function(...args) {
      const convertedArgs = checkArgs(args);
      if (!convertedArgs) {
        return null;
      }
      return fnDefinition(...convertedArgs);
    };
    wrappedFn.$args = parameterNames;
    return wrappedFn;
  }
  function meetsRange2(a3, b2) {
    return [
      a3.end === b2.start,
      a3["end included"] === true,
      b2["start included"] === true
    ].every((v4) => v4);
  }
  function before2(a3, b2) {
    if (a3 instanceof Range3 && b2 instanceof Range3) {
      return a3.end < b2.start || (!a3["end included"] || !b2["start included"]) && a3.end == b2.start;
    }
    if (a3 instanceof Range3) {
      return a3.end < b2 || !a3["end included"] && a3.end === b2;
    }
    if (b2 instanceof Range3) {
      return b2.start > a3 || !b2["start included"] && b2.start === a3;
    }
    return a3 < b2;
  }
  function sum2(list2) {
    return list2.reduce((sum3, el) => sum3 === null ? el : sum3 + el, null);
  }
  function flatten2([x3, ...xs]) {
    return x3 !== void 0 ? [...Array.isArray(x3) ? flatten2(x3) : [x3], ...flatten2(xs)] : [];
  }
  function toKeyString2(key) {
    if (typeof key === "string" && /\W/.test(key)) {
      return toString2(key, true);
    }
    return key;
  }
  function toDeepString2(obj) {
    return toString2(obj, true);
  }
  function escapeStr2(str) {
    return str.replace(/("|\\)/g, "\\$1");
  }
  function toString2(obj, wrap2 = false) {
    var _a2, _b, _c, _d;
    const type3 = getType2(obj);
    if (type3 === "nil") {
      return "null";
    }
    if (type3 === "string") {
      return wrap2 ? `"${escapeStr2(obj)}"` : obj;
    }
    if (type3 === "boolean" || type3 === "number") {
      return String(obj);
    }
    if (type3 === "list") {
      return "[" + obj.map(toDeepString2).join(", ") + "]";
    }
    if (type3 === "context") {
      return "{" + Object.entries(obj).map(([key, value]) => {
        return toKeyString2(key) + ": " + toDeepString2(value);
      }).join(", ") + "}";
    }
    if (type3 === "duration") {
      return obj.shiftTo("years", "months", "days", "hours", "minutes", "seconds").normalize().toISO();
    }
    if (type3 === "date time") {
      if (obj.zone === SystemZone.instance) {
        return obj.toISO({ suppressMilliseconds: true, includeOffset: false });
      }
      if ((_a2 = obj.zone) === null || _a2 === void 0 ? void 0 : _a2.zoneName) {
        return obj.toISO({ suppressMilliseconds: true, includeOffset: false }) + "@" + ((_b = obj.zone) === null || _b === void 0 ? void 0 : _b.zoneName);
      }
      return obj.toISO({ suppressMilliseconds: true });
    }
    if (type3 === "date") {
      return obj.toISODate();
    }
    if (type3 === "range") {
      return "<range>";
    }
    if (type3 === "time") {
      if (obj.zone === SystemZone.instance) {
        return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false });
      }
      if ((_c = obj.zone) === null || _c === void 0 ? void 0 : _c.zoneName) {
        return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false }) + "@" + ((_d = obj.zone) === null || _d === void 0 ? void 0 : _d.zoneName);
      }
      return obj.toISOTime({ suppressMilliseconds: true });
    }
    if (type3 === "function") {
      return "<function>";
    }
    throw notImplemented2("string(" + type3 + ")");
  }
  function countSymbols2(str) {
    return str.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
  }
  function bankersRound2(n3) {
    const floored = Math.floor(n3);
    const decimalPart = n3 - floored;
    if (decimalPart === 0.5) {
      return floored % 2 === 0 ? floored : floored + 1;
    }
    return Math.round(n3);
  }
  function stddev2(array) {
    const n3 = array.length;
    const mean = array.reduce((a3, b2) => a3 + b2) / n3;
    return Math.sqrt(array.map((x3) => Math.pow(x3 - mean, 2)).reduce((a3, b2) => a3 + b2) / (n3 - 1));
  }
  function listReplace2(list2, matcher, newItem) {
    if (isNumber4(matcher)) {
      return [...list2.slice(0, matcher - 1), newItem, ...list2.slice(matcher)];
    }
    return list2.map((item, _idx) => {
      if (matcher.invoke([item, newItem])) {
        return newItem;
      } else {
        return item;
      }
    });
  }
  function median2(array) {
    const n3 = array.length;
    const sorted = array.slice().sort();
    const mid = n3 / 2 - 1;
    const index2 = Math.ceil(mid);
    if (mid === index2) {
      return (sorted[index2] + sorted[index2 + 1]) / 2;
    }
    return sorted[index2];
  }
  function mode2(array) {
    if (array.length < 2) {
      return array;
    }
    const buckets = {};
    for (const n3 of array) {
      buckets[n3] = (buckets[n3] || 0) + 1;
    }
    const sorted = Object.entries(buckets).sort((a3, b2) => b2[1] - a3[1]);
    return sorted.filter((s4) => s4[1] === sorted[0][1]).map((e3) => +e3[0]);
  }
  function ifValid2(o3) {
    return o3.isValid ? o3 : null;
  }
  function parseExpression2(expression, context = {}, dialect) {
    return parser.configure({
      top: "Expression",
      contextTracker: trackVariables(context),
      dialect
    }).parse(expression);
  }
  function parseUnaryTests2(expression, context = {}, dialect) {
    return parser.configure({
      top: "UnaryTests",
      contextTracker: trackVariables(context),
      dialect
    }).parse(expression);
  }
  var SyntaxError3 = class extends Error {
    constructor(message, details) {
      super(message);
      Object.assign(this, details);
    }
  };
  var Interpreter2 = class {
    _buildExecutionTree(tree, input) {
      const root = { args: [], nodeInput: input };
      const stack = [root];
      tree.iterate({
        enter(nodeRef) {
          const { isError, isSkipped } = nodeRef.type;
          const { from, to } = nodeRef;
          if (isError) {
            const { from: from2, to: to2, message } = lintError2(nodeRef);
            throw new SyntaxError3(message, {
              input: input.slice(from2, to2),
              position: {
                from: from2,
                to: to2
              }
            });
          }
          if (isSkipped) {
            return false;
          }
          const nodeInput = input.slice(from, to);
          stack.push({
            nodeInput,
            args: []
          });
        },
        leave(nodeRef) {
          if (nodeRef.type.isSkipped) {
            return;
          }
          const { nodeInput, args } = stack.pop();
          const parent = stack[stack.length - 1];
          const expr = evalNode2(nodeRef, nodeInput, args);
          parent.args.push(expr);
        }
      });
      return root.args[root.args.length - 1];
    }
    evaluate(expression, context = {}, dialect) {
      const parseTree = parseExpression2(expression, context, dialect);
      const root = this._buildExecutionTree(parseTree, expression);
      return {
        parseTree,
        root
      };
    }
    unaryTest(expression, context = {}, dialect) {
      const parseTree = parseUnaryTests2(expression, context, dialect);
      const root = this._buildExecutionTree(parseTree, expression);
      return {
        parseTree,
        root
      };
    }
  };
  var interpreter2 = new Interpreter2();
  function evaluate2(expression, context = {}, dialect) {
    const { root } = interpreter2.evaluate(expression, context, dialect);
    return root(context);
  }
  function evalNode2(node, input, args) {
    switch (node.name) {
      case "ArithOp":
        return (context) => {
          const nullable = (op, types2 = ["number"]) => (a3, b2) => {
            const left = a3(context);
            const right = b2(context);
            if (isArray4(left)) {
              return null;
            }
            if (isArray4(right)) {
              return null;
            }
            const leftType = getType2(left);
            const rightType = getType2(right);
            const temporal = ["date", "time", "date time", "duration"];
            if (temporal.includes(leftType)) {
              if (!temporal.includes(rightType)) {
                return null;
              }
            } else if (leftType !== rightType || !types2.includes(leftType)) {
              return null;
            }
            return op(left, right);
          };
          switch (input) {
            case "+":
              return nullable((a3, b2) => {
                if (isDuration2(a3) && !isDuration2(b2)) {
                  const tmp = a3;
                  a3 = b2;
                  b2 = tmp;
                }
                if (isType2(a3, "time") && isDuration2(b2)) {
                  return a3.plus(b2).set({
                    year: 1900,
                    month: 1,
                    day: 1
                  });
                } else if (isDateTime2(a3) && isDateTime2(b2)) {
                  return null;
                } else if (isDateTime2(a3) && isDuration2(b2)) {
                  return a3.plus(b2);
                } else if (isDuration2(a3) && isDuration2(b2)) {
                  return a3.plus(b2);
                }
                return a3 + b2;
              }, ["string", "number", "date", "time", "duration", "date time"]);
            case "-":
              return nullable((a3, b2) => {
                if (isType2(a3, "time") && isDuration2(b2)) {
                  return a3.minus(b2).set({
                    year: 1900,
                    month: 1,
                    day: 1
                  });
                } else if (isDateTime2(a3) && isDateTime2(b2)) {
                  return a3.diff(b2);
                } else if (isDateTime2(a3) && isDuration2(b2)) {
                  return a3.minus(b2);
                } else if (isDuration2(a3) && isDuration2(b2)) {
                  return a3.minus(b2);
                }
                return a3 - b2;
              }, ["number", "date", "time", "duration", "date time"]);
            case "*":
              return nullable((a3, b2) => a3 * b2);
            case "/":
              return nullable((a3, b2) => !b2 ? null : a3 / b2);
            case "**":
            case "^":
              return nullable((a3, b2) => Math.pow(a3, b2));
          }
        };
      case "CompareOp":
        return tag2(() => {
          switch (input) {
            case ">":
              return (b2) => createRange2(b2, null, false, false);
            case ">=":
              return (b2) => createRange2(b2, null, true, false);
            case "<":
              return (b2) => createRange2(null, b2, false, false);
            case "<=":
              return (b2) => createRange2(null, b2, false, true);
            case "=":
              return (b2) => (a3) => equals2(a3, b2);
            case "!=":
              return (b2) => (a3) => !equals2(a3, b2);
          }
        }, Test2("boolean"));
      case "BacktickIdentifier":
        return input.replace(/`/g, "");
      case "Wildcard":
        return (_context) => true;
      case "null":
        return (_context) => {
          return null;
        };
      case "Disjunction":
        return tag2((context) => {
          const left = args[0](context);
          const right = args[2](context);
          const matrix = [
            [true, true, true],
            [true, false, true],
            [true, null, true],
            [false, true, true],
            [false, false, false],
            [false, null, null],
            [null, true, true],
            [null, false, null],
            [null, null, null]
          ];
          const a3 = typeof left === "boolean" ? left : null;
          const b2 = typeof right === "boolean" ? right : null;
          return matrix.find((el) => el[0] === a3 && el[1] === b2)[2];
        }, Test2("boolean"));
      case "Conjunction":
        return tag2((context) => {
          const left = args[0](context);
          const right = args[2](context);
          const matrix = [
            [true, true, true],
            [true, false, false],
            [true, null, null],
            [false, true, false],
            [false, false, false],
            [false, null, false],
            [null, true, null],
            [null, false, false],
            [null, null, null]
          ];
          const a3 = typeof left === "boolean" ? left : null;
          const b2 = typeof right === "boolean" ? right : null;
          return matrix.find((el) => el[0] === a3 && el[1] === b2)[2];
        }, Test2("boolean"));
      case "Context":
        return (context) => {
          return args.slice(1, -1).reduce((obj, arg) => {
            const [key, value] = arg(Object.assign(Object.assign({}, context), obj));
            return Object.assign(Object.assign({}, obj), { [key]: value });
          }, {});
        };
      case "FunctionBody":
        return args[0];
      case "FormalParameters":
        return args;
      case "FormalParameter":
        return args[0];
      case "ParameterName":
        return args.join(" ");
      case "FunctionDefinition":
        return (context) => {
          const parameterNames = args[2];
          const fnBody = args[4];
          return wrapFunction2((...args2) => {
            const fnContext = parameterNames.reduce((context2, name2, idx) => {
              context2[name2] = args2[idx];
              return context2;
            }, Object.assign({}, context));
            return fnBody(fnContext);
          }, parameterNames);
        };
      case "ContextEntry":
        return (context) => {
          const key = typeof args[0] === "function" ? args[0](context) : args[0];
          const value = args[1](context);
          return [key, value];
        };
      case "Key":
        return args[0];
      case "Identifier":
        return input;
      case "SpecialFunctionName":
        return (context) => getBuiltin2(input);
      // preserve spaces in name, but compact multiple
      // spaces into one (token)
      case "Name":
        return input.replace(/\s{2,}/g, " ");
      case "VariableName":
        return (context) => {
          const name2 = args.join(" ");
          const contextValue = getFromContext2(name2, context);
          return typeof contextValue !== "undefined" ? contextValue : getBuiltin2(name2) || null;
        };
      case "QualifiedName":
        return (context) => {
          return args.reduce((context2, arg) => arg(context2), context);
        };
      case "?":
        return (context) => getFromContext2("?", context);
      // expression
      // expression ".." expression
      case "IterationContext":
        return (context) => {
          const a3 = args[0](context);
          const b2 = args[1] && args[1](context);
          return b2 ? createRange2(a3, b2) : a3;
        };
      case "Type":
        return args[0];
      case "InExpressions":
        return (context) => {
          const iterationContexts = args.map((ctx) => ctx(context));
          if (iterationContexts.some((ctx) => getType2(ctx) !== "list")) {
            return null;
          }
          return cartesianProduct(iterationContexts).map((ctx) => {
            if (!isArray4(ctx)) {
              ctx = [ctx];
            }
            return Object.assign({}, context, ...ctx);
          });
        };
      // Name kw<"in"> Expr
      case "InExpression":
        return (context) => {
          return extractValue2(context, args[0], args[2]);
        };
      case "SpecialType":
        throw notImplemented2("SpecialType");
      case "InstanceOfExpression":
        return tag2((context) => {
          const a3 = args[0](context);
          const b2 = args[3](context);
          return a3 instanceof b2;
        }, Test2("boolean"));
      case "every":
        return tag2((context) => {
          return (_contexts, _condition) => {
            const contexts = _contexts(context);
            if (getType2(contexts) !== "list") {
              return contexts;
            }
            return contexts.every((ctx) => isTruthy2(_condition(ctx)));
          };
        }, Test2("boolean"));
      case "some":
        return tag2((context) => {
          return (_contexts, _condition) => {
            const contexts = _contexts(context);
            if (getType2(contexts) !== "list") {
              return contexts;
            }
            return contexts.some((ctx) => isTruthy2(_condition(ctx)));
          };
        }, Test2("boolean"));
      case "NumericLiteral":
        return tag2((_context) => input.includes(".") ? parseFloat(input) : parseInt(input), "number");
      case "BooleanLiteral":
        return tag2((_context) => input === "true" ? true : false, "boolean");
      case "StringLiteral":
        return tag2((_context) => parseString2(input), "string");
      case "PositionalParameters":
        return (context) => args.map((arg) => arg(context));
      case "NamedParameter":
        return (context) => {
          const name2 = args[0];
          const value = args[1](context);
          return [name2, value];
        };
      case "NamedParameters":
        return (context) => args.reduce((args2, arg) => {
          const [name2, value] = arg(context);
          args2[name2] = value;
          return args2;
        }, {});
      case "DateTimeConstructor":
        return (context) => {
          return getBuiltin2(input);
        };
      case "DateTimeLiteral":
        return (context) => {
          if (args.length === 1) {
            return args[0](context);
          } else {
            const wrappedFn = wrapFunction2(args[0](context));
            if (!wrappedFn) {
              return null;
            }
            const contextOrArgs = args[2](context);
            return wrappedFn.invoke(contextOrArgs);
          }
        };
      case "AtLiteral":
        return (context) => {
          const wrappedFn = wrapFunction2(getBuiltin2("@"));
          if (!wrappedFn) {
            return null;
          }
          return wrappedFn.invoke([args[0](context)]);
        };
      case "FunctionInvocation":
        return (context) => {
          const wrappedFn = wrapFunction2(args[0](context));
          if (!wrappedFn) {
            return null;
          }
          const contextOrArgs = args[2](context);
          return wrappedFn.invoke(contextOrArgs);
        };
      case "IfExpression":
        return function() {
          const ifCondition = args[1];
          const thenValue = args[3];
          const elseValue = args[5];
          const type3 = coalecenseTypes2(thenValue, elseValue);
          return tag2((context) => {
            if (isTruthy2(ifCondition(context))) {
              return thenValue(context);
            } else {
              return elseValue ? elseValue(context) : null;
            }
          }, type3);
        }();
      case "Parameters":
        return args.length === 3 ? args[1] : (_context) => [];
      case "Comparison":
        return (context) => {
          const operator2 = args[1];
          if (operator2 === "in") {
            return compareIn2(args[0](context), (args[3] || args[2])(context));
          }
          if (operator2 === "between") {
            const start = args[2](context);
            const end = args[4](context);
            if (start === null || end === null) {
              return null;
            }
            return createRange2(start, end).includes(args[0](context));
          }
          const left = args[0](context);
          const right = args[2](context);
          const test = operator2()(right);
          return compareValue2(test, left);
        };
      case "QuantifiedExpression":
        return (context) => {
          const testFn = args[0](context);
          const contexts = args[1];
          const condition = args[3];
          return testFn(contexts, condition);
        };
      // DMN 1.2 - 10.3.2.14
      // kw<"for"> commaSep1<InExpression<IterationContext>> kw<"return"> expression
      case "ForExpression":
        return (context) => {
          const extractor = args[args.length - 1];
          const iterationContexts = args[1](context);
          if (getType2(iterationContexts) !== "list") {
            return iterationContexts;
          }
          const partial = [];
          for (const ctx of iterationContexts) {
            partial.push(extractor(Object.assign(Object.assign({}, ctx), { partial })));
          }
          return partial;
        };
      case "ArithmeticExpression":
        return function() {
          if (args.length === 3) {
            const [a3, op, b2] = args;
            return tag2((context) => {
              return op(context)(a3, b2);
            }, coalecenseTypes2(a3, b2));
          }
          if (args.length === 2) {
            const [op, value] = args;
            return tag2((context) => {
              return op(context)(() => 0, value);
            }, value.type);
          }
        }();
      case "PositiveUnaryTest":
        return args[0];
      case "ParenthesizedExpression":
        return args[1];
      case "PathExpression":
        return (context) => {
          const pathTarget = args[0](context);
          const pathProp = args[1];
          if (isArray4(pathTarget)) {
            return pathTarget.map(pathProp);
          } else {
            return pathProp(pathTarget);
          }
        };
      // expression !filter "[" expression "]"
      case "FilterExpression":
        return (context) => {
          const target = args[0](context);
          const filterFn = args[2];
          const filterTarget = isArray4(target) ? target : [target];
          if (target === null) {
            return null;
          }
          if (typeof filterFn.type === "undefined") {
            try {
              const value = filterFn(context);
              if (isNumber4(value)) {
                filterFn.type = "number";
              }
            } catch (_err) {
            }
          }
          if (filterFn.type === "number") {
            const idx = filterFn(context);
            const value = filterTarget[idx < 0 ? filterTarget.length + idx : idx - 1];
            if (typeof value === "undefined") {
              return null;
            } else {
              return value;
            }
          }
          if (filterFn.type === "boolean") {
            if (filterFn(context)) {
              return filterTarget;
            } else {
              return [];
            }
          }
          if (filterFn.type === "string") {
            const value = filterFn(context);
            return filterTarget.filter((el) => el === value);
          }
          return filterTarget.map((el) => {
            const iterationContext = Object.assign(Object.assign(Object.assign({}, context), { item: el }), el);
            let result = filterFn(iterationContext);
            if (typeof result === "function") {
              result = result(el);
            }
            if (result instanceof Range3) {
              result = result.includes(el);
            }
            if (result === true) {
              return el;
            }
            return result;
          }).filter(isTruthy2);
        };
      case "SimplePositiveUnaryTest":
        return tag2((context) => {
          if (args.length === 1) {
            return args[0](context);
          }
          return args[0](context)(args[1](context));
        }, "test");
      case "List":
        return (context) => {
          return args.slice(1, -1).map((arg) => arg(context));
        };
      case "Interval":
        return tag2((context) => {
          const left = args[1](context);
          const right = args[2](context);
          const startIncluded = left !== null && args[0] === "[";
          const endIncluded = right !== null && args[3] === "]";
          return createRange2(left, right, startIncluded, endIncluded);
        }, Test2("boolean"));
      case "PositiveUnaryTests":
      case "Expressions":
        return (context) => {
          return args.map((a3) => a3(context));
        };
      case "Expression":
        return (context) => {
          return args[0](context);
        };
      case "UnaryTests":
        return (context) => {
          return (value = null) => {
            const negate = args[0] === "not";
            const tests = negate ? args.slice(2, -1) : args;
            const matches4 = tests.map((test) => test(context)).flat(1).map((test) => {
              if (isArray4(test)) {
                return test.includes(value);
              }
              if (test === null) {
                return null;
              }
              if (typeof test === "boolean") {
                return test;
              }
              return compareValue2(test, value);
            }).reduce(combineResult2, void 0);
            return matches4 === null ? null : negate ? !matches4 : matches4;
          };
        };
      default:
        return node.name;
    }
  }
  function getBuiltin2(name2, _context) {
    return getFromContext2(name2, builtins2);
  }
  function extractValue2(context, prop, _target) {
    const target = _target(context);
    if (["list", "range"].includes(getType2(target))) {
      return target.map((t4) => ({ [prop]: t4 }));
    }
    return null;
  }
  function compareIn2(value, tests) {
    if (!isArray4(tests)) {
      if (getType2(tests) === "nil") {
        return null;
      }
      tests = [tests];
    }
    return tests.some((test) => compareValue2(test, value));
  }
  function compareValue2(test, value) {
    if (typeof test === "function") {
      return test(value);
    }
    if (test instanceof Range3) {
      return test.includes(value);
    }
    return equals2(test, value);
  }
  var chars3 = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
  function isTyped2(type3, values2) {
    return values2.some((e3) => getType2(e3) === type3) && values2.every((e3) => e3 === null || getType2(e3) === type3);
  }
  var nullRange2 = new Range3({
    start: null,
    end: null,
    "start included": false,
    "end included": false,
    map() {
      return [];
    },
    includes() {
      return null;
    }
  });
  function createRange2(start, end, startIncluded = true, endIncluded = true) {
    if (isTyped2("string", [start, end])) {
      return createStringRange2(start, end, startIncluded, endIncluded);
    }
    if (isTyped2("number", [start, end])) {
      return createNumberRange2(start, end, startIncluded, endIncluded);
    }
    if (isTyped2("duration", [start, end])) {
      return createDurationRange2(start, end, startIncluded, endIncluded);
    }
    if (isTyped2("time", [start, end])) {
      return createDateTimeRange2(start, end, startIncluded, endIncluded);
    }
    if (isTyped2("date time", [start, end])) {
      return createDateTimeRange2(start, end, startIncluded, endIncluded);
    }
    if (isTyped2("date", [start, end])) {
      return createDateTimeRange2(start, end, startIncluded, endIncluded);
    }
    if (start === null && end === null) {
      return nullRange2;
    }
    throw new Error(`unsupported range: ${start}..${end}`);
  }
  function noopMap2() {
    return () => {
      throw new Error("unsupported range operation: map");
    };
  }
  function valuesMap2(values2) {
    return (fn4) => values2.map(fn4);
  }
  function valuesIncludes2(values2) {
    return (value) => values2.includes(value);
  }
  function numberMap2(start, end, startIncluded, endIncluded) {
    const direction = start > end ? -1 : 1;
    return (fn4) => {
      const result = [];
      for (let i4 = start; ; i4 += direction) {
        if (i4 === 0 && !startIncluded) {
          continue;
        }
        if (i4 === end && !endIncluded) {
          break;
        }
        result.push(fn4(i4));
        if (i4 === end) {
          break;
        }
      }
      return result;
    };
  }
  function includesStart2(n3, inclusive) {
    if (inclusive) {
      return (value) => n3 <= value;
    } else {
      return (value) => n3 < value;
    }
  }
  function includesEnd2(n3, inclusive) {
    if (inclusive) {
      return (value) => n3 >= value;
    } else {
      return (value) => n3 > value;
    }
  }
  function anyIncludes2(start, end, startIncluded, endIncluded, conversion = (v4) => v4) {
    let tests = [];
    if (start === null && end === null) {
      return () => null;
    }
    if (start !== null && end !== null) {
      if (start > end) {
        tests = [
          includesStart2(end, endIncluded),
          includesEnd2(start, startIncluded)
        ];
      } else {
        tests = [
          includesStart2(start, startIncluded),
          includesEnd2(end, endIncluded)
        ];
      }
    } else if (end !== null) {
      tests = [
        includesEnd2(end, endIncluded)
      ];
    } else if (start !== null) {
      tests = [
        includesStart2(start, startIncluded)
      ];
    }
    return (value) => value === null ? null : tests.every((t4) => t4(conversion(value)));
  }
  function createStringRange2(start, end, startIncluded = true, endIncluded = true) {
    if (start !== null && !chars3.includes(start)) {
      throw new Error("illegal range start: " + start);
    }
    if (end !== null && !chars3.includes(end)) {
      throw new Error("illegal range end: " + end);
    }
    let values2;
    if (start !== null && end !== null) {
      let startIdx = chars3.indexOf(start);
      let endIdx = chars3.indexOf(end);
      const direction = startIdx > endIdx ? -1 : 1;
      if (startIncluded === false) {
        startIdx += direction;
      }
      if (endIncluded === false) {
        endIdx -= direction;
      }
      values2 = chars3.slice(startIdx, endIdx + 1);
    }
    const map3 = values2 ? valuesMap2(values2) : noopMap2();
    const includes = values2 ? valuesIncludes2(values2) : anyIncludes2(start, end, startIncluded, endIncluded);
    return new Range3({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function createNumberRange2(start, end, startIncluded, endIncluded) {
    const map3 = start !== null && end !== null ? numberMap2(start, end, startIncluded, endIncluded) : noopMap2();
    const includes = anyIncludes2(start, end, startIncluded, endIncluded);
    return new Range3({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function createDurationRange2(start, end, startIncluded, endIncluded) {
    const toMillis = (d3) => d3 ? Duration.fromDurationLike(d3).toMillis() : null;
    const map3 = noopMap2();
    const includes = anyIncludes2(toMillis(start), toMillis(end), startIncluded, endIncluded, toMillis);
    return new Range3({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function createDateTimeRange2(start, end, startIncluded, endIncluded) {
    const map3 = noopMap2();
    const includes = anyIncludes2(start, end, startIncluded, endIncluded);
    return new Range3({
      start,
      end,
      "start included": startIncluded,
      "end included": endIncluded,
      map: map3,
      includes
    });
  }
  function cartesianProduct(arrays) {
    if (arrays.some((arr) => getType2(arr) === "nil")) {
      return null;
    }
    const f4 = (a3, b2) => [].concat(...a3.map((d3) => b2.map((e3) => [].concat(d3, e3))));
    const cartesian = (a3, b2, ...c3) => b2 ? cartesian(f4(a3, b2), ...c3) : a3 || [];
    return cartesian(...arrays);
  }
  function coalecenseTypes2(a3, b2) {
    if (!b2) {
      return a3.type;
    }
    if (a3.type === b2.type) {
      return a3.type;
    }
    return "any";
  }
  function tag2(fn4, type3) {
    return Object.assign(fn4, {
      type: type3,
      toString() {
        return `TaggedFunction[${type3}] ${Function.prototype.toString.call(fn4)}`;
      }
    });
  }
  function combineResult2(result, match2) {
    if (!result) {
      return match2;
    }
    return result;
  }
  function isTruthy2(obj) {
    return obj !== false && obj !== null;
  }
  function Test2(type3) {
    return `Test<${type3}>`;
  }
  function wrapFunction2(fn4, parameterNames = null) {
    if (!fn4) {
      return null;
    }
    if (fn4 instanceof FunctionWrapper2) {
      return fn4;
    }
    if (fn4 instanceof Range3) {
      return new FunctionWrapper2((value) => fn4.includes(value), ["value"]);
    }
    if (typeof fn4 !== "function") {
      return null;
    }
    return new FunctionWrapper2(fn4, parameterNames || parseParameterNames2(fn4));
  }
  function parseString2(str) {
    if (str.startsWith('"')) {
      str = str.slice(1);
    }
    if (str.endsWith('"')) {
      str = str.slice(0, -1);
    }
    return str.replace(/(\\")|(\\\\)|(\\u[a-fA-F0-9]{5,6})|((?:\\u[a-fA-F0-9]{1,4})+)/ig, function(substring, ...groups) {
      const [quotes, escape2, codePoint, charCodes] = groups;
      if (quotes) {
        return '"';
      }
      if (escape2) {
        return "\\";
      }
      const escapePattern = /\\u([a-fA-F0-9]+)/ig;
      if (codePoint) {
        const codePointMatch = escapePattern.exec(codePoint);
        return String.fromCodePoint(parseInt(codePointMatch[1], 16));
      }
      if (charCodes) {
        const chars4 = [];
        let charCodeMatch;
        while ((charCodeMatch = escapePattern.exec(substring)) !== null) {
          chars4.push(parseInt(charCodeMatch[1], 16));
        }
        return String.fromCharCode(...chars4);
      }
      throw new Error("illegal match");
    });
  }
  function lintError2(nodeRef) {
    const node = nodeRef.node;
    const parent = node.parent;
    if (node.from !== node.to) {
      return {
        from: node.from,
        to: node.to,
        message: `Unrecognized token in <${parent.name}>`
      };
    }
    const next = findNext2(node);
    if (next) {
      return {
        from: node.from,
        to: next.to,
        message: `Unrecognized token <${next.name}> in <${parent.name}>`
      };
    } else {
      const unfinished = parent.enterUnfinishedNodesBefore(nodeRef.to);
      return {
        from: node.from,
        to: node.to,
        message: `Incomplete <${(unfinished || parent).name}>`
      };
    }
  }
  function findNext2(nodeRef) {
    const node = nodeRef.node;
    let next, parent = node;
    do {
      next = parent.nextSibling;
      if (next) {
        return next;
      }
      parent = parent.parent;
    } while (parent);
    return null;
  }

  // node_modules/@marijn/find-cluster-break/src/index.js
  var rangeFrom = [];
  var rangeTo = [];
  (() => {
    let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s4) => s4 ? parseInt(s4, 36) : 1);
    for (let i4 = 0, n3 = 0; i4 < numbers.length; i4++)
      (i4 % 2 ? rangeTo : rangeFrom).push(n3 = n3 + numbers[i4]);
  })();
  function isExtendingChar(code) {
    if (code < 768) return false;
    for (let from = 0, to = rangeFrom.length; ; ) {
      let mid = from + to >> 1;
      if (code < rangeFrom[mid]) to = mid;
      else if (code >= rangeTo[mid]) from = mid + 1;
      else return true;
      if (from == to) return false;
    }
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length) return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i4 = pos - 2;
        while (i4 >= 0 && isRegionalIndicator(codePointAt(str, i4))) {
          countBefore++;
          i4 -= 2;
        }
        if (countBefore % 2 == 0) break;
        else pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos) return found;
      pos--;
    }
    return 0;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1)) return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }

  // node_modules/@codemirror/state/dist/index.js
  var Text = class _Text {
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n3) {
      if (n3 < 1 || n3 > this.lines)
        throw new RangeError(`Invalid line number ${n3} in ${this.lines}-line document`);
      return this.lineInner(n3, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from, to, text2) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(
        0,
        from,
        parts,
        2
        /* Open.To */
      );
      if (text2.length)
        text2.decompose(
          0,
          text2.length,
          parts,
          1 | 2
          /* Open.To */
        );
      this.decompose(
        to,
        this.length,
        parts,
        1
        /* Open.From */
      );
      return TextNode.from(parts, this.length - (to - from) + text2.length);
    }
    /**
    Append another document to this one.
    */
    append(other2) {
      return this.replace(this.length, this.length, other2);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from, to = this.length) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other2) {
      if (other2 == this)
        return true;
      if (other2.length != this.length || other2.lines != this.lines)
        return false;
      let start = this.scanIdentical(other2, 1), end = this.length - this.scanIdentical(other2, -1);
      let a3 = new RawTextCursor(this), b2 = new RawTextCursor(other2);
      for (let skip = start, pos = start; ; ) {
        a3.next(skip);
        b2.next(skip);
        skip = 0;
        if (a3.lineBreak != b2.lineBreak || a3.done != b2.done || a3.value != b2.value)
          return false;
        pos += a3.value.length;
        if (a3.done || pos >= end)
          return true;
      }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    /**
    Return the document as a string, using newline characters to
    separate lines.
    */
    toString() {
      return this.sliceString(0);
    }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    /**
    @internal
    */
    constructor() {
    }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text2) {
      if (text2.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text2.length == 1 && !text2[0])
        return _Text.empty;
      return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
    }
  };
  var TextLeaf = class _TextLeaf extends Text {
    constructor(text2, length = textLength(text2)) {
      super();
      this.text = text2;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset2) {
      for (let i4 = 0; ; i4++) {
        let string2 = this.text[i4], end = offset2 + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset2, end, line, string2);
        offset2 = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text2 = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
        if (joined.length <= 32) {
          target.push(new _TextLeaf(joined, prev.length + text2.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text2);
      }
    }
    replace(from, to, text2) {
      if (!(text2 instanceof _TextLeaf))
        return super.replace(from, to, text2);
      [from, to] = clip(this, from, to);
      let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text2.length - (to - from);
      if (lines.length <= 32)
        return new _TextLeaf(lines, newLen);
      return TextNode.from(_TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let pos = 0, i4 = 0; pos <= to && i4 < this.text.length; i4++) {
        let line = this.text[i4], end = pos + line.length;
        if (pos > from && i4)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text2, target) {
      let part = [], len = -1;
      for (let line of text2) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new _TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new _TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class _TextNode extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset2) {
      for (let i4 = 0; ; i4++) {
        let child = this.children[i4], end = offset2 + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset2);
        offset2 = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i4 = 0, pos = 0; pos <= to && i4 < this.children.length; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text2) {
      [from, to] = clip(this, from, to);
      if (text2.lines < this.lines)
        for (let i4 = 0, pos = 0; i4 < this.children.length; i4++) {
          let child = this.children[i4], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text2);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i4] = updated;
              return new _TextNode(copy, this.length - (to - from) + text2.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text2);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let i4 = 0, pos = 0; i4 < this.children.length && pos <= to; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (pos > from && i4)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other2, dir) {
      if (!(other2 instanceof _TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other2.children.length] : [this.children.length - 1, other2.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other2.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l4, ch) => l4 + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk2 = Math.max(
        32,
        lines >> 5
        /* Tree.BranchShift */
      ), maxChunk = chunk2 << 1, minChunk = chunk2 >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last2;
        if (child.lines > maxChunk && child instanceof _TextNode) {
          for (let node of child.children)
            add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk2)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text2) {
    let length = -1;
    for (let line of text2)
      length += line.length + 1;
    return length;
  }
  function appendText(text2, target, from = 0, to = 1e9) {
    for (let pos = 0, i4 = 0, first = true; i4 < text2.length && pos <= to; i4++) {
      let line = text2[i4], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text2, from, to) {
    return appendText(text2, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text2, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text2];
      this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last2 = this.nodes.length - 1;
        let top2 = this.nodes[last2], offsetValue = this.offsets[last2], offset2 = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset2 == (dir > 0 ? size : 0)) {
          if (last2 == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last2 - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last2] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset2 + (dir < 0 ? -1 : 0)];
          this.offsets[last2] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset2 + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last2] += dir;
          } else {
            if (dir < 0)
              this.offsets[last2]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text2, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text2, start > end ? -1 : 1);
      this.pos = start > end ? text2.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done && this.afterBreak) {
        this.value = "";
        this.afterBreak = false;
      } else if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    /**
    @internal
    */
    constructor(from, to, number2, text2) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text2;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() {
      return this.to - this.from;
    }
  };
  function clip(text2, from, to) {
    from = Math.max(0, Math.min(text2.length, from));
    return [from, Math.max(from, Math.min(text2.length, to))];
  }
  function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
    return findClusterBreak(str, pos, forward, includeExtending);
  }
  function surrogateLow2(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh2(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt2(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh2(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow2(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  function codePointSize2(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class _ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(sections) {
      this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
      let result = 0;
      for (let i4 = 0; i4 < this.sections.length; i4 += 2)
        result += this.sections[i4];
      return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
      let result = 0;
      for (let i4 = 0; i4 < this.sections.length; i4 += 2) {
        let ins = this.sections[i4 + 1];
        result += ins < 0 ? this.sections[i4] : ins;
      }
      return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f4) {
      for (let i4 = 0, posA = 0, posB = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++];
        if (ins < 0) {
          f4(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f4, individual = false) {
      iterChanges(this, f4, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
      let sections = [];
      for (let i4 = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new _ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other2) {
      return this.empty ? other2 : other2.empty ? this : composeSets(this, other2);
    }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `this` happened before the ones in `other`.
    */
    mapDesc(other2, before3 = false) {
      return other2.empty ? this : mapSet(this, other2, before3);
    }
    mapPos(pos, assoc = -1, mode3 = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i4 = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode3 != MapMode.Simple && endA >= pos && (mode3 == MapMode.TrackDel && posA < pos && endA > pos || mode3 == MapMode.TrackBefore && posA < pos || mode3 == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
      for (let i4 = 0, pos = 0; i4 < this.sections.length && pos <= to; ) {
        let len = this.sections[i4++], ins = this.sections[i4++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    /**
    @internal
    */
    toString() {
      let result = "";
      for (let i4 = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() {
      return this.sections;
    }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a3) => typeof a3 != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new _ChangeDesc(json);
    }
    /**
    @internal
    */
    static create(sections) {
      return new _ChangeDesc(sections);
    }
  };
  var ChangeSet = class _ChangeSet extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
      return doc2;
    }
    mapDesc(other2, before3 = false) {
      return mapSet(this, other2, before3, true);
    }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i4 = 0, pos = 0; i4 < sections.length; i4 += 2) {
        let len = sections[i4], ins = sections[i4 + 1];
        if (ins >= 0) {
          sections[i4] = ins;
          sections[i4 + 1] = len;
          let index2 = i4 >> 1;
          while (inserted.length < index2)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new _ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA`  `docB` and `other` represents `docB`  `docC`, the
    returned value will represent the change `docA`  `docC`.
    */
    compose(other2) {
      return this.empty ? other2 : other2.empty ? this : composeSets(this, other2, true);
    }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other2, before3 = false) {
      return other2.empty ? this : mapSet(this, other2, before3, true);
    }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f4, individual = false) {
      iterChanges(this, f4, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    /**
    @internal
    */
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done: for (let i4 = 0, pos = 0; ; ) {
        let next = i4 == ranges.length ? 1e9 : ranges[i4++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i4++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
      return {
        changes: new _ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
      let parts = [];
      for (let i4 = 0; i4 < this.sections.length; i4 += 2) {
        let len = this.sections[i4], ins = this.sections[i4 + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i4 >> 1].toJSON()));
      }
      return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set3 = new _ChangeSet(sections, inserted);
        total = total ? total.compose(set3.map(total)) : set3;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof _ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert2 } = spec;
          if (from > to || from < 0 || to > length)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
      return new _ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i4 = 0; i4 < json.length; i4++) {
        let part = json[i4];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e3, i5) => i5 && typeof e3 != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i4)
            inserted.push(Text.empty);
          inserted[i4] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i4].length);
        }
      }
      return new _ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
      return new _ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last2 = sections.length - 2;
    if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
      sections[last2] += len;
    else if (last2 >= 0 && len == 0 && sections[last2] == 0)
      sections[last2 + 1] += ins;
    else if (forceJoin) {
      sections[last2] += len;
      sections[last2 + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values2, sections, value) {
    if (value.length == 0)
      return;
    let index2 = sections.length - 2 >> 1;
    if (index2 < values2.length) {
      values2[values2.length - 1] = values2[values2.length - 1].append(value);
    } else {
      while (values2.length < index2)
        values2.push(Text.empty);
      values2.push(value);
    }
  }
  function iterChanges(desc, f4, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i4 = 0; i4 < desc.sections.length; ) {
      let len = desc.sections[i4++], ins = desc.sections[i4++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text2 = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text2 = text2.append(inserted[i4 - 2 >> 1]);
          if (individual || i4 == desc.sections.length || desc.sections[i4 + 1] < 0)
            break;
          len = desc.sections[i4++];
          ins = desc.sections[i4++];
        }
        f4(posA, endA, posB, endB, text2);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before3, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a3 = new SectionIter(setA), b2 = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a3.done && b2.len || b2.done && a3.len) {
        throw new Error("Mismatched change set lengths");
      } else if (a3.ins == -1 && b2.ins == -1) {
        let len = Math.min(a3.len, b2.len);
        addSection(sections, len, -1);
        a3.forward(len);
        b2.forward(len);
      } else if (b2.ins >= 0 && (a3.ins < 0 || inserted == a3.i || a3.off == 0 && (b2.len < a3.len || b2.len == a3.len && !before3))) {
        let len = b2.len;
        addSection(sections, b2.ins, -1);
        while (len) {
          let piece = Math.min(a3.len, len);
          if (a3.ins >= 0 && inserted < a3.i && a3.len <= piece) {
            addSection(sections, 0, a3.ins);
            if (insert2)
              addInsert(insert2, sections, a3.text);
            inserted = a3.i;
          }
          a3.forward(piece);
          len -= piece;
        }
        b2.next();
      } else if (a3.ins >= 0) {
        let len = 0, left = a3.len;
        while (left) {
          if (b2.ins == -1) {
            let piece = Math.min(left, b2.len);
            len += piece;
            left -= piece;
            b2.forward(piece);
          } else if (b2.ins == 0 && b2.len < left) {
            left -= b2.len;
            b2.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a3.i ? a3.ins : 0);
        if (insert2 && inserted < a3.i)
          addInsert(insert2, sections, a3.text);
        inserted = a3.i;
        a3.forward(a3.len - left);
      } else if (a3.done && b2.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a3 = new SectionIter(setA), b2 = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a3.done && b2.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a3.ins == 0) {
        addSection(sections, a3.len, 0, open);
        a3.next();
      } else if (b2.len == 0 && !b2.done) {
        addSection(sections, 0, b2.ins, open);
        if (insert2)
          addInsert(insert2, sections, b2.text);
        b2.next();
      } else if (a3.done || b2.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a3.len2, b2.len), sectionLen = sections.length;
        if (a3.ins == -1) {
          let insB = b2.ins == -1 ? -1 : b2.off ? 0 : b2.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b2.text);
        } else if (b2.ins == -1) {
          addSection(sections, a3.off ? 0 : a3.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a3.textBit(len));
        } else {
          addSection(sections, a3.off ? 0 : a3.len, b2.off ? 0 : b2.ins, open);
          if (insert2 && !b2.off)
            addInsert(insert2, sections, b2.text);
        }
        open = (a3.ins > len || b2.ins >= 0 && b2.len > len) && (open || sections.length > sectionLen);
        a3.forward2(len);
        b2.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set3) {
      this.set = set3;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index2 = this.i - 2 >> 1;
      return index2 >= inserted.length ? Text.empty : inserted[index2];
    }
    textBit(len) {
      let { inserted } = this.set, index2 = this.i - 2 >> 1;
      return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class _SelectionRange {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    /**
    The anchor of the rangethe side that doesn't move when you
    extend it.
    */
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() {
      return this.from == this.to;
    }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
      let level = this.flags & 7;
      return level == 7 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
      let value = this.flags >> 6;
      return value == 16777215 ? void 0 : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other2, includeAssoc = false) {
      return this.anchor == other2.anchor && this.head == other2.head && (!includeAssoc || !this.empty || this.assoc == other2.assoc);
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    /**
    @internal
    */
    static create(from, to, flags) {
      return new _SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class _EditorSelection {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return _EditorSelection.create(this.ranges.map((r3) => r3.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection. By default, ranges
    are compared only by position. When `includeAssoc` is true,
    cursor ranges must also have the same
    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
    */
    eq(other2, includeAssoc = false) {
      if (this.ranges.length != other2.ranges.length || this.mainIndex != other2.mainIndex)
        return false;
      for (let i4 = 0; i4 < this.ranges.length; i4++)
        if (!this.ranges[i4].eq(other2.ranges[i4], includeAssoc))
          return false;
      return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() {
      return this.ranges[this.mainIndex];
    }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
      return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main = true) {
      return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return _EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
      return { ranges: this.ranges.map((r3) => r3.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new _EditorSelection(json.ranges.map((r3) => SelectionRange.fromJSON(r3)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
      return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i4 = 0; i4 < ranges.length; i4++) {
        let range = ranges[i4];
        if (range.empty ? range.from <= pos : range.from < pos)
          return _EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new _EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
      return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a3, b2) => a3.from - b2.from);
      mainIndex = ranges.indexOf(main);
      for (let i4 = 1; i4 < ranges.length; i4++) {
        let range = ranges[i4], prev = ranges[i4 - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from = prev.from, to = Math.max(range.to, prev.to);
          if (i4 <= mainIndex)
            mainIndex--;
          ranges.splice(--i4, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
        }
      }
      return new _EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection2, docLength) {
    for (let range of selection2.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class _Facet {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
    get reader() {
      return this;
    }
    /**
    Define a new facet.
    */
    static define(config2 = {}) {
      return new _Facet(config2.combine || ((a3) => a3), config2.compareInput || ((a3, b2) => a3 === b2), config2.compare || (!config2.combine ? sameArray2 : (a3, b2) => a3 === b2), !!config2.static, config2.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get3);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get3);
    }
    from(field, get3) {
      if (!get3)
        get3 = (x3) => x3;
      return this.compute([field], (state) => get3(state.field(field)));
    }
  };
  function sameArray2(a3, b2) {
    return a3 == b2 || a3.length == b2.length && a3.every((e3, i4) => e3 === b2[i4]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type3, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type3;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id2];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a3, b2, compare2) {
    if (a3.length != b2.length)
      return false;
    for (let i4 = 0; i4 < a3.length; i4++)
      if (!compare2(a3[i4], b2[i4]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p3) => addresses[p3.id]);
    let providerTypes = providers.map((p3) => p3.type);
    let dynamic = providerAddrs.filter((p3) => !(p3 & 1));
    let idx = addresses[facet.id] >> 1;
    function get3(state) {
      let values2 = [];
      for (let i4 = 0; i4 < providerAddrs.length; i4++) {
        let value = getAddr(state, providerAddrs[i4]);
        if (providerTypes[i4] == 2)
          for (let val of value)
            values2.push(val);
        else
          values2.push(value);
      }
      return facet.combine(values2);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get3(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get3(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray2(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get3(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class _StateField {
    constructor(id2, createF, updateF, compareF, spec) {
      this.id = id2;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    /**
    Define a state field.
    */
    static define(config2) {
      let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a3, b2) => a3 === b2), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i4) => i4.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
          if ((reInit = init.find((i4) => i4.field == this)) && reInit != oldInit.find((i4) => i4.field == this)) {
            state.values[idx] = reInit.create(state);
            return 1;
          }
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create2) {
      return [this, initField.of({ field: this, create: create2 })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /* @__PURE__ */ prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /* @__PURE__ */ prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: /* @__PURE__ */ prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: /* @__PURE__ */ prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class _Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content2) {
      return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class _Configuration {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(
          0
          /* SlotStatus.Unresolved */
        );
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten3(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a3) => field.slot(a3));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id2 in facets) {
        let providers = facets[id2], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id2] || [];
        if (providers.every(
          (p3) => p3.type == 0
          /* Provider.Static */
        )) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray2(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p3) => p3.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p3 of providers) {
            if (p3.type == 0) {
              address[p3.id] = staticValues.length << 1 | 1;
              staticValues.push(p3.value);
            } else {
              address[p3.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a3) => p3.dynamicSlot(a3));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a3) => dynamicFacetSlot(a3, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f4) => f4(address));
      return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten3(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e3 of ext)
          inner(e3, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a3, b2) => a3.concat(b2));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((v4) => v4),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : false
  });
  var Annotation = class {
    /**
    @internal
    */
    constructor(type3, value) {
      this.type = type3;
      this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    /**
    Create an instance of this annotation.
    */
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    /**
    @internal
    */
    constructor(map3) {
      this.map = map3;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class _StateEffect {
    /**
    @internal
    */
    constructor(type3, value) {
      this.type = type3;
      this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type3) {
      return this.type == type3;
    }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v4) => v4));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class _Transaction {
    constructor(startState, changes, selection2, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection2;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection2)
        checkSelection(selection2, changes.newLength);
      if (!annotations.some((a3) => a3.type == _Transaction.time))
        this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection2, effects, annotations, scrollIntoView3) {
      return new _Transaction(startState, changes, selection2, effects, annotations, scrollIntoView3);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type3) {
      for (let ann of this.annotations)
        if (ann.type == type3)
          return ann.value;
      return void 0;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() {
      return !this.changes.empty;
    }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event2) {
      let e3 = this.annotation(_Transaction.userEvent);
      return !!(e3 && (e3 == event2 || e3.length > event2.length && e3.slice(0, event2.length) == event2 && e3[event2.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a3, b2) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a3.length && (iB == b2.length || b2[iB] >= a3[iA])) {
        from = a3[iA++];
        to = a3[iA++];
      } else if (iB < b2.length) {
        from = b2[iB++];
        to = b2[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a3, b2, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b2.changes;
      mapForB = ChangeSet.empty(b2.changes.length);
      changes = a3.changes.compose(b2.changes);
    } else {
      mapForA = b2.changes.map(a3.changes);
      mapForB = a3.changes.mapDesc(b2.changes, true);
      changes = a3.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b2.selection ? b2.selection.map(mapForB) : (_a2 = a3.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a3.effects, mapForA).concat(StateEffect.mapEffects(b2.effects, mapForB)),
      annotations: a3.annotations.length ? a3.annotations.concat(b2.annotations) : b2.annotations,
      scrollIntoView: a3.scrollIntoView || b2.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s4 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i4 = 1; i4 < specs.length; i4++) {
      if (specs[i4].filter === false)
        filter = false;
      let seq = !!specs[i4].sequential;
      s4 = mergeTransaction(s4, resolveTransactionInner(state, specs[i4], seq ? s4.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s4.changes, s4.selection, s4.effects, s4.annotations, s4.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i4 = filters.length - 1; i4 >= 0; i4--) {
      let filtered = filters[i4](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i4 = extenders.length - 1; i4 >= 0; i4--) {
      let extension = extenders[i4](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_3) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i4 = 0; i4 < str.length; i4++) {
      let ch = str[i4];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i4 = 0; i4 < wordChars.length; i4++)
        if (char.indexOf(wordChars[i4]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class _EditorState {
    constructor(config2, doc2, selection2, values2, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection2;
      this.values = values2;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i4 = 0; i4 < this.config.dynamicSlots.length; i4++)
        ensureAddr(this, i4 << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
      new _EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text2) {
      if (typeof text2 == "string")
        text2 = this.toText(text2);
      return this.changeByRange((range) => ({
        changes: { from: range.from, to: range.to, insert: text2 },
        range: EditorSelection.cursor(range.from + text2.length)
      }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f4) {
      let sel = this.selection;
      let result1 = f4(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i4 = 1; i4 < sel.ranges.length; i4++) {
        let result = f4(sel.ranges[i4]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j4 = 0; j4 < i4; j4++)
          ranges[j4] = ranges[j4].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string2) {
      return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config2 = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json, prop)) {
            let field = fields[prop], value = json[prop];
            fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
          }
        }
      return _EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editorupdated states are created by applying
    transactions.
    */
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
      let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection2, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection2 = selection2.asSingle();
      return new _EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() {
      return this.facet(_EditorState.tabSize);
    }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() {
      return this.facet(_EditorState.lineSeparator) || "\n";
    }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() {
      return this.facet(readOnly);
    }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase, ...insert2) {
      for (let map3 of this.facet(_EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map3, phrase)) {
          phrase = map3[phrase];
          break;
        }
      if (insert2.length)
        phrase = phrase.replace(/\$(\$|\d*)/g, (m3, i4) => {
          if (i4 == "$")
            return "$";
          let n3 = +(i4 || 1);
          return !n3 || n3 > insert2.length ? m3 : insert2[n3 - 1];
        });
      return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
    languageDataAt(name2, pos, side = -1) {
      let values2 = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values2.push(result[name2]);
        }
      }
      return values2;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
      let { text: text2, from, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from, end = pos - from;
      while (start > 0) {
        let prev = findClusterBreak2(text2, start, false);
        if (cat(text2.slice(prev, start)) != CharCategory.Word)
          break;
        start = prev;
      }
      while (end < length) {
        let next = findClusterBreak2(text2, end);
        if (cat(text2.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a3, b2) {
      let kA = Object.keys(a3), kB = Object.keys(b2);
      return kA.length == kB.length && kA.every((k3) => a3[k3] == b2[k3]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults3, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key of Object.keys(config2)) {
        let value = config2[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0) ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults3)
      if (result[key] === void 0)
        result[key] = defaults3[key];
    return result;
  }
  var RangeValue = class {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other2) {
      return this == other2;
    }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from, to = from) {
      return Range4.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range4 = class _Range {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    /**
    @internal
    */
    static create(from, to, value) {
      return new _Range(from, to, value);
    }
  };
  function cmpRange(a3, b2) {
    return a3.from - b2.from || a3.value.startSide - b2.value.startSide;
  }
  var Chunk = class _Chunk {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset2, from, to, f4) {
      for (let i4 = this.findIndex(from, -1e9, true), e3 = this.findIndex(to, 1e9, false, i4); i4 < e3; i4++)
        if (f4(this.from[i4] + offset2, this.to[i4] + offset2, this.value[i4]) === false)
          return false;
    }
    map(offset2, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i4 = 0; i4 < this.value.length; i4++) {
        let val = this.value[i4], curFrom = this.from[i4] + offset2, curTo = this.to[i4] + offset2, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class _RangeSet {
    constructor(chunkPos, chunk2, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk2;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk2, nextLayer, maxPoint) {
      return new _RangeSet(chunkPos, chunk2, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
      let last2 = this.chunk.length - 1;
      return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk2 of this.chunk)
        size += chunk2.value.length;
      return size;
    }
    /**
    @internal
    */
    chunkEnd(index2) {
      return this.chunkPos[index2] + this.chunk[index2].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
      let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter)
        return this;
      if (sort)
        add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty)
        return add2.length ? _RangeSet.of(add2) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i4 = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i4 < add2.length) {
        if (i4 < add2.length && (cur2.from - add2[i4].from || cur2.startSide - add2[i4].value.startSide) >= 0) {
          let range = add2[i4++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i4 == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i4].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range4.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i4 = 0; i4 < this.chunk.length; i4++) {
        let start = this.chunkPos[i4], chunk2 = this.chunk[i4];
        let touch = changes.touchesRange(start, start + chunk2.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk2.maxPoint);
          chunks.push(chunk2);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let { mapped, pos } = chunk2.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from, to, f4) {
      if (this.isEmpty)
        return;
      for (let i4 = 0; i4 < this.chunk.length; i4++) {
        let start = this.chunkPos[i4], chunk2 = this.chunk[i4];
        if (to >= start && from <= start + chunk2.length && chunk2.between(start, from - start, to - start, f4) === false)
          return;
      }
      this.nextLayer.between(from, to, f4);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    /**
    @internal
    */
    get isEmpty() {
      return this.nextLayer == this;
    }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a3 = oldSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let b2 = newSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a3, b2, textDiff);
      let sideA = new SpanCursor(a3, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b2, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a3 = oldSets.filter((set3) => !set3.isEmpty && newSets.indexOf(set3) < 0);
      let b2 = newSets.filter((set3) => !set3.isEmpty && oldSets.indexOf(set3) < 0);
      if (a3.length != b2.length)
        return false;
      if (!a3.length)
        return true;
      let sharedChunks = findSharedChunks(a3, b2);
      let sideA = new SpanCursor(a3, sharedChunks, 0).goto(from), sideB = new SpanCursor(b2, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let openRanges = cursor2.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor2.to, to);
        if (cursor2.point) {
          let active = cursor2.activeForPoint(cursor2.to);
          let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
          openRanges = Math.min(cursor2.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor2.active, openRanges);
          openRanges = cursor2.openEnd(curTo);
        }
        if (cursor2.to > to)
          return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
        pos = cursor2.to;
        cursor2.next();
      }
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range4 ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
    /**
    Join an array of range sets into a single set.
    */
    static join(sets) {
      if (!sets.length)
        return _RangeSet.empty;
      let result = sets[sets.length - 1];
      for (let i4 = sets.length - 2; i4 >= 0; i4--) {
        for (let layer = sets[i4]; layer != _RangeSet.empty; layer = layer.nextLayer)
          result = new _RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
      }
      return result;
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i4 = 1; i4 < ranges.length; i4++) {
        let cur2 = ranges[i4];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class _RangeSetBuilder {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    /**
    Create an empty builder.
    */
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
    }
    /**
    @internal
    */
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    /**
    @internal
    */
    addChunk(from, chunk2) {
      if ((from - this.lastTo || chunk2.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk2.maxPoint);
      this.chunks.push(chunk2);
      this.chunkPos.push(from);
      let last2 = chunk2.value.length - 1;
      this.last = chunk2.value[last2];
      this.lastFrom = chunk2.from[last2] + from;
      this.lastTo = chunk2.to[last2] + from;
      return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    /**
    @internal
    */
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a3, b2, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set3 of a3)
      for (let i4 = 0; i4 < set3.chunk.length; i4++)
        if (set3.chunk[i4].maxPoint <= 0)
          inA.set(set3.chunk[i4], set3.chunkPos[i4]);
    let shared = /* @__PURE__ */ new Set();
    for (let set3 of b2)
      for (let i4 = 0; i4 < set3.chunk.length; i4++) {
        let known = inA.get(set3.chunk[i4]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set3.chunkPos[i4] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set3.chunk[i4].length)))
          shared.add(set3.chunk[i4]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk2 = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk2.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk2.to[this.rangeIndex];
          this.value = chunk2.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index2) {
      if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index2;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other2) {
      return this.from - other2.from || this.startSide - other2.startSide || this.rank - other2.rank || this.to - other2.to || this.endSide - other2.endSide;
    }
  };
  var HeapCursor = class _HeapCursor {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i4 = 0; i4 < sets.length; i4++) {
        for (let cur2 = sets[i4]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur2, skip, minPoint, i4));
        }
      }
      return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i4 = this.heap.length >> 1; i4 >= 0; i4--)
        heapBubble(this.heap, i4);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i4 = this.heap.length >> 1; i4 >= 0; i4--)
        heapBubble(this.heap, i4);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index2) {
    for (let cur2 = heap[index2]; ; ) {
      let childIndex = (index2 << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap[childIndex] = cur2;
      heap[index2] = child;
      index2 = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index2) {
      remove(this.active, index2);
      remove(this.activeTo, index2);
      remove(this.activeRank, index2);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i4 = 0, { value, to, rank } = this.cursor;
      while (i4 < this.activeRank.length && (rank - this.activeRank[i4] || to - this.activeTo[i4]) > 0)
        i4++;
      insert(this.active, i4, value);
      insert(this.activeTo, i4, to);
      insert(this.activeRank, i4, rank);
      if (trackOpen)
        insert(trackOpen, i4, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a3 = this.minActive;
        if (a3 > -1 && (this.activeTo[a3] - this.cursor.from || this.active[a3].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a3] > from) {
            this.to = this.activeTo[a3];
            this.endSide = this.active[a3].endSide;
            break;
          }
          this.removeActive(a3);
          if (trackOpen)
            remove(trackOpen, a3);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i4 = trackOpen.length - 1; i4 >= 0 && trackOpen[i4] < from; i4--)
          this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i4 = this.active.length - 1; i4 >= 0; i4--) {
        if (this.activeRank[i4] < this.pointRank)
          break;
        if (this.activeTo[i4] > to || this.activeTo[i4] == to && this.active[i4].endSide >= this.point.endSide)
          active.push(this.active[i4]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i4 = this.activeTo.length - 1; i4 >= 0 && this.activeTo[i4] > to; i4--)
        open++;
      return open;
    }
  };
  function compare(a3, startA, b2, startB, length, comparator) {
    a3.goto(startA);
    b2.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let dEnd = a3.to + dPos - b2.to, diff = dEnd || a3.endSide - b2.endSide;
      let end = diff < 0 ? a3.to + dPos : b2.to, clipEnd = Math.min(end, endB);
      if (a3.point || b2.point) {
        if (!(a3.point && b2.point && (a3.point == b2.point || a3.point.eq(b2.point)) && sameValues(a3.activeForPoint(a3.to), b2.activeForPoint(b2.to))))
          comparator.comparePoint(pos, clipEnd, a3.point, b2.point);
      } else {
        if (clipEnd > pos && !sameValues(a3.active, b2.active))
          comparator.compareRange(pos, clipEnd, a3.active, b2.active);
      }
      if (end > endB)
        break;
      if ((dEnd || a3.openEnd != b2.openEnd) && comparator.boundChange)
        comparator.boundChange(end);
      pos = end;
      if (diff <= 0)
        a3.next();
      if (diff >= 0)
        b2.next();
    }
  }
  function sameValues(a3, b2) {
    if (a3.length != b2.length)
      return false;
    for (let i4 = 0; i4 < a3.length; i4++)
      if (a3[i4] != b2[i4] && !a3[i4].eq(b2[i4]))
        return false;
    return true;
  }
  function remove(array, index2) {
    for (let i4 = index2, e3 = array.length - 1; i4 < e3; i4++)
      array[i4] = array[i4 + 1];
    array.pop();
  }
  function insert(array, index2, value) {
    for (let i4 = array.length - 1; i4 >= index2; i4--)
      array[i4 + 1] = array[i4];
    array[index2] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i4 = 0; i4 < array.length; i4++)
      if ((array[i4] - foundPos || value[i4].endSide - value[found].endSide) < 0) {
        found = i4;
        foundPos = array[i4];
      }
    return found;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n3 = 0;
    for (let i4 = 0; i4 < to && i4 < string2.length; ) {
      if (string2.charCodeAt(i4) == 9) {
        n3 += tabSize - n3 % tabSize;
        i4++;
      } else {
        n3++;
        i4 = findClusterBreak2(string2, i4);
      }
    }
    return n3;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i4 = 0, n3 = 0; ; ) {
      if (n3 >= col)
        return i4;
      if (i4 == string2.length)
        break;
      n3 += string2.charCodeAt(i4) == 9 ? tabSize - n3 % tabSize : 1;
      i4 = findClusterBreak2(string2, i4);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C3 = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C3 : Symbol.for(C3);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    // :: (Object<Style>, ?{finish: ?(string)  string})
    // Create a style module from the given spec.
    //
    // When `finish` is given, it is called on regular (non-`@`)
    // selectors (after `&` expansion) to compute the final selector.
    constructor(spec, options2) {
      this.rules = [];
      let { finish } = options2 || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null) return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a3, b2) => a3.concat(b2)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l4) => "-" + l4.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
    }
    // :: ()  string
    // Returns a string containing the module's CSS rules.
    getRules() {
      return this.rules.join("\n");
    }
    // :: ()  string
    // Generate a new unique CSS class name.
    static newName() {
      let id2 = top[COUNT] || 1;
      top[COUNT] = id2 + 1;
      return C3 + id2.toString(36);
    }
    // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
    //
    // Mount the given set of modules in the given DOM root, which ensures
    // that the CSS rules defined by the module are available in that
    // context.
    //
    // Rules are only added to the document once per root.
    //
    // Rule order will follow the order of the modules, so that rules from
    // modules later in the array take precedence of those from earlier
    // modules. If you call this function multiple times for the same root
    // in a way that changes the order of already mounted modules, the old
    // order will be changed.
    //
    // If a Content Security Policy nonce is provided, it is added to
    // the `<style>` tag generated by the library.
    static mount(root, modules, options2) {
      let set3 = root[SET], nonce = options2 && options2.nonce;
      if (!set3) set3 = new StyleSet(root, nonce);
      else if (nonce) set3.setNonce(nonce);
      set3.mount(Array.isArray(modules) ? modules : [modules], root);
    }
  };
  var adoptedSet = /* @__PURE__ */ new Map();
  var StyleSet = class {
    constructor(root, nonce) {
      let doc2 = root.ownerDocument || root, win = doc2.defaultView;
      if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
        let adopted = adoptedSet.get(doc2);
        if (adopted) return root[SET] = adopted;
        this.sheet = new win.CSSStyleSheet();
        adoptedSet.set(doc2, this);
      } else {
        this.styleTag = doc2.createElement("style");
        if (nonce) this.styleTag.setAttribute("nonce", nonce);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules, root) {
      let sheet = this.sheet;
      let pos = 0, j4 = 0;
      for (let i4 = 0; i4 < modules.length; i4++) {
        let mod = modules[i4], index2 = this.modules.indexOf(mod);
        if (index2 < j4 && index2 > -1) {
          this.modules.splice(index2, 1);
          j4--;
          index2 = -1;
        }
        if (index2 == -1) {
          this.modules.splice(j4++, 0, mod);
          if (sheet) for (let k3 = 0; k3 < mod.rules.length; k3++)
            sheet.insertRule(mod.rules[k3], pos++);
        } else {
          while (j4 < index2) pos += this.modules[j4++].rules.length;
          pos += mod.rules.length;
          j4++;
        }
      }
      if (sheet) {
        if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
          root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
      } else {
        let text2 = "";
        for (let i4 = 0; i4 < this.modules.length; i4++)
          text2 += this.modules[i4].getRules() + "\n";
        this.styleTag.textContent = text2;
        let target = root.head || root;
        if (this.styleTag.parentNode != target)
          target.insertBefore(this.styleTag, target.firstChild);
      }
    }
    setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
        this.styleTag.setAttribute("nonce", nonce);
    }
  };

  // node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i4 = 0; i4 < 10; i4++) base[48 + i4] = base[96 + i4] = String(i4);
  var i4;
  for (i4 = 1; i4 <= 24; i4++) base[i4 + 111] = "F" + i4;
  var i4;
  for (i4 = 65; i4 <= 90; i4++) {
    base[i4] = String.fromCharCode(i4 + 32);
    shift[i4] = String.fromCharCode(i4);
  }
  var i4;
  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  var code;
  function keyName(event2) {
    var ignoreKey = mac && event2.metaKey && event2.shiftKey && !event2.ctrlKey && !event2.altKey || ie && event2.shiftKey && event2.key && event2.key.length == 1 || event2.key == "Unidentified";
    var name2 = !ignoreKey && event2.key || (event2.shiftKey ? shift : base)[event2.keyCode] || event2.key || "Unidentified";
    if (name2 == "Esc") name2 = "Escape";
    if (name2 == "Del") name2 = "Delete";
    if (name2 == "Left") name2 = "ArrowLeft";
    if (name2 == "Up") name2 = "ArrowUp";
    if (name2 == "Right") name2 = "ArrowRight";
    if (name2 == "Down") name2 = "ArrowDown";
    return name2;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function hasSelection(dom, selection2) {
    if (!selection2.anchorNode)
      return false;
    try {
      return contains(dom, selection2.anchorNode);
    } catch (_3) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index2 = 0; ; index2++) {
      node = node.previousSibling;
      if (!node)
        return index2;
    }
  }
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function flattenRect(rect, left) {
    let x3 = left ? rect.left : rect.right;
    return { left: x3, right: x3, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function getScale(elt2, rect) {
    let scaleX = rect.width / elt2.offsetWidth;
    let scaleY = rect.height / elt2.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt2.offsetWidth) < 1)
      scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt2.offsetHeight) < 1)
      scaleY = 1;
    return { scaleX, scaleY };
  }
  function scrollRectIntoView(dom, rect, side, x3, y3, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur2 = dom, stop = false; cur2 && !stop; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc2.body;
        let scaleX = 1, scaleY = 1;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
            stop = true;
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.assignedSlot || cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          ({ scaleX, scaleY } = getScale(cur2, rect2));
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth * scaleX,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight * scaleY
          };
        }
        let moveX = 0, moveY = 0;
        if (y3 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = rect.top - (bounding.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = rect.top - (bounding.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y3 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y3 == "start" || y3 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x3 == "nearest") {
          if (rect.left < bounding.left) {
            moveX = rect.left - (bounding.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = rect.left - (bounding.left + xMargin);
          }
        } else {
          let targetLeft = x3 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x3 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start = cur2.scrollTop;
              cur2.scrollTop += moveY / scaleY;
              movedY = (cur2.scrollTop - start) * scaleY;
            }
            if (moveX) {
              let start = cur2.scrollLeft;
              cur2.scrollLeft += moveX / scaleX;
              movedX = (cur2.scrollLeft - start) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x3 = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y3 = "nearest";
          }
        }
        if (top2)
          break;
        if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
          rect = {
            left: Math.max(rect.left, bounding.left),
            right: Math.min(rect.right, bounding.right),
            top: Math.max(rect.top, bounding.top),
            bottom: Math.min(rect.bottom, bounding.bottom)
          };
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  function scrollableParents(dom) {
    let doc2 = dom.ownerDocument, x3, y3;
    for (let cur2 = dom.parentNode; cur2; ) {
      if (cur2 == doc2.body || x3 && y3) {
        break;
      } else if (cur2.nodeType == 1) {
        if (!y3 && cur2.scrollHeight > cur2.clientHeight)
          y3 = cur2;
        if (!x3 && cur2.scrollWidth > cur2.clientWidth)
          x3 = cur2;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
    return { x: x3, y: y3 };
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      let { anchorNode, focusNode } = range;
      this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i4 = 0; i4 < stack.length; ) {
        let elt2 = stack[i4++], top2 = stack[i4++], left = stack[i4++];
        if (elt2.scrollTop != top2)
          elt2.scrollTop = top2;
        if (elt2.scrollLeft != left)
          elt2.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt2, name2, code, mods) {
    let options2 = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
    if (mods)
      ({ altKey: options2.altKey, ctrlKey: options2.ctrlKey, shiftKey: options2.shiftKey, metaKey: options2.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options2);
    down.synthetic = true;
    elt2.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options2);
    up.synthetic = true;
    elt2.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection2) {
    let node = selection2.focusNode, offset2 = selection2.focusOffset;
    if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset2)
      return false;
    offset2 = Math.min(offset2, maxOffset(node));
    for (; ; ) {
      if (offset2) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset2 - 1];
        if (prev.contentEditable == "false")
          offset2--;
        else {
          node = prev;
          offset2 = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset2 = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt2) {
    return elt2.scrollTop > Math.max(1, elt2.scrollHeight - elt2.clientHeight - 4);
  }
  function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset2 = startOffset; ; ) {
      if (node.nodeType == 3 && offset2 > 0) {
        return { node, offset: offset2 };
      } else if (node.nodeType == 1 && offset2 > 0) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset2 - 1];
        offset2 = maxOffset(node);
      } else if (node.parentNode && !isBlockElement(node)) {
        offset2 = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset2 = startOffset; ; ) {
      if (node.nodeType == 3 && offset2 < node.nodeValue.length) {
        return { node, offset: offset2 };
      } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset2];
        offset2 = 0;
      } else if (node.parentNode && !isBlockElement(node)) {
        offset2 = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  var DOMPos = class _DOMPos {
    constructor(node, offset2, precise = true) {
      this.node = node;
      this.offset = offset2;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new _DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class _ContentView {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    sync(view, track) {
      if (this.flags & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.flags & 7) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = _ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(view, track);
            child.flags &= ~7;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.flags & 1) {
        for (let child of this.children)
          if (child.flags & 7) {
            child.sync(view, track);
            child.flags &= ~7;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset2) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset2];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset2 == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !_ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i4 = 0, pos = 0; ; i4++) {
        let child = this.children[i4];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset2 = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i4 = 0, pos = offset2, prevEnd = offset2; i4 < this.children.length; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i4;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i4;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset2 + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.flags |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.flags |= 2;
        if (parent.flags & 1)
          return;
        parent.flags |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.flags & 7)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom == dom)
        return;
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v4 = this; ; ) {
        let parent = v4.parent;
        if (!parent)
          return v4;
        v4 = parent;
      }
    }
    replaceChildren(from, to, children = noChildren) {
      this.markDirty();
      for (let i4 = from; i4 < to; i4++) {
        let child = this.children[i4];
        if (child.parent == this && children.indexOf(child) < 0)
          child.destroy();
      }
      if (children.length < 250)
        this.children.splice(from, to - from, ...children);
      else
        this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
      for (let i4 = 0; i4 < children.length; i4++)
        children[i4].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other2) {
      return false;
    }
    canReuseDOM(other2) {
      return other2.constructor == this.constructor && !((this.flags | other2.flags) & 8);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() {
      return 0;
    }
    destroy() {
      for (let child of this.children)
        if (child.parent == this)
          child.destroy();
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i4) {
      this.children = children;
      this.pos = pos;
      this.i = i4;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before3 = children.length ? children[fromI] : null;
    let last2 = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
    if (fromI == toI && before3 && !breakAtStart && !breakAtEnd && insert2.length < 2 && before3.merge(fromOff, toOff, insert2.length ? last2 : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && (toOff < after.length || after.breakAfter && (last2 === null || last2 === void 0 ? void 0 : last2.breakAfter))) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff || after.children.length && !after.children[0].length)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last2)
          last2.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before3) {
      before3.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before3.merge(fromOff, before3.length, insert2[0], false, openStart, 0)) {
          before3.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before3.length || before3.children.length && before3.children[before3.children.length - 1].length == 0) {
          before3.merge(fromOff, before3.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let { i: toI, off: toOff } = cur2.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class _TextView extends ContentView {
    constructor(text2) {
      super();
      this.text = text2;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from, to, source) {
      if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8))
        return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new _TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      result.flags |= this.flags & 8;
      return result;
    }
    localPosFromDOM(node, offset2) {
      return node == this.dom ? offset2 : offset2 ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset2) {
      return { from: offset2, to: offset2 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class _MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    canReuseDOM(other2) {
      return super.canReuseDOM(other2) && !((this.flags | other2.flags) & 8);
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.flags & 4)
        this.setAttrs(this.dom);
      super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i4 = 0;
      for (let elt2 of this.children) {
        let end = off + elt2.length;
        if (end > from)
          result.push(off < from ? elt2.split(from - off) : elt2);
        if (detachFrom < 0 && off >= from)
          detachFrom = i4;
        off = end;
        i4++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new _MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text2, pos, side) {
    let length = text2.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten4 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten4 = 1;
        } else if (to < length) {
          to++;
          flatten4 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(text2, from, to).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten4 ? flatten4 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten4 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r3) => r3.width) || rect;
    return flatten4 ? flattenRect(rect, flatten4 < 0) : rect || null;
  }
  var WidgetView = class _WidgetView extends ContentView {
    static create(widget, length, side) {
      return new _WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    split(from) {
      let result = _WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other2) {
      if (other2 instanceof _WidgetView && other2.side == this.side && this.widget.constructor == other2.widget.constructor) {
        if (!this.widget.compare(other2.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other2.widget;
        this.length = other2.length;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event2) {
      return this.widget.ignoreEvent(event2);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let { view } = top2, text2 = view && view.state.doc, start = this.posAtStart;
      return text2 ? text2.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.side ? this.side < 0 : pos > 0;
      for (let i4 = fromBack ? rects.length - 1 : 0; ; i4 += fromBack ? -1 : 1) {
        rect = rects[i4];
        if (pos > 0 ? i4 == 0 : i4 == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var WidgetBufferView = class _WidgetBufferView extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other2) {
      return other2 instanceof _WidgetBufferView && other2.side == this.side;
    }
    split() {
      return new _WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return Text.empty;
    }
    get isHidden() {
      return true;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i4 = 0;
    for (let off = 0; i4 < children.length; i4++) {
      let child = children[i4], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j4 = i4; j4 > 0; j4--) {
      let prev = children[j4 - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j4 = i4; j4 < children.length; j4++) {
      let next = children[j4];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last2, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last2 = children[children.length - 1]) instanceof MarkView && last2.mark.eq(view.mark)) {
      joinInlineInto(last2, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    let before3 = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view2, pos2) {
      for (let i4 = 0, off = 0; i4 < view2.children.length && off <= pos2; i4++) {
        let child = view2.children[i4], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && (side > 0 || onSameLine(after, child))) && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
            before3 = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view, pos);
    let target = (side < 0 ? before3 : after) || before3 || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before3 ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    let last2 = view.dom.lastChild;
    if (!last2)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last2);
    return rects[rects.length - 1] || null;
  }
  function onSameLine(a3, b2) {
    let posA = a3.coordsAt(0, 1), posB = b2.coordsAt(0, 1);
    return posA && posB && posB.top < posA.bottom;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  var noAttrs = /* @__PURE__ */ Object.create(null);
  function attrsEq(a3, b2, ignore) {
    if (a3 == b2)
      return true;
    if (!a3)
      a3 = noAttrs;
    if (!b2)
      b2 = noAttrs;
    let keysA = Object.keys(a3), keysB = Object.keys(b2);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
      return false;
    for (let key of keysA) {
      if (key != ignore && (keysB.indexOf(key) == -1 || a3[key] !== b2[key]))
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs)) {
          changed = true;
          if (name2 == "style")
            dom.style.cssText = "";
          else
            dom.removeAttribute(name2);
        }
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2])) {
          changed = true;
          if (name2 == "style")
            dom.style.cssText = attrs[name2];
          else
            dom.setAttribute(name2, attrs[name2]);
        }
    }
    return changed;
  }
  function getAttrs(dom) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let i4 = 0; i4 < dom.attributes.length; i4++) {
      let attr = dom.attributes[i4];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }
  var WidgetType = class {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) {
      return false;
    }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view) {
      return false;
    }
    /**
    @internal
    */
    compare(other2) {
      return this == other2 || this.constructor == other2.constructor && this.eq(other2);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() {
      return -1;
    }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() {
      return 0;
    }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event2) {
      return true;
    }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queriedless than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) {
      return null;
    }
    /**
    @internal
    */
    get isHidden() {
      return false;
    }
    /**
    @internal
    */
    get editable() {
      return false;
    }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() {
      return false;
    }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
      let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block2 = !!spec.block;
      side += block2 && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block2, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
      let block2 = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start, end } = getInclusive(spec, block2);
        startSide = (start ? block2 ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block2 ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block2, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
      return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class _MarkDecoration extends Decoration {
    constructor(spec) {
      let { start, end } = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other2) {
      var _a2, _b;
      return this == other2 || other2 instanceof _MarkDecoration && this.tagName == other2.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other2.class || ((_b = other2.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other2.attrs, "class");
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class _LineDecoration extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other2) {
      return other2 instanceof _LineDecoration && this.spec.class == other2.spec.class && attrsEq(this.spec.attributes, other2.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class _PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block2, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block2;
      this.isReplace = isReplace;
      this.mapMode = !block2 ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
      return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other2) {
      return other2 instanceof _PointDecoration && widgetsEq(this.widget, other2.widget) && this.block == other2.block && this.startSide == other2.startSide && this.endSide == other2.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block2 = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
      start = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block2, end: end !== null && end !== void 0 ? end : block2 };
  }
  function widgetsEq(a3, b2) {
    return a3 == b2 || !!(a3 && b2 && a3.compare(b2));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last2 = ranges.length - 1;
    if (last2 >= 0 && ranges[last2] + margin >= from)
      ranges[last2] = Math.max(ranges[last2], to);
    else
      ranges.push(from, to);
  }
  var LineView = class _LineView extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof _LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new _LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i: i4, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i4].split(off), 0);
        this.children[i4].merge(off, this.children[i4].length, null, false, 0, 0);
        i4++;
      }
      for (let j4 = i4; j4 < this.children.length; j4++)
        end.append(this.children[j4], 0);
      while (i4 > 0 && this.children[i4 - 1].length == 0)
        this.children[--i4].destroy();
      this.children.length = i4;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other2) {
      if (!this.dom)
        return;
      this.markDirty();
      other2.setDOM(this.dom);
      other2.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.flags & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view, track);
      let last2 = this.dom.lastChild;
      while (last2 && ContentView.get(last2) instanceof MarkView)
        last2 = last2.lastChild;
      if (!last2 || !this.length || last2.nodeName != "BR" && ((_a2 = ContentView.get(last2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
        if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
          let dist2 = (height - heightOracle.textHeight) / 2;
          return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
        }
      }
      return rect;
    }
    become(other2) {
      return other2 instanceof _LineView && this.children.length == 0 && other2.children.length == 0 && attrsEq(this.attrs, other2.attrs) && this.breakAfter == other2.breakAfter;
    }
    covers() {
      return true;
    }
    static find(docView, pos) {
      for (let i4 = 0, off = 0; i4 < docView.children.length; i4++) {
        let block2 = docView.children[i4], end = off + block2.length;
        if (end >= pos) {
          if (block2 instanceof _LineView)
            return block2;
          if (end > pos)
            break;
        }
        off = end + block2.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class _BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
      super();
      this.widget = widget;
      this.length = length;
      this.deco = deco;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new _BlockWidgetView(this.widget, len, this.deco);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other2) {
      if (other2 instanceof _BlockWidgetView && other2.widget.constructor == this.widget.constructor) {
        if (!other2.widget.compare(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other2.widget;
        this.length = other2.length;
        this.deco = other2.deco;
        this.breakAfter = other2.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event2) {
      return this.widget.ignoreEvent(event2);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      if (this.widget instanceof BlockGapWidget)
        return null;
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
    covers(side) {
      let { startSide, endSide } = this.deco;
      return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
  };
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt2 = document.createElement("div");
      elt2.className = "cm-gap";
      this.updateDOM(elt2);
      return elt2;
    }
    eq(other2) {
      return other2.height == this.height;
    }
    updateDOM(elt2) {
      elt2.style.height = this.height + "px";
      return true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  };
  var ContentBuilder = class _ContentBuilder {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last2 = this.content[this.content.length - 1];
      return !(last2.breakAfter || last2 instanceof BlockWidgetView && last2.deco.endSide < 0);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
        this.flushBuffer();
      else
        this.pendingBuffer = 0;
      if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(
          this.text.length - this.textOff,
          length,
          512
          /* T.Chunk */
        );
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index2) {
      if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          if (deco.startSide > 0 && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
        } else {
          let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer)
            this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text2, from, to, decorations2, dynamicDecorationMap) {
      let builder = new _ContentBuilder(text2, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag4) {
      super();
      this.tag = tag4;
    }
    eq(other2) {
      return other2.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt2) {
      return elt2.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  };
  NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
  NullWidget.block = /* @__PURE__ */ new NullWidget("div");
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i4 = 0; i4 < str.length; i4++)
      result.push(1 << +str[i4]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p3 of ["()", "[]", "{}"]) {
    let l4 = /* @__PURE__ */ p3.charCodeAt(0), r3 = /* @__PURE__ */ p3.charCodeAt(1);
    Brackets[l4] = r3;
    Brackets[r3] = -l4;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    /**
    The direction of this span.
    */
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    /**
    @internal
    */
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    /**
    @internal
    */
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    /**
    @internal
    */
    forward(forward, dir) {
      return forward == (this.dir == dir);
    }
    /**
    @internal
    */
    static find(order, index2, level, assoc) {
      let maybe = -1;
      for (let i4 = 0; i4 < order.length; i4++) {
        let span = order[i4];
        if (span.from <= index2 && span.to >= index2) {
          if (span.level == level)
            return i4;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level))
            maybe = i4;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  function isolatesEq(a3, b2) {
    if (a3.length != b2.length)
      return false;
    for (let i4 = 0; i4 < a3.length; i4++) {
      let iA = a3[i4], iB = b2[i4];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
        return false;
    }
    return true;
  }
  var types = [];
  function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      let prevType = iI ? 256 : outerType;
      for (let i4 = from, prev = prevType, prevStrong = prevType; i4 < to; i4++) {
        let type3 = charType(line.charCodeAt(i4));
        if (type3 == 512)
          type3 = prev;
        else if (type3 == 8 && prevStrong == 4)
          type3 = 16;
        types[i4] = type3 == 4 ? 2 : type3;
        if (type3 & 7)
          prevStrong = type3;
        prev = type3;
      }
      for (let i4 = from, prev = prevType, prevStrong = prevType; i4 < to; i4++) {
        let type3 = types[i4];
        if (type3 == 128) {
          if (i4 < to - 1 && prev == types[i4 + 1] && prev & 24)
            type3 = types[i4] = prev;
          else
            types[i4] = 256;
        } else if (type3 == 64) {
          let end = i4 + 1;
          while (end < to && types[end] == 64)
            end++;
          let replace2 = i4 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
          for (let j4 = i4; j4 < end; j4++)
            types[j4] = replace2;
          i4 = end - 1;
        } else if (type3 == 8 && prevStrong == 1) {
          types[i4] = 1;
        }
        prev = type3;
        if (type3 & 7)
          prevStrong = type3;
      }
    }
  }
  function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i4 = from, ch, br2, type3; i4 < to; i4++) {
        if (br2 = Brackets[ch = line.charCodeAt(i4)]) {
          if (br2 < 0) {
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br2) {
                let flags = BracketStack[sJ + 2];
                let type4 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                if (type4)
                  types[i4] = types[BracketStack[sJ]] = type4;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189) {
            break;
          } else {
            BracketStack[sI++] = i4;
            BracketStack[sI++] = ch;
            BracketStack[sI++] = context;
          }
        } else if ((type3 = types[i4]) == 2 || type3 == 1) {
          let embed = type3 == outerType;
          context = embed ? 0 : 1;
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            let cur2 = BracketStack[sJ + 2];
            if (cur2 & 2)
              break;
            if (embed) {
              BracketStack[sJ + 2] |= 2;
            } else {
              if (cur2 & 4)
                break;
              BracketStack[sJ + 2] |= 4;
            }
          }
        }
      }
    }
  }
  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i4 = from; i4 < to; ) {
        let type3 = types[i4];
        if (type3 == 256) {
          let end = i4 + 1;
          for (; ; ) {
            if (end == to) {
              if (iI == isolates.length)
                break;
              end = isolates[iI++].to;
              to = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256) {
              end++;
            } else {
              break;
            }
          }
          let beforeL = prev == 1;
          let afterL = (end < rTo ? types[end] : outerType) == 1;
          let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
          for (let j4 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j4 > i4; ) {
            if (j4 == fromJ) {
              j4 = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j4] = replace2;
          }
          i4 = end;
        } else {
          prev = type3;
          i4++;
        }
      }
    }
  }
  function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 : 1;
    if (level % 2 == baseLevel % 2) {
      for (let iCh = from, iI = 0; iCh < to; ) {
        let sameDir = true, isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          let next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum)
              break run;
            let iso = isolates[iI];
            if (!sameDir)
              for (let upto = iso.to, jI = iI + 1; ; ) {
                if (upto == to)
                  break run;
                if (jI < isolates.length && isolates[jI].from == upto)
                  upto = isolates[jI++].to;
                else if (types[upto] == ourType)
                  break run;
                else
                  break;
              }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh)
                order.push(new BidiSpan(iCh, iso.from, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
        if (recurse)
          emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
        else if (iCh < iScan)
          order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      for (let iCh = to, iI = isolates.length; iCh > from; ) {
        let sameDir = true, isNum = false;
        if (!iI || iCh > isolates[iI - 1].to) {
          let next = types[iCh - 1];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI && iScan == isolates[iI - 1].to) {
            if (isNum)
              break run;
            let iso = isolates[--iI];
            if (!sameDir)
              for (let upto = iso.from, jI = iI; ; ) {
                if (upto == from)
                  break run;
                if (jI && isolates[jI - 1].to == upto)
                  upto = isolates[--jI].from;
                else if (types[upto - 1] == ourType)
                  break run;
                else
                  break;
              }
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.to < iCh)
                order.push(new BidiSpan(iso.to, iCh, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.from;
            }
            iScan = iso.from;
          } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
            break;
          } else {
            iScan--;
          }
        }
        if (recurse)
          emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
        else if (iScan < iCh)
          order.push(new BidiSpan(iScan, iCh, localLevel));
        iCh = iScan;
      }
    }
  }
  function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = level % 2 ? 2 : 1;
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
  }
  function computeOrder(line, direction, isolates) {
    if (!line)
      return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
      return trivialOrder(line.length);
    if (isolates.length)
      while (line.length > types.length)
        types[types.length] = 256;
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    if (startIndex == spanEnd) {
      let nextI = spanI += forward ? 1 : -1;
      if (nextI < 0 || nextI >= order.length)
        return null;
      span = order[spanI = nextI];
      startIndex = span.side(!forward, dir);
      spanEnd = span.side(forward, dir);
    }
    let nextIndex = findClusterBreak2(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to)
      nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
  }
  function autoDirection(text2, from, to) {
    for (let i4 = from; i4 < to; i4++) {
      let type3 = charType(text2.charCodeAt(i4));
      if (type3 == 1)
        return LTR;
      if (type3 == 2 || type3 == 4)
        return RTL;
    }
    return LTR;
  }
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var focusChangeEffect = /* @__PURE__ */ Facet.define();
  var clipboardInputFilter = /* @__PURE__ */ Facet.define();
  var clipboardOutputFilter = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x3) => x3)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x3) => x3)
  });
  var scrollHandler = /* @__PURE__ */ Facet.define();
  var ScrollTarget = class _ScrollTarget {
    constructor(range, y3 = "nearest", x3 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
      this.range = range;
      this.y = y3;
      this.x = x3;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
      this.isSnapshot = isSnapshot;
    }
    map(changes) {
      return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
      return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t4, ch) => t4.map(ch) });
  var setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class _ViewPlugin {
    constructor(id2, create2, domEventHandlers, domEventObservers, buildExtensions) {
      this.id = id2;
      this.create = create2;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create2, spec) {
      const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
      return new _ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
      return _ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e3) {
            logException(view.state, e3, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e3) {
            logException(update.state, e3, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_3) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e3) {
          logException(view.state, e3, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var outerDecorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
  function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
      return isolates;
    let sets = isolates.map((i4) => i4 instanceof Function ? i4(view) : i4);
    let result = [];
    RangeSet.spans(sets, line.from, line.to, {
      point() {
      },
      span(fromDoc, toDoc, active, open) {
        let from = fromDoc - line.from, to = toDoc - line.from;
        let level = result;
        for (let i4 = active.length - 1; i4 >= 0; i4--, open--) {
          let direction = active[i4].spec.bidiIsolate, update;
          if (direction == null)
            direction = autoDirection(line.text, from, to);
          if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
            update.to = to;
            level = update.inner;
          } else {
            let add2 = { from, to, direction, inner: [] };
            level.push(add2);
            level = add2.inner;
          }
        }
      }
    });
    return result;
  }
  var scrollMargins = /* @__PURE__ */ Facet.define();
  function getScrollMargins(view) {
    let left = 0, right = 0, top2 = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
      let m3 = source(view);
      if (m3) {
        if (m3.left != null)
          left = Math.max(left, m3.left);
        if (m3.right != null)
          right = Math.max(right, m3.right);
        if (m3.top != null)
          top2 = Math.max(top2, m3.top);
        if (m3.bottom != null)
          bottom = Math.max(bottom, m3.bottom);
      }
    }
    return { left, right, top: top2, bottom };
  }
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class _ChangedRange {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other2) {
      return new _ChangedRange(Math.min(this.fromA, other2.fromA), Math.max(this.toA, other2.toA), Math.min(this.fromB, other2.fromB), Math.max(this.toB, other2.toB));
    }
    addToSet(set3) {
      let i4 = set3.length, me = this;
      for (; i4 > 0; i4--) {
        let range = set3[i4 - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set3.splice(i4 - 1, 1);
      }
      set3.splice(i4, 0, me);
      return set3;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class _ViewUpdate {
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
      return new _ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    /**
    Returns true when
    [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
    and the viewport change is not just the result of mapping it in
    response to document changes.
    */
    get viewportMoved() {
      return (this.flags & 8) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
      return this.docChanged || (this.flags & (16 | 2)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
      return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    /**
    @internal
    */
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var DocView = class extends ContentView {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(view) {
      super();
      this.view = view;
      this.decorations = [];
      this.dynamicDecorationMap = [false];
      this.domChanged = null;
      this.hasComposition = null;
      this.markedForComposition = /* @__PURE__ */ new Set();
      this.editContextFormatting = Decoration.none;
      this.lastCompositionAfterCursor = false;
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update) {
      var _a2;
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      this.updateEditContextFormatting(update);
      let readCompositionAt = -1;
      if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
        if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
          readCompositionAt = this.domChanged.newSel.head;
        else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
          readCompositionAt = update.state.selection.main.head;
      }
      let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
      this.domChanged = null;
      if (this.hasComposition) {
        this.markedForComposition.clear();
        let { from, to } = this.hasComposition;
        changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
      }
      this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
      if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (!(this.flags & 7) && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length, composition);
        if (update.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength, composition);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(this.view, track);
        this.flags &= ~7;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      this.markedForComposition.forEach(
        (cView) => cView.flags &= ~8
        /* ViewFlag.Composition */
      );
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
      let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
      let cursor2 = this.childCursor(oldLength);
      for (let i4 = ranges.length - 1; ; i4--) {
        let next = i4 >= 0 ? ranges[i4] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
        if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
          let before3 = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
          let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
          breakAtStart = before3.breakAtStart;
          openStart = before3.openStart;
          openEnd = after.openEnd;
          let compLine = this.compositionView(composition);
          if (after.breakAtStart) {
            compLine.breakAfter = 1;
          } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
            compLine.breakAfter = after.content[0].breakAfter;
            after.content.shift();
          }
          if (before3.content.length && compLine.merge(0, 0, before3.content[before3.content.length - 1], true, 0, before3.openEnd)) {
            before3.content.pop();
          }
          content2 = before3.content.concat(compLine).concat(after.content);
        } else {
          ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
        }
        let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
      if (composition)
        this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
      this.editContextFormatting = this.editContextFormatting.map(update.changes);
      for (let tr of update.transactions)
        for (let effect of tr.effects)
          if (effect.is(setEditContextFormatting)) {
            this.editContextFormatting = effect.value;
          }
    }
    compositionView(composition) {
      let cur2 = new TextView(composition.text.nodeValue);
      cur2.flags |= 8;
      for (let { deco } of composition.marks)
        cur2 = new MarkView(deco, [cur2], cur2.length);
      let line = new LineView();
      line.append(cur2, 0);
      return line;
    }
    fixCompositionDOM(composition) {
      let fix = (dom, cView2) => {
        cView2.flags |= 8 | (cView2.children.some(
          (c3) => c3.flags & 7
          /* ViewFlag.Dirty */
        ) ? 1 : 0);
        this.markedForComposition.add(cView2);
        let prev = ContentView.get(dom);
        if (prev && prev != cView2)
          prev.dom = null;
        cView2.setDOM(dom);
      };
      let pos = this.childPos(composition.range.fromB, 1);
      let cView = this.children[pos.i];
      fix(composition.line, cView);
      for (let i4 = composition.marks.length - 1; i4 >= -1; i4--) {
        pos = cView.childPos(pos.off, 1);
        cView = cView.children[pos.i];
        fix(i4 >= 0 ? composition.marks[i4].node : composition.text, cView);
      }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
      let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
      if (!(focused || fromPointer || selectionNotFocus))
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.moveToLine(this.domAtPos(main.anchor));
      let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
      if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel) ;
          else if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text2 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                if (text2)
                  anchor = new DOMPos(text2.node, text2.offset);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
              rawSel.caretBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_3) {
            }
          } else {
            let range = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
          if (selectionNotFocus && this.view.root.activeElement == this.dom) {
            this.dom.blur();
            if (activeElt)
              activeElt.focus();
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    // If a zero-length widget is inserted next to the cursor during
    // composition, avoid moving it across it and disrupting the
    // composition.
    suppressWidgetCursorChange(sel, cursor2) {
      return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view } = this, cursor2 = view.state.selection.main;
      let sel = getSelection(view.root);
      let { anchorNode, anchorOffset } = view.observer.selectionRange;
      if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor2.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
        return;
      let before3 = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
      if (!before3 || !after || before3.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor2.head + cursor2.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      let newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
      let dom = this.dom, newPos;
      if (pos.node != dom)
        return pos;
      for (let i4 = pos.offset; !newPos && i4 < dom.childNodes.length; i4++) {
        let view = ContentView.get(dom.childNodes[i4]);
        if (view instanceof LineView)
          newPos = view.domAtPos(0);
      }
      for (let i4 = pos.offset - 1; !newPos && i4 >= 0; i4--) {
        let view = ContentView.get(dom.childNodes[i4]);
        if (view instanceof LineView)
          newPos = view.domAtPos(view.length);
      }
      return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
      for (let cur2 = dom; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset2) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset2) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i: i4, off } = this.childCursor().findPos(pos, -1);
      for (; i4 < this.children.length - 1; ) {
        let child = this.children[i4];
        if (off < child.length || child instanceof LineView)
          break;
        i4++;
        off = 0;
      }
      return this.children[i4].domAtPos(off);
    }
    coordsAt(pos, side) {
      let best = null, bestPos = 0;
      for (let off = this.length, i4 = this.children.length - 1; i4 >= 0; i4--) {
        let child = this.children[i4], end = off - child.breakAfter, start = end - child.length;
        if (end < pos)
          break;
        if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
          best = child;
          bestPos = start;
        } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
          if (child.deco.startSide < 0)
            break;
          else if (i4)
            best = null;
        }
        off = start;
      }
      return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
      let { i: i4, off } = this.childPos(pos, 1), child = this.children[i4];
      if (!(child instanceof LineView))
        return null;
      while (child.children.length) {
        let { i: i5, off: childOff } = child.childPos(off, 1);
        for (; ; i5++) {
          if (i5 == child.children.length)
            return null;
          if ((child = child.children[i5]).length)
            break;
        }
        off = childOff;
      }
      if (!(child instanceof TextView))
        return null;
      let end = findClusterBreak2(child.text, off);
      if (end == off)
        return null;
      let rects = textRange(child.dom, off, end).getClientRects();
      for (let i5 = 0; i5 < rects.length; i5++) {
        let rect = rects[i5];
        if (i5 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
          return rect;
      }
      return null;
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i4 = 0; i4 < this.children.length; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last2 = child.dom.lastChild;
            let rects = last2 ? clientRectsFor(last2) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i: i4 } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i4].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.style.position = "absolute";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
      let i4 = this.children.length;
      if (i4)
        pos -= this.children[--i4].length;
      return new ChildCursor(this.children, pos, i4);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i4 = 0; ; i4++) {
        let next = i4 == vs.viewports.length ? null : vs.viewports[i4];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let i4 = 1;
      let allDeco = this.view.state.facet(decorations).map((d3) => {
        let dynamic = this.dynamicDecorationMap[i4++] = typeof d3 == "function";
        return dynamic ? d3(this.view) : d3;
      });
      let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d3, i5) => {
        let dynamic = typeof d3 == "function";
        if (dynamic)
          dynamicOuter = true;
        return dynamic ? d3(this.view) : d3;
      });
      if (outerDeco.length) {
        this.dynamicDecorationMap[i4++] = dynamicOuter;
        allDeco.push(RangeSet.join(outerDeco));
      }
      this.decorations = [
        this.editContextFormatting,
        ...allDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
      while (i4 < this.decorations.length)
        this.dynamicDecorationMap[i4++] = false;
      return this.decorations;
    }
    scrollIntoView(target) {
      if (target.isSnapshot) {
        let ref = this.view.viewState.lineBlockAt(target.range.head);
        this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
        this.view.scrollDOM.scrollLeft = target.xMargin;
        return;
      }
      for (let handler of this.view.state.facet(scrollHandler)) {
        try {
          if (handler(this.view, target.range, target))
            return true;
        } catch (e3) {
          logException(this.view.state, e3, "scroll handler");
        }
      }
      let { range } = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other2;
      if (!rect)
        return;
      if (!range.empty && (other2 = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other2.left),
          top: Math.min(rect.top, other2.top),
          right: Math.max(rect.right, other2.right),
          bottom: Math.max(rect.bottom, other2.bottom)
        };
      let margins = getScrollMargins(this.view);
      let targetRect = {
        left: rect.left - margins.left,
        top: rect.top - margins.top,
        right: rect.right + margins.right,
        bottom: rect.bottom + margins.bottom
      };
      let { offsetWidth, offsetHeight } = this.view.scrollDOM;
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
      let descAfter = ContentView.get(textAfter.node);
      if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
        textNode = textAfter;
      } else if (view.docView.lastCompositionAfterCursor) {
        let descBefore = ContentView.get(textBefore.node);
        if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
          textNode = textAfter;
      }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
      return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
  }
  function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
      return null;
    let { node: textNode, from, to } = found, text2 = textNode.nodeValue;
    if (/[\n\r]/.test(text2))
      return null;
    if (view.state.doc.sliceString(found.from, found.to) != text2)
      return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks2 = [];
    for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
      let parentView = ContentView.get(parent);
      if (parentView instanceof MarkView)
        marks2.push({ node: parent, deco: parentView.mark });
      else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
        return { range, text: textNode, marks: marks2, line: parent };
      else if (parent != view.contentDOM)
        marks2.push({ node: parent, deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent),
          tagName: parent.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
  function nextToUneditable(node, offset2) {
    if (node.nodeType != 1)
      return 0;
    return (offset2 && node.childNodes[offset2 - 1].contentEditable == "false" ? 1 : 0) | (offset2 < node.childNodes.length && node.childNodes[offset2].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
    boundChange(pos) {
      addRange(pos, pos, this.changes);
    }
  };
  function findChangedDeco(a3, b2, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a3, b2, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
      changes.iterChangedRanges((from, to) => {
        if (from < composition.to && to > composition.from)
          touched = true;
      });
    return touched;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak2(line.text, linePos, false);
    else
      to = findClusterBreak2(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak2(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak2(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x3, rect) {
    return rect.left > x3 ? rect.left - x3 : Math.max(0, x3 - rect.right);
  }
  function getdy(y3, rect) {
    return rect.top > y3 ? rect.top - y3 : Math.max(0, y3 - rect.bottom);
  }
  function yOverlap(a3, b2) {
    return a3.top < b2.bottom - 1 && a3.bottom > b2.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x3, y3) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i4 = 0; i4 < rects.length; i4++) {
        let rect = rects[i4];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x3, rect), dy = getdy(y3, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x3, y3) : domPosAtCoords(child, x3, y3);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y3 < rect.top ? -1 : 1 : dx ? x3 < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i4 < rects.length - 1 : i4 > 0);
        }
        if (dx == 0) {
          if (y3 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y3 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y3) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y3) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x3));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y3);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y3);
    let offset2 = Array.prototype.indexOf.call(parent.childNodes, closest) + (x3 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset: offset2 };
  }
  function domPosInText(node, x3, y3) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i4 = 0; i4 < len; i4++) {
      let rects = textRange(node, i4, i4 + 1).getClientRects();
      for (let j4 = 0; j4 < rects.length; j4++) {
        let rect = rects[j4];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x3 - rect.left;
        let dy = (rect.top > y3 ? rect.top - y3 : y3 - rect.bottom) - 1;
        if (rect.left - 1 <= x3 && rect.right + 1 >= x3 && dy < closestDY) {
          let right = x3 >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i4).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i4 + (after ? 1 : 0) };
          closestOffset = i4 + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view, coords, precise, bias = -1) {
    var _a2, _b;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block2, { docHeight } = view.viewState;
    let { x: x3, y: y3 } = coords, yOffset = y3 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
      block2 = view.elementAtHeight(yOffset);
      if (block2.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block2.bottom + halfLine : block2.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y3 = docTop + yOffset;
    let lineStart = block2.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block2, x3, y3);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block2, x3, y3);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element = root.elementFromPoint(x3, y3);
    if (element && !view.contentDOM.contains(element))
      element = null;
    if (!element) {
      x3 = Math.max(content2.left + 1, Math.min(content2.right - 1, x3));
      element = root.elementFromPoint(x3, y3);
      if (element && !view.contentDOM.contains(element))
        element = null;
    }
    let node, offset2 = -1;
    if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x3, y3);
        if (pos)
          ({ offsetNode: node, offset: offset2 } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x3, y3);
        if (range) {
          ({ startContainer: node, startOffset: offset2 } = range);
          if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset2, x3) || browser.chrome && isSuspiciousChromeCaretResult(node, offset2, x3))
            node = void 0;
        }
      }
      if (node)
        offset2 = Math.min(maxOffset(node), offset2);
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block2.top + block2.height / 2 ? block2.to : block2.from;
      ({ node, offset: offset2 } = domPosAtCoords(line.dom, x3, y3));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
      return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset2) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view, contentRect, block2, x3, y3) {
    let into = Math.round((x3 - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block2.height > view.defaultLineHeight * 1.5) {
      let textHeight = view.viewState.heightOracle.textHeight;
      let line = Math.floor((y3 - block2.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block2.from, block2.to);
    return block2.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset2, x3) {
    let len;
    if (node.nodeType != 3 || offset2 != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x3;
  }
  function isSuspiciousChromeCaretResult(node, offset2, x3) {
    if (offset2 != 0)
      return false;
    for (let cur2 = node; ; ) {
      let parent = cur2.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur2 = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x3 - rect.left > 5;
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l4 of line.type) {
        if (l4.to > pos || l4.to == pos && (l4.to == line.to || l4.type == BlockType.Text))
          return l4;
      }
    return line;
  }
  function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
  }
  function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur2 = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur2;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = view.visualLineSide(line, !forward);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist2 + extra) * dir;
      let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
        let charRect = view.docView.coordsForChar(pos);
        let assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, void 0, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    for (; ; ) {
      let moved = 0;
      for (let set3 of atoms) {
        set3.between(pos - 1, pos + 1, (from, to, value) => {
          if (pos > from && pos < to) {
            let side = moved || bias || (pos - from < to - pos ? -1 : 1);
            pos = side < 0 ? from : to;
            moved = side;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f4) => f4(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text2) {
      this.text += text2;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start)
        return this;
      let parent = start.parentNode;
      for (let cur2 = start; ; ) {
        this.findPointBefore(parent, cur2);
        let oldLen = this.text.length;
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen)
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text2 = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text2.length);
      for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m3;
        if (this.lineSeparator) {
          nextBreak = text2.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m3 = re2.exec(text2)) {
          nextBreak = m3.index;
          breakSize = m3[0].length;
        }
        this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i4 = fromView.iter(); !i4.next().done; ) {
          if (i4.lineBreak)
            this.lineBreak();
          else
            this.append(i4.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, length) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
  };
  function isAtEnd(parent, node, offset2) {
    for (; ; ) {
      if (!node || offset2 < maxOffset(node))
        return false;
      if (node == parent)
        return true;
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    }
  }
  var DOMPoint = class {
    constructor(node, offset2) {
      this.node = node;
      this.offset = offset2;
      this.pos = -1;
    }
  };
  var DOMChange = class {
    constructor(view, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      this.domChanged = start > -1;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      if (view.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        let vp = view.viewport;
        if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
          let from = Math.min(head, anchor), to = Math.max(head, anchor);
          let offFrom = vp.from - from, offTo = vp.to - to;
          if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
            head = 0;
            anchor = view.state.doc.length;
          }
        }
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      let { from, to } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change) {
      return applyDOMChangeInner(view, change, newSel, lastKey);
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser.ios && view.inputState.flushIOSKey(change))
      return true;
    let sel = view.state.selection.main;
    if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
    // after a completion when you press enter
    (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return true;
    let text2 = change.insert.toString();
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some((h3) => h3(view, change.from, change.to, text2, defaultInsert)))
      view.dispatch(defaultInsert());
    return true;
  }
  function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      let before3 = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before3 + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change.from, change.to);
        let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
        if (composition) {
          let dLen = change.insert.length - (change.to - change.from);
          compositionRange = { from: composition.from, to: composition.to - dLen };
        } else {
          compositionRange = view.state.doc.lineAt(sel.head);
        }
        let offset2 = sel.to - change.to, size = sel.to - sel.from;
        tr = startState.changeByRange((range) => {
          if (range.from == sel.from && range.to == sel.to)
            return { changes, range: mainSel || range.map(changes) };
          let to = range.to - offset2, from = to - replaced.length;
          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          range.to >= compositionRange.from && range.from <= compositionRange.to)
            return { range };
          let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
      view.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
  }
  function findDiff(a3, b2, preferredPos, preferredSide) {
    let minLen = Math.min(a3.length, b2.length);
    let from = 0;
    while (from < minLen && a3.charCodeAt(from) == b2.charCodeAt(from))
      from++;
    if (from == minLen && a3.length == b2.length)
      return null;
    let toA = a3.length, toB = b2.length;
    while (toA > 0 && toB > 0 && a3.charCodeAt(toA - 1) == b2.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a3.length < b2.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var InputState = class {
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    constructor(view) {
      this.view = view;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.pendingIOSKey = void 0;
      this.tabFocusMode = -1;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.compositionPendingKey = false;
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.draggedContent = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.notifiedFocused = view.hasFocus;
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
      if (browser.gecko)
        firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event2) {
      if (!eventBelongsToEditor(this.view, event2) || this.ignoreDuringComposition(event2))
        return;
      if (event2.type == "keydown" && this.keydown(event2))
        return;
      if (this.view.updateState != 0)
        Promise.resolve().then(() => this.runHandlers(event2.type, event2));
      else
        this.runHandlers(event2.type, event2);
    }
    runHandlers(type3, event2) {
      let handlers2 = this.handlers[type3];
      if (handlers2) {
        for (let observer of handlers2.observers)
          observer(this.view, event2);
        for (let handler of handlers2.handlers) {
          if (event2.defaultPrevented)
            break;
          if (handler(this.view, event2)) {
            event2.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(plugins) {
      let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
      for (let type3 in handlers2)
        if (type3 != "scroll") {
          let passive = !handlers2[type3].handlers.length;
          let exists = prev[type3];
          if (exists && passive != !exists.handlers.length) {
            dom.removeEventListener(type3, this.handleEvent);
            exists = null;
          }
          if (!exists)
            dom.addEventListener(type3, this.handleEvent, { passive });
        }
      for (let type3 in prev)
        if (type3 != "scroll" && !handlers2[type3])
          dom.removeEventListener(type3, this.handleEvent);
      this.handlers = handlers2;
    }
    keydown(event2) {
      this.lastKeyCode = event2.keyCode;
      this.lastKeyTime = Date.now();
      if (event2.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        return true;
      if (this.tabFocusMode > 0 && event2.keyCode != 27 && modifierCodes.indexOf(event2.keyCode) < 0)
        this.tabFocusMode = -1;
      if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
        this.view.observer.delayAndroidKey(event2.key, event2.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
        this.pendingIOSKey = pending || event2;
        setTimeout(() => this.flushIOSKey(), 250);
        return true;
      }
      if (event2.keyCode != 229)
        this.view.observer.forceFlush();
      return false;
    }
    flushIOSKey(change) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
    }
    ignoreDuringComposition(event2) {
      if (!/^key/.test(event2.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
        this.compositionPendingKey = false;
        return true;
      }
      return false;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      this.view.observer.update(update);
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (this.draggedContent && update.docChanged)
        this.draggedContent = this.draggedContent.map(update.changes);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  function bindHandler(plugin, handler) {
    return (view, event2) => {
      try {
        return handler.call(plugin, event2, view);
      } catch (e3) {
        logException(view.state, e3);
      }
    };
  }
  function computeHandlers(plugins) {
    let result = /* @__PURE__ */ Object.create(null);
    function record(type3) {
      return result[type3] || (result[type3] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
      let spec = plugin.spec;
      if (spec && spec.domEventHandlers)
        for (let type3 in spec.domEventHandlers) {
          let f4 = spec.domEventHandlers[type3];
          if (f4)
            record(type3).handlers.push(bindHandler(plugin.value, f4));
        }
      if (spec && spec.domEventObservers)
        for (let type3 in spec.domEventObservers) {
          let f4 = spec.domEventObservers[type3];
          if (f4)
            record(type3).observers.push(bindHandler(plugin.value, f4));
        }
    }
    for (let type3 in handlers)
      record(type3).handlers.push(handlers[type3]);
    for (let type3 in observers)
      record(type3).observers.push(observers[type3]);
    return result;
  }
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var dragScrollMargin = 6;
  function dragScrollSpeed(dist2) {
    return Math.max(0, dist2) * 0.7 + 8;
  }
  function dist(a3, b2) {
    return Math.max(Math.abs(a3.clientX - b2.clientX), Math.abs(a3.clientY - b2.clientY));
  }
  var MouseSelection = class {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.startEvent = startEvent;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = { x: 0, y: 0 };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParents = scrollableParents(view.contentDOM);
      this.atoms = view.state.facet(atomicRanges).map((f4) => f4(view));
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event2) {
      if (this.dragging === false)
        this.select(event2);
    }
    move(event2) {
      if (event2.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && dist(this.startEvent, event2) < 10)
        return;
      this.select(this.lastEvent = event2);
      let sx = 0, sy = 0;
      let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
      if (this.scrollParents.x)
        ({ left, right } = this.scrollParents.x.getBoundingClientRect());
      if (this.scrollParents.y)
        ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
      let margins = getScrollMargins(this.view);
      if (event2.clientX - margins.left <= left + dragScrollMargin)
        sx = -dragScrollSpeed(left - event2.clientX);
      else if (event2.clientX + margins.right >= right - dragScrollMargin)
        sx = dragScrollSpeed(event2.clientX - right);
      if (event2.clientY - margins.top <= top2 + dragScrollMargin)
        sy = -dragScrollSpeed(top2 - event2.clientY);
      else if (event2.clientY + margins.bottom >= bottom - dragScrollMargin)
        sy = dragScrollSpeed(event2.clientY - bottom);
      this.setScrollSpeed(sx, sy);
    }
    up(event2) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event2.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = { x: sx, y: sy };
      if (sx || sy) {
        if (this.scrolling < 0)
          this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      let { x: x3, y: y3 } = this.scrollSpeed;
      if (x3 && this.scrollParents.x) {
        this.scrollParents.x.scrollLeft += x3;
        x3 = 0;
      }
      if (y3 && this.scrollParents.y) {
        this.scrollParents.y.scrollTop += y3;
        y3 = 0;
      }
      if (x3 || y3)
        this.view.win.scrollBy(x3, y3);
      if (this.dragging === false)
        this.select(this.lastEvent);
    }
    skipAtoms(sel) {
      let ranges = null;
      for (let i4 = 0; i4 < sel.ranges.length; i4++) {
        let range = sel.ranges[i4], updated = null;
        if (range.empty) {
          let pos = skipAtomicRanges(this.atoms, range.from, 0);
          if (pos != range.from)
            updated = EditorSelection.cursor(pos, -1);
        } else {
          let from = skipAtomicRanges(this.atoms, range.from, -1);
          let to = skipAtomicRanges(this.atoms, range.to, 1);
          if (from != range.from || to != range.to)
            updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
        }
        if (updated) {
          if (!ranges)
            ranges = sel.ranges.slice();
          ranges[i4] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event2) {
      let { view } = this, selection2 = this.skipAtoms(this.style.get(event2, this.extend, this.multiple));
      if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
        this.view.dispatch({
          selection: selection2,
          userEvent: "select.pointer"
        });
      this.mustSelect = false;
    }
    update(update) {
      if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
        this.destroy();
      else if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event2) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
  }
  function dragMovesSelection(view, event2) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
  }
  function isInPrimarySelection(view, event2) {
    let { main } = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i4 = 0; i4 < rects.length; i4++) {
      let rect = rects[i4];
      if (rect.left <= event2.clientX && rect.right >= event2.clientX && rect.top <= event2.clientY && rect.bottom >= event2.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event2) {
    if (!event2.bubbles)
      return true;
    if (event2.defaultPrevented)
      return false;
    for (let node = event2.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event2))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var observers = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function textFilter(state, facet, text2) {
    for (let filter of state.facet(facet))
      text2 = filter(text2, state);
    return text2;
  }
  function doPaste(view, input) {
    input = textFilter(view.state, clipboardInputFilter, input);
    let { state } = view, changes, i4 = 1, text2 = state.toText(input);
    let byLine = text2.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r3) => r3.empty) && lastLinewiseCopy == text2.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return { range };
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text2.line(i4++).text : input) + state.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text2.line(i4++);
        return {
          changes: { from: range.from, to: range.to, insert: line.text },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text2);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = (view) => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
  };
  handlers.keydown = (view, event2) => {
    view.inputState.setSelectionOrigin("select");
    if (event2.keyCode == 27 && view.inputState.tabFocusMode != 0)
      view.inputState.tabFocusMode = Date.now() + 2e3;
    return false;
  };
  observers.touchstart = (view, e3) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view, event2) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event2);
      if (style)
        break;
    }
    if (!style && event2.button == 0)
      style = basicMouseSelection(view, event2);
    if (style) {
      let mustFocus = !view.hasFocus;
      view.inputState.startMouseSelection(new MouseSelection(view, event2, style, mustFocus));
      if (mustFocus)
        view.observer.ignore(() => {
          focusPreventScroll(view.contentDOM);
          let active = view.root.activeElement;
          if (active && !active.contains(view.contentDOM))
            active.blur();
        });
      let mouseSel = view.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event2);
        return mouseSel.dragging === false;
      }
    }
    return false;
  };
  function rangeForClick(view, pos, bias, type3) {
    if (type3 == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type3 == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var inside = (x3, y3, rect) => y3 >= rect.top && y3 <= rect.bottom && x3 >= rect.left && x3 <= rect.right;
  function findPositionSide(view, pos, x3, y3) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before3 = line.coordsAt(off, -1);
    if (before3 && inside(x3, y3, before3))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x3, y3, after))
      return 1;
    return before3 && before3.bottom >= y3 ? -1 : 1;
  }
  function queryPos(view, event2) {
    let pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event2.clientX, event2.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event2) {
    if (!BadMouseDetail)
      return event2.detail;
    let last2 = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event2;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event2.clientX) < 2 && Math.abs(last2.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event2) {
    let start = queryPos(view, event2), type3 = getClickType(event2);
    let startSel = view.state.selection;
    return {
      update(update) {
        if (update.docChanged) {
          start.pos = update.changes.mapPos(start.pos);
          startSel = startSel.map(update.changes);
        }
      },
      get(event3, extend, multiple) {
        let cur2 = queryPos(view, event3), removed;
        let range = rangeForClick(view, cur2.pos, cur2.bias, type3);
        if (start.pos != cur2.pos && !extend) {
          let startRange = rangeForClick(view, start.pos, start.bias, type3);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && type3 == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
          return removed;
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (let i4 = 0; i4 < sel.ranges.length; i4++) {
      let { from, to } = sel.ranges[i4];
      if (from <= pos && to >= pos)
        return EditorSelection.create(sel.ranges.slice(0, i4).concat(sel.ranges.slice(i4 + 1)), sel.mainIndex == i4 ? 0 : sel.mainIndex - (sel.mainIndex > i4 ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = (view, event2) => {
    let { selection: { main: range } } = view.state;
    if (event2.target.draggable) {
      let cView = view.docView.nearest(event2.target);
      if (cView && cView.isWidget) {
        let from = cView.posAtStart, to = from + cView.length;
        if (from >= range.to || to <= range.from)
          range = EditorSelection.range(from, to);
      }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
      inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event2.dataTransfer) {
      event2.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
      event2.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  handlers.dragend = (view) => {
    view.inputState.draggedContent = null;
    return false;
  };
  function dropText(view, event2, text2, direct) {
    text2 = textFilter(view.state, clipboardInputFilter, text2);
    if (!text2)
      return;
    let dropPos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event2) ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text2 };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
  }
  handlers.drop = (view, event2) => {
    if (!event2.dataTransfer)
      return false;
    if (view.state.readOnly)
      return true;
    let files = event2.dataTransfer.files;
    if (files && files.length) {
      let text2 = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event2, text2.filter((s4) => s4 != null).join(view.state.lineBreak), false);
      };
      for (let i4 = 0; i4 < files.length; i4++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text2[i4] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i4]);
      }
      return true;
    } else {
      let text2 = event2.dataTransfer.getData("Text");
      if (text2) {
        dropText(view, event2, text2, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = (view, event2) => {
    if (view.state.readOnly)
      return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event2.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
      return true;
    } else {
      capturePaste(view);
      return false;
    }
  };
  function captureCopy(view, text2) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text2;
    target.focus();
    target.selectionEnd = text2.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
      if (!range.empty) {
        content2.push(state.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event2) => {
    let { text: text2, ranges, linewise } = copiedRange(view.state);
    if (!text2 && !linewise)
      return false;
    lastLinewiseCopy = linewise ? text2 : null;
    if (event2.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
    let data = brokenClipboardAPI ? null : event2.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text2);
      return true;
    } else {
      captureCopy(view, text2);
      return false;
    }
  };
  var isFocusChange = /* @__PURE__ */ Annotation.define();
  function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
      let effect = getEffect(state, focus);
      if (effect)
        effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
  }
  function updateForFocusChange(view) {
    setTimeout(() => {
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        let tr = focusChangeTransaction(view.state, focus);
        if (tr)
          view.dispatch(tr);
        else
          view.update([]);
      }
    }, 10);
  }
  observers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  observers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  observers.compositionstart = observers.compositionupdate = (view) => {
    if (view.observer.editContext)
      return;
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  observers.compositionend = (view) => {
    if (view.observer.editContext)
      return;
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
      view.observer.flushSoon();
    } else if (view.inputState.compositionPendingChange) {
      Promise.resolve().then(() => view.observer.flush());
    } else {
      setTimeout(() => {
        if (view.inputState.composing < 0 && view.docView.hasComposition)
          view.update([]);
      }, 50);
    }
  };
  observers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event2) => {
    var _a2, _b;
    if (event2.inputType == "insertReplacementText" && view.observer.editContext) {
      let text2 = (_a2 = event2.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event2.getTargetRanges();
      if (text2 && ranges.length) {
        let r3 = ranges[0];
        let from = view.posAtDOM(r3.startContainer, r3.startOffset), to = view.posAtDOM(r3.endContainer, r3.endOffset);
        applyDOMChangeInner(view, { from, to, insert: view.state.toText(text2) }, null);
        return true;
      }
    }
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event2.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
    if (browser.ios && event2.inputType == "deleteContentForward") {
      view.observer.flushSoon();
    }
    if (browser.safari && event2.inputType == "insertText" && view.inputState.composing >= 0) {
      setTimeout(() => observers.compositionend(view, event2), 20);
    }
    return false;
  };
  var appliedFirefoxHack = /* @__PURE__ */ new Set();
  function firefoxCopyCutHack(doc2) {
    if (!appliedFirefoxHack.has(doc2)) {
      appliedFirefoxHack.add(doc2);
      doc2.addEventListener("copy", () => {
      });
      doc2.addEventListener("cut", () => {
      });
    }
  }
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var heightChangeFlag = false;
  function clearHeightChangeFlag() {
    heightChangeFlag = false;
  }
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i4 = 0; i4 < lineHeights.length; i4++) {
        let h3 = lineHeights[i4];
        if (h3 < 0) {
          i4++;
        } else if (!this.heightSamples[Math.floor(h3 * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h3 * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i4 = 0; i4 < knownHeights.length; i4++) {
          let h3 = knownHeights[i4];
          if (h3 < 0)
            i4++;
          else
            this.heightSamples[Math.floor(h3 * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class _BlockInfo {
    /**
    @internal
    */
    constructor(from, length, top2, height, _content) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
      return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() {
      return this.from + this.length;
    }
    /**
    The bottom position of the element.
    */
    get bottom() {
      return this.top + this.height;
    }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
      return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other2) {
      let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other2._content) ? other2._content : [other2]);
      return new _BlockInfo(this.from, this.length + other2.length, this.top, this.height + other2.height, content2);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType2;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class _HeightMap {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          heightChangeFlag = true;
        this.height = height;
      }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
      return _HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this, doc2 = oracle.doc;
      for (let i4 = changes.length - 1; i4 >= 0; i4--) {
        let { fromA, toA, fromB, toB } = changes[i4];
        let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i4 > 0 && start.from <= changes[i4 - 1].toA) {
          fromA = changes[i4 - 1].fromA;
          fromB = changes[i4 - 1].fromB;
          i4--;
          if (fromA < start.from)
            start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me = replace(me, me.replace(fromA, toA, nodes));
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i4 = 0, j4 = nodes.length, before3 = 0, after = 0;
      for (; ; ) {
        if (i4 == j4) {
          if (before3 > after * 2) {
            let split = nodes[i4 - 1];
            if (split.break)
              nodes.splice(--i4, 1, split.left, null, split.right);
            else
              nodes.splice(--i4, 1, split.left, split.right);
            j4 += 1 + split.break;
            before3 -= split.size;
          } else if (after > before3 * 2) {
            let split = nodes[j4];
            if (split.break)
              nodes.splice(j4, 1, split.left, null, split.right);
            else
              nodes.splice(j4, 1, split.left, split.right);
            j4 += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before3 < after) {
          let next = nodes[i4++];
          if (next)
            before3 += next.size;
        } else {
          let next = nodes[--j4];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i4 - 1] == null) {
        brk = 1;
        i4--;
      } else if (nodes[i4] == null) {
        brk = 1;
        j4++;
      }
      return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i4)), brk, _HeightMap.of(nodes.slice(j4)));
    }
  };
  function replace(old, val) {
    if (old == val)
      return old;
    if (old.constructor != val.constructor)
      heightChangeFlag = true;
    return val;
  }
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, deco) {
      super(length, height);
      this.deco = deco;
    }
    blockAt(_height, _oracle, top2, offset2) {
      return new BlockInfo(offset2, this.length, top2, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top2, offset2) {
      return this.blockAt(0, oracle, top2, offset2);
    }
    forEachLine(from, to, oracle, top2, offset2, f4) {
      if (from <= offset2 + this.length && to >= offset2)
        f4(this.blockAt(0, oracle, top2, offset2));
    }
    updateHeight(oracle, offset2 = 0, _force = false, measured) {
      if (measured && measured.from <= offset2 && measured.more)
        this.setHeight(measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class _HeightMapText extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, null);
      this.collapsed = 0;
      this.widgetHeight = 0;
      this.breaks = 0;
    }
    blockAt(_height, _oracle, top2, offset2) {
      return new BlockInfo(offset2, this.length, top2, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new _HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset2 = 0, force = false, measured) {
      if (measured && measured.from <= offset2 && measured.more)
        this.setHeight(measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class _HeightMapGap extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    heightMetrics(oracle, offset2) {
      let firstLine = oracle.doc.lineAt(offset2).number, lastLine = oracle.doc.lineAt(offset2 + this.length).number;
      let lines = lastLine - firstLine + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
        perLine = totalPerLine / lines;
        if (this.length > lines + 1)
          perChar = (this.height - totalPerLine) / (this.length - lines - 1);
      } else {
        perLine = this.height / lines;
      }
      return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top2, offset2) {
      let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset2);
      if (oracle.lineWrapping) {
        let guess = offset2 + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
        let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
        let lineTop = Math.max(top2, height - lineHeight / 2);
        return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
      } else {
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
        let { from, length } = oracle.doc.line(firstLine + line);
        return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
      }
    }
    lineAt(value, type3, oracle, top2, offset2) {
      if (type3 == QueryType.ByHeight)
        return this.blockAt(value, oracle, top2, offset2);
      if (type3 == QueryType.ByPosNoHeight) {
        let { from, to } = oracle.doc.lineAt(value);
        return new BlockInfo(from, to - from, 0, 0, 0);
      }
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset2);
      let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
      let linesAbove = line.number - firstLine;
      let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset2 - linesAbove);
      return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top2, offset2, f4) {
      from = Math.max(from, offset2);
      to = Math.min(to, offset2 + this.length);
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset2);
      for (let pos = from, lineTop = top2; pos <= to; ) {
        let line = oracle.doc.lineAt(pos);
        if (pos == from) {
          let linesAbove = line.number - firstLine;
          lineTop += perLine * linesAbove + perChar * (from - offset2 - linesAbove);
        }
        let lineHeight = perLine + perChar * line.length;
        f4(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
        lineTop += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last2 = nodes[nodes.length - 1];
        if (last2 instanceof _HeightMapGap)
          nodes[nodes.length - 1] = new _HeightMapGap(last2.length + after);
        else
          nodes.push(null, new _HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof _HeightMapGap)
          nodes[0] = new _HeightMapGap(from + first.length);
        else
          nodes.unshift(new _HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new _HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new _HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset2 = 0, force = false, measured) {
      let end = offset2 + this.length;
      if (measured && measured.from <= offset2 + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset2, measured.from), singleHeight = -1;
        if (measured.from > offset2)
          nodes.push(new _HeightMapGap(measured.from - offset2 - 1).updateHeight(oracle, offset2));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset2).perLine) >= Epsilon)
          heightChangeFlag = true;
        return replace(this, result);
      } else if (force || this.outdated) {
        this.setHeight(oracle.heightForGap(offset2, offset2 + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, oracle, top2, offset2) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, oracle, top2, offset2) : this.right.blockAt(height, oracle, mid, offset2 + this.left.length + this.break);
    }
    lineAt(value, type3, oracle, top2, offset2) {
      let rightTop = top2 + this.left.height, rightOffset = offset2 + this.left.length + this.break;
      let left = type3 == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type3, oracle, top2, offset2) : this.right.lineAt(value, type3, oracle, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type3 == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset2).join(base2);
    }
    forEachLine(from, to, oracle, top2, offset2, f4) {
      let rightTop = top2 + this.left.height, rightOffset = offset2 + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, oracle, top2, offset2, f4);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f4);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset2);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, oracle, top2, offset2, f4);
        if (mid.to >= from && mid.from <= to)
          f4(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f4);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = replace(this.left, left);
      this.right = replace(this.right, right);
      this.setHeight(left.height + right.height);
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset2 = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset2 + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset2 + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset2, force, measured);
      else
        left.updateHeight(oracle, offset2, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before3, after;
    if (nodes[around] == null && (before3 = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before3.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class _NodeBuilder {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
        if (last2 instanceof HeightMapText)
          last2.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        let breaks = deco.widget ? deco.widget.lineBreaks : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco));
        } else if (len || breaks || height >= relevantWidgetHeight) {
          this.addLineDeco(height, breaks, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last2 instanceof HeightMapText)
        return last2;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block2) {
      this.enterLine();
      let deco = block2.deco;
      if (deco && deco.startSide > 0 && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block2);
      this.writtenTo = this.pos = this.pos + block2.length;
      if (deco && deco.endSide > 0)
        this.covering = block2;
    }
    addLineDeco(height, breaks, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      line.breaks += breaks;
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last2 == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations2, from, to) {
      let builder = new _NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a3, b2, diff) {
    let comp = new DecorationComparator2();
    RangeSet.compare(a3, b2, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator2 = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a3, b2) {
      if (from < to || a3 && a3.heightRelevant || b2 && b2.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt2 = parent;
        let style = window.getComputedStyle(elt2);
        if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style.overflow != "visible") {
          let parentRect = elt2.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function inWindow(elt2) {
    let rect = elt2.getBoundingClientRect(), win = elt2.ownerDocument.defaultView || window;
    return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size, displaySize) {
      this.from = from;
      this.to = to;
      this.size = size;
      this.displaySize = displaySize;
    }
    static same(a3, b2) {
      if (a3.length != b2.length)
        return false;
      for (let i4 = 0; i4 < a3.length; i4++) {
        let gA = a3[i4], gB = b2[i4];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(viewState, wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
      }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other2) {
      return other2.size == this.size && other2.vertical == this.vertical;
    }
    toDOM() {
      let elt2 = document.createElement("div");
      if (this.vertical) {
        elt2.style.height = this.size + "px";
      } else {
        elt2.style.width = this.size + "px";
        elt2.style.height = "2px";
        elt2.style.display = "inline-block";
      }
      return elt2;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scrollTop = 0;
      this.scrolledToBottom = false;
      this.scaleX = 1;
      this.scaleY = 1;
      this.scrollAnchorPos = 0;
      this.scrollAnchorHeight = -1;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v4) => typeof v4 != "function" && v4.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d3) => typeof d3 != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      for (let i4 = 0; i4 < 2; i4++) {
        this.viewport = this.getViewport(0, null);
        if (!this.updateForViewport())
          break;
      }
      this.updateViewportLines();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main } = this.state.selection;
      for (let i4 = 0; i4 <= 1; i4++) {
        let pos = i4 ? main.head : main.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a3, b2) => a3.from - b2.from);
      return this.updateScaler();
    }
    updateScaler() {
      let scaler = this.scaler;
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
      return scaler.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block2) => {
        this.viewportLines.push(scaleBlock(block2, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d3) => typeof d3 != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      clearHeightChangeFlag();
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight || heightChangeFlag)
        update.flags |= 2;
      if (scrollAnchor) {
        this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
        this.scrollAnchorHeight = scrollAnchor.top;
      } else {
        this.scrollAnchorPos = -1;
        this.scrollAnchorHeight = this.heightMap.height;
      }
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      update.flags |= this.updateForViewport();
      if (viewportChange || !update.changes.empty || update.flags & 2)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges(update.changes);
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom = view.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      if (domRect.width && domRect.height) {
        let { scaleX, scaleY } = getScale(dom, domRect);
        if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          result |= 16;
          refresh = measureContent = true;
        }
      }
      let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
      let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 16 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 16;
      }
      let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
      if (this.scrollTop != scrollTop) {
        this.scrollAnchorHeight = -1;
        this.scrollTop = scrollTop;
      }
      this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
        return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 16;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 16;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        clearHeightChangeFlag();
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (heightChangeFlag)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange) {
        if (result & 2)
          result |= this.updateScaler();
        this.viewport = this.getViewport(bias, this.scrollTarget);
        result |= this.updateForViewport();
      }
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map3 = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map3.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block2 = map3.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block2.top + block2.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block2.top;
          else
            topPos = block2.bottom - viewHeight;
          viewport = new Viewport(map3.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
      let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
        -bias,
        250
        /* VP.MaxCoverMargin */
      ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
        bias,
        250
        /* VP.MaxCoverMargin */
      ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
      return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from, to, line, structure) => {
        if (to - from < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find2(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r3) => r3.from <= to && r3.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from)
              to = lineStart;
          }
          let size = this.gapSize(line, from, to, structure);
          let displaySize = wrapping || size < 2e6 ? size : 2e6;
          gap = new LineGap(from, to, size, displaySize);
        }
        gaps.push(gap);
      };
      let checkLine = (line) => {
        if (line.length < doubleMargin || line.type != BlockType.Text)
          return;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          return;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let horizOffset = 0;
          if (totalWidth > 2e6)
            for (let old of current) {
              if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                horizOffset = old.size - old.displaySize;
            }
          let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (pxLeft - marginWidth) / totalWidth;
            right = (pxRight + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      };
      for (let line of this.viewportLines) {
        if (Array.isArray(line.type))
          line.type.forEach(checkLine);
        else
          checkLine(line);
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges(changes) {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({ from, to });
        },
        point() {
        }
      }, 20);
      let changed = 0;
      if (ranges.length != this.visibleRanges.length) {
        changed = 8 | 4;
      } else {
        for (let i4 = 0; i4 < ranges.length && !(changed & 8); i4++) {
          let old = this.visibleRanges[i4], nw = ranges[i4];
          if (old.from != nw.from || old.to != nw.to) {
            changed |= 4;
            if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
              changed |= 8;
          }
        }
      }
      this.visibleRanges = ranges;
      return changed;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b2) => b2.from <= pos && b2.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l4) => l4.top <= height && l4.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
      let block2 = this.lineBlockAtHeight(scrollTop + 8);
      return block2.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block2 : this.viewportLines[0];
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist2 = Math.floor(total * ratio);
    for (let i4 = 0; ; i4++) {
      let { from, to } = ranges[i4], size = to - from;
      if (dist2 <= size)
        return from + dist2;
      dist2 -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find2(array, f4) {
    for (let val of array)
      if (f4(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n3) {
      return n3;
    },
    fromDOM(n3) {
      return n3;
    },
    scale: 1,
    eq(other2) {
      return other2 == this;
    }
  };
  var BigScaler = class _BigScaler {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n3) {
      for (let i4 = 0, base2 = 0, domBase = 0; ; i4++) {
        let vp = i4 < this.viewports.length ? this.viewports[i4] : null;
        if (!vp || n3 < vp.top)
          return domBase + (n3 - base2) * this.scale;
        if (n3 <= vp.bottom)
          return vp.domTop + (n3 - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n3) {
      for (let i4 = 0, base2 = 0, domBase = 0; ; i4++) {
        let vp = i4 < this.viewports.length ? this.viewports[i4] : null;
        if (!vp || n3 < vp.domTop)
          return base2 + (n3 - domBase) / this.scale;
        if (n3 <= vp.domBottom)
          return vp.top + (n3 - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    eq(other2) {
      if (!(other2 instanceof _BigScaler))
        return false;
      return this.scale == other2.scale && this.viewports.length == other2.viewports.length && this.viewports.every((vp, i4) => vp.from == other2.viewports[i4].from && vp.to == other2.viewports[i4].to);
    }
  };
  function scaleBlock(block2, scaler) {
    if (scaler.scale == 1)
      return block2;
    let bTop = scaler.toDOM(block2.top), bBottom = scaler.toDOM(block2.bottom);
    return new BlockInfo(block2.from, block2.length, bTop, bBottom - bTop, Array.isArray(block2._content) ? block2._content.map((b2) => scaleBlock(b2, scaler)) : block2._content);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m3) => {
          if (m3 == "&")
            return main;
          if (!scopes || !scopes[m3])
            throw new RangeError(`Unsupported selector: ${m3}`);
          return scopes[m3];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        // Provide a simple default outline to make sure a focused
        // editor is visually distinct. Can't leave the default behavior
        // because that will apply to the content element, which is
        // inside the scrollable container and doesn't include the
        // gutters. We also can't use an 'auto' outline, since those
        // are, for some reason, drawn behind the element content, which
        // will cause things like the active line background to cover
        // the outline (#297).
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0,
      overflowAnchor: "none"
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      // https://github.com/codemirror/dev/issues/456
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      // For IE
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      // For Safari, which doesn't support overflow-wrap: anywhere
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      // Necessary -- prevents margin collapsing
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0,
      zIndex: 300
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top",
      userSelect: "none"
    },
    ".cm-highlightSpace": {
      backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
      backgroundPosition: "center"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view) {
      this.view = view;
      this.active = false;
      this.editContext = null;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.printQuery = null;
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m3) => m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
      !(browser.chrome && browser.chrome_version < 126)) {
        this.editContext = new EditContextManager(view);
        if (view.state.facet(editable))
          view.contentDOM.editContext = this.editContext.editContext;
      }
      if (useCharData)
        this.onCharData = (event2) => {
          this.queue.push({
            target: event2.target,
            type: "characterData",
            oldValue: event2.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (window.matchMedia)
        this.printQuery = window.matchMedia("print");
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resizeScroll.observe(view.scrollDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries2) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, { threshold: [0, 1e-3] });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries2) => {
          if (entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e3) {
      this.view.inputState.runHandlers("scroll", e3);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e3) {
      if (this.intersecting)
        this.flush(false);
      if (this.editContext)
        this.view.requestMeasure(this.editContext.measureReq);
      this.onScrollChanged(e3);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint(event2) {
      if ((event2.type == "change" || !event2.type) && !event2.matches)
        return;
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g4, i4) => g4 != gaps[i4]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event2) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
        return;
      let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event2)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
      sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view } = this;
      let selection2 = getSelection(view.root);
      if (!selection2)
        return false;
      let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
      if (!range || this.selectionRange.eq(range))
        return false;
      let local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i4 = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i4 < this.scrollTargets.length && this.scrollTargets[i4] == dom)
            i4++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i4);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i4 < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i4);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f4) {
      if (!this.active)
        return f4();
      try {
        this.stop();
        return f4();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            this.view.inputState.lastKeyCode = key2.keyCode;
            this.view.inputState.lastKeyTime = Date.now();
            let flushed = this.flush();
            if (!flushed && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          // Only run the key handler when no changes are detected if
          // this isn't coming right after another change, in which case
          // it is probably part of a weird chain of updates, and should
          // be ignored if it returns the DOM to its previous state.
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    pendingRecords() {
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
      return this.queue;
    }
    processRecords() {
      let records = this.pendingRecords();
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to } = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      return { from, to, typeOver };
    }
    readChange() {
      let { from, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return null;
      if (from > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      let change = new DOMChange(this.view, from, to, typeOver);
      this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
      return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange) {
        this.view.requestMeasure();
        return false;
      }
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.flags |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.addEventListener)
          this.printQuery.addEventListener("change", this.onPrint);
        else
          this.printQuery.addListener(this.onPrint);
      } else
        win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.removeEventListener)
          this.printQuery.removeEventListener("change", this.onPrint);
        else
          this.printQuery.removeListener(this.onPrint);
      } else
        win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
      if (this.editContext) {
        this.editContext.update(update);
        if (update.startState.facet(editable) != update.state.facet(editable))
          update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      if (this.editContext) {
        this.view.contentDOM.editContext = null;
        this.editContext.destroy();
      }
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariSelectionRangeHack(view, selection2) {
    if (selection2.getComposedRanges) {
      let range = selection2.getComposedRanges(view.root)[0];
      if (range)
        return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    function read(event2) {
      event2.preventDefault();
      event2.stopImmediatePropagation();
      found = event2.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
  }
  var EditContextManager = class {
    constructor(view) {
      this.from = 0;
      this.to = 0;
      this.pendingContextChange = null;
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = null;
      this.resetRange(view.state);
      let context = this.editContext = new window.EditContext({
        text: view.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(view.state.selection.main.head)
      });
      this.handlers.textupdate = (e3) => {
        let main = view.state.selection.main, { anchor, head } = main;
        let from = this.toEditorPos(e3.updateRangeStart), to = this.toEditorPos(e3.updateRangeEnd);
        if (view.inputState.composing >= 0 && !this.composing)
          this.composing = { contextBase: e3.updateRangeStart, editorBase: from, drifted: false };
        let change = { from, to, insert: Text.of(e3.text.split("\n")) };
        if (change.from == this.from && anchor < this.from)
          change.from = anchor;
        else if (change.to == this.to && anchor > this.to)
          change.to = anchor;
        if (change.from == change.to && !change.insert.length) {
          let newSel = EditorSelection.single(this.toEditorPos(e3.selectionStart), this.toEditorPos(e3.selectionEnd));
          if (!newSel.main.eq(main))
            view.dispatch({ selection: newSel, userEvent: "select" });
          return;
        }
        if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e3.text) && view.contentDOM.getAttribute("autocorrect") == "off")
          change = { from, to, insert: Text.of([e3.text.replace(".", " ")]) };
        this.pendingContextChange = change;
        if (!view.state.readOnly) {
          let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
          applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e3.selectionStart, newLen), this.toEditorPos(e3.selectionEnd, newLen)));
        }
        if (this.pendingContextChange) {
          this.revertPending(view.state);
          this.setSelection(view.state);
        }
      };
      this.handlers.characterboundsupdate = (e3) => {
        let rects = [], prev = null;
        for (let i4 = this.toEditorPos(e3.rangeStart), end = this.toEditorPos(e3.rangeEnd); i4 < end; i4++) {
          let rect = view.coordsForChar(i4);
          prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
          rects.push(prev);
        }
        context.updateCharacterBounds(e3.rangeStart, rects);
      };
      this.handlers.textformatupdate = (e3) => {
        let deco = [];
        for (let format of e3.getTextFormats()) {
          let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
          if (lineStyle != "None" && thickness != "None") {
            let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
            if (from < to) {
              let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
              deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
            }
          }
        }
        view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
      };
      this.handlers.compositionstart = () => {
        if (view.inputState.composing < 0) {
          view.inputState.composing = 0;
          view.inputState.compositionFirstChange = true;
        }
      };
      this.handlers.compositionend = () => {
        view.inputState.composing = -1;
        view.inputState.compositionFirstChange = null;
        if (this.composing) {
          let { drifted } = this.composing;
          this.composing = null;
          if (drifted)
            this.reset(view.state);
        }
      };
      for (let event2 in this.handlers)
        context.addEventListener(event2, this.handlers[event2]);
      this.measureReq = { read: (view2) => {
        this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
        let sel = getSelection(view2.root);
        if (sel && sel.rangeCount)
          this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
      } };
    }
    applyEdits(update) {
      let off = 0, abort = false, pending = this.pendingContextChange;
      update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
        if (abort)
          return;
        let dLen = insert2.length - (toA - fromA);
        if (pending && toA >= pending.to) {
          if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
            pending = this.pendingContextChange = null;
            off += dLen;
            this.to += dLen;
            return;
          } else {
            pending = null;
            this.revertPending(update.state);
          }
        }
        fromA += off;
        toA += off;
        if (toA <= this.from) {
          this.from += dLen;
          this.to += dLen;
        } else if (fromA < this.to) {
          if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
            abort = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
          this.to += dLen;
        }
        off += dLen;
      });
      if (pending && !abort)
        this.revertPending(update.state);
      return !abort;
    }
    update(update) {
      let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
      if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
        this.composing.drifted = true;
        this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
      } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
        this.pendingContextChange = null;
        this.reset(update.state);
      } else if (update.docChanged || update.selectionSet || reverted) {
        this.setSelection(update.state);
      }
      if (update.geometryChanged || update.docChanged || update.selectionSet)
        update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
      let { head } = state.selection.main;
      this.from = Math.max(
        0,
        head - 1e4
        /* CxVp.Margin */
      );
      this.to = Math.min(
        state.doc.length,
        head + 1e4
        /* CxVp.Margin */
      );
    }
    reset(state) {
      this.resetRange(state);
      this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
      this.setSelection(state);
    }
    revertPending(state) {
      let pending = this.pendingContextChange;
      this.pendingContextChange = null;
      this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
      let { main } = state.selection;
      let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
      let end = this.toContextPos(main.head);
      if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
        this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
      let { head } = state.selection.main;
      return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(contextPos, clipLen = this.to - this.from) {
      contextPos = Math.min(contextPos, clipLen);
      let c3 = this.composing;
      return c3 && c3.drifted ? c3.editorBase + (contextPos - c3.contextBase) : contextPos + this.from;
    }
    toContextPos(editorPos) {
      let c3 = this.composing;
      return c3 && c3.drifted ? c3.contextBase + (editorPos - c3.editorBase) : editorPos - this.from;
    }
    destroy() {
      for (let event2 in this.handlers)
        this.editContext.removeEventListener(event2, this.handlers[event2]);
    }
  };
  var EditorView = class _EditorView {
    /**
    The current editor state.
    */
    get state() {
      return this.viewState.state;
    }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() {
      return this.viewState.viewport;
    }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() {
      return this.viewState.inView;
    }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() {
      return this.inputState.composing > 0;
    }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    /**
    The document or shadow root that the view lives in.
    */
    get root() {
      return this._root;
    }
    /**
    @internal
    */
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config2 = {}) {
      var _a2;
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.className = "cm-announced";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      if (config2.parent)
        config2.parent.appendChild(this.dom);
      let { dispatch } = config2;
      this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
      this.dispatch = this.dispatch.bind(this);
      this._root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create(config2));
      if (config2.scrollTo && config2.scrollTo.is(scrollIntoView))
        this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
        document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
      let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
      this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr) => tr.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus;
        focusFlag = 1;
      } else if (focus != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus;
        dispatchFocus = focusChangeTransaction(state, focus);
        if (!dispatchFocus)
          focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      update.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main } = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e3 of tr.effects)
            if (e3.is(scrollIntoView))
              scrollTarget = e3.value.clip(this.state);
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (redrawn)
        this.docViewUpdate();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener)) {
          try {
            listener(update);
          } catch (e3) {
            logException(this.state, e3, "update listener");
          }
        }
      if (dispatchFocus || domChange)
        Promise.resolve().then(() => {
          if (dispatchFocus && this.state == dispatchFocus.startState)
            this.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(this, domChange) && pendingKey.force)
              dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView.destroy();
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
      } else {
        for (let p3 of this.plugins)
          p3.mustUpdate = update;
      }
      for (let i4 = 0; i4 < this.plugins.length; i4++)
        this.plugins[i4].update(this);
      if (prevSpecs != specs)
        this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let plugin of this.plugins) {
        let val = plugin.value;
        if (val && val.docViewUpdate) {
          try {
            val.docViewUpdate(this);
          } catch (e3) {
            logException(this.state, e3, "doc view update listener");
          }
        }
      }
    }
    /**
    @internal
    */
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      if (this.observer.delayedAndroidKey) {
        this.measureScheduled = -1;
        this.requestMeasure();
        return;
      }
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
      let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
      if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
        scrollAnchorHeight = -1;
      this.viewState.scrollAnchorHeight = -1;
      try {
        for (let i4 = 0; ; i4++) {
          if (scrollAnchorHeight < 0) {
            if (isScrolledToBottom(sDOM)) {
              scrollAnchorPos = -1;
              scrollAnchorHeight = this.viewState.heightMap.height;
            } else {
              let block2 = this.viewState.scrollAnchorAt(scrollTop);
              scrollAnchorPos = block2.from;
              scrollAnchorHeight = block2.top;
            }
          }
          this.updateState = 1;
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i4 > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m3) => {
            try {
              return m3.read(this);
            } catch (e3) {
              logException(this.state, e3);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false;
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
            if (redrawn)
              this.docViewUpdate();
          }
          for (let i5 = 0; i5 < measuring.length; i5++)
            if (measured[i5] != BadMeasure) {
              try {
                let m3 = measuring[i5];
                if (m3.write)
                  m3.write(measured[i5], this);
              } catch (e3) {
                logException(this.state, e3);
              }
            }
          if (redrawn)
            this.docView.updateSelection(true);
          if (!update.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight) {
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                scrollAnchorHeight = -1;
                continue;
              } else {
                let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                let diff = newAnchorHeight - scrollAnchorHeight;
                if (diff > 1 || diff < -1) {
                  scrollTop = scrollTop + diff;
                  sDOM.scrollTop = scrollTop / this.scaleY;
                  scrollAnchorHeight = -1;
                  continue;
                }
              }
            }
            break;
          }
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        writingsuggestions: "false",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(_EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      let nonce = this.state.facet(_EditorView.cspNonce);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (this.measureRequests.indexOf(request) > -1)
          return;
        if (request.key != null)
          for (let i4 = 0; i4 < this.measureRequests.length; i4++) {
            if (this.measureRequests[i4].key === request.key) {
              this.measureRequests[i4] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p3) => p3.spec == plugin) || null);
      return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() {
      return this.viewState.scaleX;
    }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() {
      return this.viewState.scaleY;
    }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    /**
    Get the cursor position visually at the start or end of a line.
    Note that this may differ from the _logical_ position at its
    start or end (which is simply at `line.from`/`line.to`) if text
    at the start or end goes against the line's base text direction.
    */
    visualLineSide(line, end) {
      let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
      let span = order[end ? order.length - 1 : 0];
      return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset2 = 0) {
      return this.docView.posFromDOM(node, offset2);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
      this.readMeasured();
      return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from), isolates;
      for (let entry of this.bidiCache) {
        if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
          return entry.order;
      }
      if (!isolates)
        isolates = getIsolatedRanges(this, line);
      let order = computeOrder(line.text, dir, isolates);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
      return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
      if (this.root.activeElement == this.contentDOM)
        this.contentDOM.blur();
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.docView.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options2 = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
      let { scrollTop, scrollLeft } = this.scrollDOM;
      let ref = this.viewState.scrollAnchorAt(scrollTop);
      return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    /**
    Enable or disable tab-focus mode, which disables key bindings
    for Tab and Shift-Tab, letting the browser's default
    focus-changing behavior go through instead. This is useful to
    prevent trapping keyboard users in your editor.
    
    Without argument, this toggles the mode. With a boolean, it
    enables (true) or disables it (false). Given a number, it
    temporarily enables the mode until that number of milliseconds
    have passed or another non-Tab key is pressed.
    */
    setTabFocusMode(to) {
      if (to == null)
        this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
      else if (typeof to == "boolean")
        this.inputState.tabFocusMode = to ? 0 : -1;
      else if (this.inputState.tabFocusMode != 0)
        this.inputState.tabFocusMode = Date.now() + to;
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers2) {
      return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
    addedneed to be explicitly differentiated by adding an `&` to
    the selector for that elementfor example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options2) {
      let prefix2 = StyleModule.newName();
      let result = [theme.of(prefix2), styleModule.of(buildTheme(`.${prefix2}`, spec))];
      if (options2 && options2.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.clipboardInputFilter = clipboardInputFilter;
  EditorView.clipboardOutputFilter = clipboardOutputFilter;
  EditorView.scrollHandler = scrollHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.outerDecorations = outerDecorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : "" });
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class _CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty && !cache.some((c3) => c3.fresh))
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i4 = Math.max(0, cache.length - 10); i4 < cache.length; i4++) {
        let entry = cache[i4];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i4 = sources.length - 1; i4 >= 0; i4--) {
      let source = sources[i4], value = typeof source == "function" ? source(view) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i4 = 0; i4 < parts.length - 1; ++i4) {
      const mod = parts[i4];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event2, shift2) {
    if (event2.altKey)
      name2 = "Alt-" + name2;
    if (event2.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event2.metaKey)
      name2 = "Meta-" + name2;
    if (shift2 !== false && event2.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event2, view) {
      return runHandlers(getKeymap(view.state), event2, view, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map3 = Keymaps.get(bindings);
    if (!map3)
      Keymaps.set(bindings, map3 = buildKeymap(bindings.reduce((a3, b2) => a3.concat(b2), [])));
    return map3;
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name2, is) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is;
      else if (current != is)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key, command2, preventDefault2, stopPropagation) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k3) => normalizeKeyName(k3, platform));
      for (let i4 = 1; i4 < parts.length; i4++) {
        let prefix2 = parts.slice(0, i4).join(" ");
        checkPrefix(prefix2, true);
        if (!scopeObj[prefix2])
          scopeObj[prefix2] = {
            preventDefault: true,
            stopPropagation: false,
            run: [(view) => {
              let ourObj = storedPrefix = { view, prefix: prefix2, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command2)
        binding.run.push(command2);
      if (preventDefault2)
        binding.preventDefault = true;
      if (stopPropagation)
        binding.stopPropagation = true;
    };
    for (let b2 of bindings) {
      let scopes = b2.scope ? b2.scope.split(" ") : ["editor"];
      if (b2.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
          let { any } = b2;
          for (let key in scopeObj)
            scopeObj[key].run.push((view) => any(view, currentKeyEvent));
        }
      let name2 = b2[platform] || b2.key;
      if (!name2)
        continue;
      for (let scope of scopes) {
        add2(scope, name2, b2.run, b2.preventDefault, b2.stopPropagation);
        if (b2.shift)
          add2(scope, "Shift-" + name2, b2.shift, b2.preventDefault, b2.stopPropagation);
      }
    }
    return bound;
  }
  var currentKeyEvent = null;
  function runHandlers(map3, event2, view, scope) {
    currentKeyEvent = event2;
    let name2 = keyName(event2);
    let charCode = codePointAt2(name2, 0), isChar = codePointSize2(charCode) == name2.length && name2 != " ";
    let prefix2 = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix2 = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event2.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd of binding.run)
          if (!ran.has(cmd)) {
            ran.add(cmd);
            if (cmd(view)) {
              if (binding.stopPropagation)
                stopPropagation = true;
              return true;
            }
          }
        if (binding.preventDefault) {
          if (binding.stopPropagation)
            stopPropagation = true;
          prevented = true;
        }
      }
      return false;
    };
    let scopeObj = map3[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix2 + modifiers(name2, event2, !isChar)])) {
        handled = true;
      } else if (isChar && (event2.altKey || event2.metaKey || event2.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(browser.windows && event2.ctrlKey && event2.altKey) && (baseName = base[event2.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix2 + modifiers(baseName, event2, true)])) {
          handled = true;
        } else if (event2.shiftKey && (shiftName = shift[event2.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix2 + modifiers(shiftName, event2, false)])) {
          handled = true;
        }
      } else if (isChar && event2.shiftKey && runFor(scopeObj[prefix2 + modifiers(name2, event2, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any))
        handled = true;
    }
    if (prevented)
      handled = true;
    if (handled && stopPropagation)
      event2.stopPropagation();
    currentKeyEvent = null;
    return handled;
  }
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Placeholder = class extends WidgetType {
    constructor(content2) {
      super();
      this.content = content2;
    }
    toDOM(view) {
      let wrap2 = document.createElement("span");
      wrap2.className = "cm-placeholder";
      wrap2.style.pointerEvents = "none";
      wrap2.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
      if (typeof this.content == "string")
        wrap2.setAttribute("aria-label", "placeholder " + this.content);
      else
        wrap2.setAttribute("aria-hidden", "true");
      return wrap2;
    }
    coordsAt(dom) {
      let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
      if (!rects.length)
        return null;
      let style = window.getComputedStyle(dom.parentNode);
      let rect = flattenRect(rects[0], style.direction != "rtl");
      let lineHeight = parseInt(style.lineHeight);
      if (rect.bottom - rect.top > lineHeight * 1.5)
        return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
      return rect;
    }
    ignoreEvent() {
      return false;
    }
  };
  function placeholder(content2) {
    return ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]) : Decoration.none;
      }
      get decorations() {
        return this.view.state.doc.length ? Decoration.none : this.placeholder;
      }
    }, { decorations: (v4) => v4.decorations });
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view, facet, createTooltipView, removeTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.removeTooltipView = removeTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t4) => t4);
      let prev = null;
      this.tooltipViews = this.tooltips.map((t4) => prev = createTooltipView(t4, prev));
    }
    update(update, above) {
      var _a2;
      let input = update.state.facet(this.facet);
      let tooltips2 = input.filter((x3) => x3);
      if (input === this.input) {
        for (let t4 of this.tooltipViews)
          if (t4.update)
            t4.update(update);
        return false;
      }
      let tooltipViews = [], newAbove = above ? [] : null;
      for (let i4 = 0; i4 < tooltips2.length; i4++) {
        let tip = tooltips2[i4], known = -1;
        if (!tip)
          continue;
        for (let i5 = 0; i5 < this.tooltips.length; i5++) {
          let other2 = this.tooltips[i5];
          if (other2 && other2.create == tip.create)
            known = i5;
        }
        if (known < 0) {
          tooltipViews[i4] = this.createTooltipView(tip, i4 ? tooltipViews[i4 - 1] : null);
          if (newAbove)
            newAbove[i4] = !!tip.above;
        } else {
          let tooltipView = tooltipViews[i4] = this.tooltipViews[known];
          if (newAbove)
            newAbove[i4] = above[known];
          if (tooltipView.update)
            tooltipView.update(update);
        }
      }
      for (let t4 of this.tooltipViews)
        if (tooltipViews.indexOf(t4) < 0) {
          this.removeTooltipView(t4);
          (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
        }
      if (above) {
        newAbove.forEach((val, i4) => above[i4] = val);
        above.length = newAbove.length;
      }
      this.input = input;
      this.tooltips = tooltips2;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function tooltips(config2 = {}) {
    return tooltipConfig.of(config2);
  }
  function windowSpace(view) {
    let docElt = view.dom.ownerDocument.documentElement;
    return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values2) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values2.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var knownHeight = /* @__PURE__ */ new WeakMap();
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.above = [];
      this.inView = true;
      this.madeAbsolute = false;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
      this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
      this.manager = new TooltipViewManager(view, showTooltip, (t4, p3) => this.createTooltip(t4, p3), (t4) => {
        if (this.resizeObserver)
          this.resizeObserver.unobserve(t4.dom);
        t4.dom.remove();
      });
      this.above = this.manager.tooltips.map((t4) => !!t4.above);
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries2) => {
        if (Date.now() > this.lastTransaction - 50 && entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, { threshold: [1] }) : null;
      this.observeIntersection();
      view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update) {
      if (update.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update, this.above);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update.geometryChanged;
      let newConfig = update.state.facet(tooltipConfig);
      if (newConfig.position != this.position && !this.madeAbsolute) {
        this.position = newConfig.position;
        for (let t4 of this.manager.tooltipViews)
          t4.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t4 of this.manager.tooltipViews)
          this.container.appendChild(t4.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
      let tooltipView = tooltip.create(this.view);
      let before3 = prev ? prev.dom : null;
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      tooltipView.dom.style.left = "0px";
      this.container.insertBefore(tooltipView.dom, before3);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      if (this.resizeObserver)
        this.resizeObserver.observe(tooltipView.dom);
      return tooltipView;
    }
    destroy() {
      var _a2, _b, _c;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      if (this.parent)
        this.container.remove();
      (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let scaleX = 1, scaleY = 1, makeAbsolute = false;
      if (this.position == "fixed" && this.manager.tooltipViews.length) {
        let { dom } = this.manager.tooltipViews[0];
        if (browser.gecko) {
          makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
        } else if (dom.style.top == Outside && dom.style.left == "0px") {
          let rect = dom.getBoundingClientRect();
          makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
        }
      }
      if (makeAbsolute || this.position == "absolute") {
        if (this.parent) {
          let rect = this.parent.getBoundingClientRect();
          if (rect.width && rect.height) {
            scaleX = rect.width / this.parent.offsetWidth;
            scaleY = rect.height / this.parent.offsetHeight;
          }
        } else {
          ({ scaleX, scaleY } = this.view.viewState);
        }
      }
      let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
      return {
        visible: {
          left: visible.left + margins.left,
          top: visible.top + margins.top,
          right: visible.right - margins.right,
          bottom: visible.bottom - margins.bottom
        },
        parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
        pos: this.manager.tooltips.map((t4, i4) => {
          let tv = this.manager.tooltipViews[i4];
          return tv.getCoords ? tv.getCoords(t4.pos) : this.view.coordsAtPos(t4.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        scaleX,
        scaleY,
        makeAbsolute
      };
    }
    writeMeasure(measured) {
      var _a2;
      if (measured.makeAbsolute) {
        this.madeAbsolute = true;
        this.position = "absolute";
        for (let t4 of this.manager.tooltipViews)
          t4.dom.style.position = "absolute";
      }
      let { visible, space: space2, scaleX, scaleY } = measured;
      let others = [];
      for (let i4 = 0; i4 < this.manager.tooltips.length; i4++) {
        let tooltip = this.manager.tooltips[i4], tView = this.manager.tooltipViews[i4], { dom } = tView;
        let pos = measured.pos[i4], size = measured.size[i4];
        if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space2.top) || pos.top >= Math.min(visible.bottom, space2.bottom) || pos.right < Math.max(visible.left, space2.left) - 0.1 || pos.left > Math.min(visible.right, space2.right) + 0.1)) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
        let offset2 = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size.width > space2.right - space2.left ? ltr ? space2.left : space2.right - size.width : ltr ? Math.max(space2.left, Math.min(pos.left - (arrow ? 14 : 0) + offset2.x, space2.right - width)) : Math.min(Math.max(space2.left, pos.left - width + (arrow ? 14 : 0) - offset2.x), space2.right - width);
        let above = this.above[i4];
        if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset2.y < space2.top : pos.bottom + height + arrowHeight + offset2.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top)
          above = this.above[i4] = !above;
        let spaceVert = (above ? pos.top - space2.top : space2.bottom - pos.bottom) - arrowHeight;
        if (spaceVert < height && tView.resize !== false) {
          if (spaceVert < this.view.defaultLineHeight) {
            dom.style.top = Outside;
            continue;
          }
          knownHeight.set(tView, height);
          dom.style.height = (height = spaceVert) / scaleY + "px";
        } else if (dom.style.height) {
          dom.style.height = "";
        }
        let top2 = above ? pos.top - height - arrowHeight - offset2.y : pos.bottom + arrowHeight + offset2.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r3 of others)
            if (r3.left < right && r3.right > left && r3.top < top2 + height && r3.bottom > top2)
              top2 = above ? r3.top - height - 2 - arrowHeight : r3.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
          setLeftStyle(dom, (left - measured.parent.left) / scaleX);
        } else {
          dom.style.top = top2 / scaleY + "px";
          setLeftStyle(dom, left / scaleX);
        }
        if (arrow) {
          let arrowLeft = pos.left + (ltr ? offset2.x : -offset2.x) - (left + 14 - 7);
          arrow.style.left = arrowLeft / scaleX + "px";
        }
        if (tView.overlap !== true)
          others.push({ left, top: top2, right, bottom: top2 + height });
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventObservers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  function setLeftStyle(elt2, value) {
    let current = parseInt(elt2.style.left, 10);
    if (isNaN(current) || Math.abs(value - current) > 1)
      elt2.style.left = value + "px";
  }
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 500,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = { x: 0, y: 0 };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define({
    combine: (inputs) => inputs.reduce((a3, i4) => a3.concat(i4), [])
  });
  var HoverTooltipHost = class _HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view) {
      return new _HoverTooltipHost(view);
    }
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t4, p3) => this.createHostedView(t4, p3), (t4) => t4.dom.remove());
    }
    createHostedView(tooltip, prev) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned(space2) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned(space2);
      }
    }
    update(update) {
      this.manager.update(update);
    }
    destroy() {
      var _a2;
      for (let t4 of this.manager.tooltipViews)
        (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
    }
    passProp(name2) {
      let value = void 0;
      for (let view of this.manager.tooltipViews) {
        let given = view[name2];
        if (given !== void 0) {
          if (value === void 0)
            value = given;
          else if (value !== given)
            return void 0;
        }
      }
      return value;
    }
    get offset() {
      return this.passProp("offset");
    }
    get getCoords() {
      return this.passProp("getCoords");
    }
    get overlap() {
      return this.passProp("overlap");
    }
    get resize() {
      return this.passProp("resize");
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
    let tooltips2 = state.facet(showHoverTooltip);
    if (tooltips2.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips2.map((t4) => t4.pos)),
      end: Math.max(...tooltips2.map((t4) => {
        var _a2;
        return (_a2 = t4.end) !== null && _a2 !== void 0 ? _a2 : t4.pos;
      })),
      create: HoverTooltipHost.create,
      above: tooltips2[0].above,
      arrow: tooltips2.some((t4) => t4.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active.length)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { view, lastMove } = this;
      let desc = view.docView.nearest(lastMove.target);
      if (!desc)
        return;
      let pos, side = 1;
      if (desc instanceof WidgetView) {
        pos = desc.posAtStart;
      } else {
        pos = view.posAtCoords(lastMove);
        if (pos == null)
          return;
        let posCoords = view.coordsAtPos(pos);
        if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
          return;
        let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s4) => s4.from <= pos && s4.to >= pos);
        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
        side = lastMove.x < posCoords.left ? -rtl : rtl;
      }
      let open = this.source(view, pos, side);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = { pos };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result && !(Array.isArray(result) && !result.length))
              view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
          }
        }, (e3) => logException(view.state, e3, "hover tooltip"));
      } else if (open && !(Array.isArray(open) && !open.length)) {
        view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
      }
    }
    get tooltip() {
      let plugin = this.view.plugin(tooltipPlugin);
      let index2 = plugin ? plugin.manager.tooltips.findIndex((t4) => t4.create == HoverTooltipHost.create) : -1;
      return index2 > -1 ? plugin.manager.tooltipViews[index2] : null;
    }
    mousemove(event2) {
      var _a2, _b;
      this.lastMove = { x: event2.clientX, y: event2.clientY, target: event2.target, time: Date.now() };
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let { active, tooltip } = this;
      if (active.length && tooltip && !isInTooltip(tooltip.dom, event2) || this.pending) {
        let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event2.clientX, event2.clientY)) {
          this.view.dispatch({ effects: this.setHover.of([]) });
          this.pending = null;
        }
      }
    }
    mouseleave(event2) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      let { active } = this;
      if (active.length) {
        let { tooltip } = this;
        let inTooltip = tooltip && tooltip.dom.contains(event2.relatedTarget);
        if (!inTooltip)
          this.view.dispatch({ effects: this.setHover.of([]) });
        else
          this.watchTooltipLeave(tooltip.dom);
      }
    }
    watchTooltipLeave(tooltip) {
      let watch = (event2) => {
        tooltip.removeEventListener("mouseleave", watch);
        if (this.active.length && !this.view.dom.contains(event2.relatedTarget))
          this.view.dispatch({ effects: this.setHover.of([]) });
      };
      tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  var tooltipMargin = 4;
  function isInTooltip(tooltip, event2) {
    let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
      let arrowRect = arrow.getBoundingClientRect();
      top2 = Math.min(arrowRect.top, top2);
      bottom = Math.max(arrowRect.bottom, bottom);
    }
    return event2.clientX >= left - tooltipMargin && event2.clientX <= right + tooltipMargin && event2.clientY >= top2 - tooltipMargin && event2.clientY <= bottom + tooltipMargin;
  }
  function isOverRange(view, from, to, x3, y3, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x3 || rect.right < x3 || rect.top > y3 || Math.min(rect.bottom, docBottom) < y3)
      return false;
    let pos = view.posAtCoords({ x: x3, y: y3 }, false);
    return pos >= from && pos <= to;
  }
  function hoverTooltip(source, options2 = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return [];
      },
      update(value, tr) {
        if (value.length) {
          if (options2.hideOnChange && (tr.docChanged || tr.selection))
            value = [];
          else if (options2.hideOn)
            value = value.filter((v4) => !options2.hideOn(tr, v4));
          if (tr.docChanged) {
            let mapped = [];
            for (let tooltip of value) {
              let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
              if (newPos != null) {
                let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
                copy.pos = newPos;
                if (copy.end != null)
                  copy.end = tr.changes.mapPos(copy.end);
                mapped.push(copy);
              }
            }
            value = mapped;
          }
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = [];
        }
        return value;
      },
      provide: (f4) => showHoverTooltip.from(f4)
    });
    return {
      active: hoverState,
      extension: [
        hoverState,
        ViewPlugin.define((view) => new HoverPlugin(
          view,
          source,
          hoverState,
          setHover,
          options2.hoverTime || 300
          /* Hover.Time */
        )),
        showHoverTooltipHost
      ]
    };
  }
  function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c3 of configs) {
        topContainer = topContainer || c3.topContainer;
        bottomContainer = bottomContainer || c3.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s4) => s4);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p3) => p3.top));
      this.bottom.sync(this.panels.filter((p3) => !p3.top));
      for (let p3 of this.panels) {
        p3.dom.classList.add("cm-panel");
        if (p3.mount)
          p3.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x3) => x3);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p3 of mount) {
          p3.dom.classList.add("cm-panel");
          if (p3.mount)
            p3.mount();
        }
      } else {
        for (let p3 of this.panels)
          if (p3.update)
            p3.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p3 of this.panels)
        if (p3.destroy && panels.indexOf(p3) < 0)
          p3.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    /**
    @internal
    */
    compare(other2) {
      return this == other2 || this.constructor == other2.constructor && this.eq(other2);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other2) {
      return false;
    }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var gutterWidgetClass = /* @__PURE__ */ Facet.define();
  var activeGutters = /* @__PURE__ */ Facet.define();
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x3) => x3)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged) {
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      }
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        if (classSet.length)
          classSet = [];
        if (Array.isArray(line.type)) {
          let first = true;
          for (let b2 of line.type) {
            if (b2.type == BlockType.Text && first) {
              advanceCursor(lineClasses, classSet, b2.from);
              for (let cx of contexts)
                cx.line(this.view, b2, classSet);
              first = false;
            } else if (b2.widget) {
              for (let cx of contexts)
                cx.widget(this.view, b2);
            }
          }
        } else if (line.type == BlockType.Text) {
          advanceCursor(lineClasses, classSet, line.from);
          for (let cx of contexts)
            cx.line(this.view, line, classSet);
        } else if (line.widget) {
          for (let cx of contexts)
            cx.widget(this.view, line);
        }
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g4 of this.gutters) {
          g4.dom.remove();
          if (gutters2.indexOf(g4) < 0)
            g4.destroy();
        }
        for (let g4 of gutters2)
          this.dom.appendChild(g4.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor2, collect, pos) {
    while (cursor2.value && cursor2.from <= pos) {
      if (cursor2.from == pos)
        collect.push(cursor2.value);
      cursor2.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    addElement(view, block2, markers) {
      let { gutter: gutter2 } = this, above = (block2.top - this.height) / view.scaleY, height = block2.height / view.scaleY;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, height, above, markers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, height, above, markers);
      }
      this.height = block2.bottom;
      this.i++;
    }
    line(view, line, extraMarkers) {
      let localMarkers = [];
      advanceCursor(this.cursor, localMarkers, line.from);
      if (extraMarkers.length)
        localMarkers = localMarkers.concat(extraMarkers);
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      this.addElement(view, line, localMarkers);
    }
    widget(view, block2) {
      let marker = this.gutter.config.widgetMarker(view, block2.widget, block2), markers = marker ? [marker] : null;
      for (let cls of view.state.facet(gutterWidgetClass)) {
        let marker2 = cls(view, block2.widget, block2);
        if (marker2)
          (markers || (markers = [])).push(marker2);
      }
      if (markers)
        this.addElement(view, block2, markers);
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last2 = gutter2.elements.pop();
        gutter2.dom.removeChild(last2.dom);
        last2.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config2) {
      this.view = view;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event2) => {
          let target = event2.target, y3;
          if (target != this.dom && this.dom.contains(target)) {
            while (target.parentNode != this.dom)
              target = target.parentNode;
            let rect = target.getBoundingClientRect();
            y3 = (rect.top + rect.bottom) / 2;
          } else {
            y3 = event2.clientY;
          }
          let line = view.lineBlockAtHeight(y3 - view.documentTop);
          if (config2.domEventHandlers[prop](view, line, event2))
            event2.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt2 of this.elements)
        elt2.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height) {
        this.height = height;
        this.dom.style.height = height + "px";
      }
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c3 = marker.elementClass;
          if (c3)
            cls += " " + c3;
          for (let i4 = iOld; i4 < this.markers.length; i4++)
            if (this.markers[i4].compare(marker)) {
              skipTo = i4;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a3, b2) {
    if (a3.length != b2.length)
      return false;
    for (let i4 = 0; i4 < a3.length; i4++)
      if (!a3[i4].compare(b2[i4]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a3, b2) {
          let result = Object.assign({}, a3);
          for (let event2 in b2) {
            let exists = result[event2], add2 = b2[event2];
            result[event2] = exists ? (view, line, event3) => exists(view, line, event3) || add2(view, line, event3) : add2;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other2) {
      return this.number == other2.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m3) => m3.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view, widget, block2) => {
      for (let m3 of view.state.facet(lineNumberWidgetMarker)) {
        let result = m3(view, widget, block2);
        if (result)
          return result;
      }
      return null;
    },
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last2 = 9;
    while (last2 < lines)
      last2 = last2 * 10 + 9;
    return last2;
  }

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values2) => values2.concat(baseData) : void 0
    });
  }
  var sublanguageProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(data, parser5, extraExtensions = [], name2 = "") {
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser5;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => {
          let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
          if (!data2)
            return [];
          let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
          if (sub) {
            let innerNode = top2.resolve(pos - top2.from, side);
            for (let sublang of sub)
              if (sublang.test(innerNode, state)) {
                let data3 = state.facet(sublang.facet);
                return sublang.type == "replace" ? data3 : data3.concat(base2);
              }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos, side = -1) {
      return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r3 of mount.overlay)
                result.push({ from: r3.from + from, to: r3.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size)
              return;
          }
        }
        for (let i4 = 0; i4 < tree.children.length; i4++) {
          let ch = tree.children[i4];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i4] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        if (node.type.isTop)
          tree = node;
    }
    return tree;
  }
  var LRLanguage = class _LRLanguage extends Language {
    constructor(data, parser5, name2) {
      super(data, parser5, [], name2);
      this.parser = parser5;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new _LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type3) => type3.isTop ? data : void 0)]
      }), spec.name);
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
    configure(options2, name2) {
      return new _LRLanguage(this.data, this.parser.configure(options2), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    /**
    Create an input object for the given document.
    */
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class _ParseContext {
    constructor(parser5, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser5;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser5, state, viewport) {
      return new _ParseContext(parser5, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    /**
    @internal
    */
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f4) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f4();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r3; r3 = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r3.from, r3.to);
      return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r3 of this.skipped) {
            let from = changes.mapPos(r3.from, 1), to = changes.mapPos(r3.to, -1);
            if (from < to)
              skipped.push({ from, to });
          }
        }
      }
      return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i4 = 0; i4 < this.skipped.length; i4++) {
        let { from, to } = this.skipped[i4];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i4--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    /**
    @internal
    */
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
      this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser5 = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r3 of ranges)
                  cx.tempSkipped.push(r3);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser5;
        }
      }();
    }
    /**
    @internal
    */
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
  }
  var LanguageState = class _LanguageState {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new _LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new _LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e3 of tr.effects)
        if (e3.is(Language.setState))
          return e3.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(
      () => callback(),
      500
      /* Work.MaxPause */
    );
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(
        () => {
          idle = requestIdleCallback(callback, {
            timeout: 500 - 100
            /* Work.MinPause */
          });
        },
        100
        /* Work.MinPause */
      );
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged || update.selectionSet) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state } = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now2 = Date.now();
      if (this.chunkEnd < now2 && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now2 + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(
        vpTo + 1e5
        /* Work.MaxParseAhead */
      ))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now2;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language3) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language3], (state) => {
        let lang = state.facet(language3);
        return lang && lang.name ? { "data-language": lang.name } : {};
      })
    ]
  });
  var LanguageSupport = class {
    /**
    Create a language support object.
    */
    constructor(language3, support = []) {
      this.language = language3;
      this.support = support;
      this.extension = [language3, support];
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values2) => {
      if (!values2.length)
        return "  ";
      let unit = values2[0];
      if (!unit || /\S/.test(unit) || Array.from(unit).some((e3) => e3 != unit[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
      return unit;
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "	") {
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
      ch = " ";
    }
    for (let i4 = 0; i4 < cols; i4++)
      result += ch;
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    /**
    Create an indent context.
    */
    constructor(state, options2 = {}) {
      this.state = state;
      this.options = options2;
      this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text: text2, from } = this.lineAt(pos, bias);
      return text2.slice(pos - from, Math.min(text2.length, pos + 100 - from));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
      let { text: text2, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text2, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text2, text2.search(/\S|$/));
      return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
      let { text: text2, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text2, text2.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
      let add2 = [];
      for (let cur2 = inner; cur2 && !(cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
        add2.push(cur2);
      for (let i4 = add2.length - 1; i4 >= 0; i4--)
        stack = { node: add2[i4], next: stack };
    }
    return indentFor(stack, cx, pos);
  }
  function indentFor(stack, cx, pos) {
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let strategy = indentStrategy(cur2.node);
      if (strategy)
        return strategy(TreeIndentContext.create(cx, pos, cur2));
    }
    return 0;
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last2 = tree.lastChild, closed = last2 && close.indexOf(last2.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last2.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class _TreeIndentContext extends IndentContext {
    constructor(base2, pos, context) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.context = context;
    }
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    get node() {
      return this.context.node;
    }
    /**
    @internal
    */
    static create(base2, pos, context) {
      return new _TreeIndentContext(base2, pos, context);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
    baseIndentFor(node) {
      let line = this.state.doc.lineAt(node.from);
      for (; ; ) {
        let atBreak = node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
      return indentFor(this.context.next, this.base, this.pos);
    }
  };
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last2 = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last2)
        return null;
      if (!next.type.isSkipped) {
        if (next.from >= lineEnd2)
          return null;
        let space2 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
        return { from: openToken.from, to: openToken.to + space2 };
      }
      pos = next.to;
    }
  }
  function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing2);
  }
  function delimitedStrategy(context, align, units, closing2, closedAt) {
    let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context.pos + space2;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
      let matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length)
        return tr;
      let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r3) => r3.test(lineStart)))
        return tr;
      let { state } = tr, last2 = -1, changes = [];
      for (let { head: head2 } of state.selection.ranges) {
        let line2 = state.doc.lineAt(head2);
        if (line2.from == last2)
          continue;
        last2 = line2.from;
        let indent2 = getIndentation(state, line2.from);
        if (indent2 == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state, indent2);
        if (cur2 != norm)
          changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
      }
      return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
  }
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last2 = node.lastChild;
    return first && first.to < last2.from ? { from: first.to, to: last2.type.isError ? node.to : last2.from } : null;
  }
  var HighlightStyle = class _HighlightStyle {
    constructor(specs, options2) {
      this.specs = specs;
      let modSpec;
      function def2(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all = typeof options2.all == "string" ? options2.all : options2.all ? def2(options2.all) : void 0;
      const scopeOpt = options2.scope;
      this.scope = scopeOpt instanceof Language ? (type3) => type3.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type3) => type3 == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def2(Object.assign({}, style, { tag: null }))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options2.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options2) {
      return new _HighlightStyle(specs, options2 || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return values2.length ? [values2[0]] : null;
    }
  });
  function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options2) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
      this.decoratedTo = view.viewport.to;
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
      if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
        this.decorations = this.decorations.map(update.changes);
        this.decoratedTo = decoratedToMapped;
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
        this.decoratedTo = viewport.to;
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from, to } of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to2, style) => {
          builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
        }, from, to);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v4) => v4.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
  function defaultRenderMatch(match2) {
    let decorations2 = [];
    let mark = match2.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match2.start.from, match2.start.to));
    if (match2.end)
      decorations2.push(mark.range(match2.end.from, match2.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range of tr.state.selection.ranges) {
        if (!range.empty)
          continue;
        let match2 = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
        if (match2)
          decorations2 = decorations2.concat(config2.renderMatch(match2, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f4) => EditorView.decorations.from(f4)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index2 = brackets.indexOf(node.name);
      if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index2 + dir]];
    }
    return null;
  }
  function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
  }
  function matchBrackets(state, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches4 = matchingNodes(cur2.type, dir, brackets);
      if (matches4 && cur2.from < cur2.to) {
        let handle = findHandle(cur2);
        if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
          return matchMarkedBrackets(state, pos, dir, cur2, handle, matches4, brackets);
      }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
            let endHandle = findHandle(cursor2);
            return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
          } else if (matchingNodes(cursor2.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor2.type, -dir, brackets)) {
            if (depth == 0) {
              let endHandle = findHandle(cursor2);
              return {
                start: firstToken,
                end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                matched: false
              };
            }
            depth--;
          }
        }
      } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text2 = iter.value;
      if (dir < 0)
        distance += text2.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text2.length - 1, end = dir > 0 ? text2.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text2[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text2.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var byTag = /* @__PURE__ */ Object.create(null);
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name3 of tagStr.split(" ")) {
      let found = [];
      for (let part of name3.split(".")) {
        let value = extra[part] || tags[part];
        if (!value) {
          warnForPart(part, `Unknown highlighting tag ${part}`);
        } else if (typeof value == "function") {
          if (!found.length)
            warnForPart(part, `Modifier ${part} used at start of tag`);
          else
            found = found.map(value);
        } else {
          if (found.length)
            warnForPart(part, `Tag ${part} used as modifier`);
          else
            found = Array.isArray(value) ? value : [value];
        }
      }
      for (let tag4 of found)
        tags$1.push(tag4);
    }
    if (!tags$1.length)
      return 0;
    let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t4) => t4.id);
    let known = byTag[key];
    if (known)
      return known.id;
    let type3 = byTag[key] = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [styleTags({ [name2]: tags$1 })]
    });
    typeArray.push(type3);
    return type3.id;
  }
  var marks = {
    rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
    ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
    auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
  };

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    /**
    Create a new completion context. (Mostly useful for testing
    completion sourcesin the editor, the extension will create
    these for you.)
    */
    constructor(state, pos, explicit, view) {
      this.state = state;
      this.pos = pos;
      this.explicit = explicit;
      this.view = view;
      this.abortListeners = [];
      this.abortOnDocChange = false;
    }
    /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    /**
    Get the match of the given expression directly before the
    cursor.
    */
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    /**
    Yields true when the query has been aborted. Can be useful in
    asynchronous queries to avoid doing work that will be ignored.
    */
    get aborted() {
      return this.abortListeners == null;
    }
    /**
    Allows you to register abort handlers, which will be called when
    the query is
    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
    
    By default, running queries will not be aborted for regular
    typing or backspacing, on the assumption that they are likely to
    return a result with a
    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
    allows the result to be used after all. Passing `onDocChange:
    true` will cause this query to be aborted for any document
    change.
    */
    addEventListener(type3, listener, options2) {
      if (type3 == "abort" && this.abortListeners) {
        this.abortListeners.push(listener);
        if (options2 && options2.onDocChange)
          this.abortOnDocChange = true;
      }
    }
  };
  function toSet(chars4) {
    let flat = Object.keys(chars4).join("");
    let words = /\w/.test(flat);
    if (words)
      flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options2) {
    let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
    for (let { label } of options2) {
      first[label[0]] = true;
      for (let i4 = 1; i4 < label.length; i4++)
        rest[label[i4]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
  }
  function completeFromList(list2) {
    let options2 = list2.map((o3) => typeof o3 == "string" ? { label: o3 } : o3);
    let [validFor, match2] = options2.every((o3) => /^\w+$/.test(o3.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
    return (context) => {
      let token = context.matchBefore(match2);
      return token || context.explicit ? { from: token ? token.from : context.pos, options: options2, validFor } : null;
    };
  }
  var Option = class {
    constructor(completion, source, match2, score2) {
      this.completion = completion;
      this.source = source;
      this.match = match2;
      this.score = score2;
    }
  };
  function cur(state) {
    return state.selection.main.from;
  }
  function ensureAnchor(expr, start) {
    var _a2;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  var pickedCompletion = /* @__PURE__ */ Annotation.define();
  function insertCompletionText(state, text2, from, to) {
    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
    return Object.assign(Object.assign({}, state.changeByRange((range) => {
      if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
        return { range };
      let lines = state.toText(text2);
      return {
        changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
        range: EditorSelection.cursor(range.from + fromOff + lines.length)
      };
    })), { scrollIntoView: true, userEvent: "input.complete" });
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source))
      return source;
    let known = SourceCache.get(source);
    if (!known)
      SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var FuzzyMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      this.score = 0;
      this.matched = [];
      for (let p3 = 0; p3 < pattern.length; ) {
        let char = codePointAt2(pattern, p3), size = codePointSize2(char);
        this.chars.push(char);
        let part = pattern.slice(p3, p3 + size), upper = part.toUpperCase();
        this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
        p3 += size;
      }
      this.astral = pattern.length != this.chars.length;
    }
    ret(score2, matched) {
      this.score = score2;
      this.matched = matched;
      return this;
    }
    // Matches a given word (completion) against the pattern (input).
    // Will return a boolean indicating whether there was a match and,
    // on success, set `this.score` to the score, `this.matched` to an
    // array of `from, to` pairs indicating the matched parts of `word`.
    //
    // The score is a number that is more negative the worse the match
    // is. See `Penalty` above.
    match(word) {
      if (this.pattern.length == 0)
        return this.ret(-100, []);
      if (word.length < this.pattern.length)
        return null;
      let { chars: chars4, folded, any, precise, byWord } = this;
      if (chars4.length == 1) {
        let first = codePointAt2(word, 0), firstSize = codePointSize2(first);
        let score2 = firstSize == word.length ? 0 : -100;
        if (first == chars4[0]) ;
        else if (first == folded[0])
          score2 += -200;
        else
          return null;
        return this.ret(score2, [0, firstSize]);
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
      let len = chars4.length, anyTo = 0;
      if (direct < 0) {
        for (let i4 = 0, e3 = Math.min(word.length, 200); i4 < e3 && anyTo < len; ) {
          let next = codePointAt2(word, i4);
          if (next == chars4[anyTo] || next == folded[anyTo])
            any[anyTo++] = i4;
          i4 += codePointSize2(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i4 = 0, e3 = Math.min(word.length, 200), prevType = 0; i4 < e3 && byWordTo < len; ) {
        let next = codePointAt2(word, i4);
        if (direct < 0) {
          if (preciseTo < len && next == chars4[preciseTo])
            precise[preciseTo++] = i4;
          if (adjacentTo < len) {
            if (next == chars4[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i4;
              adjacentEnd = i4 + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type3 = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i4 || type3 == 1 && hasLower || prevType == 0 && type3 != 0) {
          if (chars4[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i4;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type3;
        i4 += codePointSize2(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
      if (direct > -1)
        return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
      if (adjacentTo == len)
        return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars4.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score2, positions, word) {
      let result = [], i4 = 0;
      for (let pos of positions) {
        let to = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
        if (i4 && result[i4 - 1] == pos)
          result[i4 - 1] = to;
        else {
          result[i4++] = pos;
          result[i4++] = to;
        }
      }
      return this.ret(score2 - word.length, result);
    }
  };
  var StrictMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.matched = [];
      this.score = 0;
      this.folded = pattern.toLowerCase();
    }
    match(word) {
      if (word.length < this.pattern.length)
        return null;
      let start = word.slice(0, this.pattern.length);
      let match2 = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
      if (match2 == null)
        return null;
      this.matched = [0, start.length];
      this.score = match2 + (word.length == this.pattern.length ? 0 : -100);
      return this;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        activateOnCompletion: () => false,
        activateOnTypingDelay: 100,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        filterStrict: false,
        compareCompletions: (a3, b2) => a3.label.localeCompare(b2.label),
        interactionDelay: 75,
        updateSyncTime: 100
      }, {
        defaultKeymap: (a3, b2) => a3 && b2,
        closeOnBlur: (a3, b2) => a3 && b2,
        icons: (a3, b2) => a3 && b2,
        tooltipClass: (a3, b2) => (c3) => joinClass(a3(c3), b2(c3)),
        optionClass: (a3, b2) => (c3) => joinClass(a3(c3), b2(c3)),
        addToOptions: (a3, b2) => a3.concat(b2),
        filterStrict: (a3, b2) => a3 || b2
      });
    }
  });
  function joinClass(a3, b2) {
    return a3 ? b2 ? a3 + " " + b2 : a3 : b2;
  }
  function defaultPositionInfo(view, list2, option, info, space2, tooltip) {
    let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
    let side = "top", offset2, maxWidth;
    let spaceLeft = list2.left - space2.left, spaceRight = space2.right - list2.right;
    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight))
      left = false;
    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
      left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
      offset2 = Math.max(space2.top, Math.min(option.top, space2.bottom - infoHeight)) - list2.top;
      maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
    } else {
      narrow = true;
      maxWidth = Math.min(
        400,
        (rtl ? list2.right : space2.right - list2.left) - 30
        /* Info.Margin */
      );
      let spaceBelow = space2.bottom - list2.bottom;
      if (spaceBelow >= infoHeight || spaceBelow > list2.top) {
        offset2 = option.bottom - list2.top;
      } else {
        side = "bottom";
        offset2 = list2.bottom - option.top;
      }
    }
    let scaleY = (list2.bottom - list2.top) / tooltip.offsetHeight;
    let scaleX = (list2.right - list2.left) / tooltip.offsetWidth;
    return {
      style: `${side}: ${offset2 / scaleY}px; max-width: ${maxWidth / scaleX}px`,
      class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
    };
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons)
      content2.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content2.push({
      render(completion, _s, _v, match2) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let label = completion.displayLabel || completion.label, off = 0;
        for (let j4 = 0; j4 < match2.length; ) {
          let from = match2[j4++], to = match2[j4++];
          if (from > off)
            labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length)
          labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a3, b2) => a3.position - b2.position).map((a3) => a3.render);
  }
  function rangeAroundSelected(total, selected, max) {
    if (total <= max)
      return { from: 0, to: total };
    if (selected < 0)
      selected = 0;
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max);
      return { from: off2 * max, to: (off2 + 1) * max };
    }
    let off = Math.floor((total - selected) / max);
    return { from: total - (off + 1) * max, to: total - off * max };
  }
  var CompletionTooltip = class {
    constructor(view, stateField, applyCompletion2) {
      this.view = view;
      this.stateField = stateField;
      this.applyCompletion = applyCompletion2;
      this.info = null;
      this.infoDestroy = null;
      this.placeInfoReq = {
        read: () => this.measureInfo(),
        write: (pos) => this.placeInfo(pos),
        key: this
      };
      this.space = null;
      this.currentClass = "";
      let cState = view.state.field(stateField);
      let { options: options2, selected } = cState.open;
      let config2 = view.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.tooltipClass = config2.tooltipClass;
      this.range = rangeAroundSelected(options2.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.updateTooltipClass(view.state);
      this.dom.addEventListener("mousedown", (e3) => {
        let { options: options3 } = view.state.field(stateField).open;
        for (let dom = e3.target, match2; dom && dom != this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match2 = /-(\d+)$/.exec(dom.id)) && +match2[1] < options3.length) {
            this.applyCompletion(view, options3[+match2[1]]);
            e3.preventDefault();
            return;
          }
        }
      });
      this.dom.addEventListener("focusout", (e3) => {
        let state = view.state.field(this.stateField, false);
        if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e3.relatedTarget != view.contentDOM)
          view.dispatch({ effects: closeCompletionEffect.of(null) });
      });
      this.showOptions(options2, cState.id);
    }
    mount() {
      this.updateSel();
    }
    showOptions(options2, id2) {
      if (this.list)
        this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(options2, id2, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfoReq);
      });
    }
    update(update) {
      var _a2;
      let cState = update.state.field(this.stateField);
      let prevState = update.startState.field(this.stateField);
      this.updateTooltipClass(update.state);
      if (cState != prevState) {
        let { options: options2, selected, disabled } = cState.open;
        if (!prevState.open || prevState.open.options != options2) {
          this.range = rangeAroundSelected(options2.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
          this.showOptions(options2, cState.id);
        }
        this.updateSel();
        if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
      }
    }
    updateTooltipClass(state) {
      let cls = this.tooltipClass(state);
      if (cls != this.currentClass) {
        for (let c3 of this.currentClass.split(" "))
          if (c3)
            this.dom.classList.remove(c3);
        for (let c3 of cls.split(" "))
          if (c3)
            this.dom.classList.add(c3);
        this.currentClass = cls;
      }
    }
    positioned(space2) {
      this.space = space2;
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(open.options, cState.id);
      }
      if (this.updateSelectedOption(open.selected)) {
        this.destroyInfo();
        let { completion } = open.options[open.selected];
        let { info } = completion;
        if (!info)
          return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((obj) => {
            if (obj && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(obj, completion);
          }).catch((e3) => logException(this.view.state, e3, "completion info"));
        } else {
          this.addInfoPane(infoResult, completion);
        }
      }
    }
    addInfoPane(content2, completion) {
      this.destroyInfo();
      let wrap2 = this.info = document.createElement("div");
      wrap2.className = "cm-tooltip cm-completionInfo";
      if (content2.nodeType != null) {
        wrap2.appendChild(content2);
        this.infoDestroy = null;
      } else {
        let { dom, destroy } = content2;
        wrap2.appendChild(dom);
        this.infoDestroy = destroy || null;
      }
      this.dom.appendChild(wrap2);
      this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(selected) {
      let set3 = null;
      for (let opt = this.list.firstChild, i4 = this.range.from; opt; opt = opt.nextSibling, i4++) {
        if (opt.nodeName != "LI" || !opt.id) {
          i4--;
        } else if (i4 == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set3 = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set3)
        scrollIntoView2(this.list, set3);
      return set3;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      let space2 = this.space;
      if (!space2) {
        let docElt = this.dom.ownerDocument.documentElement;
        space2 = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
      }
      if (selRect.top > Math.min(space2.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space2.top, listRect.top) + 10)
        return null;
      return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space2, this.dom);
    }
    placeInfo(pos) {
      if (this.info) {
        if (pos) {
          if (pos.style)
            this.info.style.cssText = pos.style;
          this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
        } else {
          this.info.style.cssText = "top: -1e6px";
        }
      }
    }
    createListBox(options2, id2, range) {
      const ul = document.createElement("ul");
      ul.id = id2;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      ul.addEventListener("mousedown", (e3) => {
        if (e3.target == ul)
          e3.preventDefault();
      });
      let curSection = null;
      for (let i4 = range.from; i4 < range.to; i4++) {
        let { completion, match: match2 } = options2[i4], { section } = completion;
        if (section) {
          let name2 = typeof section == "string" ? section : section.name;
          if (name2 != curSection && (i4 > range.from || range.from == 0)) {
            curSection = name2;
            if (typeof section != "string" && section.header) {
              ul.appendChild(section.header(section));
            } else {
              let header = ul.appendChild(document.createElement("completion-section"));
              header.textContent = name2;
            }
          }
        }
        const li = ul.appendChild(document.createElement("li"));
        li.id = id2 + "-" + i4;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source of this.optionContent) {
          let node = source(completion, this.view.state, this.view, match2);
          if (node)
            li.appendChild(node);
        }
      }
      if (range.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range.to < options2.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
    destroyInfo() {
      if (this.info) {
        if (this.infoDestroy)
          this.infoDestroy();
        this.info.remove();
        this.info = null;
      }
    }
    destroy() {
      this.destroyInfo();
    }
  };
  function completionTooltip(stateField, applyCompletion2) {
    return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
  }
  function scrollIntoView2(container, element) {
    let parent = container.getBoundingClientRect();
    let self2 = element.getBoundingClientRect();
    let scaleY = parent.height / container.offsetHeight;
    if (self2.top < parent.top)
      container.scrollTop -= (parent.top - self2.top) / scaleY;
    else if (self2.bottom > parent.bottom)
      container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state) {
    let options2 = [];
    let sections = null;
    let addOption = (option) => {
      options2.push(option);
      let { section } = option.completion;
      if (section) {
        if (!sections)
          sections = [];
        let name2 = typeof section == "string" ? section : section.name;
        if (!sections.some((s4) => s4.name == name2))
          sections.push(typeof section == "string" ? { name: name2 } : section);
      }
    };
    let conf = state.facet(completionConfig);
    for (let a3 of active)
      if (a3.hasResult()) {
        let getMatch = a3.result.getMatch;
        if (a3.result.filter === false) {
          for (let option of a3.result.options) {
            addOption(new Option(option, a3.source, getMatch ? getMatch(option) : [], 1e9 - options2.length));
          }
        } else {
          let pattern = state.sliceDoc(a3.from, a3.to), match2;
          let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
          for (let option of a3.result.options)
            if (match2 = matcher.match(option.label)) {
              let matched = !option.displayLabel ? match2.matched : getMatch ? getMatch(option, match2.matched) : [];
              addOption(new Option(option, a3.source, matched, match2.score + (option.boost || 0)));
            }
        }
      }
    if (sections) {
      let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
      let cmp = (a3, b2) => {
        var _a2, _b;
        return ((_a2 = a3.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) - ((_b = b2.rank) !== null && _b !== void 0 ? _b : 1e9) || (a3.name < b2.name ? -1 : 1);
      };
      for (let s4 of sections.sort(cmp)) {
        pos -= 1e5;
        sectionOrder[s4.name] = pos;
      }
      for (let option of options2) {
        let { section } = option.completion;
        if (section)
          option.score += sectionOrder[typeof section == "string" ? section : section.name];
      }
    }
    let result = [], prev = null;
    let compare2 = conf.compareCompletions;
    for (let opt of options2.sort((a3, b2) => b2.score - a3.score || compare2(a3.completion, b2.completion))) {
      let cur2 = opt.completion;
      if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class _CompletionDialog {
    constructor(options2, attrs, tooltip, timestamp, selected, disabled) {
      this.options = options2;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
      this.disabled = disabled;
    }
    setSelected(selected, id2) {
      return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id2, prev, conf, didSetActive) {
      if (prev && !didSetActive && active.some((s4) => s4.isPending))
        return prev.setDisabled();
      let options2 = sortOptions(active, state);
      if (!options2.length)
        return prev && active.some((a3) => a3.isPending) ? prev.setDisabled() : null;
      let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
      if (prev && prev.selected != selected && prev.selected != -1) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i4 = 0; i4 < options2.length; i4++)
          if (options2[i4].completion == selectedValue) {
            selected = i4;
            break;
          }
      }
      return new _CompletionDialog(options2, makeAttrs(id2, selected), {
        pos: active.reduce((a3, b2) => b2.hasResult() ? Math.min(a3, b2.from) : a3, 1e8),
        create: createTooltip,
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
      return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
      return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
  };
  var CompletionState = class _CompletionState {
    constructor(active, id2, open) {
      this.active = active;
      this.id = id2;
      this.open = open;
    }
    static start() {
      return new _CompletionState(none2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let { state } = tr, conf = state.facet(completionConfig);
      let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
      let active = sources.map((source) => {
        let value = this.active.find((s4) => s4.source == source) || new ActiveSource(
          source,
          this.active.some(
            (a3) => a3.state != 0
            /* State.Inactive */
          ) ? 1 : 0
          /* State.Inactive */
        );
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a3, i4) => a3 == this.active[i4]))
        active = this.active;
      let open = this.open, didSet = tr.effects.some((e3) => e3.is(setActiveEffect));
      if (open && tr.docChanged)
        open = open.map(tr.changes);
      if (tr.selection || active.some((a3) => a3.hasResult() && tr.changes.touchesRange(a3.from, a3.to)) || !sameResults(active, this.active) || didSet)
        open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
      else if (open && open.disabled && !active.some((a3) => a3.isPending))
        open = null;
      if (!open && active.every((a3) => !a3.isPending) && active.some((a3) => a3.hasResult()))
        active = active.map((a3) => a3.hasResult() ? new ActiveSource(
          a3.source,
          0
          /* State.Inactive */
        ) : a3);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
    }
  };
  function sameResults(a3, b2) {
    if (a3 == b2)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a3.length && !a3[iA].hasResult())
        iA++;
      while (iB < b2.length && !b2[iB].hasResult())
        iB++;
      let endA = iA == a3.length, endB = iB == b2.length;
      if (endA || endB)
        return endA == endB;
      if (a3[iA++].result != b2[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  var noAttrs2 = {};
  function makeAttrs(id2, selected) {
    let result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id2
    };
    if (selected > -1)
      result["aria-activedescendant"] = id2 + "-" + selected;
    return result;
  }
  var none2 = [];
  function getUpdateType(tr, conf) {
    if (tr.isUserEvent("input.complete")) {
      let completion = tr.annotation(pickedCompletion);
      if (completion && conf.activateOnCompletion(completion))
        return 4 | 8;
    }
    let typing = tr.isUserEvent("input.type");
    return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
  }
  var ActiveSource = class _ActiveSource {
    constructor(source, state, explicit = false) {
      this.source = source;
      this.state = state;
      this.explicit = explicit;
    }
    hasResult() {
      return false;
    }
    get isPending() {
      return this.state == 1;
    }
    update(tr, conf) {
      let type3 = getUpdateType(tr, conf), value = this;
      if (type3 & 8 || type3 & 16 && this.touches(tr))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      if (type3 & 4 && value.state == 0)
        value = new _ActiveSource(
          this.source,
          1
          /* State.Pending */
        );
      value = value.updateFor(tr, type3);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value = new _ActiveSource(value.source, 1, effect.value);
        else if (effect.is(closeCompletionEffect))
          value = new _ActiveSource(
            value.source,
            0
            /* State.Inactive */
          );
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value.source)
              value = active;
        }
      }
      return value;
    }
    updateFor(tr, type3) {
      return this.map(tr.changes);
    }
    map(changes) {
      return this;
    }
    touches(tr) {
      return tr.changes.touchesRange(cur(tr.state));
    }
  };
  var ActiveResult = class _ActiveResult extends ActiveSource {
    constructor(source, explicit, limit, result, from, to) {
      super(source, 3, explicit);
      this.limit = limit;
      this.result = result;
      this.from = from;
      this.to = to;
    }
    hasResult() {
      return true;
    }
    updateFor(tr, type3) {
      var _a2;
      if (!(type3 & 3))
        return this.map(tr.changes);
      let result = this.result;
      if (result.map && !tr.changes.empty)
        result = result.map(result, tr.changes);
      let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if (pos > to || !result || type3 & 2 && (cur(tr.startState) == this.from || pos < this.limit))
        return new ActiveSource(
          this.source,
          type3 & 4 ? 1 : 0
          /* State.Inactive */
        );
      let limit = tr.changes.mapPos(this.limit);
      if (checkValid(result.validFor, tr.state, from, to))
        return new _ActiveResult(this.source, this.explicit, limit, result, from, to);
      if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
        return new _ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, this.explicit);
    }
    map(mapping) {
      if (mapping.empty)
        return this;
      let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
      if (!result)
        return new ActiveSource(
          this.source,
          0
          /* State.Inactive */
        );
      return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
    touches(tr) {
      return tr.changes.touchesRange(this.from, this.to);
    }
  };
  function checkValid(validFor, state, from, to) {
    if (!validFor)
      return false;
    let text2 = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text2, from, to, state) : ensureAnchor(validFor, true).test(text2);
  }
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources, mapping) {
      return sources.map((s4) => s4.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f4) => [
      showTooltip.from(f4, (val) => val.tooltip),
      EditorView.contentAttributes.from(f4, (state) => state.attrs)
    ]
  });
  function applyCompletion(view, option) {
    const apply2 = option.completion.apply || option.completion.label;
    let result = view.state.field(completionState).active.find((a3) => a3.source == option.source);
    if (!(result instanceof ActiveResult))
      return false;
    if (typeof apply2 == "string")
      view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply2, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
    else
      apply2(view, option.completion, result.from, result.to);
    return true;
  }
  var createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
  function moveCompletionSelection(forward, by = "option") {
    return (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
        step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let { length } = cState.open.options;
      let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
      if (selected < 0)
        selected = by == "page" ? 0 : length - 1;
      else if (selected >= length)
        selected = by == "page" ? length - 1 : 0;
      view.dispatch({ effects: setSelectedEffect.of(selected) });
      return true;
    };
  }
  var acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    return applyCompletion(view, cState.open.options[cState.open.selected]);
  };
  var startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
      return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
  };
  var closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some(
      (a3) => a3.state != 0
      /* State.Inactive */
    ))
      return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
  };
  var RunningQuery = class {
    constructor(active, context) {
      this.active = active;
      this.context = context;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.pendingStart = false;
      this.composing = 0;
      for (let active of view.state.field(completionState).active)
        if (active.isPending)
          this.startQuery(active);
    }
    update(update) {
      let cState = update.state.field(completionState);
      let conf = update.state.facet(completionConfig);
      if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
        return;
      let doesReset = update.transactions.some((tr) => {
        let type3 = getUpdateType(tr, conf);
        return type3 & 8 || (tr.selection || tr.docChanged) && !(type3 & 3);
      });
      for (let i4 = 0; i4 < this.running.length; i4++) {
        let query2 = this.running[i4];
        if (doesReset || query2.context.abortOnDocChange && update.docChanged || query2.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query2.time > MinAbortTime) {
          for (let handler of query2.context.abortListeners) {
            try {
              handler();
            } catch (e3) {
              logException(this.view.state, e3);
            }
          }
          query2.context.abortListeners = null;
          this.running.splice(i4--, 1);
        } else {
          query2.updates.push(...update.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      if (update.transactions.some((tr) => tr.effects.some((e3) => e3.is(startCompletionEffect))))
        this.pendingStart = true;
      let delay3 = this.pendingStart ? 50 : conf.activateOnTypingDelay;
      this.debounceUpdate = cState.active.some((a3) => a3.isPending && !this.running.some((q4) => q4.active.source == a3.source)) ? setTimeout(() => this.startUpdate(), delay3) : -1;
      if (this.composing != 0)
        for (let tr of update.transactions) {
          if (tr.isUserEvent("input.type"))
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      this.pendingStart = false;
      let { state } = this.view, cState = state.field(completionState);
      for (let active of cState.active) {
        if (active.isPending && !this.running.some((r3) => r3.active.source == active.source))
          this.startQuery(active);
      }
      if (this.running.length && cState.open && cState.open.disabled)
        this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    startQuery(active) {
      let { state } = this.view, pos = cur(state);
      let context = new CompletionContext(state, pos, active.explicit, this.view);
      let pending = new RunningQuery(active, context);
      this.running.push(pending);
      Promise.resolve(active.source(context)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q4) => q4.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    // For each finished query in this.running, try to create a result
    // or, if appropriate, restart the query.
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
      for (let i4 = 0; i4 < this.running.length; i4++) {
        let query2 = this.running[i4];
        if (query2.done === void 0)
          continue;
        this.running.splice(i4--, 1);
        if (query2.done) {
          let pos = cur(query2.updates.length ? query2.updates[0].startState : this.view.state);
          let limit = Math.min(pos, query2.done.from + (query2.active.explicit ? 0 : 1));
          let active = new ActiveResult(query2.active.source, query2.active.explicit, limit, query2.done, query2.done.from, (_a2 = query2.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
          for (let tr of query2.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = cState.active.find((a3) => a3.source == query2.active.source);
        if (current && current.isPending) {
          if (query2.done == null) {
            let active = new ActiveSource(
              query2.active.source,
              0
              /* State.Inactive */
            );
            for (let tr of query2.updates)
              active = active.update(tr, conf);
            if (!active.isPending)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length || cState.open && cState.open.disabled)
        this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
  }, {
    eventHandlers: {
      blur(event2) {
        let state = this.view.state.field(completionState, false);
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
          let dialog = state.open && getTooltip(this.view, state.open.tooltip);
          if (!dialog || !dialog.dom.contains(event2.relatedTarget))
            setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
        }
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
        }
        this.composing = 0;
      }
    }
  });
  var windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
  var commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event2, view) {
      let field = view.state.field(completionState, false);
      if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event2.key.length > 1 || event2.ctrlKey && !(windows && event2.altKey) || event2.metaKey)
        return false;
      let option = field.open.options[field.open.selected];
      let result = field.active.find((a3) => a3.source == option.source);
      let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
      if (commitChars && commitChars.indexOf(event2.key) > -1)
        applyCompletion(view, option);
      return false;
    }
  }));
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": {
          padding: "1px 3px",
          lineHeight: 1.2
        },
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer"
        },
        "& > completion-section": {
          display: "list-item",
          borderBottom: "1px solid silver",
          paddingLeft: "0.5em",
          opacity: 0.7
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box",
      whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": { content: "'\u0192'" }
    },
    ".cm-completionIcon-class": {
      "&:after": { content: "'\u25CB'" }
    },
    ".cm-completionIcon-interface": {
      "&:after": { content: "'\u25CC'" }
    },
    ".cm-completionIcon-variable": {
      "&:after": { content: "'\u{1D465}'" }
    },
    ".cm-completionIcon-constant": {
      "&:after": { content: "'\u{1D436}'" }
    },
    ".cm-completionIcon-type": {
      "&:after": { content: "'\u{1D461}'" }
    },
    ".cm-completionIcon-enum": {
      "&:after": { content: "'\u222A'" }
    },
    ".cm-completionIcon-property": {
      "&:after": { content: "'\u25A1'" }
    },
    ".cm-completionIcon-keyword": {
      "&:after": { content: "'\u{1F511}\uFE0E'" }
      // Disable emoji rendering
    },
    ".cm-completionIcon-namespace": {
      "&:after": { content: "'\u25A2'" }
    },
    ".cm-completionIcon-text": {
      "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
  });
  var FieldPos = class {
    constructor(field, line, from, to) {
      this.field = field;
      this.line = line;
      this.from = from;
      this.to = to;
    }
  };
  var FieldRange = class _FieldRange {
    constructor(field, from, to) {
      this.field = field;
      this.from = from;
      this.to = to;
    }
    map(changes) {
      let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
      let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
      return from == null || to == null ? null : new _FieldRange(this.field, from, to);
    }
  };
  var Snippet = class _Snippet {
    constructor(lines, fieldPositions) {
      this.lines = lines;
      this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
      let text2 = [], lineStart = [pos];
      let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
      for (let line of this.lines) {
        if (text2.length) {
          let indent2 = baseIndent, tabs = /^\t*/.exec(line)[0].length;
          for (let i4 = 0; i4 < tabs; i4++)
            indent2 += state.facet(indentUnit);
          lineStart.push(pos + indent2.length - tabs);
          line = indent2 + line.slice(tabs);
        }
        text2.push(line);
        pos += line.length + 1;
      }
      let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
      return { text: text2, ranges };
    }
    static parse(template) {
      let fields = [];
      let lines = [], positions = [], m3;
      for (let line of template.split(/\r\n?|\n/)) {
        while (m3 = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line)) {
          let seq = m3[1] ? +m3[1] : null, rawName = m3[2] || m3[3] || "", found = -1;
          let name2 = rawName.replace(/\\[{}]/g, (m4) => m4[1]);
          for (let i4 = 0; i4 < fields.length; i4++) {
            if (seq != null ? fields[i4].seq == seq : name2 ? fields[i4].name == name2 : false)
              found = i4;
          }
          if (found < 0) {
            let i4 = 0;
            while (i4 < fields.length && (seq == null || fields[i4].seq != null && fields[i4].seq < seq))
              i4++;
            fields.splice(i4, 0, { seq, name: name2 });
            found = i4;
            for (let pos of positions)
              if (pos.field >= found)
                pos.field++;
          }
          positions.push(new FieldPos(found, lines.length, m3.index, m3.index + name2.length));
          line = line.slice(0, m3.index) + rawName + line.slice(m3.index + m3[0].length);
        }
        line = line.replace(/\\([{}])/g, (_3, brace, index2) => {
          for (let pos of positions)
            if (pos.line == lines.length && pos.from > index2) {
              pos.from--;
              pos.to--;
            }
          return brace;
        });
        lines.push(line);
      }
      return new _Snippet(lines, positions);
    }
  };
  var fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM() {
      let span = document.createElement("span");
      span.className = "cm-snippetFieldPosition";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  }() });
  var fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
  var ActiveSnippet = class _ActiveSnippet {
    constructor(ranges, active) {
      this.ranges = ranges;
      this.active = active;
      this.deco = Decoration.set(ranges.map((r3) => (r3.from == r3.to ? fieldMarker : fieldRange).range(r3.from, r3.to)));
    }
    map(changes) {
      let ranges = [];
      for (let r3 of this.ranges) {
        let mapped = r3.map(changes);
        if (!mapped)
          return null;
        ranges.push(mapped);
      }
      return new _ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
      return sel.ranges.every((range) => this.ranges.some((r3) => r3.field == this.active && r3.from <= range.from && r3.to >= range.to));
    }
  };
  var setActive = /* @__PURE__ */ StateEffect.define({
    map(value, changes) {
      return value && value.map(changes);
    }
  });
  var moveToField = /* @__PURE__ */ StateEffect.define();
  var snippetState = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setActive))
          return effect.value;
        if (effect.is(moveToField) && value)
          return new ActiveSnippet(value.ranges, effect.value);
      }
      if (value && tr.docChanged)
        value = value.map(tr.changes);
      if (value && tr.selection && !value.selectionInsideField(tr.selection))
        value = null;
      return value;
    },
    provide: (f4) => EditorView.decorations.from(f4, (val) => val ? val.deco : Decoration.none)
  });
  function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter((r3) => r3.field == field).map((r3) => EditorSelection.range(r3.from, r3.to)));
  }
  function snippet(template) {
    let snippet2 = Snippet.parse(template);
    return (editor, completion, from, to) => {
      let { text: text2, ranges } = snippet2.instantiate(editor.state, from);
      let { main } = editor.state.selection;
      let spec = {
        changes: { from, to: to == main.from ? main.to : to, insert: Text.of(text2) },
        scrollIntoView: true,
        annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
      };
      if (ranges.length)
        spec.selection = fieldSelection(ranges, 0);
      if (ranges.some((r3) => r3.field > 0)) {
        let active = new ActiveSnippet(ranges, 0);
        let effects = spec.effects = [setActive.of(active)];
        if (editor.state.field(snippetState, false) === void 0)
          effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme3]));
      }
      editor.dispatch(editor.state.update(spec));
    };
  }
  function moveField(dir) {
    return ({ state, dispatch }) => {
      let active = state.field(snippetState, false);
      if (!active || dir < 0 && active.active == 0)
        return false;
      let next = active.active + dir, last2 = dir > 0 && !active.ranges.some((r3) => r3.field == next + dir);
      dispatch(state.update({
        selection: fieldSelection(active.ranges, next),
        effects: setActive.of(last2 ? null : new ActiveSnippet(active.ranges, next)),
        scrollIntoView: true
      }));
      return true;
    };
  }
  var clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active)
      return false;
    dispatch(state.update({ effects: setActive.of(null) }));
    return true;
  };
  var nextSnippetField = /* @__PURE__ */ moveField(1);
  var prevSnippetField = /* @__PURE__ */ moveField(-1);
  var defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
  ];
  var snippetKeymap = /* @__PURE__ */ Facet.define({
    combine(maps) {
      return maps.length ? maps[0] : defaultSnippetKeymap;
    }
  });
  var addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
  function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
  }
  var snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
    mousedown(event2, view) {
      let active = view.state.field(snippetState, false), pos;
      if (!active || (pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY })) == null)
        return false;
      let match2 = active.ranges.find((r3) => r3.from <= pos && r3.to >= pos);
      if (!match2 || match2.field == active.active)
        return false;
      view.dispatch({
        selection: fieldSelection(active.ranges, match2.field),
        effects: setActive.of(active.ranges.some((r3) => r3.field > match2.field) ? new ActiveSnippet(active.ranges, match2.field) : null),
        scrollIntoView: true
      });
      return true;
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      value = value.map(tr.changes);
      if (tr.selection) {
        let line = tr.state.doc.lineAt(tr.selection.main.head);
        value = value.update({ filter: (from) => from >= line.from && from <= line.to });
      }
      for (let effect of tr.effects)
        if (effect.is(closeBracketEffect))
          value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
      return value;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
  function closing(ch) {
    for (let i4 = 0; i4 < definedClosing.length; i4 += 2)
      if (definedClosing.charCodeAt(i4) == ch)
        return definedClosing.charAt(i4 + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
      return false;
    let sel = view.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from != sel.from || to != sel.to)
      return false;
    let tr = insertBracket(view.state, insert2);
    if (!tr)
      return false;
    view.dispatch(tr);
    return true;
  });
  function insertBracket(state, bracket2) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt2(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
        return handleClose(state, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, (from) => {
      if (from == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize2(codePointAt2(next, 0)));
  }
  function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
          effects: closeBracketEffect.of(range.to + open.length),
          range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
      let next = nextChar(state.doc, range.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: { insert: open + close, from: range.head },
          effects: closeBracketEffect.of(range.head + open.length),
          range: EditorSelection.cursor(range.head + open.length)
        };
      return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state, _open, close) {
    let dont = null, changes = state.changeByRange((range) => {
      if (range.empty && nextChar(state.doc, range.head) == close)
        return {
          changes: { from: range.head, to: range.head + close.length, insert: close },
          range: EditorSelection.cursor(range.head + close.length)
        };
      return dont = { range };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleSame(state, token, allowTriple, config2) {
    let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
          effects: closeBracketEffect.of(range.to + token.length),
          range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
      let pos = range.head, next = nextChar(state.doc, pos), start;
      if (next == token) {
        if (nodeStart(state, pos)) {
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state, pos)) {
          let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          let content2 = isTriple ? token + token + token : token;
          return {
            changes: { from: pos, to: pos + content2.length, insert: content2 },
            range: EditorSelection.cursor(pos + content2.length)
          };
        }
      } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
        return {
          changes: { insert: token + token + token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
        if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state, pos) {
    let tree = syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state, pos, quoteToken, prefixes) {
    let node = syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m3, p3) => Math.max(m3, p3.length), 0);
    for (let i4 = 0; i4 < 5; i4++) {
      let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      let quotePos = start.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
        let first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
            return false;
          first = first.firstChild;
        }
        return true;
      }
      let parent = node.to == pos && node.parent;
      if (!parent)
        break;
      node = parent;
    }
    return false;
  }
  function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
      return pos;
    for (let prefix2 of prefixes) {
      let start = pos - prefix2.length;
      if (state.sliceDoc(start, pos) == prefix2 && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
        return start;
    }
    return -1;
  }
  function autocompletion(config2 = {}) {
    return [
      commitCharacters,
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme3
    ];
  }
  var completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { mac: "Alt-`", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
    { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
    { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
    { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f4, option) {
    return ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let tr = f4(option, state);
      if (!tr)
        return false;
      dispatch(state.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(
    changeLineComment,
    0
    /* CommentOption.Toggle */
  );
  var toggleBlockComment = /* @__PURE__ */ command(
    changeBlockComment,
    0
    /* CommentOption.Toggle */
  );
  var toggleBlockCommentByLine = /* @__PURE__ */ command(
    (o3, s4) => changeBlockComment(o3, s4, selectedLineRanges(s4)),
    0
    /* CommentOption.Toggle */
  );
  function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos, 1);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r3 of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r3.from);
      let toLine = r3.to <= fromLine.to ? fromLine : state.doc.lineAt(r3.to);
      if (toLine.from > fromLine.from && toLine.from == r3.to)
        toLine = r3.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r3.to - 1);
      let last2 = ranges.length - 1;
      if (last2 >= 0 && ranges[last2].to > fromLine.from)
        ranges[last2].to = toLine.to;
      else
        ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r3) => getConfig(state, r3.from).block);
    if (!tokens.every((c3) => c3))
      return null;
    let comments = ranges.map((r3, i4) => findBlockComment(state, tokens[i4], r3.from, r3.to));
    if (option != 2 && !comments.every((c3) => c3)) {
      return { changes: state.changes(ranges.map((range, i4) => {
        if (comments[i4])
          return [];
        return [{ from: range.from, insert: tokens[i4].open + " " }, { from: range.to, insert: " " + tokens[i4].close }];
      })) };
    } else if (option != 1 && comments.some((c3) => c3)) {
      let changes = [];
      for (let i4 = 0, comment2; i4 < comments.length; i4++)
        if (comment2 = comments[i4]) {
          let token = tokens[i4], { open, close } = comment2;
          changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      let token = getConfig(state, from).line;
      if (!token)
        continue;
      for (let pos = from; pos <= to; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from == to || to > line.from)) {
          prevLine = line.from;
          let indent2 = /^\s*/.exec(line.text)[0].length;
          let empty = indent2 == line.length;
          let comment2 = line.text.slice(indent2, indent2 + token.length) == token ? indent2 : -1;
          if (indent2 < line.text.length && indent2 < minIndent)
            minIndent = indent2;
          lines.push({ line, comment: comment2, token, indent: indent2, empty, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i4 = startI; i4 < lines.length; i4++)
          if (lines[i4].indent < lines[i4].line.text.length)
            lines[i4].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l4) => l4.comment < 0 && (!l4.empty || l4.single))) {
      let changes = [];
      for (let { line, token, indent: indent2, empty, single } of lines)
        if (single || !empty)
          changes.push({ from: line.from + indent2, insert: token + " " });
      let changeSet = state.changes(changes);
      return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    } else if (option != 1 && lines.some((l4) => l4.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines)
        if (comment2 >= 0) {
          let from = line.from + comment2, to = from + token.length;
          if (line.text[to - line.from] == " ")
            to++;
          changes.push({ from, to });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var HistEvent = class _HistEvent {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s4) => s4.toJSON())
      };
    }
    static fromJSON(json) {
      return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr, selection2) {
      let effects = none3;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none3);
    }
    static selection(selections) {
      return new _HistEvent(void 0, none3, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a3, b2) {
    let ranges = [], isAdjacent2 = false;
    a3.iterChangedRanges((f4, t4) => ranges.push(f4, t4));
    b2.iterChangedRanges((_f, _t, f4, t4) => {
      for (let i4 = 0; i4 < ranges.length; ) {
        let from = ranges[i4++], to = ranges[i4++];
        if (t4 >= from && f4 <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a3, b2) {
    return a3.ranges.length == b2.ranges.length && a3.ranges.filter((r3, i4) => r3.empty != b2.ranges[i4].empty).length === 0;
  }
  function conc(a3, b2) {
    return !a3.length ? b2 : !b2.length ? a3 : a3.concat(b2);
  }
  var none3 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection2) {
    if (!branch.length) {
      return [HistEvent.selection([selection2])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection2))
        return branch;
      sels.push(selection2);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last2 = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last2.setSelAfter(last2.selectionsAfter.slice(0, last2.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none3;
    while (length) {
      let event2 = mapEvent(branch[length - 1], mapping, selections);
      if (event2.changes && !event2.changes.empty || event2.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event2;
        return result;
      } else {
        mapping = event2.mapped;
        length--;
        selections = event2.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none3;
  }
  function mapEvent(event2, mapping, extraSelections) {
    let selections = conc(event2.selectionsAfter.length ? event2.selectionsAfter.map((s4) => s4.map(mapping)) : none3, extraSelections);
    if (!event2.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event2.changes.map(mapping), before3 = mapping.mapDesc(event2.changes, true);
    let fullMapping = event2.mapped ? event2.mapped.composeDesc(before3) : before3;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event2.effects, mapping), fullMapping, event2.startSelection.map(before3), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class _HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
    }
    addChanges(event2, time, userEvent, config2, tr) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event2.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event2.changes)) || // For compose (but not compose.start) events, always join with previous event
      userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event2.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event2.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none3));
      } else {
        done = updateBranch(done, done.length, config2.minDepth, event2);
      }
      return new _HistoryState(done, none3, time, userEvent);
    }
    addSelection(selection2, time, userEvent, newGroupDelay) {
      let last2 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none3;
      if (last2.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last2[last2.length - 1], selection2))
        return this;
      return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event2 = branch[branch.length - 1], selection2 = event2.selectionsAfter[0] || state.selection;
      if (onlySelection && event2.selectionsAfter.length) {
        return state.update({
          selection: event2.selectionsAfter[event2.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event2.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none3 : branch.slice(0, branch.length - 1);
        if (event2.mapped)
          rest = addMappingToBranch(rest, event2.mapped);
        return state.update({
          changes: event2.changes,
          selection: event2.startSelection,
          effects: event2.effects,
          annotations: fromHistory.of({ side, rest, selection: selection2 }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none3, none3);
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection2) {
    return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state, dispatch }, how) {
    let selection2 = updateSel(state.selection, how);
    if (selection2.eq(state.selection, true))
      return false;
    dispatch(setSel(state, selection2));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start, forward) {
    let pos = syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match2, newPos;
    if (bracket2 && (match2 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match2.matched)
      newPos = forward ? match2.end.to : match2.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function cursorByLine(view, forward) {
    return moveSel(view, (range) => {
      if (!range.empty)
        return rangeEnd(range, forward);
      let moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function pageInfo(view) {
    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
      for (let source of view.state.facet(EditorView.scrollMargins)) {
        let margins = source(view);
        if (margins === null || margins === void 0 ? void 0 : margins.top)
          marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom)
          marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view, forward) {
    let page = pageInfo(view);
    let { state } = view, selection2 = updateSel(state.selection, (range) => {
      return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
    });
    if (selection2.eq(state.selection))
      return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view.coordsAtPos(state.selection.main.head);
      let scrollRect = view.scrollDOM.getBoundingClientRect();
      let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
        effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view.dispatch(setSel(state, selection2), { effects: effect });
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
      moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space2 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space2 && start.head != line.from + space2)
        moved = EditorSelection.cursor(line.from + space2);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
  var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
  function toMatchingBracket(state, dispatch, extend) {
    let found = false, selection2 = updateSel(state.selection, (range) => {
      let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
      if (!matching || !matching.end)
        return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch(setSel(state, selection2));
    return true;
  }
  var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
  function extendSel(target, how) {
    let selection2 = updateSel(target.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
    });
    if (selection2.eq(target.state.selection))
      return false;
    target.dispatch(setSel(target.state, selection2));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range) => view.moveByChar(range, forward));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range) => view.moveByGroup(range, forward));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function selectByLine(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
  var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
  var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
  var cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
  };
  var selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
  };
  var selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state, dispatch }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state, dispatch }) => {
    let selection2 = updateSel(state.selection, (range) => {
      let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
      if (range.empty) {
        let stackBefore = tree.resolveStack(range.from, -1);
        if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
          stack = stackBefore;
      }
      for (let cur2 = stack; cur2; cur2 = cur2.next) {
        let { node } = cur2;
        if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
          return EditorSelection.range(node.to, node.from);
      }
      return range;
    });
    if (selection2.eq(state.selection))
      return false;
    dispatch(setSel(state, selection2));
    return true;
  };
  var simplifySelection = ({ state, dispatch }) => {
    let cur2 = state.selection, selection2 = null;
    if (cur2.ranges.length > 1)
      selection2 = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection2)
      return false;
    dispatch(setSel(state, selection2));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event2 = "delete.selection", { state } = target;
    let changes = state.changeByRange((range) => {
      let { from, to } = range;
      if (from == to) {
        let towards = by(range);
        if (towards < from) {
          event2 = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event2 = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event2,
      effects: event2 == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f4) => f4(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before3, targetPos;
    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before3 = line.text.slice(0, pos - line.from))) {
      if (before3[before3.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before3, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i4 = 0; i4 < drop && before3[before3.length - 1 - i4] == " "; i4++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak2(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
      else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
        targetPos = findClusterBreak2(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
  });
  var deleteCharBackward = (view) => deleteByChar(view, false, true);
  var deleteCharForward = (view) => deleteByChar(view, true, false);
  var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak2(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != range.head)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (range) => {
    let lineEnd2 = view.lineBlockAt(range.head).to;
    return range.head < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, range.head + 1);
  });
  var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, false).head;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
  });
  var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, true).head;
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
  });
  var splitLine = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      return {
        changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state.doc.length)
        return { range };
      let pos = range.from, line = state.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak2(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak2(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
      let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
      if (!range.empty && range.to == endLine.from)
        endLine = state.doc.lineAt(range.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch, forward) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block2 of selectedLineBlocks(state)) {
      if (forward ? block2.to == state.doc.length : block2.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward ? block2.to + 1 : block2.from - 1);
      let size = nextLine.length + 1;
      if (forward) {
        changes.push({ from: block2.to, to: nextLine.to }, { from: block2.from, insert: nextLine.text + state.lineBreak });
        for (let r3 of block2.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r3.anchor + size), Math.min(state.doc.length, r3.head + size)));
      } else {
        changes.push({ from: nextLine.from, to: block2.from }, { from: block2.to, insert: state.lineBreak + nextLine.text });
        for (let r3 of block2.ranges)
          ranges.push(EditorSelection.range(r3.anchor - size, r3.head - size));
      }
    }
    if (!changes.length)
      return false;
    dispatch(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
  var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
  function copyLine(state, dispatch, forward) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block2 of selectedLineBlocks(state)) {
      if (forward)
        changes.push({ from: block2.from, insert: state.doc.slice(block2.from, block2.to) + state.lineBreak });
      else
        changes.push({ from: block2.to, insert: state.lineBreak + state.doc.slice(block2.from, block2.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
  var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
  var deleteLine = (view) => {
    if (view.state.readOnly)
      return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
      if (from > 0)
        from--;
      else if (to < state.doc.length)
        to++;
      return { from, to };
    }));
    let selection2 = updateSel(state.selection, (range) => {
      let dist2 = void 0;
      if (view.lineWrapping) {
        let block2 = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
        if (pos)
          dist2 = block2.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
      }
      return view.moveVertically(range, true, dist2);
    }).map(changes);
    view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context = syntaxTree(state).resolveInner(pos);
    let before3 = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before3 && after && before3.to <= pos && after.from >= pos && (closedBy = before3.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before3.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before3.to, after.from)))
      return { from: before3.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        let { from, to } = range, line = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof)
          from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent2 = getIndentation(cx, from);
        if (indent2 == null)
          indent2 = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({ from, to } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert2 = ["", indentString(state, indent2)];
        if (explode)
          insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: { from, to, insert: Text.of(insert2) },
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state, f4) {
    let atLine = -1;
    return state.changeByRange((range) => {
      let changes = [];
      for (let pos = range.from; pos <= range.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f4(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  var indentSelection = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: (start) => {
      let found = updated[start];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state, (line, changes2, range) => {
      let indent2 = getIndentation(context, line.from);
      if (indent2 == null)
        return;
      if (!/\S/.test(line.text))
        indent2 = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent2);
      if (cur2 != norm || range.from < line.from + cur2.length) {
        updated[line.from] = indent2;
        changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch(state.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({ from: line.from, insert: state.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      let space2 = /^\s*/.exec(line.text)[0];
      if (!space2)
        return;
      let col = countColumn(space2, state.tabSize), keep = 0;
      let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space2.length && keep < insert2.length && space2.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space2.length, insert: insert2.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var toggleTabFocusMode = (view) => {
    view.setTabFocusMode();
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b2) => ({ mac: b2.key, run: b2.run, shift: b2.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
  ].concat(standardKeymap);

  // node_modules/crelt/index.js
  function crelt() {
    var elt2 = arguments[0];
    if (typeof elt2 == "string") elt2 = document.createElement(elt2);
    var i4 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2];
        if (typeof value == "string") elt2.setAttribute(name2, value);
        else if (value != null) elt2[name2] = value;
      }
      i4++;
    }
    for (; i4 < arguments.length; i4++) add(elt2, arguments[i4]);
    return elt2;
  }
  function add(elt2, child) {
    if (typeof child == "string") {
      elt2.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt2.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i4 = 0; i4 < child.length; i4++) add(elt2, child[i4]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class _LintState {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state) {
      let diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        diagnostics = diagnosticFilter(diagnostics, state);
      let sorted = diagnostics.slice().sort((a3, b2) => a3.from - b2.from || a3.to - b2.to);
      let deco = new RangeSetBuilder(), active = [], pos = 0;
      for (let i4 = 0; ; ) {
        let next = i4 == sorted.length ? null : sorted[i4];
        if (!next && !active.length)
          break;
        let from, to;
        if (active.length) {
          from = pos;
          to = active.reduce((p3, d3) => Math.min(p3, d3.to), next && next.from > from ? next.from : 1e8);
        } else {
          from = next.from;
          to = next.to;
          active.push(next);
          i4++;
        }
        while (i4 < sorted.length) {
          let next2 = sorted[i4];
          if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
            active.push(next2);
            i4++;
            to = Math.min(next2.to, to);
          } else {
            to = Math.min(next2.from, to);
            break;
          }
        }
        let sev = maxSeverity(active);
        if (active.some((d3) => d3.from == d3.to || d3.from == d3.to - 1 && state.doc.lineAt(d3.from).to == d3.from)) {
          deco.add(from, from, Decoration.widget({
            widget: new DiagnosticWidget(sev),
            diagnostics: active.slice()
          }));
        } else {
          let markClass = active.reduce((c3, d3) => d3.markClass ? c3 + " " + d3.markClass : c3, "");
          deco.add(from, to, Decoration.mark({
            class: "cm-lintRange cm-lintRange-" + sev + markClass,
            diagnostics: active.slice(),
            inclusiveEnd: active.some((a3) => a3.to > to)
          }));
        }
        pos = to;
        for (let i5 = 0; i5 < active.length; i5++)
          if (active[i5].to <= pos)
            active.splice(i5--, 1);
      }
      let set3 = deco.finish();
      return new _LintState(set3, panel, findDiagnostic(set3));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
      if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
        return;
      if (!found)
        found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
      else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
        return false;
      else
        found = new SelectedDiagnostic(found.from, to, found.diagnostic);
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    let from = tooltip.pos, to = tooltip.end || from;
    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
    if (result != null)
      return result;
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some((e3) => e3.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
  }
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged && value.diagnostics.size) {
        let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
          panel = null;
        value = new LintState(mapped, panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
          value = LintState.init(effect.value, panel, tr.state);
        } else if (effect.is(togglePanel)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f4) => [
      showPanel.from(f4, (val) => val.panel),
      EditorView.decorations.from(f4, (s4) => s4.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
  function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found, start = -1, end = -1;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found = spec.diagnostics;
        start = from;
        end = to;
        return false;
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (found && diagnosticFilter)
      found = diagnosticFilter(found, view.state);
    if (!found)
      return null;
    return {
      pos: start,
      end,
      above: view.state.doc.lineAt(start).to < end,
      create() {
        return { dom: diagnosticsTooltip(view, found) };
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d3) => renderDiagnostic(view, d3, false)));
  }
  var closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.timeout = -1;
      this.set = true;
      let { delay: delay3 } = view.state.facet(lintConfig);
      this.lintTime = Date.now() + delay3;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay3);
    }
    run() {
      clearTimeout(this.timeout);
      let now2 = Date.now();
      if (now2 < this.lintTime - 10) {
        this.timeout = setTimeout(this.run, this.lintTime - now2);
      } else {
        this.set = false;
        let { state } = this.view, { sources } = state.facet(lintConfig);
        if (sources.length)
          batchResults(sources.map((s4) => Promise.resolve(s4(this.view))), (annotations) => {
            if (this.view.state.doc == state.doc)
              this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a3, b2) => a3.concat(b2))));
          }, (error2) => {
            logException(this.view.state, error2);
          });
      }
    }
    update(update) {
      let config2 = update.state.facet(lintConfig);
      if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
        this.lintTime = Date.now() + config2.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config2.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  function batchResults(promises, sink, error2) {
    let collected = [], timeout = -1;
    for (let p3 of promises)
      p3.then((value) => {
        collected.push(value);
        clearTimeout(timeout);
        if (collected.length == promises.length)
          sink(collected);
        else
          timeout = setTimeout(() => sink(collected), 200);
      }, error2);
  }
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({ sources: input.map((i4) => i4.source).filter((x3) => x3 != null) }, combineConfig(input.map((i4) => i4.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        needsRefresh: (a3, b2) => !a3 ? b2 : !b2 ? a3 : (u4) => a3(u4) || b2(u4)
      }));
    }
  });
  function linter(source, config2 = {}) {
    return [
      lintConfig.of({ source, config: config2 }),
      lintPlugin,
      lintExtensions
    ];
  }
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions: for (let { name: name2 } of actions) {
        for (let i4 = 0; i4 < name2.length; i4++) {
          let ch = name2[i4];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c3) => c3.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i4) => {
      let fired = false, click = (e3) => {
        e3.preventDefault();
        if (fired)
          return;
        fired = true;
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action.apply(view, found.from, found.to);
      };
      let { name: name2 } = action, keyIndex = keys[i4] ? name2.indexOf(keys[i4]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [
        name2.slice(0, keyIndex),
        crelt("u", name2.slice(keyIndex, keyIndex + 1)),
        name2.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys[i4]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(sev) {
      super();
      this.sev = sev;
    }
    eq(other2) {
      return other2.sev == this.sev;
    }
    toDOM() {
      return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
    }
  };
  var PanelItem = class {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class _LintPanel {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event2) => {
        if (event2.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event2.keyCode == 38 || event2.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event2.keyCode == 40 || event2.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event2.keyCode == 36) {
          this.moveSelection(0);
        } else if (event2.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event2.keyCode == 13) {
          this.view.focus();
        } else if (event2.keyCode >= 65 && event2.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
          for (let i4 = 0; i4 < keys.length; i4++)
            if (keys[i4].toUpperCase().charCodeAt(0) == event2.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i4].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event2.preventDefault();
      };
      let onclick = (event2) => {
        for (let i4 = 0; i4 < this.items.length; i4++) {
          if (this.items[i4].dom.contains(event2.target))
            this.moveSelection(i4);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i4 = 0; i4 < this.items.length; i4++)
        if (this.items[i4].diagnostic == selected.diagnostic)
          return i4;
      return -1;
    }
    update() {
      let { diagnostics, selected } = this.view.state.field(lintState);
      let i4 = 0, needsSync = false, newSelectedItem = null;
      let seen = /* @__PURE__ */ new Set();
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        for (let diagnostic of spec.diagnostics) {
          if (seen.has(diagnostic))
            continue;
          seen.add(diagnostic);
          let found = -1, item;
          for (let j4 = i4; j4 < this.items.length; j4++)
            if (this.items[j4].diagnostic == diagnostic) {
              found = j4;
              break;
            }
          if (found < 0) {
            item = new PanelItem(this.view, diagnostic);
            this.items.splice(i4, 0, item);
            needsSync = true;
          } else {
            item = this.items[found];
            if (found > i4) {
              this.items.splice(i4, found - i4);
              needsSync = true;
            }
          }
          if (selected && item.diagnostic == selected.diagnostic) {
            if (!item.dom.hasAttribute("aria-selected")) {
              item.dom.setAttribute("aria-selected", "true");
              newSelectedItem = item;
            }
          } else if (item.dom.hasAttribute("aria-selected")) {
            item.dom.removeAttribute("aria-selected");
          }
          i4++;
        }
      });
      while (i4 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
          write: ({ sel, panel }) => {
            let scaleY = panel.height / this.list.offsetHeight;
            if (sel.top < panel.top)
              this.list.scrollTop -= (panel.top - sel.top) / scaleY;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection2)
        return;
      this.view.dispatch({
        selection: { anchor: selection2.from, head: selection2.to },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection2)
      });
    }
    static open(view) {
      return new _LintPanel(view);
    }
  };
  function svg2(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg2(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
    ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
      "&:after": { borderBottomColor: "#999" }
    },
    ".cm-lintPoint-hint": {
      "&:after": { borderBottomColor: "#66d" }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": { textDecoration: "underline" }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  function severityWeight(sev) {
    return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
  }
  function maxSeverity(diagnostics) {
    let sev = "hint", weight = 1;
    for (let d3 of diagnostics) {
      let w3 = severityWeight(d3.severity);
      if (w3 > weight) {
        weight = w3;
        sev = d3.severity;
      }
    }
    return sev;
  }
  var lintExtensions = [
    lintState,
    /* @__PURE__ */ EditorView.decorations.compute([lintState], (state) => {
      let { selected, panel } = state.field(lintState);
      return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
        activeMark.range(selected.from, selected.to)
      ]);
    }),
    /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    baseTheme4
  ];

  // node_modules/@lezer/markdown/dist/index.js
  var CompositeBlock = class _CompositeBlock {
    static create(type3, value, from, parentHash, end) {
      let hash = parentHash + (parentHash << 8) + type3 + (value << 4) | 0;
      return new _CompositeBlock(type3, value, from, hash, end, [], []);
    }
    constructor(type3, value, from, hash, end, children, positions) {
      this.type = type3;
      this.value = value;
      this.from = from;
      this.hash = hash;
      this.end = end;
      this.children = children;
      this.positions = positions;
      this.hashProp = [[NodeProp.contextHash, hash]];
    }
    addChild(child, pos) {
      if (child.prop(NodeProp.contextHash) != this.hash)
        child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
      this.children.push(child);
      this.positions.push(pos);
    }
    toTree(nodeSet, end = this.end) {
      let last2 = this.children.length - 1;
      if (last2 >= 0)
        end = Math.max(end, this.positions[last2] + this.children[last2].length + this.from);
      return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
        makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)
      });
    }
  };
  var Type;
  (function(Type2) {
    Type2[Type2["Document"] = 1] = "Document";
    Type2[Type2["CodeBlock"] = 2] = "CodeBlock";
    Type2[Type2["FencedCode"] = 3] = "FencedCode";
    Type2[Type2["Blockquote"] = 4] = "Blockquote";
    Type2[Type2["HorizontalRule"] = 5] = "HorizontalRule";
    Type2[Type2["BulletList"] = 6] = "BulletList";
    Type2[Type2["OrderedList"] = 7] = "OrderedList";
    Type2[Type2["ListItem"] = 8] = "ListItem";
    Type2[Type2["ATXHeading1"] = 9] = "ATXHeading1";
    Type2[Type2["ATXHeading2"] = 10] = "ATXHeading2";
    Type2[Type2["ATXHeading3"] = 11] = "ATXHeading3";
    Type2[Type2["ATXHeading4"] = 12] = "ATXHeading4";
    Type2[Type2["ATXHeading5"] = 13] = "ATXHeading5";
    Type2[Type2["ATXHeading6"] = 14] = "ATXHeading6";
    Type2[Type2["SetextHeading1"] = 15] = "SetextHeading1";
    Type2[Type2["SetextHeading2"] = 16] = "SetextHeading2";
    Type2[Type2["HTMLBlock"] = 17] = "HTMLBlock";
    Type2[Type2["LinkReference"] = 18] = "LinkReference";
    Type2[Type2["Paragraph"] = 19] = "Paragraph";
    Type2[Type2["CommentBlock"] = 20] = "CommentBlock";
    Type2[Type2["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
    Type2[Type2["Escape"] = 22] = "Escape";
    Type2[Type2["Entity"] = 23] = "Entity";
    Type2[Type2["HardBreak"] = 24] = "HardBreak";
    Type2[Type2["Emphasis"] = 25] = "Emphasis";
    Type2[Type2["StrongEmphasis"] = 26] = "StrongEmphasis";
    Type2[Type2["Link"] = 27] = "Link";
    Type2[Type2["Image"] = 28] = "Image";
    Type2[Type2["InlineCode"] = 29] = "InlineCode";
    Type2[Type2["HTMLTag"] = 30] = "HTMLTag";
    Type2[Type2["Comment"] = 31] = "Comment";
    Type2[Type2["ProcessingInstruction"] = 32] = "ProcessingInstruction";
    Type2[Type2["Autolink"] = 33] = "Autolink";
    Type2[Type2["HeaderMark"] = 34] = "HeaderMark";
    Type2[Type2["QuoteMark"] = 35] = "QuoteMark";
    Type2[Type2["ListMark"] = 36] = "ListMark";
    Type2[Type2["LinkMark"] = 37] = "LinkMark";
    Type2[Type2["EmphasisMark"] = 38] = "EmphasisMark";
    Type2[Type2["CodeMark"] = 39] = "CodeMark";
    Type2[Type2["CodeText"] = 40] = "CodeText";
    Type2[Type2["CodeInfo"] = 41] = "CodeInfo";
    Type2[Type2["LinkTitle"] = 42] = "LinkTitle";
    Type2[Type2["LinkLabel"] = 43] = "LinkLabel";
    Type2[Type2["URL"] = 44] = "URL";
  })(Type || (Type = {}));
  var LeafBlock = class {
    /**
    @internal
    */
    constructor(start, content2) {
      this.start = start;
      this.content = content2;
      this.marks = [];
      this.parsers = [];
    }
  };
  var Line2 = class {
    constructor() {
      this.text = "";
      this.baseIndent = 0;
      this.basePos = 0;
      this.depth = 0;
      this.markers = [];
      this.pos = 0;
      this.indent = 0;
      this.next = -1;
    }
    /**
    @internal
    */
    forward() {
      if (this.basePos > this.pos)
        this.forwardInner();
    }
    /**
    @internal
    */
    forwardInner() {
      let newPos = this.skipSpace(this.basePos);
      this.indent = this.countIndent(newPos, this.pos, this.indent);
      this.pos = newPos;
      this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
    }
    /**
    Skip whitespace after the given position, return the position of
    the next non-space character or the end of the line if there's
    only space after `from`.
    */
    skipSpace(from) {
      return skipSpace(this.text, from);
    }
    /**
    @internal
    */
    reset(text2) {
      this.text = text2;
      this.baseIndent = this.basePos = this.pos = this.indent = 0;
      this.forwardInner();
      this.depth = 1;
      while (this.markers.length)
        this.markers.pop();
    }
    /**
    Move the line's base position forward to the given position.
    This should only be called by composite [block
    parsers](#BlockParser.parse) or [markup skipping
    functions](#NodeSpec.composite).
    */
    moveBase(to) {
      this.basePos = to;
      this.baseIndent = this.countIndent(to, this.pos, this.indent);
    }
    /**
    Move the line's base position forward to the given _column_.
    */
    moveBaseColumn(indent2) {
      this.baseIndent = indent2;
      this.basePos = this.findColumn(indent2);
    }
    /**
    Store a composite-block-level marker. Should be called from
    [markup skipping functions](#NodeSpec.composite) when they
    consume any non-whitespace characters.
    */
    addMarker(elt2) {
      this.markers.push(elt2);
    }
    /**
    Find the column position at `to`, optionally starting at a given
    position and column.
    */
    countIndent(to, from = 0, indent2 = 0) {
      for (let i4 = from; i4 < to; i4++)
        indent2 += this.text.charCodeAt(i4) == 9 ? 4 - indent2 % 4 : 1;
      return indent2;
    }
    /**
    Find the position corresponding to the given column.
    */
    findColumn(goal) {
      let i4 = 0;
      for (let indent2 = 0; i4 < this.text.length && indent2 < goal; i4++)
        indent2 += this.text.charCodeAt(i4) == 9 ? 4 - indent2 % 4 : 1;
      return i4;
    }
    /**
    @internal
    */
    scrub() {
      if (!this.baseIndent)
        return this.text;
      let result = "";
      for (let i4 = 0; i4 < this.basePos; i4++)
        result += " ";
      return result + this.text.slice(this.basePos);
    }
  };
  function skipForList(bl, cx, line) {
    if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
      return true;
    if (line.indent >= line.baseIndent + 4)
      return false;
    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
    return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
  }
  var DefaultSkipMarkup = {
    [Type.Blockquote](bl, cx, line) {
      if (line.next != 62)
        return false;
      line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
      line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
      bl.end = cx.lineStart + line.text.length;
      return true;
    },
    [Type.ListItem](bl, _cx, line) {
      if (line.indent < line.baseIndent + bl.value && line.next > -1)
        return false;
      line.moveBaseColumn(line.baseIndent + bl.value);
      return true;
    },
    [Type.OrderedList]: skipForList,
    [Type.BulletList]: skipForList,
    [Type.Document]() {
      return true;
    }
  };
  function space(ch) {
    return ch == 32 || ch == 9 || ch == 10 || ch == 13;
  }
  function skipSpace(line, i4 = 0) {
    while (i4 < line.length && space(line.charCodeAt(i4)))
      i4++;
    return i4;
  }
  function skipSpaceBack(line, i4, to) {
    while (i4 > to && space(line.charCodeAt(i4 - 1)))
      i4--;
    return i4;
  }
  function isFencedCode(line) {
    if (line.next != 96 && line.next != 126)
      return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
      pos++;
    if (pos < line.pos + 3)
      return -1;
    if (line.next == 96) {
      for (let i4 = pos; i4 < line.text.length; i4++)
        if (line.text.charCodeAt(i4) == 96)
          return -1;
    }
    return pos;
  }
  function isBlockquote(line) {
    return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
  }
  function isHorizontalRule(line, cx, breaking) {
    if (line.next != 42 && line.next != 45 && line.next != 95)
      return -1;
    let count = 1;
    for (let pos = line.pos + 1; pos < line.text.length; pos++) {
      let ch = line.text.charCodeAt(pos);
      if (ch == line.next)
        count++;
      else if (!space(ch))
        return -1;
    }
    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length && cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)
      return -1;
    return count < 3 ? -1 : 1;
  }
  function inList(cx, type3) {
    for (let i4 = cx.stack.length - 1; i4 >= 0; i4--)
      if (cx.stack[i4].type == type3)
        return true;
    return false;
  }
  function isBulletList(line, cx, breaking) {
    return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
  }
  function isOrderedList(line, cx, breaking) {
    let pos = line.pos, next = line.next;
    for (; ; ) {
      if (next >= 48 && next <= 57)
        pos++;
      else
        break;
      if (pos == line.text.length)
        return -1;
      next = line.text.charCodeAt(pos);
    }
    if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
      return -1;
    return pos + 1 - line.pos;
  }
  function isAtxHeading(line) {
    if (line.next != 35)
      return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
      pos++;
    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
      return -1;
    let size = pos - line.pos;
    return size > 6 ? -1 : size;
  }
  function isSetextUnderline(line) {
    if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
      return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
      pos++;
    let end = pos;
    while (pos < line.text.length && space(line.text.charCodeAt(pos)))
      pos++;
    return pos == line.text.length ? end : -1;
  }
  var EmptyLine = /^[ \t]*$/;
  var CommentEnd = /-->/;
  var ProcessingEnd = /\?>/;
  var HTMLBlockStyle = [
    [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
    [/^\s*<!--/, CommentEnd],
    [/^\s*<\?/, ProcessingEnd],
    [/^\s*<![A-Z]/, />/],
    [/^\s*<!\[CDATA\[/, /\]\]>/],
    [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
    [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
  ];
  function isHTMLBlock(line, _cx, breaking) {
    if (line.next != 60)
      return -1;
    let rest = line.text.slice(line.pos);
    for (let i4 = 0, e3 = HTMLBlockStyle.length - (breaking ? 1 : 0); i4 < e3; i4++)
      if (HTMLBlockStyle[i4][0].test(rest))
        return i4;
    return -1;
  }
  function getListIndent(line, pos) {
    let indentAfter = line.countIndent(pos, line.pos, line.indent);
    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
  }
  function addCodeText(marks2, from, to) {
    let last2 = marks2.length - 1;
    if (last2 >= 0 && marks2[last2].to == from && marks2[last2].type == Type.CodeText)
      marks2[last2].to = to;
    else
      marks2.push(elt(Type.CodeText, from, to));
  }
  var DefaultBlockParsers = {
    LinkReference: void 0,
    IndentedCode(cx, line) {
      let base2 = line.baseIndent + 4;
      if (line.indent < base2)
        return false;
      let start = line.findColumn(base2);
      let from = cx.lineStart + start, to = cx.lineStart + line.text.length;
      let marks2 = [], pendingMarks = [];
      addCodeText(marks2, from, to);
      while (cx.nextLine() && line.depth >= cx.stack.length) {
        if (line.pos == line.text.length) {
          addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
          for (let m3 of line.markers)
            pendingMarks.push(m3);
        } else if (line.indent < base2) {
          break;
        } else {
          if (pendingMarks.length) {
            for (let m3 of pendingMarks) {
              if (m3.type == Type.CodeText)
                addCodeText(marks2, m3.from, m3.to);
              else
                marks2.push(m3);
            }
            pendingMarks = [];
          }
          addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
          for (let m3 of line.markers)
            marks2.push(m3);
          to = cx.lineStart + line.text.length;
          let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
          if (codeStart < to)
            addCodeText(marks2, codeStart, to);
        }
      }
      if (pendingMarks.length) {
        pendingMarks = pendingMarks.filter((m3) => m3.type != Type.CodeText);
        if (pendingMarks.length)
          line.markers = pendingMarks.concat(line.markers);
      }
      cx.addNode(cx.buffer.writeElements(marks2, -from).finish(Type.CodeBlock, to - from), from);
      return true;
    },
    FencedCode(cx, line) {
      let fenceEnd = isFencedCode(line);
      if (fenceEnd < 0)
        return false;
      let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
      let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
      let marks2 = [elt(Type.CodeMark, from, from + len)];
      if (infoFrom < infoTo)
        marks2.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
      for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
        let i4 = line.pos;
        if (line.indent - line.baseIndent < 4)
          while (i4 < line.text.length && line.text.charCodeAt(i4) == ch)
            i4++;
        if (i4 - line.pos >= len && line.skipSpace(i4) == line.text.length) {
          for (let m3 of line.markers)
            marks2.push(m3);
          marks2.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i4));
          cx.nextLine();
          break;
        } else {
          if (!first)
            addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
          for (let m3 of line.markers)
            marks2.push(m3);
          let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
          if (textStart < textEnd)
            addCodeText(marks2, textStart, textEnd);
        }
      }
      cx.addNode(cx.buffer.writeElements(marks2, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
      return true;
    },
    Blockquote(cx, line) {
      let size = isBlockquote(line);
      if (size < 0)
        return false;
      cx.startContext(Type.Blockquote, line.pos);
      cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
      line.moveBase(line.pos + size);
      return null;
    },
    HorizontalRule(cx, line) {
      if (isHorizontalRule(line, cx, false) < 0)
        return false;
      let from = cx.lineStart + line.pos;
      cx.nextLine();
      cx.addNode(Type.HorizontalRule, from);
      return true;
    },
    BulletList(cx, line) {
      let size = isBulletList(line, cx, false);
      if (size < 0)
        return false;
      if (cx.block.type != Type.BulletList)
        cx.startContext(Type.BulletList, line.basePos, line.next);
      let newBase = getListIndent(line, line.pos + 1);
      cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
      cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
      line.moveBaseColumn(newBase);
      return null;
    },
    OrderedList(cx, line) {
      let size = isOrderedList(line, cx, false);
      if (size < 0)
        return false;
      if (cx.block.type != Type.OrderedList)
        cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
      let newBase = getListIndent(line, line.pos + size);
      cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
      cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
      line.moveBaseColumn(newBase);
      return null;
    },
    ATXHeading(cx, line) {
      let size = isAtxHeading(line);
      if (size < 0)
        return false;
      let off = line.pos, from = cx.lineStart + off;
      let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
      while (after > off && line.text.charCodeAt(after - 1) == line.next)
        after--;
      if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))
        after = line.text.length;
      let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
      if (after < line.text.length)
        buf.write(Type.HeaderMark, after - off, endOfSpace - off);
      let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
      cx.nextLine();
      cx.addNode(node, from);
      return true;
    },
    HTMLBlock(cx, line) {
      let type3 = isHTMLBlock(line, cx, false);
      if (type3 < 0)
        return false;
      let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type3][1];
      let marks2 = [], trailing = end != EmptyLine;
      while (!end.test(line.text) && cx.nextLine()) {
        if (line.depth < cx.stack.length) {
          trailing = false;
          break;
        }
        for (let m3 of line.markers)
          marks2.push(m3);
      }
      if (trailing)
        cx.nextLine();
      let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
      let to = cx.prevLineEnd();
      cx.addNode(cx.buffer.writeElements(marks2, -from).finish(nodeType, to - from), from);
      return true;
    },
    SetextHeading: void 0
    // Specifies relative precedence for block-continue function
  };
  var LinkReferenceParser = class {
    constructor(leaf) {
      this.stage = 0;
      this.elts = [];
      this.pos = 0;
      this.start = leaf.start;
      this.advance(leaf.content);
    }
    nextLine(cx, line, leaf) {
      if (this.stage == -1)
        return false;
      let content2 = leaf.content + "\n" + line.scrub();
      let finish = this.advance(content2);
      if (finish > -1 && finish < content2.length)
        return this.complete(cx, leaf, finish);
      return false;
    }
    finish(cx, leaf) {
      if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
        return this.complete(cx, leaf, leaf.content.length);
      return false;
    }
    complete(cx, leaf, len) {
      cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
      return true;
    }
    nextStage(elt2) {
      if (elt2) {
        this.pos = elt2.to - this.start;
        this.elts.push(elt2);
        this.stage++;
        return true;
      }
      if (elt2 === false)
        this.stage = -1;
      return false;
    }
    advance(content2) {
      for (; ; ) {
        if (this.stage == -1) {
          return -1;
        } else if (this.stage == 0) {
          if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true)))
            return -1;
          if (content2.charCodeAt(this.pos) != 58)
            return this.stage = -1;
          this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
          this.pos++;
        } else if (this.stage == 1) {
          if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
            return -1;
        } else if (this.stage == 2) {
          let skip = skipSpace(content2, this.pos), end = 0;
          if (skip > this.pos) {
            let title = parseLinkTitle(content2, skip, this.start);
            if (title) {
              let titleEnd = lineEnd(content2, title.to - this.start);
              if (titleEnd > 0) {
                this.nextStage(title);
                end = titleEnd;
              }
            }
          }
          if (!end)
            end = lineEnd(content2, this.pos);
          return end > 0 && end < content2.length ? end : -1;
        } else {
          return lineEnd(content2, this.pos);
        }
      }
    }
  };
  function lineEnd(text2, pos) {
    for (; pos < text2.length; pos++) {
      let next = text2.charCodeAt(pos);
      if (next == 10)
        break;
      if (!space(next))
        return -1;
    }
    return pos;
  }
  var SetextHeadingParser = class {
    nextLine(cx, line, leaf) {
      let underline2 = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
      let next = line.next;
      if (underline2 < 0)
        return false;
      let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline2);
      cx.nextLine();
      cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
        ...cx.parser.parseInline(leaf.content, leaf.start),
        underlineMark
      ]));
      return true;
    }
    finish() {
      return false;
    }
  };
  var DefaultLeafBlocks = {
    LinkReference(_3, leaf) {
      return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
    },
    SetextHeading() {
      return new SetextHeadingParser();
    }
  };
  var DefaultEndLeaf = [
    (_3, line) => isAtxHeading(line) >= 0,
    (_3, line) => isFencedCode(line) >= 0,
    (_3, line) => isBlockquote(line) >= 0,
    (p3, line) => isBulletList(line, p3, true) >= 0,
    (p3, line) => isOrderedList(line, p3, true) >= 0,
    (p3, line) => isHorizontalRule(line, p3, true) >= 0,
    (p3, line) => isHTMLBlock(line, p3, true) >= 0
  ];
  var scanLineResult = { text: "", end: 0 };
  var BlockContext = class {
    /**
    @internal
    */
    constructor(parser5, input, fragments, ranges) {
      this.parser = parser5;
      this.input = input;
      this.ranges = ranges;
      this.line = new Line2();
      this.atEnd = false;
      this.reusePlaceholders = /* @__PURE__ */ new Map();
      this.stoppedAt = null;
      this.rangeI = 0;
      this.to = ranges[ranges.length - 1].to;
      this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
      this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
      this.stack = [this.block];
      this.fragments = fragments.length ? new FragmentCursor3(fragments, input) : null;
      this.readLine();
    }
    get parsedPos() {
      return this.absoluteLineStart;
    }
    advance() {
      if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
        return this.finish();
      let { line } = this;
      for (; ; ) {
        for (let markI = 0; ; ) {
          let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
          while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {
            let mark = line.markers[markI++];
            this.addNode(mark.type, mark.from, mark.to);
          }
          if (!next)
            break;
          this.finishContext();
        }
        if (line.pos < line.text.length)
          break;
        if (!this.nextLine())
          return this.finish();
      }
      if (this.fragments && this.reuseFragment(line.basePos))
        return null;
      start: for (; ; ) {
        for (let type3 of this.parser.blockParsers)
          if (type3) {
            let result = type3(this, line);
            if (result != false) {
              if (result == true)
                return null;
              line.forward();
              continue start;
            }
          }
        break;
      }
      let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
      for (let parse4 of this.parser.leafBlockParsers)
        if (parse4) {
          let parser5 = parse4(this, leaf);
          if (parser5)
            leaf.parsers.push(parser5);
        }
      lines: while (this.nextLine()) {
        if (line.pos == line.text.length)
          break;
        if (line.indent < line.baseIndent + 4) {
          for (let stop of this.parser.endLeafBlock)
            if (stop(this, line, leaf))
              break lines;
        }
        for (let parser5 of leaf.parsers)
          if (parser5.nextLine(this, line, leaf))
            return null;
        leaf.content += "\n" + line.scrub();
        for (let m3 of line.markers)
          leaf.marks.push(m3);
      }
      this.finishLeaf(leaf);
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    reuseFragment(start) {
      if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
        return false;
      let taken = this.fragments.takeNodes(this);
      if (!taken)
        return false;
      this.absoluteLineStart += taken;
      this.lineStart = toRelative(this.absoluteLineStart, this.ranges);
      this.moveRangeI();
      if (this.absoluteLineStart < this.to) {
        this.lineStart++;
        this.absoluteLineStart++;
        this.readLine();
      } else {
        this.atEnd = true;
        this.readLine();
      }
      return true;
    }
    /**
    The number of parent blocks surrounding the current block.
    */
    get depth() {
      return this.stack.length;
    }
    /**
    Get the type of the parent block at the given depth. When no
    depth is passed, return the type of the innermost parent.
    */
    parentType(depth = this.depth - 1) {
      return this.parser.nodeSet.types[this.stack[depth].type];
    }
    /**
    Move to the next input line. This should only be called by
    (non-composite) [block parsers](#BlockParser.parse) that consume
    the line directly, or leaf block parser
    [`nextLine`](#LeafBlockParser.nextLine) methods when they
    consume the current line (and return true).
    */
    nextLine() {
      this.lineStart += this.line.text.length;
      if (this.absoluteLineEnd >= this.to) {
        this.absoluteLineStart = this.absoluteLineEnd;
        this.atEnd = true;
        this.readLine();
        return false;
      } else {
        this.lineStart++;
        this.absoluteLineStart = this.absoluteLineEnd + 1;
        this.moveRangeI();
        this.readLine();
        return true;
      }
    }
    /**
    Retrieve the text of the line after the current one, without
    actually moving the context's current line forward.
    */
    peekLine() {
      return this.scanLine(this.absoluteLineEnd + 1).text;
    }
    moveRangeI() {
      while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
        this.rangeI++;
        this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
      }
    }
    /**
    @internal
    Collect the text for the next line.
    */
    scanLine(start) {
      let r3 = scanLineResult;
      r3.end = start;
      if (start >= this.to) {
        r3.text = "";
      } else {
        r3.text = this.lineChunkAt(start);
        r3.end += r3.text.length;
        if (this.ranges.length > 1) {
          let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
          while (this.ranges[rangeI].to < r3.end) {
            rangeI++;
            let nextFrom = this.ranges[rangeI].from;
            let after = this.lineChunkAt(nextFrom);
            r3.end = nextFrom + after.length;
            r3.text = r3.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
            textOffset = r3.end - r3.text.length;
          }
        }
      }
      return r3;
    }
    /**
    @internal
    Populate this.line with the content of the next line. Skip
    leading characters covered by composite blocks.
    */
    readLine() {
      let { line } = this, { text: text2, end } = this.scanLine(this.absoluteLineStart);
      this.absoluteLineEnd = end;
      line.reset(text2);
      for (; line.depth < this.stack.length; line.depth++) {
        let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
        if (!handler)
          throw new Error("Unhandled block context " + Type[cx.type]);
        if (!handler(cx, this, line))
          break;
        line.forward();
      }
    }
    lineChunkAt(pos) {
      let next = this.input.chunk(pos), text2;
      if (!this.input.lineChunks) {
        let eol = next.indexOf("\n");
        text2 = eol < 0 ? next : next.slice(0, eol);
      } else {
        text2 = next == "\n" ? "" : next;
      }
      return pos + text2.length > this.to ? text2.slice(0, this.to - pos) : text2;
    }
    /**
    The end position of the previous line.
    */
    prevLineEnd() {
      return this.atEnd ? this.lineStart : this.lineStart - 1;
    }
    /**
    @internal
    */
    startContext(type3, start, value = 0) {
      this.block = CompositeBlock.create(type3, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
      this.stack.push(this.block);
    }
    /**
    Start a composite block. Should only be called from [block
    parser functions](#BlockParser.parse) that return null.
    */
    startComposite(type3, start, value = 0) {
      this.startContext(this.parser.getNodeType(type3), start, value);
    }
    /**
    @internal
    */
    addNode(block2, from, to) {
      if (typeof block2 == "number")
        block2 = new Tree(this.parser.nodeSet.types[block2], none4, none4, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
      this.block.addChild(block2, from - this.block.from);
    }
    /**
    Add a block element. Can be called by [block
    parsers](#BlockParser.parse).
    */
    addElement(elt2) {
      this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
    }
    /**
    Add a block element from a [leaf parser](#LeafBlockParser). This
    makes sure any extra composite block markup (such as blockquote
    markers) inside the block are also added to the syntax tree.
    */
    addLeafElement(leaf, elt2) {
      this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
    }
    /**
    @internal
    */
    finishContext() {
      let cx = this.stack.pop();
      let top2 = this.stack[this.stack.length - 1];
      top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
      this.block = top2;
    }
    finish() {
      while (this.stack.length > 1)
        this.finishContext();
      return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
    }
    addGaps(tree) {
      return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;
    }
    /**
    @internal
    */
    finishLeaf(leaf) {
      for (let parser5 of leaf.parsers)
        if (parser5.finish(this, leaf))
          return;
      let inline2 = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
      this.addNode(this.buffer.writeElements(inline2, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
    }
    elt(type3, from, to, children) {
      if (typeof type3 == "string")
        return elt(this.parser.getNodeType(type3), from, to, children);
      return new TreeElement(type3, from);
    }
    /**
    @internal
    */
    get buffer() {
      return new Buffer2(this.parser.nodeSet);
    }
  };
  function injectGaps(ranges, rangeI, tree, offset2, dummies) {
    let rangeEnd2 = ranges[rangeI].to;
    let children = [], positions = [], start = tree.from + offset2;
    function movePastNext(upto, inclusive) {
      while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
        let size = ranges[rangeI + 1].from - rangeEnd2;
        offset2 += size;
        upto += size;
        rangeI++;
        rangeEnd2 = ranges[rangeI].to;
      }
    }
    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
      movePastNext(ch.from + offset2, true);
      let from = ch.from + offset2, node, reuse = dummies.get(ch.tree);
      if (reuse) {
        node = reuse;
      } else if (ch.to + offset2 > rangeEnd2) {
        node = injectGaps(ranges, rangeI, ch, offset2, dummies);
        movePastNext(ch.to + offset2, false);
      } else {
        node = ch.toTree();
      }
      children.push(node);
      positions.push(from - start);
    }
    movePastNext(tree.to + offset2, false);
    return new Tree(tree.type, children, positions, tree.to + offset2 - start, tree.tree ? tree.tree.propValues : void 0);
  }
  var MarkdownParser = class _MarkdownParser extends Parser {
    /**
    @internal
    */
    constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
      super();
      this.nodeSet = nodeSet;
      this.blockParsers = blockParsers;
      this.leafBlockParsers = leafBlockParsers;
      this.blockNames = blockNames;
      this.endLeafBlock = endLeafBlock;
      this.skipContextMarkup = skipContextMarkup;
      this.inlineParsers = inlineParsers;
      this.inlineNames = inlineNames;
      this.wrappers = wrappers;
      this.nodeTypes = /* @__PURE__ */ Object.create(null);
      for (let t4 of nodeSet.types)
        this.nodeTypes[t4.name] = t4.id;
    }
    createParse(input, fragments, ranges) {
      let parse4 = new BlockContext(this, input, fragments, ranges);
      for (let w3 of this.wrappers)
        parse4 = w3(parse4, input, fragments, ranges);
      return parse4;
    }
    /**
    Reconfigure the parser.
    */
    configure(spec) {
      let config2 = resolveConfig(spec);
      if (!config2)
        return this;
      let { nodeSet, skipContextMarkup } = this;
      let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
      if (nonEmpty(config2.defineNodes)) {
        skipContextMarkup = Object.assign({}, skipContextMarkup);
        let nodeTypes2 = nodeSet.types.slice(), styles;
        for (let s4 of config2.defineNodes) {
          let { name: name2, block: block2, composite, style } = typeof s4 == "string" ? { name: s4 } : s4;
          if (nodeTypes2.some((t4) => t4.name == name2))
            continue;
          if (composite)
            skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value);
          let id2 = nodeTypes2.length;
          let group = composite ? ["Block", "BlockContext"] : !block2 ? void 0 : id2 >= Type.ATXHeading1 && id2 <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
          nodeTypes2.push(NodeType.define({
            id: id2,
            name: name2,
            props: group && [[NodeProp.group, group]]
          }));
          if (style) {
            if (!styles)
              styles = {};
            if (Array.isArray(style) || style instanceof Tag)
              styles[name2] = style;
            else
              Object.assign(styles, style);
          }
        }
        nodeSet = new NodeSet(nodeTypes2);
        if (styles)
          nodeSet = nodeSet.extend(styleTags(styles));
      }
      if (nonEmpty(config2.props))
        nodeSet = nodeSet.extend(...config2.props);
      if (nonEmpty(config2.remove)) {
        for (let rm2 of config2.remove) {
          let block2 = this.blockNames.indexOf(rm2), inline2 = this.inlineNames.indexOf(rm2);
          if (block2 > -1)
            blockParsers[block2] = leafBlockParsers[block2] = void 0;
          if (inline2 > -1)
            inlineParsers[inline2] = void 0;
        }
      }
      if (nonEmpty(config2.parseBlock)) {
        for (let spec2 of config2.parseBlock) {
          let found = blockNames.indexOf(spec2.name);
          if (found > -1) {
            blockParsers[found] = spec2.parse;
            leafBlockParsers[found] = spec2.leaf;
          } else {
            let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
            blockParsers.splice(pos, 0, spec2.parse);
            leafBlockParsers.splice(pos, 0, spec2.leaf);
            blockNames.splice(pos, 0, spec2.name);
          }
          if (spec2.endLeaf)
            endLeafBlock.push(spec2.endLeaf);
        }
      }
      if (nonEmpty(config2.parseInline)) {
        for (let spec2 of config2.parseInline) {
          let found = inlineNames.indexOf(spec2.name);
          if (found > -1) {
            inlineParsers[found] = spec2.parse;
          } else {
            let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
            inlineParsers.splice(pos, 0, spec2.parse);
            inlineNames.splice(pos, 0, spec2.name);
          }
        }
      }
      if (config2.wrap)
        wrappers = wrappers.concat(config2.wrap);
      return new _MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
    }
    /**
    @internal
    */
    getNodeType(name2) {
      let found = this.nodeTypes[name2];
      if (found == null)
        throw new RangeError(`Unknown node type '${name2}'`);
      return found;
    }
    /**
    Parse the given piece of inline text at the given offset,
    returning an array of [`Element`](#Element) objects representing
    the inline content.
    */
    parseInline(text2, offset2) {
      let cx = new InlineContext(this, text2, offset2);
      outer: for (let pos = offset2; pos < cx.end; ) {
        let next = cx.char(pos);
        for (let token of this.inlineParsers)
          if (token) {
            let result = token(cx, next, pos);
            if (result >= 0) {
              pos = result;
              continue outer;
            }
          }
        pos++;
      }
      return cx.resolveMarkers(0);
    }
  };
  function nonEmpty(a3) {
    return a3 != null && a3.length > 0;
  }
  function resolveConfig(spec) {
    if (!Array.isArray(spec))
      return spec;
    if (spec.length == 0)
      return null;
    let conf = resolveConfig(spec[0]);
    if (spec.length == 1)
      return conf;
    let rest = resolveConfig(spec.slice(1));
    if (!rest || !conf)
      return conf || rest;
    let conc2 = (a3, b2) => (a3 || none4).concat(b2 || none4);
    let wrapA = conf.wrap, wrapB = rest.wrap;
    return {
      props: conc2(conf.props, rest.props),
      defineNodes: conc2(conf.defineNodes, rest.defineNodes),
      parseBlock: conc2(conf.parseBlock, rest.parseBlock),
      parseInline: conc2(conf.parseInline, rest.parseInline),
      remove: conc2(conf.remove, rest.remove),
      wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
    };
  }
  function findName(names, name2) {
    let found = names.indexOf(name2);
    if (found < 0)
      throw new RangeError(`Position specified relative to unknown parser ${name2}`);
    return found;
  }
  var nodeTypes = [NodeType.none];
  for (let i4 = 1, name2; name2 = Type[i4]; i4++) {
    nodeTypes[i4] = NodeType.define({
      id: i4,
      name: name2,
      props: i4 >= Type.Escape ? [] : [[NodeProp.group, i4 in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
      top: name2 == "Document"
    });
  }
  var none4 = [];
  var Buffer2 = class {
    constructor(nodeSet) {
      this.nodeSet = nodeSet;
      this.content = [];
      this.nodes = [];
    }
    write(type3, from, to, children = 0) {
      this.content.push(type3, from, to, 4 + children * 4);
      return this;
    }
    writeElements(elts, offset2 = 0) {
      for (let e3 of elts)
        e3.writeTo(this, offset2);
      return this;
    }
    finish(type3, length) {
      return Tree.build({
        buffer: this.content,
        nodeSet: this.nodeSet,
        reused: this.nodes,
        topID: type3,
        length
      });
    }
  };
  var Element2 = class {
    /**
    @internal
    */
    constructor(type3, from, to, children = none4) {
      this.type = type3;
      this.from = from;
      this.to = to;
      this.children = children;
    }
    /**
    @internal
    */
    writeTo(buf, offset2) {
      let startOff = buf.content.length;
      buf.writeElements(this.children, offset2);
      buf.content.push(this.type, this.from + offset2, this.to + offset2, buf.content.length + 4 - startOff);
    }
    /**
    @internal
    */
    toTree(nodeSet) {
      return new Buffer2(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
    }
  };
  var TreeElement = class {
    constructor(tree, from) {
      this.tree = tree;
      this.from = from;
    }
    get to() {
      return this.from + this.tree.length;
    }
    get type() {
      return this.tree.type.id;
    }
    get children() {
      return none4;
    }
    writeTo(buf, offset2) {
      buf.nodes.push(this.tree);
      buf.content.push(buf.nodes.length - 1, this.from + offset2, this.to + offset2, -1);
    }
    toTree() {
      return this.tree;
    }
  };
  function elt(type3, from, to, children) {
    return new Element2(type3, from, to, children);
  }
  var EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
  var EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
  var LinkStart = {};
  var ImageStart = {};
  var InlineDelimiter = class {
    constructor(type3, from, to, side) {
      this.type = type3;
      this.from = from;
      this.to = to;
      this.side = side;
    }
  };
  var Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  var Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
  try {
    Punctuation = new RegExp("[\\p{S}|\\p{P}]", "u");
  } catch (_3) {
  }
  var DefaultInline = {
    Escape(cx, next, start) {
      if (next != 92 || start == cx.end - 1)
        return -1;
      let escaped = cx.char(start + 1);
      for (let i4 = 0; i4 < Escapable.length; i4++)
        if (Escapable.charCodeAt(i4) == escaped)
          return cx.append(elt(Type.Escape, start, start + 2));
      return -1;
    },
    Entity(cx, next, start) {
      if (next != 38)
        return -1;
      let m3 = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
      return m3 ? cx.append(elt(Type.Entity, start, start + 1 + m3[0].length)) : -1;
    },
    InlineCode(cx, next, start) {
      if (next != 96 || start && cx.char(start - 1) == 96)
        return -1;
      let pos = start + 1;
      while (pos < cx.end && cx.char(pos) == 96)
        pos++;
      let size = pos - start, curSize = 0;
      for (; pos < cx.end; pos++) {
        if (cx.char(pos) == 96) {
          curSize++;
          if (curSize == size && cx.char(pos + 1) != 96)
            return cx.append(elt(Type.InlineCode, start, pos + 1, [
              elt(Type.CodeMark, start, start + size),
              elt(Type.CodeMark, pos + 1 - size, pos + 1)
            ]));
        } else {
          curSize = 0;
        }
      }
      return -1;
    },
    HTMLTag(cx, next, start) {
      if (next != 60 || start == cx.end - 1)
        return -1;
      let after = cx.slice(start + 1, cx.end);
      let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
      if (url) {
        return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [
          elt(Type.LinkMark, start, start + 1),
          // url[0] includes the closing bracket, so exclude it from this slice
          elt(Type.URL, start + 1, start + url[0].length),
          elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)
        ]));
      }
      let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
      if (comment2)
        return cx.append(elt(Type.Comment, start, start + 1 + comment2[0].length));
      let procInst = /^\?[^]*?\?>/.exec(after);
      if (procInst)
        return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
      let m3 = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
      if (!m3)
        return -1;
      return cx.append(elt(Type.HTMLTag, start, start + 1 + m3[0].length));
    },
    Emphasis(cx, next, start) {
      if (next != 95 && next != 42)
        return -1;
      let pos = start + 1;
      while (cx.char(pos) == next)
        pos++;
      let before3 = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
      let pBefore = Punctuation.test(before3), pAfter = Punctuation.test(after);
      let sBefore = /\s|^$/.test(before3), sAfter = /\s|^$/.test(after);
      let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
      let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
      let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
      let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
      return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
    },
    HardBreak(cx, next, start) {
      if (next == 92 && cx.char(start + 1) == 10)
        return cx.append(elt(Type.HardBreak, start, start + 2));
      if (next == 32) {
        let pos = start + 1;
        while (cx.char(pos) == 32)
          pos++;
        if (cx.char(pos) == 10 && pos >= start + 2)
          return cx.append(elt(Type.HardBreak, start, pos + 1));
      }
      return -1;
    },
    Link(cx, next, start) {
      return next == 91 ? cx.append(new InlineDelimiter(
        LinkStart,
        start,
        start + 1,
        1
        /* Mark.Open */
      )) : -1;
    },
    Image(cx, next, start) {
      return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(
        ImageStart,
        start,
        start + 2,
        1
        /* Mark.Open */
      )) : -1;
    },
    LinkEnd(cx, next, start) {
      if (next != 93)
        return -1;
      for (let i4 = cx.parts.length - 1; i4 >= 0; i4--) {
        let part = cx.parts[i4];
        if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
          if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
            cx.parts[i4] = null;
            return -1;
          }
          let content2 = cx.takeContent(i4);
          let link2 = cx.parts[i4] = finishLink(cx, content2, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
          if (part.type == LinkStart)
            for (let j4 = 0; j4 < i4; j4++) {
              let p3 = cx.parts[j4];
              if (p3 instanceof InlineDelimiter && p3.type == LinkStart)
                p3.side = 0;
            }
          return link2.to;
        }
      }
      return -1;
    }
  };
  function finishLink(cx, content2, type3, start, startPos) {
    let { text: text2 } = cx, next = cx.char(startPos), endPos = startPos;
    content2.unshift(elt(Type.LinkMark, start, start + (type3 == Type.Image ? 2 : 1)));
    content2.push(elt(Type.LinkMark, startPos - 1, startPos));
    if (next == 40) {
      let pos = cx.skipSpace(startPos + 1);
      let dest = parseURL(text2, pos - cx.offset, cx.offset), title;
      if (dest) {
        pos = cx.skipSpace(dest.to);
        if (pos != dest.to) {
          title = parseLinkTitle(text2, pos - cx.offset, cx.offset);
          if (title)
            pos = cx.skipSpace(title.to);
        }
      }
      if (cx.char(pos) == 41) {
        content2.push(elt(Type.LinkMark, startPos, startPos + 1));
        endPos = pos + 1;
        if (dest)
          content2.push(dest);
        if (title)
          content2.push(title);
        content2.push(elt(Type.LinkMark, pos, endPos));
      }
    } else if (next == 91) {
      let label = parseLinkLabel(text2, startPos - cx.offset, cx.offset, false);
      if (label) {
        content2.push(label);
        endPos = label.to;
      }
    }
    return elt(type3, start, endPos, content2);
  }
  function parseURL(text2, start, offset2) {
    let next = text2.charCodeAt(start);
    if (next == 60) {
      for (let pos = start + 1; pos < text2.length; pos++) {
        let ch = text2.charCodeAt(pos);
        if (ch == 62)
          return elt(Type.URL, start + offset2, pos + 1 + offset2);
        if (ch == 60 || ch == 10)
          return false;
      }
      return null;
    } else {
      let depth = 0, pos = start;
      for (let escaped = false; pos < text2.length; pos++) {
        let ch = text2.charCodeAt(pos);
        if (space(ch)) {
          break;
        } else if (escaped) {
          escaped = false;
        } else if (ch == 40) {
          depth++;
        } else if (ch == 41) {
          if (!depth)
            break;
          depth--;
        } else if (ch == 92) {
          escaped = true;
        }
      }
      return pos > start ? elt(Type.URL, start + offset2, pos + offset2) : pos == text2.length ? null : false;
    }
  }
  function parseLinkTitle(text2, start, offset2) {
    let next = text2.charCodeAt(start);
    if (next != 39 && next != 34 && next != 40)
      return false;
    let end = next == 40 ? 41 : next;
    for (let pos = start + 1, escaped = false; pos < text2.length; pos++) {
      let ch = text2.charCodeAt(pos);
      if (escaped)
        escaped = false;
      else if (ch == end)
        return elt(Type.LinkTitle, start + offset2, pos + 1 + offset2);
      else if (ch == 92)
        escaped = true;
    }
    return null;
  }
  function parseLinkLabel(text2, start, offset2, requireNonWS) {
    for (let escaped = false, pos = start + 1, end = Math.min(text2.length, pos + 999); pos < end; pos++) {
      let ch = text2.charCodeAt(pos);
      if (escaped)
        escaped = false;
      else if (ch == 93)
        return requireNonWS ? false : elt(Type.LinkLabel, start + offset2, pos + 1 + offset2);
      else {
        if (requireNonWS && !space(ch))
          requireNonWS = false;
        if (ch == 91)
          return false;
        else if (ch == 92)
          escaped = true;
      }
    }
    return null;
  }
  var InlineContext = class {
    /**
    @internal
    */
    constructor(parser5, text2, offset2) {
      this.parser = parser5;
      this.text = text2;
      this.offset = offset2;
      this.parts = [];
    }
    /**
    Get the character code at the given (document-relative)
    position.
    */
    char(pos) {
      return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
    }
    /**
    The position of the end of this inline section.
    */
    get end() {
      return this.offset + this.text.length;
    }
    /**
    Get a substring of this inline section. Again uses
    document-relative positions.
    */
    slice(from, to) {
      return this.text.slice(from - this.offset, to - this.offset);
    }
    /**
    @internal
    */
    append(elt2) {
      this.parts.push(elt2);
      return elt2.to;
    }
    /**
    Add a [delimiter](#DelimiterType) at this given position. `open`
    and `close` indicate whether this delimiter is opening, closing,
    or both. Returns the end of the delimiter, for convenient
    returning from [parse functions](#InlineParser.parse).
    */
    addDelimiter(type3, from, to, open, close) {
      return this.append(new InlineDelimiter(type3, from, to, (open ? 1 : 0) | (close ? 2 : 0)));
    }
    /**
    Returns true when there is an unmatched link or image opening
    token before the current position.
    */
    get hasOpenLink() {
      for (let i4 = this.parts.length - 1; i4 >= 0; i4--) {
        let part = this.parts[i4];
        if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
          return true;
      }
      return false;
    }
    /**
    Add an inline element. Returns the end of the element.
    */
    addElement(elt2) {
      return this.append(elt2);
    }
    /**
    Resolve markers between this.parts.length and from, wrapping matched markers in the
    appropriate node and updating the content of this.parts. @internal
    */
    resolveMarkers(from) {
      for (let i4 = from; i4 < this.parts.length; i4++) {
        let close = this.parts[i4];
        if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
          continue;
        let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
        let closeSize = close.to - close.from;
        let open, j4 = i4 - 1;
        for (; j4 >= from; j4--) {
          let part = this.parts[j4];
          if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && // Ignore emphasis delimiters where the character count doesn't match
          !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
            open = part;
            break;
          }
        }
        if (!open)
          continue;
        let type3 = close.type.resolve, content2 = [];
        let start = open.from, end = close.to;
        if (emp) {
          let size = Math.min(2, open.to - open.from, closeSize);
          start = open.to - size;
          end = close.from + size;
          type3 = size == 1 ? "Emphasis" : "StrongEmphasis";
        }
        if (open.type.mark)
          content2.push(this.elt(open.type.mark, start, open.to));
        for (let k3 = j4 + 1; k3 < i4; k3++) {
          if (this.parts[k3] instanceof Element2)
            content2.push(this.parts[k3]);
          this.parts[k3] = null;
        }
        if (close.type.mark)
          content2.push(this.elt(close.type.mark, close.from, end));
        let element = this.elt(type3, start, end, content2);
        this.parts[j4] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
        let keep = this.parts[i4] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
        if (keep)
          this.parts.splice(i4, 0, element);
        else
          this.parts[i4] = element;
      }
      let result = [];
      for (let i4 = from; i4 < this.parts.length; i4++) {
        let part = this.parts[i4];
        if (part instanceof Element2)
          result.push(part);
      }
      return result;
    }
    /**
    Find an opening delimiter of the given type. Returns `null` if
    no delimiter is found, or an index that can be passed to
    [`takeContent`](#InlineContext.takeContent) otherwise.
    */
    findOpeningDelimiter(type3) {
      for (let i4 = this.parts.length - 1; i4 >= 0; i4--) {
        let part = this.parts[i4];
        if (part instanceof InlineDelimiter && part.type == type3)
          return i4;
      }
      return null;
    }
    /**
    Remove all inline elements and delimiters starting from the
    given index (which you should get from
    [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
    resolve delimiters inside of them, and return them as an array
    of elements.
    */
    takeContent(startIndex) {
      let content2 = this.resolveMarkers(startIndex);
      this.parts.length = startIndex;
      return content2;
    }
    /**
    Skip space after the given (document) position, returning either
    the position of the next non-space character or the end of the
    section.
    */
    skipSpace(from) {
      return skipSpace(this.text, from - this.offset) + this.offset;
    }
    elt(type3, from, to, children) {
      if (typeof type3 == "string")
        return elt(this.parser.getNodeType(type3), from, to, children);
      return new TreeElement(type3, from);
    }
  };
  function injectMarks(elements, marks2) {
    if (!marks2.length)
      return elements;
    if (!elements.length)
      return marks2;
    let elts = elements.slice(), eI = 0;
    for (let mark of marks2) {
      while (eI < elts.length && elts[eI].to < mark.to)
        eI++;
      if (eI < elts.length && elts[eI].from < mark.from) {
        let e3 = elts[eI];
        if (e3 instanceof Element2)
          elts[eI] = new Element2(e3.type, e3.from, e3.to, injectMarks(e3.children, [mark]));
      } else {
        elts.splice(eI++, 0, mark);
      }
    }
    return elts;
  }
  var NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
  var FragmentCursor3 = class {
    constructor(fragments, input) {
      this.fragments = fragments;
      this.input = input;
      this.i = 0;
      this.fragment = null;
      this.fragmentEnd = -1;
      this.cursor = null;
      if (fragments.length)
        this.fragment = fragments[this.i++];
    }
    nextFragment() {
      this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
      this.cursor = null;
      this.fragmentEnd = -1;
    }
    moveTo(pos, lineStart) {
      while (this.fragment && this.fragment.to <= pos)
        this.nextFragment();
      if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
        return false;
      if (this.fragmentEnd < 0) {
        let end = this.fragment.to;
        while (end > 0 && this.input.read(end - 1, end) != "\n")
          end--;
        this.fragmentEnd = end ? end - 1 : 0;
      }
      let c3 = this.cursor;
      if (!c3) {
        c3 = this.cursor = this.fragment.tree.cursor();
        c3.firstChild();
      }
      let rPos = pos + this.fragment.offset;
      while (c3.to <= rPos)
        if (!c3.parent())
          return false;
      for (; ; ) {
        if (c3.from >= rPos)
          return this.fragment.from <= lineStart;
        if (!c3.childAfter(rPos))
          return false;
      }
    }
    matches(hash) {
      let tree = this.cursor.tree;
      return tree && tree.prop(NodeProp.contextHash) == hash;
    }
    takeNodes(cx) {
      let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
      let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
      let prevEnd = end, prevI = blockI;
      for (; ; ) {
        if (cur2.to - off > fragEnd) {
          if (cur2.type.isAnonymous && cur2.firstChild())
            continue;
          break;
        }
        let pos = toRelative(cur2.from - off, cx.ranges);
        if (cur2.to - off <= cx.ranges[cx.rangeI].to) {
          cx.addNode(cur2.tree, pos);
        } else {
          let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);
          cx.reusePlaceholders.set(dummy, cur2.tree);
          cx.addNode(dummy, pos);
        }
        if (cur2.type.is("Block")) {
          if (NotLast.indexOf(cur2.type.id) < 0) {
            end = cur2.to - off;
            blockI = cx.block.children.length;
          } else {
            end = prevEnd;
            blockI = prevI;
            prevEnd = cur2.to - off;
            prevI = cx.block.children.length;
          }
        }
        if (!cur2.nextSibling())
          break;
      }
      while (cx.block.children.length > blockI) {
        cx.block.children.pop();
        cx.block.positions.pop();
      }
      return end - start;
    }
  };
  function toRelative(abs, ranges) {
    let pos = abs;
    for (let i4 = 1; i4 < ranges.length; i4++) {
      let gapFrom = ranges[i4 - 1].to, gapTo = ranges[i4].from;
      if (gapFrom < abs)
        pos -= gapTo - gapFrom;
    }
    return pos;
  }
  var markdownHighlighting = styleTags({
    "Blockquote/...": tags.quote,
    HorizontalRule: tags.contentSeparator,
    "ATXHeading1/... SetextHeading1/...": tags.heading1,
    "ATXHeading2/... SetextHeading2/...": tags.heading2,
    "ATXHeading3/...": tags.heading3,
    "ATXHeading4/...": tags.heading4,
    "ATXHeading5/...": tags.heading5,
    "ATXHeading6/...": tags.heading6,
    "Comment CommentBlock": tags.comment,
    Escape: tags.escape,
    Entity: tags.character,
    "Emphasis/...": tags.emphasis,
    "StrongEmphasis/...": tags.strong,
    "Link/... Image/...": tags.link,
    "OrderedList/... BulletList/...": tags.list,
    "BlockQuote/...": tags.quote,
    "InlineCode CodeText": tags.monospace,
    "URL Autolink": tags.url,
    "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags.processingInstruction,
    "CodeInfo LinkLabel": tags.labelName,
    LinkTitle: tags.string,
    Paragraph: tags.content
  });
  var parser2 = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n3) => DefaultBlockParsers[n3]), Object.keys(DefaultBlockParsers).map((n3) => DefaultLeafBlocks[n3]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n3) => DefaultInline[n3]), Object.keys(DefaultInline), []);
  var StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
  var Strikethrough = {
    defineNodes: [{
      name: "Strikethrough",
      style: { "Strikethrough/...": tags.strikethrough }
    }, {
      name: "StrikethroughMark",
      style: tags.processingInstruction
    }],
    parseInline: [{
      name: "Strikethrough",
      parse(cx, next, pos) {
        if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
          return -1;
        let before3 = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
        let sBefore = /\s|^$/.test(before3), sAfter = /\s|^$/.test(after);
        let pBefore = Punctuation.test(before3), pAfter = Punctuation.test(after);
        return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
      },
      after: "Emphasis"
    }]
  };
  function parseRow(cx, line, startI = 0, elts, offset2 = 0) {
    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
    let parseCell = () => {
      elts.push(cx.elt("TableCell", offset2 + cellStart, offset2 + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset2 + cellStart)));
    };
    for (let i4 = startI; i4 < line.length; i4++) {
      let next = line.charCodeAt(i4);
      if (next == 124 && !esc) {
        if (!first || cellStart > -1)
          count++;
        first = false;
        if (elts) {
          if (cellStart > -1)
            parseCell();
          elts.push(cx.elt("TableDelimiter", i4 + offset2, i4 + offset2 + 1));
        }
        cellStart = cellEnd = -1;
      } else if (esc || next != 32 && next != 9) {
        if (cellStart < 0)
          cellStart = i4;
        cellEnd = i4 + 1;
      }
      esc = !esc && next == 92;
    }
    if (cellStart > -1) {
      count++;
      if (elts)
        parseCell();
    }
    return count;
  }
  function hasPipe(str, start) {
    for (let i4 = start; i4 < str.length; i4++) {
      let next = str.charCodeAt(i4);
      if (next == 124)
        return true;
      if (next == 92)
        i4++;
    }
    return false;
  }
  var delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
  var TableParser = class {
    constructor() {
      this.rows = null;
    }
    nextLine(cx, line, leaf) {
      if (this.rows == null) {
        this.rows = false;
        let lineText;
        if ((line.next == 45 || line.next == 58 || line.next == 124) && delimiterLine.test(lineText = line.text.slice(line.pos))) {
          let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
          if (firstCount == parseRow(cx, lineText, line.pos))
            this.rows = [
              cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
              cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
            ];
        }
      } else if (this.rows) {
        let content2 = [];
        parseRow(cx, line.text, line.pos, content2, cx.lineStart);
        this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content2));
      }
      return false;
    }
    finish(cx, leaf) {
      if (!this.rows)
        return false;
      cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
      return true;
    }
  };
  var Table = {
    defineNodes: [
      { name: "Table", block: true },
      { name: "TableHeader", style: { "TableHeader/...": tags.heading } },
      "TableRow",
      { name: "TableCell", style: tags.content },
      { name: "TableDelimiter", style: tags.processingInstruction }
    ],
    parseBlock: [{
      name: "Table",
      leaf(_3, leaf) {
        return hasPipe(leaf.content, 0) ? new TableParser() : null;
      },
      endLeaf(cx, line, leaf) {
        if (leaf.parsers.some((p3) => p3 instanceof TableParser) || !hasPipe(line.text, line.basePos))
          return false;
        let next = cx.peekLine();
        return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
      },
      before: "SetextHeading"
    }]
  };
  var TaskParser = class {
    nextLine() {
      return false;
    }
    finish(cx, leaf) {
      cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
        cx.elt("TaskMarker", leaf.start, leaf.start + 3),
        ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
      ]));
      return true;
    }
  };
  var TaskList = {
    defineNodes: [
      { name: "Task", block: true, style: tags.list },
      { name: "TaskMarker", style: tags.atom }
    ],
    parseBlock: [{
      name: "TaskList",
      leaf(cx, leaf) {
        return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
      },
      after: "SetextHeading"
    }]
  };
  function parseSubSuper(ch, node, mark) {
    return (cx, next, pos) => {
      if (next != ch || cx.char(pos + 1) == ch)
        return -1;
      let elts = [cx.elt(mark, pos, pos + 1)];
      for (let i4 = pos + 1; i4 < cx.end; i4++) {
        let next2 = cx.char(i4);
        if (next2 == ch)
          return cx.addElement(cx.elt(node, pos, i4 + 1, elts.concat(cx.elt(mark, i4, i4 + 1))));
        if (next2 == 92)
          elts.push(cx.elt("Escape", i4, i4++ + 2));
        if (space(next2))
          break;
      }
      return -1;
    };
  }
  var Superscript = {
    defineNodes: [
      { name: "Superscript", style: tags.special(tags.content) },
      { name: "SuperscriptMark", style: tags.processingInstruction }
    ],
    parseInline: [{
      name: "Superscript",
      parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
    }]
  };
  var Subscript = {
    defineNodes: [
      { name: "Subscript", style: tags.special(tags.content) },
      { name: "SubscriptMark", style: tags.processingInstruction }
    ],
    parseInline: [{
      name: "Subscript",
      parse: parseSubSuper(126, "Subscript", "SubscriptMark")
    }]
  };
  var Emoji = {
    defineNodes: [{ name: "Emoji", style: tags.character }],
    parseInline: [{
      name: "Emoji",
      parse(cx, next, pos) {
        let match2;
        if (next != 58 || !(match2 = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
          return -1;
        return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match2[0].length));
      }
    }]
  };

  // node_modules/@bpmn-io/feel-lint/dist/index.esm.js
  function lintSyntax(syntaxTree2) {
    const lintMessages = [];
    syntaxTree2.iterate({
      enter: (ref) => {
        const node = ref.node;
        if (!node.type.isError) {
          return;
        }
        const parent = node.parent;
        const next = getNextNode(node);
        const message = {
          from: node.from,
          to: node.to,
          severity: "error",
          type: "Syntax Error"
        };
        if (node.from !== node.to) {
          message.message = `Unrecognized token in <${parent.name}>`;
        } else if (next) {
          message.message = `Unrecognized token <${next.name}> in <${parent.name}>`;
          message.to = next.to;
        } else {
          const before3 = parent.enterUnfinishedNodesBefore(node.to);
          message.message = `Incomplete <${(before3 || parent).name}>`;
        }
        lintMessages.push(message);
      }
    });
    return lintMessages;
  }
  function getNextNode(node) {
    if (!node) {
      return null;
    }
    return node.nextSibling || getNextNode(node.parent);
  }
  var RULE_NAME = "first-item";
  var firstItem = {
    create(context) {
      return {
        enter(node) {
          if (node.name !== "FilterExpression") {
            return;
          }
          const content2 = context.readContent(node.from, node.to);
          if (zeroIndexPattern().test(content2)) {
            const {
              from,
              to
            } = node;
            context.report({
              from,
              to,
              message: "First item is accessed via [1]",
              severity: "warning",
              type: RULE_NAME,
              actions: [
                {
                  name: "fix",
                  apply(_3, start = from, end = to) {
                    context.updateContent(start, end, content2.replace(zeroIndexPattern(), "[1]"));
                  }
                }
              ]
            });
          }
        }
      };
    }
  };
  function zeroIndexPattern() {
    return /\[\s*0\s*\]$/;
  }
  var RULES = [
    firstItem
  ];
  function lintRules(context) {
    const {
      readContent,
      syntaxTree: syntaxTree2,
      updateContent
    } = context;
    const lintMessages = [];
    const ruleContext = {
      readContent,
      report: (message) => {
        lintMessages.push(message);
      },
      updateContent
    };
    const rules = RULES.map((rule) => rule.create(ruleContext));
    syntaxTree2.iterate({
      enter: (ref) => {
        for (const rule of rules) {
          rule.enter && rule.enter(ref);
        }
      },
      leave: (ref) => {
        for (const rule of rules) {
          rule.leave && rule.leave(ref);
        }
      }
    });
    return lintMessages;
  }
  function lintAll(context) {
    const lintMessages = [
      ...lintSyntax(context.syntaxTree),
      ...lintRules(context)
    ];
    return lintMessages;
  }
  var cmFeelLinter = () => (editorView) => {
    if (editorView.state.doc.length === 0) {
      return [];
    }
    const tree = syntaxTree(editorView.state);
    const messages = lintAll({
      syntaxTree: tree,
      readContent: (from, to) => editorView.state.sliceDoc(from, to),
      updateContent: (from, to, content2) => editorView.dispatch({
        changes: { from, to, insert: content2 }
      })
    });
    return messages.map((message) => ({
      ...message,
      source: message.type
    }));
  };

  // node_modules/@bpmn-io/cm-theme/dist/index.es.js
  var highlightStyle$2 = syntaxHighlighting(HighlightStyle.define([
    { tag: tags.strong, fontWeight: "bold" },
    { tag: tags.emphasis, fontStyle: "italic" }
  ]));
  var theme$2 = EditorView.theme({
    "& .cm-lintRange": {
      position: "relative"
    },
    "& .cm-lintRange::after": {
      content: '""',
      width: "100%",
      position: "absolute",
      left: "0px",
      bottom: "-2px",
      height: "3px",
      backgroundRepeat: "repeat-x"
    },
    "& .cm-lintRange.cm-lintRange-warning, & .cm-lintRange.cm-lintRange-error": {
      backgroundImage: "none"
    },
    "& .cm-lintPoint::after": {
      bottom: "-2px"
    }
  });
  var commonTheme = [
    theme$2,
    highlightStyle$2
  ];
  var _urlify = (color) => `%23${color.slice(1)}`;
  var colors = {
    black: "#1f2b36",
    darkGrey: "#2f3d58",
    grey: "#404a5c",
    midGrey: "#576071",
    lightGrey: "#c5d1e5",
    offWhite: "#d9e0f5",
    snowWhite: "#eaf1ff",
    white: "#ffffff",
    mossGreen: "#7ab6aa",
    iceBlue: "#6cbfd8",
    waterBlue: "#065aaa",
    brightBlue: "#0a56b9",
    deepBlue: "#355472",
    red: "#9f1c15",
    orangeBrown: "#b4502f",
    yellow: "#debd71",
    lila: "#9a4890",
    purple: "#5b2c83"
  };
  var colorByRole = {
    lightBackground: colors.white,
    darkBackground: colors.snowWhite,
    selection: colors.snowWhite,
    tooltipBackground: colors.offWhite,
    error: colors.red,
    warning: colors.yellow,
    invalid: "#b40000"
  };
  var theme$1 = EditorView.theme(
    {
      "&": { color: colors.black, backgroundColor: colorByRole.lightBackground },
      ".cm-content": { caretColor: colors.darkGrey },
      ".cm-cursor, .cm-dropCursor": { borderLeftColor: colors.darkGrey },
      "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: colorByRole.selection },
      ".cm-panels": { backgroundColor: colorByRole.darkBackground, color: colors.grey },
      ".cm-panels.cm-panels-top": { borderBottom: `2px solid ${colors.black}` },
      ".cm-panels.cm-panels-bottom": { borderTop: `2px solid ${colors.black}` },
      ".cm-searchMatch": {
        backgroundColor: "#72a1ff59",
        outline: `1px solid ${colors.midGrey}`
      },
      ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: colors.offWhite },
      ".cm-activeLine": { backgroundColor: colorByRole.selection },
      ".cm-selectionMatch": { backgroundColor: colors.offWhite },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        outline: `1px solid ${colors.grey}`
      },
      "&.cm-focused .cm-matchingBracket": {
        backgroundColor: colors.snowWhite
      },
      ".cm-gutters": {
        backgroundColor: "#f3f7fe",
        color: "#52668d",
        border: "none",
        padding: "0 5px"
      },
      ".cm-activeLineGutter": {
        backgroundColor: colorByRole.selection
      },
      ".cm-foldPlaceholder": {
        backgroundColor: "transparent",
        border: "none",
        color: "#ddd"
      },
      ".cm-tooltip": {
        border: "none",
        backgroundColor: colorByRole.tooltipBackground
      },
      ".cm-tooltip .cm-tooltip-arrow:before": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      },
      ".cm-tooltip .cm-tooltip-arrow:after": {
        borderTopColor: colorByRole.tooltipBackground,
        borderBottomColor: colorByRole.tooltipBackground
      },
      ".cm-tooltip-autocomplete": {
        "& > ul > li[aria-selected]": {
          backgroundColor: colorByRole.darkBackground,
          color: colors.midGrey
        }
      },
      "& .cm-lintRange.cm-lintRange-warning::after": {
        backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${_urlify(colorByRole.warning)}' fill='none' stroke-width='1.2'/></svg>")`
      },
      "& .cm-lintRange.cm-lintRange-error::after": {
        backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${_urlify(colorByRole.error)}' fill='none' stroke-width='1.2'/></svg>")`
      },
      "& .cm-diagnostic-warning": {
        border: `1px solid ${colorByRole.warning}`,
        borderLeft: `5px solid ${colorByRole.warning}`,
        background: colorByRole.lightBackground
      },
      "& .cm-diagnostic-error": {
        border: `1px solid ${colorByRole.error}`,
        borderLeft: `5px solid ${colorByRole.error}`,
        background: colorByRole.lightBackground
      },
      "& .cm-diagnostic": {
        padding: "3px 8px"
      }
    },
    { dark: false }
  );
  var highlightStyle$1 = syntaxHighlighting(HighlightStyle.define([
    {
      tag: [tags.macroName, tags.variableName],
      color: colors.waterBlue
    },
    {
      tag: [tags.special(tags.bracket)],
      color: colors.waterBlue,
      fontWeight: "bold"
    },
    {
      tag: [tags.color, tags.name, tags.definition(tags.name), tags.constant(tags.name), tags.standard(tags.name), tags.propertyName],
      color: colors.deepBlue
    },
    {
      tag: [tags.definition(tags.variableName), tags.function(tags.variableName), tags.function(tags.propertyName)],
      color: colors.brightBlue
    },
    { tag: [tags.labelName], color: colors.orangeBrown },
    {
      tag: [tags.annotation],
      color: colorByRole.invalid
    },
    {
      tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace, tags.atom, tags.bool, tags.special(tags.variableName)],
      color: colors.red
    },
    {
      tag: [tags.typeName, tags.className, tags.attributeName],
      color: colors.lila
    },
    {
      tag: [tags.operator, tags.operatorKeyword, tags.tagName, tags.keyword],
      color: colors.purple
    },
    {
      tag: [tags.angleBracket, tags.squareBracket, tags.brace, tags.separator, tags.punctuation],
      color: colors.midGrey
    },
    {
      tag: [tags.regexp],
      color: colors.deepBlue
    },
    {
      tag: [tags.quote],
      color: colors.darkGrey
    },
    { tag: [tags.string, tags.character, tags.deleted], color: colors.orangeBrown },
    {
      tag: tags.link,
      color: colors.mossGreen,
      textDecoration: "underline",
      textUnderlinePosition: "under"
    },
    {
      tag: [tags.url, tags.escape, tags.special(tags.string)],
      color: colors.red
    },
    { tag: [tags.meta], color: colors.iceBlue },
    { tag: [tags.comment], color: colors.midGrey, fontStyle: "italic" },
    { tag: tags.strong, fontWeight: "bold", color: colors.deepBlue },
    { tag: tags.emphasis, fontStyle: "italic", color: colors.deepBlue },
    { tag: tags.strikethrough, textDecoration: "line-through" },
    { tag: tags.heading, fontWeight: "bold", color: colors.midGray },
    { tag: tags.special(tags.heading1), fontWeight: "bold", color: colors.darkGrey },
    {
      tag: [tags.heading1, tags.heading2, tags.heading3, tags.heading4],
      fontWeight: "bold",
      color: colors.midGrey
    },
    { tag: [tags.heading5, tags.heading6, tags.processingInstruction, tags.inserted], color: colors.grey },
    {
      tag: [tags.contentSeparator],
      color: colors.yellow
    },
    { tag: tags.invalid, color: colors.midGrey, borderBottom: `1px dotted ${colorByRole.invalid}` }
  ]));
  var bpmnioLight = [
    theme$1,
    highlightStyle$1
  ];
  var ivory = "#abb2bf";
  var peach = "#f07178";
  var stone = "#7d8799";
  var invalid = "#ffffff";
  var pastelYellow = "#fffce1";
  var pastelOrange = "#ec9e6f";
  var raisinBlack = "#21252b";
  var highlightBackground = "rgba(0, 0, 0, 0.5)";
  var background = "#292d3e";
  var tooltipBackground = "#353a42";
  var selection = "rgba(128, 203, 196, 0.2)";
  var cursor = "#ffcc00";
  var urlHash = "%23";
  var warningColorHex = "fff890";
  var errorColor = "red";
  var warningBackgroundColor = "#281e16";
  var errorBackgroundColor = "#281616";
  var theme2 = EditorView.theme(
    {
      "&": {
        color: "#ffffff",
        backgroundColor: background
      },
      ".cm-content": {
        caretColor: cursor
      },
      "&.cm-focused .cm-cursor": {
        borderLeftColor: cursor
      },
      "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
      ".cm-panels": { backgroundColor: raisinBlack, color: "#ffffff" },
      ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
      ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
      ".cm-searchMatch": {
        backgroundColor: "#72a1ff59",
        outline: "1px solid #457dff"
      },
      ".cm-searchMatch.cm-searchMatch-selected": {
        backgroundColor: "#6199ff2f"
      },
      ".cm-activeLine": { backgroundColor: highlightBackground },
      ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "#bad0f847",
        outline: "1px solid #515a6b"
      },
      ".cm-gutters": {
        background: "#292d3e",
        color: "#676e95",
        border: "none",
        padding: "0 5px"
      },
      ".cm-activeLineGutter": {
        backgroundColor: highlightBackground
      },
      ".cm-foldPlaceholder": {
        backgroundColor: "transparent",
        border: "none",
        color: "#ddd"
      },
      ".cm-tooltip": {
        border: "none",
        backgroundColor: tooltipBackground
      },
      ".cm-tooltip .cm-tooltip-arrow:before": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      },
      ".cm-tooltip .cm-tooltip-arrow:after": {
        borderTopColor: tooltipBackground,
        borderBottomColor: tooltipBackground
      },
      ".cm-tooltip-autocomplete": {
        "& > ul > li[aria-selected]": {
          backgroundColor: highlightBackground,
          color: ivory
        }
      },
      "& .cm-lintRange.cm-lintRange-warning::after": {
        backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${urlHash + warningColorHex}' fill='none' stroke-width='1.2'/></svg>")`
      },
      "& .cm-lintRange.cm-lintRange-error::after": {
        backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${errorColor}' fill='none' stroke-width='1.2'/></svg>")`
      },
      "& .cm-diagnostic-warning": {
        borderLeft: `5px solid #${warningColorHex}`,
        background: warningBackgroundColor
      },
      "& .cm-diagnostic-error": {
        borderLeft: `5px solid ${errorColor}`,
        background: errorBackgroundColor
      },
      "& .cm-diagnostic": {
        borderRadius: "2px",
        padding: "3px 8px"
      }
    },
    { dark: true }
  );
  var highlightStyle = syntaxHighlighting(HighlightStyle.define([
    // Markdown headings
    { tag: tags.heading1, color: pastelYellow },
    { tag: tags.heading2, color: pastelYellow },
    { tag: tags.heading3, color: pastelYellow },
    { tag: tags.heading4, color: pastelYellow },
    { tag: tags.heading5, color: pastelYellow },
    { tag: tags.heading6, color: pastelYellow },
    // Feelers
    { tag: tags.special(tags.bracket), color: pastelOrange, fontWeight: "bold" },
    // Everything else
    { tag: tags.keyword, color: "#c792ea" },
    { tag: tags.operator, color: "#89ddff" },
    { tag: tags.special(tags.variableName), color: "#eeffff" },
    { tag: tags.typeName, color: "#f07178" },
    { tag: tags.atom, color: "#f78c6c" },
    { tag: tags.number, color: "#ff5370" },
    { tag: tags.bool, color: "#ff5370" },
    { tag: tags.definition(tags.variableName), color: "#82aaff" },
    { tag: tags.string, color: "#c3e88d" },
    { tag: tags.comment, color: stone },
    { tag: tags.tagName, color: "#ff5370" },
    { tag: tags.bracket, color: "#a2a1a4" },
    { tag: tags.meta, color: "#ffcb6b" },
    { tag: tags.special(tags.string), color: peach },
    { tag: tags.propertyName, color: pastelOrange },
    { tag: tags.variableName, color: pastelOrange },
    { tag: tags.attributeName, color: peach },
    { tag: tags.className, color: peach },
    { tag: tags.invalid, color: invalid }
  ]));
  var bpmnioDark = [
    theme2,
    highlightStyle
  ];
  var lightTheme = [...commonTheme, ...bpmnioLight];
  var darkTheme2 = [...commonTheme, ...bpmnioDark];

  // node_modules/feelers/dist/index.mjs
  var Feel = 1;
  var FeelBlock = 2;
  var SimpleTextBlock = 3;
  var CHAR_TABLE = {
    "{": 123,
    "}": 125
  };
  var isClosingFeelScope = (input, offset2 = 0) => {
    const isReadingCloseCurrent = input.peek(offset2) === CHAR_TABLE["}"];
    const isReadingCloseAhead = input.peek(offset2 + 1) === CHAR_TABLE["}"];
    const isReadingClose = isReadingCloseCurrent && isReadingCloseAhead;
    return isReadingClose || input.peek(offset2) === -1;
  };
  var feelBlock = new ExternalTokenizer((input, stack) => {
    let lookAhead = 0;
    while (!isClosingFeelScope(input, lookAhead)) {
      lookAhead++;
    }
    if (lookAhead > 0) {
      input.advance(lookAhead);
      input.acceptToken(FeelBlock);
    }
  });
  var isClosingTextScope = (input, offset2 = 0) => {
    const isReadingOpenCurrent = input.peek(offset2) === CHAR_TABLE["{"];
    const isReadingOpenAhead = input.peek(offset2 + 1) === CHAR_TABLE["{"];
    const isReadOpen = isReadingOpenCurrent && isReadingOpenAhead;
    return isReadOpen || input.peek(offset2) === -1;
  };
  var simpleTextBlock = new ExternalTokenizer((input, stack) => {
    let lookAhead = 0;
    while (!isClosingTextScope(input, lookAhead)) {
      lookAhead++;
    }
    if (lookAhead > 0) {
      input.advance(lookAhead);
      input.acceptToken(SimpleTextBlock);
    }
  });
  var feel = new ExternalTokenizer((input, stack) => {
    let lookAhead = 0;
    while (input.peek(lookAhead) !== -1) {
      lookAhead++;
    }
    if (lookAhead > 0) {
      input.advance(lookAhead);
      input.acceptToken(Feel);
    }
  });
  var feelersHighlighting = styleTags({
    ConditionalSpanner: tags.special(tags.bracket),
    ConditionalSpannerClose: tags.special(tags.bracket),
    ConditionalSpannerCloseNl: tags.special(tags.bracket),
    LoopSpanner: tags.special(tags.bracket),
    LoopSpannerClose: tags.special(tags.bracket),
    LoopSpannerCloseNl: tags.special(tags.bracket),
    EmptyInsert: tags.special(tags.bracket),
    Insert: tags.special(tags.bracket)
  });
  var parser3 = LRParser.deserialize({
    version: 14,
    states: "$bOQOaOOOfOXO'#CbOOO`'#Cm'#CmOqOWO'#CcOvOWO'#CfOOO`'#Cp'#CpOOO`'#Ci'#CiO{OaO'#ClO!jOSOOQOOOOOO!oOPO,58{O!tOXO,58|OOO`,58|,58|O!|OQO,58}O#ROQO,59QOOO`-E6g-E6gOOO`1G.g1G.gO#WOPO1G.gOOO`1G.h1G.hO#]OaO1G.iO#qOaO1G.lOOO`7+$R7+$RO$VOPO7+$TO$_OPO7+$WOOO`<<Go<<GoOOO`<<Gr<<Gr",
    stateData: "$g~ORUO_WObPOeROgSO^`P~OQYO_ZOc[O~OQ]O~OQ^O~ORUObPOeROgSO^`XW`XX`XZ`X[`X~OPXO~Oc`O~OQaOcbO~OfcO~OfdO~OceO~ORUObPOeROgSOW`PX`P~ORUObPOeROgSOZ`P[`P~OWhOXhO~OZiO[iO~O",
    goto: "!ZePPPPPfflPPlPPrPPz!TPP!TXQOVcdXTOVcdUVOcdR_VQXOQfcRgdXUOVcd",
    nodeNames: "\u26A0 Feel FeelBlock SimpleTextBlock Feelers Insert EmptyInsert ConditionalSpanner ConditionalSpannerClose ConditionalSpannerCloseNl LoopSpanner LoopSpannerClose LoopSpannerCloseNl",
    maxTerm: 23,
    propSources: [feelersHighlighting],
    skippedNodes: [0],
    repeatNodeCount: 1,
    tokenData: "%X~RR!_!`[#o#pa#q#r$r~aO_~~dP#o#pg~lQb~str!P!Q!{~uQ#]#^{#`#a!^~!OP#Y#Z!R~!UPpq!X~!^Oe~~!aP#c#d!d~!gP#c#d!j~!mP#d#e!p~!sPpq!v~!{Og~~#OQ#]#^#U#`#a#u~#XP#Y#Z#[~#_P#q#r#b~#eP#q#r#h~#mPW~YZ#p~#uOX~~#xP#c#d#{~$OP#c#d$R~$UP#d#e$X~$[P#q#r$_~$bP#q#r$e~$jPZ~YZ$m~$rO[~R$uP#q#r$xR%PPcPfQYZ%SQ%XOfQ",
    tokenizers: [0, 1, feel, feelBlock, simpleTextBlock],
    topRules: { "Feelers": [0, 4] },
    tokenPrec: 0
  });
  function buildSimpleTree(parseTree, templateString) {
    const stack = [{ children: [] }];
    const isLeafNode = (node) => ["SimpleTextBlock", "Feel", "FeelBlock"].includes(node.type.name);
    parseTree.iterate({
      enter: (node, pos, type3) => {
        const nodeRepresentation = {
          name: node.type.name,
          children: []
        };
        if (isLeafNode(node)) {
          nodeRepresentation.content = templateString.slice(node.from, node.to);
        }
        stack.push(nodeRepresentation);
      },
      leave: (node, pos, type3) => {
        const result = stack.pop();
        const parent = stack[stack.length - 1];
        result.parent = parent;
        parent.children.push(result);
      }
    });
    return stack[0].children[0];
  }
  var evaluate3 = (templateString, context = {}, options2 = {}) => {
    const {
      debug = false,
      strict = false,
      buildDebugString = (e3) => `{{ ${e3.message.toLowerCase()} }}`,
      sanitizer
    } = options2;
    const parseTree = parser3.parse(templateString);
    const simpleTreeRoot = buildSimpleTree(parseTree, templateString);
    const evaluateNode = buildNodeEvaluator({ debug, strict, buildDebugString, sanitizer });
    return evaluateNode(simpleTreeRoot, enhanceContext(context, null));
  };
  var buildNodeEvaluator = (options2) => {
    const {
      debug,
      strict,
      buildDebugString,
      sanitizer
    } = options2;
    const errorHandler = (error2) => {
      if (debug) {
        return buildDebugString(error2);
      }
      throw error2;
    };
    const evaluateNodeValue = (node, context = {}) => {
      switch (node.name) {
        case "SimpleTextBlock":
          return node.content;
        case "Insert": {
          const feel3 = node.children[0].content;
          try {
            const result = evaluate2(`string(${feel3})`, context);
            return sanitizer ? sanitizer(result) : result;
          } catch {
            return errorHandler(new Error(`FEEL expression ${feel3} couldn't be evaluated`));
          }
        }
        case "EmptyInsert":
          return "";
        case "Feel":
        case "FeelBlock": {
          const feel3 = node.content;
          try {
            const result = evaluate2(`string(${feel3})`, context);
            return sanitizer ? sanitizer(result) : result;
          } catch (e3) {
            return errorHandler(new Error(`FEEL expression ${feel3} couldn't be evaluated`));
          }
        }
        case "Feelers":
          return node.children.map((child) => evaluateNode(child, context)).join("");
        case "ConditionalSpanner": {
          const feel3 = node.children[0].content;
          let shouldRender;
          try {
            shouldRender = evaluate2(feel3, context);
          } catch {
            return errorHandler(new Error(`FEEL expression ${feel3} couldn't be evaluated`));
          }
          if (strict && typeof shouldRender !== "boolean") {
            return errorHandler(new Error(`FEEL expression ${feel3} expected to evaluate to a boolean`));
          }
          if (shouldRender) {
            const children = node.children.slice(1, node.children.length - 1);
            const innerRender = children.map((child) => evaluateNode(child, context)).join("");
            const closeNode = node.children[node.children.length - 1];
            const shouldAddNewline = closeNode.name.endsWith("Nl") && !innerRender.endsWith("\n");
            return innerRender + (shouldAddNewline ? "\n" : "");
          }
          return "";
        }
        case "LoopSpanner": {
          const feel3 = node.children[0].content;
          let loopArray;
          try {
            loopArray = evaluate2(feel3, context);
          } catch {
            return errorHandler(new Error(`FEEL expression ${feel3} couldn't be evaluated`));
          }
          if (!Array.isArray(loopArray)) {
            if (strict) {
              return errorHandler(new Error(`FEEL expression ${feel3} expected to evaluate to an array`));
            } else if (loopArray === void 0 || loopArray === null) {
              loopArray = [];
            } else {
              loopArray = [loopArray];
            }
          }
          const childrenToLoop = node.children.slice(1, node.children.length - 1);
          const evaluateChildren = (arrayElement, parentContext) => {
            const childContext = enhanceContext(arrayElement, parentContext);
            return childrenToLoop.map((child) => evaluateNode(child, childContext)).join("");
          };
          const innerRender = loopArray.map((arrayElement) => evaluateChildren(arrayElement, context)).join("");
          const closeNode = node.children[node.children.length - 1];
          const shouldAddNewline = closeNode.name.endsWith("Nl") && !innerRender.endsWith("\n");
          return innerRender + (shouldAddNewline ? "\n" : "");
        }
      }
    };
    const evaluateNode = (node, context = {}) => {
      try {
        return evaluateNodeValue(node, context);
      } catch (error2) {
        return errorHandler(error2);
      }
    };
    return evaluateNode;
  };
  var enhanceContext = (context, parentContext) => {
    if (typeof context === "object") {
      return { this: context, parent: parentContext, ...context, _this_: context, _parent_: parentContext };
    }
    return { this: context, parent: parentContext, _this_: context, _parent_: parentContext };
  };
  var foldMetadata = {
    ConditionalSpanner: foldInside,
    LoopSpanner: foldInside
  };
  function createMixedLanguage(hostLanguage = null) {
    const _mixedParser = parser3.configure({
      wrap: parseMixed((node) => {
        if (node.name == "Feel" || node.name == "FeelBlock") {
          return { parser };
        }
        if (hostLanguage && node.name == "SimpleTextBlock") {
          return { parser: hostLanguage };
        }
        return null;
      }),
      props: [
        foldNodeProp.add(foldMetadata)
      ]
    });
    return LRLanguage.define({ parser: _mixedParser });
  }
  var createFeelersLanguageSupport = (hostLanguageParser) => new LanguageSupport(createMixedLanguage(hostLanguageParser), []);
  function lintEmptyInserts(syntaxTree2) {
    const lintMessages = [];
    syntaxTree2.iterate({
      enter: (node) => {
        if (node.type.name === "EmptyInsert") {
          lintMessages.push(
            {
              from: node.from,
              to: node.to,
              severity: "warning",
              message: "this insert is empty and will be ignored",
              type: "emptyInsert"
            }
          );
        }
      }
    });
    return lintMessages;
  }
  function lintAll2(syntaxTree2) {
    const lintMessages = [
      ...lintEmptyInserts(syntaxTree2)
    ];
    return lintMessages;
  }
  function cmFeelersLinter() {
    const lintFeel = cmFeelLinter();
    return (editorView) => {
      const feelMessages = lintFeel(editorView);
      if (editorView.state.doc.length === 0) {
        return [];
      }
      const tree = syntaxTree(editorView.state);
      const feelersMessages = lintAll2(tree);
      return [
        ...feelMessages,
        ...feelersMessages.map((message) => ({
          ...message,
          source: "feelers linter"
        }))
      ];
    };
  }
  var lint = linter(cmFeelersLinter());
  function FeelersEditor({
    container,
    tooltipContainer,
    hostLanguage,
    hostLanguageParser,
    onChange = () => {
    },
    onKeyDown = () => {
    },
    onLint = () => {
    },
    contentAttributes: contentAttributes2 = {},
    readOnly: readOnly2 = false,
    value = "",
    enableGutters = false,
    singleLine = false,
    lineWrap = false,
    darkMode = false
  }) {
    const changeHandler = EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        onChange(update.state.doc.toString());
      }
    });
    const lintHandler = EditorView.updateListener.of((update) => {
      const diagnosticEffects = update.transactions.flatMap((t4) => t4.effects).filter((effect) => effect.is(setDiagnosticsEffect));
      if (!diagnosticEffects.length) {
        return;
      }
      const messages = diagnosticEffects.flatMap((effect) => effect.value);
      onLint(messages);
    });
    const contentAttributesExtension = EditorView.contentAttributes.of(contentAttributes2);
    const keyHandler = EditorView.domEventHandlers(
      {
        keydown: onKeyDown
      }
    );
    if (typeof tooltipContainer === "string") {
      tooltipContainer = document.querySelector(tooltipContainer);
    }
    const tooltipLayout = tooltipContainer ? tooltips({
      tooltipSpace: function() {
        return tooltipContainer.getBoundingClientRect();
      }
    }) : [];
    const _getHostLanguageParser = (hostLanguage2) => {
      switch (hostLanguage2) {
        case "markdown":
          return parser2;
        default:
          return null;
      }
    };
    const feelersLanguageSupport = createFeelersLanguageSupport(hostLanguageParser || hostLanguage && _getHostLanguageParser(hostLanguage));
    const extensions = [
      bracketMatching(),
      changeHandler,
      contentAttributesExtension,
      closeBrackets(),
      indentOnInput(),
      keyHandler,
      keymap.of([
        ...defaultKeymap
      ]),
      feelersLanguageSupport,
      lint,
      lintHandler,
      tooltipLayout,
      darkMode ? darkTheme2 : lightTheme,
      ...enableGutters ? [
        // todo: adjust folding boundaries first foldGutter(),
        lineNumbers()
      ] : [],
      ...singleLine ? [
        EditorState.transactionFilter.of((tr) => tr.newDoc.lines > 1 ? [] : tr)
      ] : [],
      ...lineWrap ? [
        EditorView.lineWrapping
      ] : []
    ];
    if (readOnly2) {
      extensions.push(EditorView.editable.of(false));
    }
    if (singleLine && value) {
      value = value.toString().split("\n")[0];
    }
    this._cmEditor = new EditorView({
      state: EditorState.create({
        doc: value,
        extensions
      }),
      parent: container
    });
    return this;
  }
  FeelersEditor.prototype.setValue = function(value) {
    this._cmEditor.dispatch({
      changes: {
        from: 0,
        to: this._cmEditor.state.doc.length,
        insert: value
      }
    });
  };
  FeelersEditor.prototype.focus = function(position) {
    const cmEditor = this._cmEditor;
    cmEditor.contentDOM.focus();
    cmEditor.focus();
    if (typeof position === "number") {
      const end = cmEditor.state.doc.length;
      cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
    }
  };
  FeelersEditor.prototype.getSelection = function() {
    return this._cmEditor.state.selection;
  };

  // node_modules/marked/lib/marked.esm.js
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  var _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  var noopTest = { exec: () => null };
  function edit(regex, opt = "") {
    let source = typeof regex === "string" ? regex : regex.source;
    const obj = {
      replace: (name2, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(other.caret, "$1");
        source = source.replace(name2, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  var other = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (indent2) => new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
    hrRegex: (indent2) => new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (indent2) => new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (indent2) => new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}#`),
    htmlBeginRegex: (indent2) => new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}<(?:[a-z].*>|!--)`, "i")
  };
  var newline = /^(?:[ \t]*(?:\n|$))+/;
  var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  var heading2 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  var bullet = /(?:[*+-]|\d{1,9}[.)])/;
  var lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
  var lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
  var lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
  var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  var blockText = /^[^\n]+/;
  var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  var html2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
  var blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading: heading2,
    hr,
    html: html2,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
  };
  var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockGfm = {
    ...blockNormal,
    lheading: lheadingGfm,
    table: gfmTable,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
  };
  var blockPedantic = {
    ...blockNormal,
    html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  };
  var escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  var br = /^( {2,}|\\)\n(?!\s*$)/;
  var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  var _punctuation = /[\p{P}\p{S}]/u;
  var _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
  var _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
  var punctuation2 = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
  var _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
  var _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
  var _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
  var blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
  var emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
  var emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
  var emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
  var emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
  var emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
  var emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
  var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
  var anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
  var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
  var tag3 = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
  var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
  var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
  var inlineNormal = {
    _backpedal: noopTest,
    // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape: escape$1,
    link,
    nolink,
    punctuation: punctuation2,
    reflink,
    reflinkSearch,
    tag: tag3,
    text: inlineText,
    url: noopTest
  };
  var inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
  };
  var inlineGfm = {
    ...inlineNormal,
    emStrongRDelimAst: emStrongRDelimAstGfm,
    emStrongLDelim: emStrongLDelimGfm,
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  var inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace("{2,}", "*").getRegex(),
    text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  var block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
  };
  var inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
  };
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape(html3, encode) {
    if (encode) {
      if (other.escapeTest.test(html3)) {
        return html3.replace(other.escapeReplace, getEscapeReplacement);
      }
    } else {
      if (other.escapeTestNoEncode.test(html3)) {
        return html3.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html3;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(other.percentDecode, "%");
    } catch {
      return null;
    }
    return href;
  }
  function splitCells(tableRow, count) {
    const row = tableRow.replace(other.findPipe, (match2, offset2, str) => {
      let escaped = false;
      let curr = offset2;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(other.splitPipe);
    let i4 = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells.at(-1)?.trim()) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
    }
    for (; i4 < cells.length; i4++) {
      cells[i4] = cells[i4].trim().replace(other.slashPipe, "|");
    }
    return cells;
  }
  function rtrim(str, c3, invert) {
    const l4 = str.length;
    if (l4 === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l4) {
      const currChar = str.charAt(l4 - suffLen - 1);
      if (currChar === c3 && true) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l4 - suffLen);
  }
  function findClosingBracket(str, b2) {
    if (str.indexOf(b2[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i4 = 0; i4 < str.length; i4++) {
      if (str[i4] === "\\") {
        i4++;
      } else if (str[i4] === b2[0]) {
        level++;
      } else if (str[i4] === b2[1]) {
        level--;
        if (level < 0) {
          return i4;
        }
      }
    }
    return -1;
  }
  function outputLink(cap, link2, raw, lexer2, rules) {
    const href = link2.href;
    const title = link2.title || null;
    const text2 = cap[1].replace(rules.other.outputLinkReplace, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer2.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text: text2,
        tokens: lexer2.inlineTokens(text2)
      };
      lexer2.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: text2
    };
  }
  function indentCodeCompensation(raw, text2, rules) {
    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
    if (matchIndentToCode === null) {
      return text2;
    }
    const indentToCode = matchIndentToCode[1];
    return text2.split("\n").map((node) => {
      const matchIndentInNode = node.match(rules.other.beginningSpace);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var _Tokenizer = class {
    options;
    rules;
    // set by the lexer
    lexer;
    // set by the lexer
    constructor(options2) {
      this.options = options2 || _defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text2 = cap[0].replace(this.rules.other.codeRemoveIndent, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text2, "\n") : text2
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text2 = indentCodeCompensation(raw, cap[3] || "", this.rules);
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
          text: text2
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text2 = cap[2].trim();
        if (this.rules.other.endingHash.test(text2)) {
          const trimmed = rtrim(text2, "#");
          if (this.options.pedantic) {
            text2 = trimmed.trim();
          } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
            text2 = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text: text2,
          tokens: this.lexer.inline(text2)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: rtrim(cap[0], "\n")
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        let lines = rtrim(cap[0], "\n").split("\n");
        let raw = "";
        let text2 = "";
        const tokens = [];
        while (lines.length > 0) {
          let inBlockquote = false;
          const currentLines = [];
          let i4;
          for (i4 = 0; i4 < lines.length; i4++) {
            if (this.rules.other.blockquoteStart.test(lines[i4])) {
              currentLines.push(lines[i4]);
              inBlockquote = true;
            } else if (!inBlockquote) {
              currentLines.push(lines[i4]);
            } else {
              break;
            }
          }
          lines = lines.slice(i4);
          const currentRaw = currentLines.join("\n");
          const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
          raw = raw ? `${raw}
${currentRaw}` : currentRaw;
          text2 = text2 ? `${text2}
${currentText}` : currentText;
          const top2 = this.lexer.state.top;
          this.lexer.state.top = true;
          this.lexer.blockTokens(currentText, tokens, true);
          this.lexer.state.top = top2;
          if (lines.length === 0) {
            break;
          }
          const lastToken = tokens.at(-1);
          if (lastToken?.type === "code") {
            break;
          } else if (lastToken?.type === "blockquote") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.blockquote(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
            text2 = text2.substring(0, text2.length - oldToken.text.length) + newToken.text;
            break;
          } else if (lastToken?.type === "list") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.list(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
            text2 = text2.substring(0, text2.length - oldToken.raw.length) + newToken.raw;
            lines = newText.substring(tokens.at(-1).raw.length).split("\n");
            continue;
          }
        }
        return {
          type: "blockquote",
          raw,
          tokens,
          text: text2
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = this.rules.other.listItemRegex(bull);
        let endsWithBlankLine = false;
        while (src) {
          let endEarly = false;
          let raw = "";
          let itemContents = "";
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t4) => " ".repeat(3 * t4.length));
          let nextLine = src.split("\n", 1)[0];
          let blankLine = !line.trim();
          let indent2 = 0;
          if (this.options.pedantic) {
            indent2 = 2;
            itemContents = line.trimStart();
          } else if (blankLine) {
            indent2 = cap[1].length + 1;
          } else {
            indent2 = cap[2].search(this.rules.other.nonSpaceChar);
            indent2 = indent2 > 4 ? 1 : indent2;
            itemContents = line.slice(indent2);
            indent2 += cap[1].length;
          }
          if (blankLine && this.rules.other.blankLine.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = this.rules.other.nextBulletRegex(indent2);
            const hrRegex = this.rules.other.hrRegex(indent2);
            const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent2);
            const headingBeginRegex = this.rules.other.headingBeginRegex(indent2);
            const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent2);
            while (src) {
              const rawLine = src.split("\n", 1)[0];
              let nextLineWithoutTabs;
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
                nextLineWithoutTabs = nextLine;
              } else {
                nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (htmlBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(nextLine)) {
                break;
              }
              if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent2 || !nextLine.trim()) {
                itemContents += "\n" + nextLineWithoutTabs.slice(indent2);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLineWithoutTabs.slice(indent2);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (this.rules.other.doubleBlankLine.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          let istask = null;
          let ischecked;
          if (this.options.gfm) {
            istask = this.rules.other.listIsTask.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents,
            tokens: []
          });
          list2.raw += raw;
        }
        const lastItem = list2.items.at(-1);
        if (lastItem) {
          lastItem.raw = lastItem.raw.trimEnd();
          lastItem.text = lastItem.text.trimEnd();
        } else {
          return;
        }
        list2.raw = list2.raw.trimEnd();
        for (let i4 = 0; i4 < list2.items.length; i4++) {
          this.lexer.state.top = false;
          list2.items[i4].tokens = this.lexer.blockTokens(list2.items[i4].text, []);
          if (!list2.loose) {
            const spacers = list2.items[i4].tokens.filter((t4) => t4.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t4) => this.rules.other.anyLine.test(t4.raw));
            list2.loose = hasMultipleLineBreaks;
          }
        }
        if (list2.loose) {
          for (let i4 = 0; i4 < list2.items.length; i4++) {
            list2.items[i4].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
          text: cap[0]
        };
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag4 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
        const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
        return {
          type: "def",
          tag: tag4,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (!cap) {
        return;
      }
      if (!this.rules.other.tableDelimiter.test(cap[2])) {
        return;
      }
      const headers = splitCells(cap[1]);
      const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
      const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
      const item = {
        type: "table",
        raw: cap[0],
        header: [],
        align: [],
        rows: []
      };
      if (headers.length !== aligns.length) {
        return;
      }
      for (const align of aligns) {
        if (this.rules.other.tableAlignRight.test(align)) {
          item.align.push("right");
        } else if (this.rules.other.tableAlignCenter.test(align)) {
          item.align.push("center");
        } else if (this.rules.other.tableAlignLeft.test(align)) {
          item.align.push("left");
        } else {
          item.align.push(null);
        }
      }
      for (let i4 = 0; i4 < headers.length; i4++) {
        item.header.push({
          text: headers[i4],
          tokens: this.lexer.inline(headers[i4]),
          header: true,
          align: item.align[i4]
        });
      }
      for (const row of rows) {
        item.rows.push(splitCells(row, item.header.length).map((cell, i4) => {
          return {
            text: cell,
            tokens: this.lexer.inline(cell),
            header: false,
            align: item.align[i4]
          };
        }));
      }
      return item;
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text: text2,
          tokens: this.lexer.inline(text2)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: cap[1]
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
          if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link2 = this.rules.other.pedanticHrefTitle.exec(href);
          if (link2) {
            href = link2[1];
            title = link2[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (this.rules.other.startAngleBracket.test(href)) {
          if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
          title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
        }, cap[0], this.lexer, this.rules);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
        const link2 = links[linkString.toLowerCase()];
        if (!link2) {
          const text2 = cap[0].charAt(0);
          return {
            type: "text",
            raw: text2,
            text: text2
          };
        }
        return outputLink(cap, link2, cap[0], this.lexer, this.rules);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match2 = this.rules.inline.emStrongLDelim.exec(src);
      if (!match2)
        return;
      if (match2[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
        return;
      const nextChar2 = match2[1] || match2[2] || "";
      if (!nextChar2 || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = [...match2[0]].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match2[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match2 = endReg.exec(maskedSrc)) != null) {
          rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];
          if (!rDelim)
            continue;
          rLength = [...rDelim].length;
          if (match2[3] || match2[4]) {
            delimTotal += rLength;
            continue;
          } else if (match2[5] || match2[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const lastCharLength = [...match2[0]][0].length;
          const raw = src.slice(0, lLength + match2.index + lastCharLength + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text3 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text3,
              tokens: this.lexer.inlineTokens(text3)
            };
          }
          const text2 = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text2 = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
        const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text2);
        const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text2) && this.rules.other.endingSpaceChar.test(text2);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text2 = text2.substring(1, text2.length - 1);
        }
        return {
          type: "codespan",
          raw: cap[0],
          text: text2
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text2, href;
        if (cap[2] === "@") {
          text2 = cap[1];
          href = "mailto:" + text2;
        } else {
          text2 = cap[1];
          href = text2;
        }
        return {
          type: "link",
          raw: cap[0],
          text: text2,
          href,
          tokens: [
            {
              type: "text",
              raw: text2,
              text: text2
            }
          ]
        };
      }
    }
    url(src) {
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text2, href;
        if (cap[2] === "@") {
          text2 = cap[0];
          href = "mailto:" + text2;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? "";
          } while (prevCapZero !== cap[0]);
          text2 = cap[0];
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text: text2,
          href,
          tokens: [
            {
              type: "text",
              raw: text2,
              text: text2
            }
          ]
        };
      }
    }
    inlineText(src) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        const escaped = this.lexer.state.inRawBlock;
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          escaped
        };
      }
    }
  };
  var _Lexer = class __Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options2) {
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options2 || _defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        other,
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options2) {
      const lexer2 = new __Lexer(options2);
      return lexer2.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options2) {
      const lexer2 = new __Lexer(options2);
      return lexer2.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(other.carriageReturn, "\n");
      this.blockTokens(src, this.tokens);
      for (let i4 = 0; i4 < this.inlineQueue.length; i4++) {
        const next = this.inlineQueue[i4];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
      if (this.options.pedantic) {
        src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
      }
      while (src) {
        let token;
        if (this.options.extensions?.block?.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (token.raw.length === 1 && lastToken !== void 0) {
            lastToken.raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (lastToken?.type === "paragraph" || lastToken?.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.at(-1).src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (lastToken?.type === "paragraph" || lastToken?.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue.at(-1).src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        let cutSrc = src;
        if (this.options.extensions?.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          const lastToken = tokens.at(-1);
          if (lastParagraphClipped && lastToken?.type === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue.at(-1).src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (lastToken?.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue.at(-1).src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      let maskedSrc = src;
      let match2 = null;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match2 = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match2.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      let keepPrevChar = false;
      let prevChar = "";
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        let token;
        if (this.options.extensions?.inline?.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (token.type === "text" && lastToken?.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        let cutSrc = src;
        if (this.options.extensions?.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          const lastToken = tokens.at(-1);
          if (lastToken?.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  var _Renderer = class {
    options;
    parser;
    // set by the parser
    constructor(options2) {
      this.options = options2 || _defaults;
    }
    space(token) {
      return "";
    }
    code({ text: text2, lang, escaped }) {
      const langString = (lang || "").match(other.notSpaceStart)?.[0];
      const code = text2.replace(other.endingNewline, "") + "\n";
      if (!langString) {
        return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    blockquote({ tokens }) {
      const body = this.parser.parse(tokens);
      return `<blockquote>
${body}</blockquote>
`;
    }
    html({ text: text2 }) {
      return text2;
    }
    heading({ tokens, depth }) {
      return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
    }
    hr(token) {
      return "<hr>\n";
    }
    list(token) {
      const ordered = token.ordered;
      const start = token.start;
      let body = "";
      for (let j4 = 0; j4 < token.items.length; j4++) {
        const item = token.items[j4];
        body += this.listitem(item);
      }
      const type3 = ordered ? "ol" : "ul";
      const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type3 + startAttr + ">\n" + body + "</" + type3 + ">\n";
    }
    listitem(item) {
      let itemBody = "";
      if (item.task) {
        const checkbox = this.checkbox({ checked: !!item.checked });
        if (item.loose) {
          if (item.tokens[0]?.type === "paragraph") {
            item.tokens[0].text = checkbox + " " + item.tokens[0].text;
            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
              item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text);
              item.tokens[0].tokens[0].escaped = true;
            }
          } else {
            item.tokens.unshift({
              type: "text",
              raw: checkbox + " ",
              text: checkbox + " ",
              escaped: true
            });
          }
        } else {
          itemBody += checkbox + " ";
        }
      }
      itemBody += this.parser.parse(item.tokens, !!item.loose);
      return `<li>${itemBody}</li>
`;
    }
    checkbox({ checked }) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
      return `<p>${this.parser.parseInline(tokens)}</p>
`;
    }
    table(token) {
      let header = "";
      let cell = "";
      for (let j4 = 0; j4 < token.header.length; j4++) {
        cell += this.tablecell(token.header[j4]);
      }
      header += this.tablerow({ text: cell });
      let body = "";
      for (let j4 = 0; j4 < token.rows.length; j4++) {
        const row = token.rows[j4];
        cell = "";
        for (let k3 = 0; k3 < row.length; k3++) {
          cell += this.tablecell(row[k3]);
        }
        body += this.tablerow({ text: cell });
      }
      if (body)
        body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow({ text: text2 }) {
      return `<tr>
${text2}</tr>
`;
    }
    tablecell(token) {
      const content2 = this.parser.parseInline(token.tokens);
      const type3 = token.header ? "th" : "td";
      const tag4 = token.align ? `<${type3} align="${token.align}">` : `<${type3}>`;
      return tag4 + content2 + `</${type3}>
`;
    }
    /**
     * span level renderer
     */
    strong({ tokens }) {
      return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
      return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text: text2 }) {
      return `<code>${escape(text2, true)}</code>`;
    }
    br(token) {
      return "<br>";
    }
    del({ tokens }) {
      return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
      const text2 = this.parser.parseInline(tokens);
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text2;
      }
      href = cleanHref;
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + escape(title) + '"';
      }
      out += ">" + text2 + "</a>";
      return out;
    }
    image({ href, title, text: text2 }) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return escape(text2);
      }
      href = cleanHref;
      let out = `<img src="${href}" alt="${text2}"`;
      if (title) {
        out += ` title="${escape(title)}"`;
      }
      out += ">";
      return out;
    }
    text(token) {
      return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
    }
  };
  var _TextRenderer = class {
    // no need for block level renderers
    strong({ text: text2 }) {
      return text2;
    }
    em({ text: text2 }) {
      return text2;
    }
    codespan({ text: text2 }) {
      return text2;
    }
    del({ text: text2 }) {
      return text2;
    }
    html({ text: text2 }) {
      return text2;
    }
    text({ text: text2 }) {
      return text2;
    }
    link({ text: text2 }) {
      return "" + text2;
    }
    image({ text: text2 }) {
      return "" + text2;
    }
    br() {
      return "";
    }
  };
  var _Parser = class __Parser {
    options;
    renderer;
    textRenderer;
    constructor(options2) {
      this.options = options2 || _defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.renderer.parser = this;
      this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options2) {
      const parser5 = new __Parser(options2);
      return parser5.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options2) {
      const parser5 = new __Parser(options2);
      return parser5.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top2 = true) {
      let out = "";
      for (let i4 = 0; i4 < tokens.length; i4++) {
        const anyToken = tokens[i4];
        if (this.options.extensions?.renderers?.[anyToken.type]) {
          const genericToken = anyToken;
          const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "space": {
            out += this.renderer.space(token);
            continue;
          }
          case "hr": {
            out += this.renderer.hr(token);
            continue;
          }
          case "heading": {
            out += this.renderer.heading(token);
            continue;
          }
          case "code": {
            out += this.renderer.code(token);
            continue;
          }
          case "table": {
            out += this.renderer.table(token);
            continue;
          }
          case "blockquote": {
            out += this.renderer.blockquote(token);
            continue;
          }
          case "list": {
            out += this.renderer.list(token);
            continue;
          }
          case "html": {
            out += this.renderer.html(token);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(token);
            continue;
          }
          case "text": {
            let textToken = token;
            let body = this.renderer.text(textToken);
            while (i4 + 1 < tokens.length && tokens[i4 + 1].type === "text") {
              textToken = tokens[++i4];
              body += "\n" + this.renderer.text(textToken);
            }
            if (top2) {
              out += this.renderer.paragraph({
                type: "paragraph",
                raw: body,
                text: body,
                tokens: [{ type: "text", raw: body, text: body, escaped: true }]
              });
            } else {
              out += body;
            }
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer = this.renderer) {
      let out = "";
      for (let i4 = 0; i4 < tokens.length; i4++) {
        const anyToken = tokens[i4];
        if (this.options.extensions?.renderers?.[anyToken.type]) {
          const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "escape": {
            out += renderer.text(token);
            break;
          }
          case "html": {
            out += renderer.html(token);
            break;
          }
          case "link": {
            out += renderer.link(token);
            break;
          }
          case "image": {
            out += renderer.image(token);
            break;
          }
          case "strong": {
            out += renderer.strong(token);
            break;
          }
          case "em": {
            out += renderer.em(token);
            break;
          }
          case "codespan": {
            out += renderer.codespan(token);
            break;
          }
          case "br": {
            out += renderer.br(token);
            break;
          }
          case "del": {
            out += renderer.del(token);
            break;
          }
          case "text": {
            out += renderer.text(token);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  var _Hooks = class {
    options;
    block;
    constructor(options2) {
      this.options = options2 || _defaults;
    }
    static passThroughHooks = /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]);
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html3) {
      return html3;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
      return tokens;
    }
    /**
     * Provide function to tokenize markdown
     */
    provideLexer() {
      return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    /**
     * Provide function to parse tokens
     */
    provideParser() {
      return this.block ? _Parser.parse : _Parser.parseInline;
    }
  };
  var Marked = class {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args) {
      this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
      let values2 = [];
      for (const token of tokens) {
        values2 = values2.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            const tableToken = token;
            for (const cell of tableToken.header) {
              values2 = values2.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tableToken.rows) {
              for (const cell of row) {
                values2 = values2.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            const listToken = token;
            values2 = values2.concat(this.walkTokens(listToken.items, callback));
            break;
          }
          default: {
            const genericToken = token;
            if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
              this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                const tokens2 = genericToken[childTokens].flat(Infinity);
                values2 = values2.concat(this.walkTokens(tokens2, callback));
              });
            } else if (genericToken.tokens) {
              values2 = values2.concat(this.walkTokens(genericToken.tokens, callback));
            }
          }
        }
      }
      return values2;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if ("renderer" in ext) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if ("tokenizer" in ext) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              const extLevel = extensions[ext.level];
              if (extLevel) {
                extLevel.unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if ("childTokens" in ext && ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer = this.defaults.renderer || new _Renderer(this.defaults);
          for (const prop in pack.renderer) {
            if (!(prop in renderer)) {
              throw new Error(`renderer '${prop}' does not exist`);
            }
            if (["options", "parser"].includes(prop)) {
              continue;
            }
            const rendererProp = prop;
            const rendererFunc = pack.renderer[rendererProp];
            const prevRenderer = renderer[rendererProp];
            renderer[rendererProp] = (...args2) => {
              let ret = rendererFunc.apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret || "";
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            if (!(prop in tokenizer)) {
              throw new Error(`tokenizer '${prop}' does not exist`);
            }
            if (["options", "rules", "lexer"].includes(prop)) {
              continue;
            }
            const tokenizerProp = prop;
            const tokenizerFunc = pack.tokenizer[tokenizerProp];
            const prevTokenizer = tokenizer[tokenizerProp];
            tokenizer[tokenizerProp] = (...args2) => {
              let ret = tokenizerFunc.apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw new Error(`hook '${prop}' does not exist`);
            }
            if (["options", "block"].includes(prop)) {
              continue;
            }
            const hooksProp = prop;
            const hooksFunc = pack.hooks[hooksProp];
            const prevHook = hooks[hooksProp];
            if (_Hooks.passThroughHooks.has(prop)) {
              hooks[hooksProp] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = hooksFunc.call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[hooksProp] = (...args2) => {
                let ret = hooksFunc.apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens2 = this.defaults.walkTokens;
          const packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values2 = [];
            values2.push(packWalktokens.call(this, token));
            if (walkTokens2) {
              values2 = values2.concat(walkTokens2.call(this, token));
            }
            return values2;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
    lexer(src, options2) {
      return _Lexer.lex(src, options2 ?? this.defaults);
    }
    parser(tokens, options2) {
      return _Parser.parse(tokens, options2 ?? this.defaults);
    }
    parseMarkdown(blockType) {
      const parse4 = (src, options2) => {
        const origOpt = { ...options2 };
        const opt = { ...this.defaults, ...origOpt };
        const throwError = this.onError(!!opt.silent, !!opt.async);
        if (this.defaults.async === true && origOpt.async === false) {
          return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        }
        if (typeof src === "undefined" || src === null) {
          return throwError(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
          opt.hooks.block = blockType;
        }
        const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
        const parser5 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser5(tokens, opt)).then((html3) => opt.hooks ? opt.hooks.postprocess(html3) : html3).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          let tokens = lexer2(src, opt);
          if (opt.hooks) {
            tokens = opt.hooks.processAllTokens(tokens);
          }
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html3 = parser5(tokens, opt);
          if (opt.hooks) {
            html3 = opt.hooks.postprocess(html3);
          }
          return html3;
        } catch (e3) {
          return throwError(e3);
        }
      };
      return parse4;
    }
    onError(silent, async) {
      return (e3) => {
        e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape(e3.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e3);
        }
        throw e3;
      };
    }
  };
  var markedInstance = new Marked();
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  marked.options = marked.setOptions = function(options2) {
    markedInstance.setOptions(options2);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parser4 = _Parser.parse;
  var lexer = _Lexer.lex;

  // node_modules/@bpmn-io/form-js-viewer/dist/index.es.js
  var getFlavouredFeelVariableNames = (feelString, feelFlavour = "expression", options2 = {}) => {
    const {
      depth = 0,
      specialDepthAccessors = {}
    } = options2;
    if (!["expression", "unaryTest"].includes(feelFlavour)) return [];
    const tree = feelFlavour === "expression" ? parseExpression(feelString) : parseUnaryTests(feelString);
    const simpleExpressionTree = _buildSimpleFeelStructureTree(tree, feelString);
    const variables = function _unfoldVariables(node) {
      if (node.name === "PathExpression") {
        const pathRoot = _linearizePathExpression(node)[0];
        if (pathRoot.name === "Context") {
          return _unfoldVariables(pathRoot);
        }
        if (Object.keys(specialDepthAccessors).length === 0) {
          return depth === 0 ? [_getVariableNameAtPathIndex(node, 0)] : [];
        }
        return Array.from(_smartExtractVariableNames(node, depth, specialDepthAccessors));
      }
      if (depth === 0 && node.name === "VariableName") return [node.variableName];
      if (node.children) {
        const variables2 = node.children.reduce((acc, child) => {
          return acc.concat(_unfoldVariables(child));
        }, []);
        return node.name === "FilterContext" ? variables2.filter((name2) => name2 !== "item") : variables2;
      }
      return [];
    }(simpleExpressionTree);
    return [...new Set(variables)];
  };
  var _getVariableNameAtPathIndex = (root, index2) => {
    const nodes = _linearizePathExpression(root);
    return nodes[index2].variableName || null;
  };
  var _smartExtractVariableNames = (node, initialDepth, specialDepthAccessors) => {
    let accessorDepthInfos = [{
      previous: null,
      current: initialDepth - 1
    }];
    const extractedVariables = /* @__PURE__ */ new Set();
    const pathNodes = _linearizePathExpression(node);
    for (let i4 = 0; i4 < pathNodes.length; i4++) {
      const currentAccessor = pathNodes[i4].variableName;
      if (currentAccessor in specialDepthAccessors) {
        const depthOffsets = specialDepthAccessors[currentAccessor];
        accessorDepthInfos = depthOffsets.reduce((accumulator, offset2) => {
          return [...accumulator, ...accessorDepthInfos.map((depthInfo) => ({
            previous: depthInfo.current,
            current: depthInfo.current + offset2
          }))];
        }, []).filter((depthInfo) => depthInfo.current >= -1);
      } else {
        accessorDepthInfos = accessorDepthInfos.map((depthInfo) => ({
          previous: depthInfo.current,
          current: depthInfo.current + 1
        }));
      }
      if (accessorDepthInfos.some((depthInfo) => depthInfo.previous === -1 && depthInfo.current === 0)) {
        extractedVariables.add(currentAccessor);
      }
    }
    return new Set(extractedVariables);
  };
  var _linearizePathExpression = (root) => {
    let node = root;
    let parts = [];
    while (node.name === "PathExpression") {
      parts.push(node.children[1]);
      node = node.children[0];
    }
    parts.push(node);
    return parts.reverse();
  };
  var _buildSimpleFeelStructureTree = (parseTree, feelString) => {
    const stack = [{
      children: []
    }];
    parseTree.iterate({
      enter: (node) => {
        const nodeRepresentation = {
          name: node.type.name,
          children: []
        };
        if (node.type.name === "VariableName") {
          nodeRepresentation.variableName = feelString.slice(node.from, node.to);
        }
        stack.push(nodeRepresentation);
      },
      leave: () => {
        const result = stack.pop();
        const parent = stack[stack.length - 1];
        parent.children.push(result);
      }
    });
    return _extractFilterExpressions(stack[0].children[0]);
  };
  var _extractFilterExpressions = (tree) => {
    const flattenedExpressionTree = {
      name: "Root",
      children: [tree]
    };
    const iterate = (node) => {
      if (node.children) {
        for (let x3 = 0; x3 < node.children.length; x3++) {
          if (node.children[x3].name === "FilterExpression") {
            const filterTarget = node.children[x3].children[0];
            const filterExpression = node.children[x3].children[2];
            node.children[x3] = filterTarget;
            const taggedFilterExpression = {
              name: "FilterContext",
              children: [filterExpression]
            };
            flattenedExpressionTree.children.push(taggedFilterExpression);
            iterate(filterExpression);
          } else {
            iterate(node.children[x3]);
          }
        }
      }
    };
    iterate(tree);
    return flattenedExpressionTree;
  };
  var FeelExpressionLanguage = class {
    constructor(eventBus) {
      this._eventBus = eventBus;
    }
    /**
     * Determines if the given value is a FEEL expression.
     *
     * @param {any} value
     * @returns {boolean}
     *
     */
    isExpression(value) {
      return isString(value) && value.startsWith("=");
    }
    /**
     * Retrieve variable names from a given FEEL expression.
     *
     * @param {string} expression
     * @param {object} [options]
     * @param {string} [options.type]
     *
     * @returns {string[]}
     */
    getVariableNames(expression, options2 = {}) {
      const {
        type: type3 = "expression"
      } = options2;
      if (!this.isExpression(expression)) {
        return [];
      }
      if (!["unaryTest", "expression"].includes(type3)) {
        throw new Error("Unknown expression type: " + type3);
      }
      return getFlavouredFeelVariableNames(expression, type3);
    }
    /**
     * Evaluate an expression.
     *
     * @param {string} expression
     * @param {import('../../types').Data} [data]
     *
     * @returns {any}
     */
    evaluate(expression, data = {}) {
      if (!expression) {
        return null;
      }
      if (!isString(expression) || !expression.startsWith("=")) {
        return null;
      }
      try {
        const result = evaluate(expression.slice(1), data);
        return result;
      } catch (error2) {
        this._eventBus.fire("error", {
          error: error2
        });
        return null;
      }
    }
  };
  FeelExpressionLanguage.$inject = ["eventBus"];
  var FeelersTemplating = class {
    constructor() {
    }
    /**
     * Determines if the given value is a feelers template.
     *
     * @param {any} value
     * @returns {boolean}
     *
     */
    isTemplate(value) {
      return isString(value) && (value.startsWith("=") || /{{.*?}}/.test(value));
    }
    /**
     * Retrieve variable names from a given feelers template.
     *
     * @param {string} template
     *
     * @returns {string[]}
     */
    getVariableNames(template) {
      if (!this.isTemplate(template)) {
        return [];
      }
      const expressions = this._extractExpressionsWithDepth(template);
      const specialDepthAccessors = {
        parent: [-1, 1],
        _parent_: [-1],
        this: [0, 1],
        _this_: [0]
      };
      return expressions.reduce((variables, {
        expression,
        depth
      }) => {
        return variables.concat(getFlavouredFeelVariableNames(expression, "expression", {
          depth,
          specialDepthAccessors
        }));
      }, []);
    }
    /**
     * Evaluate a template.
     *
     * @param {string} template
     * @param {Object<string, any>} context
     * @param {Object} options
     * @param {boolean} [options.debug = false]
     * @param {boolean} [options.strict = false]
     * @param {Function} [options.buildDebugString]
     * @param {Function} [options.sanitizer]
     *
     * @returns
     */
    evaluate(template, context = {}, options2 = {}) {
      const {
        debug = false,
        strict = false,
        buildDebugString = (err) => " {{\u26A0}} ",
        sanitizer = (value) => value
      } = options2;
      return evaluate3(template, context, {
        debug,
        strict,
        buildDebugString,
        sanitizer
      });
    }
    /**
     * @typedef {Object} ExpressionWithDepth
     * @property {number} depth - The depth of the expression in the syntax tree.
     * @property {string} expression - The extracted expression
     */
    /**
    * Extracts all feel expressions in the template along with their depth in the syntax tree.
    * The depth is incremented for child expressions of loops to account for context drilling.
    * @name extractExpressionsWithDepth
    * @param {string} template - A feelers template string.
    * @returns {Array<ExpressionWithDepth>} An array of objects, each containing the depth and the extracted expression.
    *
    * @example
    * const template = "Hello {{user}}, you have:{{#loop items}}\n- {{amount}} {{name}}{{/loop}}.";
    * const extractedExpressions = _extractExpressionsWithDepth(template);
    */
    _extractExpressionsWithDepth(template) {
      const parseTree = parser3.parse(template);
      const tree = buildSimpleTree(parseTree, template);
      return function _traverse(n3, depth = 0) {
        if (["Feel", "FeelBlock"].includes(n3.name)) {
          return [{
            depth,
            expression: n3.content
          }];
        }
        if (n3.name === "LoopSpanner") {
          const loopExpression = n3.children[0].content;
          const childResults = n3.children.slice(1).reduce((acc, child) => {
            return acc.concat(_traverse(child, depth + 1));
          }, []);
          return [{
            depth,
            expression: loopExpression
          }, ...childResults];
        }
        return n3.children.reduce((acc, child) => {
          return acc.concat(_traverse(child, depth));
        }, []);
      }(tree);
    }
  };
  FeelersTemplating.$inject = [];
  var MINUTES_IN_DAY = 60 * 24;
  var DATETIME_SUBTYPES = {
    DATE: "date",
    TIME: "time",
    DATETIME: "datetime"
  };
  var TIME_SERIALISING_FORMATS = {
    UTC_OFFSET: "utc_offset",
    UTC_NORMALIZED: "utc_normalized",
    NO_TIMEZONE: "no_timezone"
  };
  var DATETIME_SUBTYPES_LABELS = {
    [DATETIME_SUBTYPES.DATE]: "Date",
    [DATETIME_SUBTYPES.TIME]: "Time",
    [DATETIME_SUBTYPES.DATETIME]: "Date & Time"
  };
  var TIME_SERIALISINGFORMAT_LABELS = {
    [TIME_SERIALISING_FORMATS.UTC_OFFSET]: "UTC offset",
    [TIME_SERIALISING_FORMATS.UTC_NORMALIZED]: "UTC normalized",
    [TIME_SERIALISING_FORMATS.NO_TIMEZONE]: "No timezone"
  };
  var DATETIME_SUBTYPE_PATH = ["subtype"];
  var DATE_LABEL_PATH = ["dateLabel"];
  var DATE_DISALLOW_PAST_PATH = ["disallowPassedDates"];
  var TIME_LABEL_PATH = ["timeLabel"];
  var TIME_USE24H_PATH = ["use24h"];
  var TIME_INTERVAL_PATH = ["timeInterval"];
  var TIME_SERIALISING_FORMAT_PATH = ["timeSerializingFormat"];
  var OPTIONS_SOURCES = {
    STATIC: "static",
    INPUT: "input",
    EXPRESSION: "expression"
  };
  var OPTIONS_SOURCE_DEFAULT = OPTIONS_SOURCES.STATIC;
  var OPTIONS_SOURCES_LABELS = {
    [OPTIONS_SOURCES.STATIC]: "Static",
    [OPTIONS_SOURCES.INPUT]: "Input data",
    [OPTIONS_SOURCES.EXPRESSION]: "Expression"
  };
  var OPTIONS_SOURCES_PATHS = {
    [OPTIONS_SOURCES.STATIC]: ["values"],
    [OPTIONS_SOURCES.INPUT]: ["valuesKey"],
    [OPTIONS_SOURCES.EXPRESSION]: ["valuesExpression"]
  };
  var OPTIONS_SOURCES_DEFAULTS = {
    [OPTIONS_SOURCES.STATIC]: [{
      label: "Value",
      value: "value"
    }],
    [OPTIONS_SOURCES.INPUT]: "",
    [OPTIONS_SOURCES.EXPRESSION]: "="
  };
  function getOptionsSource(field) {
    for (const source of Object.values(OPTIONS_SOURCES)) {
      if (get(field, OPTIONS_SOURCES_PATHS[source]) !== void 0) {
        return source;
      }
    }
    return OPTIONS_SOURCE_DEFAULT;
  }
  var SANDBOX_ATTRIBUTE = "sandbox";
  var ALLOW_ATTRIBUTE = "allow";
  var SECURITY_ATTRIBUTES_DEFINITIONS = [{
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-scripts",
    property: "allowScripts",
    label: "Script execution"
  }, {
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-same-origin",
    property: "allowSameOrigin",
    label: "Allow same origin"
  }, {
    attribute: ALLOW_ATTRIBUTE,
    directive: "fullscreen",
    property: "fullscreen",
    label: "Open in fullscreen"
  }, {
    attribute: ALLOW_ATTRIBUTE,
    directive: "geolocation",
    property: "geolocation",
    label: "Geolocation"
  }, {
    attribute: ALLOW_ATTRIBUTE,
    directive: "camera",
    property: "camera",
    label: "Camera access"
  }, {
    attribute: ALLOW_ATTRIBUTE,
    directive: "microphone",
    property: "microphone",
    label: "Microphone access"
  }, {
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-forms",
    property: "allowForms",
    label: "Forms submission"
  }, {
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-modals",
    property: "allowModals",
    label: "Open modal windows"
  }, {
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-popups",
    property: "allowPopups",
    label: "Open popups"
  }, {
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-top-navigation",
    property: "allowTopNavigation",
    label: "Top level navigation"
  }, {
    attribute: SANDBOX_ATTRIBUTE,
    directive: "allow-storage-access-by-user-activation",
    property: "allowStorageAccessByUserActivation",
    label: "Storage access by user"
  }];
  function createInjector(bootstrapModules) {
    const injector = new Injector(bootstrapModules);
    injector.init();
    return injector;
  }
  function createFormContainer(prefix2 = "fjs") {
    const container = document.createElement("div");
    container.classList.add(`${prefix2}-container`);
    return container;
  }
  function formFieldClasses(type3, {
    errors = [],
    disabled = false,
    readonly = false
  } = {}) {
    if (!type3) {
      throw new Error("type required");
    }
    return (0, import_classnames.default)("fjs-form-field", `fjs-form-field-${type3}`, {
      "fjs-has-errors": errors.length > 0,
      "fjs-disabled": disabled,
      "fjs-readonly": readonly
    });
  }
  function gridColumnClasses(formField) {
    const {
      layout = {}
    } = formField;
    const {
      columns
    } = layout;
    return (0, import_classnames.default)(
      "fjs-layout-column",
      `cds--col${columns ? "-lg-" + columns : ""}`,
      // always fall back to top-down on smallest screens
      "cds--col-sm-16",
      "cds--col-md-16"
    );
  }
  function textToLabel(text2) {
    if (typeof text2 != "string") return null;
    for (const line of text2.split("\n")) {
      const displayLine = line.trim();
      if (displayLine !== "") {
        return displayLine;
      }
    }
    return null;
  }
  function prefixId(id2, formId, indexes) {
    let result = "fjs-form";
    if (formId) {
      result += `-${formId}`;
    }
    result += `-${id2}`;
    Object.values(indexes || {}).forEach((index2) => {
      result += `_${index2}`;
    });
    return result;
  }
  var FormRenderContext = K({
    Empty: (props) => {
      return null;
    },
    Hidden: (props) => {
      return null;
    },
    Children: (props) => {
      return u2("div", {
        class: props.class,
        style: props.style,
        children: props.children
      });
    },
    Element: (props) => {
      return u2("div", {
        class: props.class,
        style: props.style,
        children: props.children
      });
    },
    Row: (props) => {
      return u2("div", {
        class: props.class,
        style: props.style,
        children: props.children
      });
    },
    Column: (props) => {
      if (props.field.type === "default") {
        return props.children;
      }
      return u2("div", {
        class: props.class,
        style: props.style,
        children: props.children
      });
    },
    hoverInfo: {
      cleanup: () => {
      }
    }
  });
  var LocalExpressionContext = K({
    data: null,
    this: null,
    parent: null,
    i: null
  });
  function getService(type3, strict) {
  }
  var FormContext = K({
    getService,
    formId: null
  });
  function useService(type3, strict) {
    const {
      getService: getService3
    } = x2(FormContext);
    return getService3(type3, strict);
  }
  function clone4(data, replacer) {
    return JSON.parse(JSON.stringify(data, replacer));
  }
  function runRecursively(formField, fn4) {
    const components = formField.components || [];
    components.forEach((component, _3) => {
      runRecursively(component, fn4);
    });
    fn4(formField);
  }
  function wrapObjectKeysWithUnderscores(obj) {
    const newObj = {};
    for (const [key, value] of Object.entries(obj)) {
      newObj[`_${key}_`] = value;
    }
    return newObj;
  }
  function buildExpressionContext(context) {
    const {
      data,
      ...specialContextKeys
    } = context;
    return {
      ...specialContextKeys,
      ...data,
      ...wrapObjectKeysWithUnderscores(specialContextKeys)
    };
  }
  function runExpressionEvaluation(expressionLanguage2, value, expressionContextInfo) {
    if (expressionLanguage2 && expressionLanguage2.isExpression(value)) {
      return expressionLanguage2.evaluate(value, buildExpressionContext(expressionContextInfo));
    }
    return value;
  }
  function useCondition(condition) {
    const conditionChecker = useService("conditionChecker", false);
    const expressionContextInfo = x2(LocalExpressionContext);
    return T2(() => {
      return conditionChecker ? conditionChecker.check(condition, buildExpressionContext(expressionContextInfo)) : null;
    }, [conditionChecker, condition, expressionContextInfo]);
  }
  function getSimpleOptionsData(formField, formData) {
    const {
      valuesExpression: optionsExpression,
      valuesKey: optionsKey,
      values: staticOptions
    } = formField;
    if (optionsExpression) {
      return null;
    }
    return optionsKey ? get(formData, [optionsKey]) : staticOptions;
  }
  function normalizeOptionsData(optionsData) {
    return optionsData.filter(_isAllowedValue).map(_normalizeOption).filter((o3) => !isNil(o3));
  }
  function createEmptyOptions(options2 = {}) {
    const defaults3 = {};
    if (!options2.valuesKey && !options2.valuesExpression) {
      defaults3.values = [{
        label: "Value",
        value: "value"
      }];
    }
    return {
      ...defaults3,
      ...options2
    };
  }
  function _normalizeOption(option) {
    if (_isAllowedPrimitive(option)) {
      return {
        value: option,
        label: `${option}`
      };
    }
    if (isObject(option)) {
      const isValidLabel = _isValidLabel(option.label);
      if (!isValidLabel && _isAllowedPrimitive(option.value)) {
        return {
          value: option.value,
          label: `${option.value}`
        };
      }
      if (isValidLabel && _isAllowedValue(option.value)) {
        return option;
      }
    }
    return null;
  }
  function _isAllowedPrimitive(value) {
    const isAllowedPrimitiveType = ["number", "string", "boolean"].includes(typeof value);
    const isValid = value || value === 0 || value === false;
    return isAllowedPrimitiveType && isValid;
  }
  function _isValidLabel(label) {
    return label && isString(label);
  }
  function _isAllowedValue(value) {
    if (isObject(value)) {
      return Object.keys(value).length > 0;
    }
    return _isAllowedPrimitive(value);
  }
  function useExpressionEvaluation(value) {
    const expressionLanguage2 = useService("expressionLanguage");
    const expressionContextInfo = x2(LocalExpressionContext);
    return T2(() => runExpressionEvaluation(expressionLanguage2, value, expressionContextInfo), [expressionLanguage2, expressionContextInfo, value]);
  }
  function useDeepCompareMemoize(value) {
    const ref = A2();
    if (!(0, import_isEqual.default)(value, ref.current)) {
      ref.current = value;
    }
    return ref.current;
  }
  var LOAD_STATES = {
    LOADED: "loaded",
    ERROR: "error"
  };
  function useOptionsAsync(field) {
    const {
      valuesExpression: optionsExpression,
      valuesKey: optionsKey,
      values: staticOptions
    } = field;
    const initialData = useService("form")._getState().initialData;
    const expressionEvaluation = useExpressionEvaluation(optionsExpression);
    const evaluatedOptions = useDeepCompareMemoize(expressionEvaluation || []);
    const optionsGetter = T2(() => {
      let options2 = [];
      if (optionsKey !== void 0) {
        const keyedOptions = (initialData || {})[optionsKey];
        if (keyedOptions && Array.isArray(keyedOptions)) {
          options2 = keyedOptions;
        }
      } else if (staticOptions !== void 0) {
        options2 = Array.isArray(staticOptions) ? staticOptions : [];
      } else if (optionsExpression && evaluatedOptions && Array.isArray(evaluatedOptions)) {
        options2 = evaluatedOptions;
      } else {
        return buildErrorState("No options source defined in the form definition");
      }
      return buildLoadedState(normalizeOptionsData(options2));
    }, [optionsKey, staticOptions, initialData, optionsExpression, evaluatedOptions]);
    return optionsGetter;
  }
  var buildErrorState = (error2) => ({
    options: [],
    error: error2,
    loadState: LOAD_STATES.ERROR
  });
  var buildLoadedState = (options2) => ({
    options: options2,
    error: void 0,
    loadState: LOAD_STATES.LOADED
  });
  var useDangerousHTMLWrapper = (props) => {
    const {
      html: html3,
      transform = (html4) => html4,
      sanitize = true,
      sanitizeStyleTags = true
    } = props;
    const sanitizedHtml = T2(() => sanitize ? purify.sanitize(html3, getDOMPurifyConfig(sanitizeStyleTags)) : html3, [html3, sanitize, sanitizeStyleTags]);
    const transformedHtml = T2(() => transform(sanitizedHtml), [sanitizedHtml, transform]);
    return {
      __html: transformedHtml
    };
  };
  var getDOMPurifyConfig = (sanitizeStyleTags) => {
    return {
      FORCE_BODY: true,
      FORBID_TAGS: sanitizeStyleTags ? ["style"] : []
    };
  };
  function useSecurityAttributesMap(security) {
    const securityMemoized = useDeepCompareMemoize(security);
    const sandbox = T2(() => SECURITY_ATTRIBUTES_DEFINITIONS.filter(({
      attribute
    }) => attribute === SANDBOX_ATTRIBUTE).filter(({
      property
    }) => get(securityMemoized, [property], false)).map(({
      directive
    }) => directive).join(" "), [securityMemoized]);
    const allow = T2(() => SECURITY_ATTRIBUTES_DEFINITIONS.filter(({
      attribute
    }) => attribute !== SANDBOX_ATTRIBUTE).filter(({
      property
    }) => get(securityMemoized, [property], false)).map(({
      directive
    }) => directive).join("; "), [securityMemoized]);
    return [sandbox, allow];
  }
  function useGetLabelCorrelation(options2) {
    const labelMap = T2(() => Object.assign({}, ...options2.map((o3) => ({
      [_getValueHash(o3.value)]: o3.label
    }))), [options2]);
    return q2((value) => labelMap[_getValueHash(value)], [labelMap]);
  }
  var _getValueHash = (value) => {
    return isObject(value) ? JSON.stringify(value) : value;
  };
  function wrapCSSStyles(rootNode, prefix2) {
    const styleTags2 = rootNode.querySelectorAll("style");
    styleTags2.forEach((styleTag) => {
      const topLevelRules = extractTopLevelRules(styleTag.textContent);
      const scopedCss = topLevelRules.map((rule) => {
        const {
          selector,
          styles
        } = splitRule(rule);
        const scopedSelector = scopeSelector(selector, prefix2);
        return `${scopedSelector} ${styles}`;
      }).join(" ");
      styleTag.textContent = scopedCss;
    });
    return rootNode;
  }
  function extractTopLevelRules(cssString) {
    let cursor2 = 0;
    let start = 0;
    let level = 0;
    const topLevelRules = [];
    while (cursor2 < cssString.length) {
      if (cssString[cursor2] === "{") {
        level++;
      }
      if (cssString[cursor2] === "}") {
        level--;
        if (level === 0) {
          topLevelRules.push(cssString.substring(start, cursor2 + 1));
          start = cursor2 + 1;
        }
      }
      cursor2++;
    }
    return topLevelRules.map((rule) => rule.trim());
  }
  function splitRule(rule) {
    const firstBracket = rule.indexOf("{");
    const selector = rule.substring(0, firstBracket);
    const styles = rule.substring(firstBracket);
    return {
      selector,
      styles
    };
  }
  function scopeSelector(selector, prefix2) {
    return selector.split(",").map((sel) => `${prefix2} ${sel.trim()}`).join(", ");
  }
  function getScrollContainer(el) {
    while (el && el !== document.body && el !== document.documentElement) {
      if (_isElementScrollable(el)) {
        return el;
      }
      el = el.parentElement;
    }
    if (_isElementScrollable(document.body)) {
      return document.body;
    } else if (_isElementScrollable(document.documentElement)) {
      return document.documentElement;
    }
    return null;
  }
  function _isElementScrollable(el) {
    const style = window.getComputedStyle(el);
    const overflowY = style.overflowY || style.overflow;
    return (overflowY === "auto" || overflowY === "scroll") && el.scrollHeight > el.clientHeight;
  }
  var EMPTY_OBJECT = {};
  var EMPTY_ARRAY$2 = [];
  function useScrollIntoView(scrolledElementRef, deps, scrollOptions, flagRefs) {
    const _scrollOptions = scrollOptions || EMPTY_OBJECT;
    const _flagRefs = flagRefs || EMPTY_ARRAY$2;
    y2(() => {
      if (some(_flagRefs, (ref) => !ref.current) || !scrolledElementRef.current) {
        return;
      }
      for (let i4 = 0; i4 < _flagRefs.length; i4++) {
        _flagRefs[i4].current = false;
      }
      const itemToBeScrolled = scrolledElementRef.current;
      const scrollContainer = getScrollContainer(itemToBeScrolled);
      if (!scrollContainer) {
        return;
      }
      const itemRect = itemToBeScrolled.getBoundingClientRect();
      const containerRect = scrollContainer.getBoundingClientRect();
      const {
        align = "center",
        offset: offset2 = 0,
        behavior = "auto",
        scrollIfVisible = false
      } = _scrollOptions;
      const shouldScroll = scrollIfVisible || !(itemRect.top >= containerRect.top && itemRect.bottom <= containerRect.bottom);
      if (!shouldScroll) {
        return;
      }
      const topOffset = _getTopOffset(itemToBeScrolled, scrollContainer, {
        align,
        offset: offset2
      });
      scrollContainer.scroll({
        top: topOffset,
        behavior
      });
    }, deps);
  }
  function _getTopOffset(item, scrollContainer, options2) {
    const itemRect = item.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    if (options2.align === "top") {
      return itemRect.top - containerRect.top + scrollContainer.scrollTop - options2.offset;
    } else if (options2.align === "bottom") {
      return itemRect.bottom - containerRect.top - scrollContainer.clientHeight + scrollContainer.scrollTop + options2.offset;
    } else if (options2.align === "center") {
      return itemRect.top - containerRect.top - scrollContainer.clientHeight / 2 + scrollContainer.scrollTop + itemRect.height / 2 + options2.offset;
    }
    return 0;
  }
  function useBooleanExpressionEvaluation(value) {
    const expressionLanguage2 = useService("expressionLanguage");
    const expressionContextInfo = x2(LocalExpressionContext);
    return T2(() => {
      const evaluationResult = runExpressionEvaluation(expressionLanguage2, value, expressionContextInfo);
      return typeof evaluationResult === "boolean" ? evaluationResult : false;
    }, [expressionLanguage2, expressionContextInfo, value]);
  }
  function useFilteredFormData() {
    const {
      initialData,
      data
    } = useService("form")._getState();
    const conditionChecker = useService("conditionChecker", false);
    return T2(() => {
      const newData = conditionChecker ? conditionChecker.applyConditions(data, data) : data;
      return {
        ...initialData,
        ...newData
      };
    }, [conditionChecker, data, initialData]);
  }
  function useKeyDownAction(targetKey, action, listenerElement = window) {
    function downHandler({
      key
    }) {
      if (key === targetKey) {
        action();
      }
    }
    y2(() => {
      listenerElement.addEventListener("keydown", downHandler);
      return () => {
        listenerElement.removeEventListener("keydown", downHandler);
      };
    });
  }
  function useReadonly(formField, properties = {}) {
    const expressionLanguage2 = useService("expressionLanguage");
    const conditionChecker = useService("conditionChecker", false);
    const expressionContextInfo = x2(LocalExpressionContext);
    const {
      readonly
    } = formField;
    if (properties.readOnly) {
      return true;
    }
    if (expressionLanguage2 && expressionLanguage2.isExpression(readonly)) {
      return conditionChecker ? conditionChecker.check(readonly, buildExpressionContext(expressionContextInfo)) : false;
    }
    return readonly || false;
  }
  function usePrevious(value, defaultValue = null) {
    const ref = A2(defaultValue);
    y2(() => ref.current = value, [value]);
    return ref.current;
  }
  function useFlushDebounce(func) {
    const timeoutRef = A2(null);
    const lastArgsRef = A2(null);
    const config2 = useService("config", false);
    const debounce3 = config2 && config2.debounce;
    const shouldDebounce = debounce3 !== false && debounce3 !== 0;
    const delay3 = typeof debounce3 === "number" ? debounce3 : 300;
    const debounceFunc = q2((...args) => {
      if (!shouldDebounce) {
        func(...args);
        return;
      }
      lastArgsRef.current = args;
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        func(...lastArgsRef.current);
        lastArgsRef.current = null;
      }, delay3);
    }, [func, delay3, shouldDebounce]);
    const flushFunc = q2(() => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        if (lastArgsRef.current !== null) {
          func(...lastArgsRef.current);
          lastArgsRef.current = null;
        }
        timeoutRef.current = null;
      }
    }, [func]);
    return [debounceFunc, flushFunc];
  }
  function useTemplateEvaluation(value, options2 = {}) {
    const templating = useService("templating");
    const expressionContextInfo = x2(LocalExpressionContext);
    return T2(() => {
      if (templating && templating.isTemplate(value)) {
        return templating.evaluate(value, buildExpressionContext(expressionContextInfo), options2);
      }
      return value;
    }, [templating, value, expressionContextInfo, options2]);
  }
  function useSingleLineTemplateEvaluation(value, options2 = {}) {
    const evaluatedTemplate = useTemplateEvaluation(value, options2);
    return T2(() => evaluatedTemplate && evaluatedTemplate.split("\n")[0], [evaluatedTemplate]);
  }
  var ENTER_KEYDOWN_EVENT = new KeyboardEvent("keydown", {
    code: "Enter",
    key: "Enter",
    charCode: 13,
    keyCode: 13,
    bubbles: true
  });
  function focusRelevantFlatpickerDay(flatpickrInstance) {
    if (!flatpickrInstance) return;
    !flatpickrInstance.isOpen && flatpickrInstance.open();
    const container = flatpickrInstance.calendarContainer;
    const dayToFocus = container.querySelector(".flatpickr-day.selected") || container.querySelector(".flatpickr-day.today") || container.querySelector(".flatpickr-day");
    dayToFocus && dayToFocus.focus();
  }
  function formatTime(use24h, minutes) {
    if (minutes === null) return null;
    const wrappedMinutes = minutes % (24 * 60);
    const minute = minutes % 60;
    let hour = Math.floor(wrappedMinutes / 60);
    if (use24h) {
      return _getZeroPaddedString(hour) + ":" + _getZeroPaddedString(minute);
    }
    hour = hour % 12 || 12;
    const isPM = wrappedMinutes >= 12 * 60;
    return _getZeroPaddedString(hour) + ":" + _getZeroPaddedString(minute) + " " + (isPM ? "PM" : "AM");
  }
  function parseInputTime(stringTime) {
    let workingString = stringTime.toLowerCase();
    const is12h = workingString.includes("am") || workingString.includes("pm");
    if (is12h) {
      const isPM = workingString.includes("pm");
      const digits = workingString.match(/\d+/g);
      const displayHour = parseInt(digits && digits[0]);
      const minute = parseInt(digits && digits[1]) || 0;
      const isValidDisplayHour = isNumber(displayHour) && displayHour >= 1 && displayHour <= 12;
      const isValidMinute = minute >= 0 && minute <= 59;
      if (!isValidDisplayHour || !isValidMinute) return null;
      const hour = displayHour % 12 + (isPM ? 12 : 0);
      return hour * 60 + minute;
    } else {
      const digits = workingString.match(/\d+/g);
      const hour = parseInt(digits && digits[0]);
      const minute = parseInt(digits && digits[1]);
      const isValidHour = isNumber(hour) && hour >= 0 && hour <= 23;
      const isValidMinute = isNumber(minute) && minute >= 0 && minute <= 59;
      if (!isValidHour || !isValidMinute) return null;
      return hour * 60 + minute;
    }
  }
  function serializeTime(minutes, offset2, timeSerializingFormat) {
    if (timeSerializingFormat === TIME_SERIALISING_FORMATS.UTC_NORMALIZED) {
      const normalizedMinutes = (minutes + offset2 + MINUTES_IN_DAY) % MINUTES_IN_DAY;
      return _getZeroPaddedString(Math.floor(normalizedMinutes / 60)) + ":" + _getZeroPaddedString(normalizedMinutes % 60) + "Z";
    }
    const baseTime = _getZeroPaddedString(Math.floor(minutes / 60)) + ":" + _getZeroPaddedString(minutes % 60);
    const addUTCOffset = timeSerializingFormat === TIME_SERIALISING_FORMATS.UTC_OFFSET;
    return baseTime + (addUTCOffset ? formatTimezoneOffset(offset2) : "");
  }
  function parseIsoTime(isoTimeString) {
    if (!isoTimeString) return null;
    const parseBasicMinutes = (timeString) => {
      const timeSegments = timeString.split(":");
      const hour = parseInt(timeSegments[0]);
      const minute = timeSegments.length > 1 ? parseInt(timeSegments[1]) : 0;
      if (isNaN(hour) || hour < 0 || hour > 24 || isNaN(minute) || minute < 0 || minute > 60) return null;
      return hour * 60 + minute;
    };
    const localOffset = (/* @__PURE__ */ new Date()).getTimezoneOffset();
    if (isoTimeString.includes("Z")) {
      isoTimeString = isoTimeString.replace("Z", "");
      const minutes = parseBasicMinutes(isoTimeString);
      if (minutes === null) return null;
      return (minutes - localOffset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
    } else if (isoTimeString.includes("+")) {
      const [timeString, offsetString] = isoTimeString.split("+");
      const minutes = parseBasicMinutes(timeString);
      let inboundOffset = parseBasicMinutes(offsetString);
      if (minutes === null || inboundOffset === null) return null;
      inboundOffset = -inboundOffset;
      return (minutes + inboundOffset - localOffset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
    } else if (isoTimeString.includes("-")) {
      const [timeString, offsetString] = isoTimeString.split("-");
      const minutes = parseBasicMinutes(timeString);
      let inboundOffset = parseBasicMinutes(offsetString);
      if (minutes === null || inboundOffset === null) return null;
      return (minutes + inboundOffset - localOffset + MINUTES_IN_DAY) % MINUTES_IN_DAY;
    } else {
      return parseBasicMinutes(isoTimeString);
    }
  }
  function serializeDate(date3) {
    return DateTime.fromJSDate(date3).toISODate();
  }
  function isDateTimeInputInformationSufficient(value) {
    if (!value || typeof value !== "string") return false;
    const segments = value.split("T");
    if (segments.length != 2) return false;
    const dateNumbers = segments[0].split("-");
    if (dateNumbers.length != 3) return false;
    return true;
  }
  function isDateInputInformationMatching(value) {
    if (!value || typeof value !== "string") return false;
    if (value.includes("T")) return false;
    const dateNumbers = value.split("-");
    if (dateNumbers.length != 3) return false;
    return true;
  }
  function serializeDateTime(date3, time, timeSerializingFormat) {
    const workingDate = /* @__PURE__ */ new Date();
    workingDate.setFullYear(date3.getFullYear(), date3.getMonth(), date3.getDate());
    workingDate.setHours(Math.floor(time / 60), time % 60, 0, 0);
    if (timeSerializingFormat === TIME_SERIALISING_FORMATS.UTC_NORMALIZED) {
      const timezoneOffsetMinutes = workingDate.getTimezoneOffset();
      const dayOffset = time + timezoneOffsetMinutes < 0 ? -1 : time + timezoneOffsetMinutes > MINUTES_IN_DAY ? 1 : 0;
      workingDate.setHours(workingDate.getHours() + dayOffset * 24);
    }
    return serializeDate(workingDate) + "T" + serializeTime(time, workingDate.getTimezoneOffset(), timeSerializingFormat);
  }
  function formatTimezoneOffset(minutes) {
    return _getSignedPaddedHours(minutes) + ":" + _getZeroPaddedString(Math.abs(minutes % 60));
  }
  function isInvalidDateString(value) {
    return isNaN(new Date(Date.parse(value)).getTime());
  }
  function getNullDateTime() {
    return {
      date: new Date(Date.parse(null)),
      time: null
    };
  }
  function isValidDate(date3) {
    return date3 && !isNaN(date3.getTime());
  }
  function isValidTime(time) {
    return !isNaN(parseInt(time));
  }
  function _getSignedPaddedHours(minutes) {
    if (minutes > 0) {
      return "-" + _getZeroPaddedString(Math.floor(minutes / 60));
    } else {
      return "+" + _getZeroPaddedString(Math.floor((0 - minutes) / 60));
    }
  }
  function _getZeroPaddedString(time) {
    return time.toString().padStart(2, "0");
  }
  var ALLOWED_IMAGE_SRC_PATTERN = /^(https?|data):.*/i;
  var ALLOWED_IFRAME_SRC_PATTERN = /^(https):\/\/*/i;
  function sanitizeDateTimePickerValue(options2) {
    const {
      formField,
      value
    } = options2;
    const {
      subtype
    } = formField;
    if (typeof value !== "string") return null;
    if (subtype === DATETIME_SUBTYPES.DATE && (isInvalidDateString(value) || !isDateInputInformationMatching(value))) return null;
    if (subtype === DATETIME_SUBTYPES.TIME && parseIsoTime(value) === null) return null;
    if (subtype === DATETIME_SUBTYPES.DATETIME && (isInvalidDateString(value) || !isDateTimeInputInformationSufficient(value))) return null;
    return value;
  }
  function hasEqualValue(value, array) {
    if (!Array.isArray(array)) {
      return false;
    }
    return array.some((element) => (0, import_isEqual.default)(value, element));
  }
  function sanitizeSingleSelectValue(options2) {
    const {
      formField,
      data,
      value
    } = options2;
    const {
      valuesExpression: optionsExpression
    } = formField;
    try {
      if (optionsExpression) {
        return value;
      }
      const validValues = normalizeOptionsData(getSimpleOptionsData(formField, data)).map((v4) => v4.value);
      return hasEqualValue(value, validValues) ? value : null;
    } catch (error2) {
      return null;
    }
  }
  function sanitizeMultiSelectValue(options2) {
    const {
      formField,
      data,
      value
    } = options2;
    const {
      valuesExpression: optionsExpression
    } = formField;
    try {
      if (optionsExpression) {
        return value;
      }
      const validValues = normalizeOptionsData(getSimpleOptionsData(formField, data)).map((v4) => v4.value);
      return value.filter((v4) => hasEqualValue(v4, validValues));
    } catch (error2) {
      return [];
    }
  }
  function sanitizeImageSource(src) {
    const valid = ALLOWED_IMAGE_SRC_PATTERN.test(src);
    return valid ? src : "";
  }
  function sanitizeIFrameSource(src) {
    const valid = ALLOWED_IFRAME_SRC_PATTERN.test(src);
    return valid ? src : "";
  }
  function escapeHTML(html3) {
    const escapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;",
      "{": "&#123;",
      "}": "&#125;",
      ":": "&#58;",
      ";": "&#59;"
    };
    return html3.replace(/[&<>"'{};:]/g, (match2) => escapeMap[match2]);
  }
  function useCleanupSingleSelectValue(props) {
    const {
      field,
      options: options2,
      loadState,
      onChange,
      value
    } = props;
    y2(() => {
      if (loadState !== LOAD_STATES.LOADED) {
        return;
      }
      const optionValues = options2.map((o3) => o3.value);
      const hasValueNotInOptions = value && !hasEqualValue(value, optionValues);
      if (hasValueNotInOptions) {
        onChange({
          field,
          value: null
        });
      }
    }, [field, options2, onChange, value, loadState]);
  }
  function useCleanupMultiSelectValue(props) {
    const {
      field,
      options: options2,
      loadState,
      onChange,
      values: values2
    } = props;
    const memoizedValues = useDeepCompareMemoize(values2 || []);
    y2(() => {
      if (loadState !== LOAD_STATES.LOADED) {
        return;
      }
      const optionValues = options2.map((o3) => o3.value);
      const hasValuesNotInOptions = memoizedValues.some((v4) => !hasEqualValue(v4, optionValues));
      if (hasValuesNotInOptions) {
        onChange({
          field,
          value: memoizedValues.filter((v4) => hasEqualValue(v4, optionValues))
        });
      }
    }, [field, options2, onChange, memoizedValues, loadState]);
  }
  var type$j = "button";
  function Button(props) {
    const {
      disabled,
      onFocus,
      onBlur,
      field
    } = props;
    const {
      action = "submit"
    } = field;
    const evaluatedLabel = useSingleLineTemplateEvaluation(field.label || "", {
      debug: true
    });
    return u2("div", {
      class: formFieldClasses(type$j),
      children: u2("button", {
        class: "fjs-button",
        type: action,
        disabled,
        onFocus: () => onFocus && onFocus(),
        onBlur: () => onBlur && onBlur(),
        children: evaluatedLabel
      })
    });
  }
  Button.config = {
    type: type$j,
    keyed: false,
    name: "Button",
    group: "action",
    create: (options2 = {}) => ({
      label: "Button",
      action: "submit",
      ...options2
    })
  };
  function Description(props) {
    const {
      description: description2,
      id: id2
    } = props;
    const evaluatedDescription = useSingleLineTemplateEvaluation(description2 || "", {
      debug: true
    });
    if (!evaluatedDescription) {
      return null;
    }
    return u2("div", {
      id: id2,
      class: "fjs-form-field-description",
      children: evaluatedDescription
    });
  }
  function Errors(props) {
    const {
      errors,
      id: id2
    } = props;
    if (!errors.length) {
      return null;
    }
    return u2("div", {
      class: "fjs-form-field-error",
      "aria-live": "polite",
      id: id2,
      children: u2("ul", {
        children: errors.map((error2, index2) => {
          return u2("li", {
            children: error2
          }, index2);
        })
      })
    });
  }
  function Label(props) {
    const {
      id: id2,
      htmlFor,
      label,
      collapseOnEmpty = true,
      required = false
    } = props;
    const evaluatedLabel = useSingleLineTemplateEvaluation(label || "", {
      debug: true
    });
    return u2("label", {
      id: id2,
      htmlFor,
      class: (0, import_classnames.default)("fjs-form-field-label", {
        "fjs-incollapsible-label": !collapseOnEmpty
      }, props["class"]),
      children: [props.children, evaluatedLabel, required && u2("span", {
        class: "fjs-asterix",
        "aria-hidden": true,
        children: "*"
      })]
    });
  }
  var type$i = "checkbox";
  function Checkbox(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      readonly,
      value = false
    } = props;
    const {
      description: description2,
      label,
      validate: validate2 = {}
    } = field;
    const {
      required
    } = validate2;
    const onChange = ({
      target
    }) => {
      props.onChange({
        value: target.checked
      });
    };
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      class: (0, import_classnames.default)(formFieldClasses(type$i, {
        errors,
        disabled,
        readonly
      }), {
        "fjs-checked": value
      }),
      children: [u2("div", {
        class: "fjs-inline-label",
        children: [u2("input", {
          checked: value,
          class: "fjs-input",
          disabled,
          readOnly: readonly,
          id: domId,
          type: "checkbox",
          onChange,
          onBlur: () => onBlur && onBlur(),
          onFocus: () => onFocus && onFocus(),
          required,
          "aria-invalid": errors.length > 0,
          "aria-describedby": [descriptionId, errorMessageId].join(" ")
        }), u2(Label, {
          htmlFor: domId,
          label,
          required
        })]
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Checkbox.config = {
    type: type$i,
    keyed: true,
    name: "Checkbox",
    group: "selection",
    emptyValue: false,
    sanitizeValue: ({
      value
    }) => value === true,
    create: (options2 = {}) => ({
      label: "Checkbox",
      ...options2
    })
  };
  var type$h = "checklist";
  function Checklist(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      readonly,
      value: values2 = []
    } = props;
    const {
      description: description2,
      label,
      validate: validate2 = {}
    } = field;
    const outerDivRef = A2();
    const {
      required
    } = validate2;
    const toggleCheckbox = (toggledValue) => {
      const newValues = hasEqualValue(toggledValue, values2) ? values2.filter((value) => !(0, import_isEqual.default)(value, toggledValue)) : [...values2, toggledValue];
      props.onChange({
        value: newValues
      });
    };
    const onCheckboxBlur = (e3) => {
      if (outerDivRef.current.contains(e3.relatedTarget)) {
        return;
      }
      onBlur && onBlur();
    };
    const onCheckboxFocus = (e3) => {
      if (outerDivRef.current.contains(e3.relatedTarget)) {
        return;
      }
      onFocus && onFocus();
    };
    const {
      loadState,
      options: options2
    } = useOptionsAsync(field);
    useCleanupMultiSelectValue({
      field,
      loadState,
      options: options2,
      values: values2,
      onChange: props.onChange
    });
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      class: (0, import_classnames.default)(formFieldClasses(type$h, {
        errors,
        disabled,
        readonly
      })),
      ref: outerDivRef,
      children: [u2(Label, {
        label,
        required
      }), loadState == LOAD_STATES.LOADED && options2.map((option, index2) => {
        const itemDomId = `${domId}-${index2}`;
        const isChecked = hasEqualValue(option.value, values2);
        return u2("div", {
          className: (0, import_classnames.default)("fjs-inline-label", {
            "fjs-checked": isChecked
          }),
          children: [u2("input", {
            checked: isChecked,
            class: "fjs-input",
            disabled,
            readOnly: readonly,
            id: itemDomId,
            type: "checkbox",
            onClick: () => toggleCheckbox(option.value),
            onBlur: onCheckboxBlur,
            onFocus: onCheckboxFocus,
            required,
            "aria-invalid": errors.length > 0,
            "aria-describedby": [descriptionId, errorMessageId].join(" ")
          }), u2(Label, {
            htmlFor: itemDomId,
            label: option.label,
            required: false
          })]
        }, option.value);
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Checklist.config = {
    type: type$h,
    keyed: true,
    name: "Checkbox group",
    group: "selection",
    emptyValue: [],
    sanitizeValue: sanitizeMultiSelectValue,
    create: (options2 = {}) => ({
      label: "Checkbox group",
      ...createEmptyOptions(options2)
    })
  };
  var noop$1 = () => false;
  var ids$2 = new index_esm_default([32, 36, 1]);
  function FormField(props) {
    const instanceIdRef = A2(ids$2.next());
    const {
      field,
      indexes,
      onChange: _onChange
    } = props;
    const formFields2 = useService("formFields"), viewerCommands = useService("viewerCommands", false), formFieldInstanceRegistry = useService("formFieldInstanceRegistry", false), pathRegistry = useService("pathRegistry"), eventBus = useService("eventBus"), form = useService("form");
    const {
      initialData,
      data,
      errors,
      properties
    } = form._getState();
    const {
      Element: Element3,
      Hidden,
      Column: Column2
    } = x2(FormRenderContext);
    const {
      formId
    } = x2(FormContext);
    const [initialValidationTrigger, setInitialValidationTrigger] = d2(!!viewerCommands);
    const FormFieldComponent = formFields2.get(field.type);
    if (!FormFieldComponent) {
      throw new Error(`cannot render field <${field.type}>`);
    }
    const fieldConfig = FormFieldComponent.config;
    const localExpressionContext = x2(LocalExpressionContext);
    const valuePath = T2(() => pathRegistry.getValuePath(field, {
      indexes
    }), [field, indexes, pathRegistry]);
    const initialValue = T2(() => get(initialData, valuePath), [initialData, valuePath]);
    const readonly = useReadonly(field, properties);
    const value = get(data, valuePath);
    const disabled = !properties.readOnly && (properties.disabled || field.disabled || false);
    const hidden = useCondition(field.conditional && field.conditional.hide || null);
    const instanceId = T2(() => {
      if (!formFieldInstanceRegistry) {
        return null;
      }
      return formFieldInstanceRegistry.syncInstance(instanceIdRef.current, {
        id: field.id,
        expressionContextInfo: localExpressionContext,
        valuePath,
        value,
        indexes,
        hidden
      });
    }, [formFieldInstanceRegistry, field.id, localExpressionContext, valuePath, value, indexes, hidden]);
    const fieldInstance = instanceId ? formFieldInstanceRegistry.get(instanceId) : null;
    y2(() => {
      const instanceId2 = instanceIdRef.current;
      if (formFieldInstanceRegistry) {
        return () => formFieldInstanceRegistry.cleanupInstance(instanceId2);
      }
    }, [formFieldInstanceRegistry]);
    y2(() => {
      if (!viewerCommands) {
        return;
      }
      const resetValidation = () => {
        setInitialValidationTrigger(true);
      };
      eventBus.on("import.done", resetValidation);
      eventBus.on("reset", resetValidation);
      return () => {
        eventBus.off("import.done", resetValidation);
        eventBus.off("reset", resetValidation);
      };
    }, [eventBus, viewerCommands]);
    y2(() => {
      const hasInitialValue = initialValue && !(0, import_isEqual.default)(initialValue, []);
      if (initialValidationTrigger && hasInitialValue && fieldInstance) {
        setInitialValidationTrigger(false);
        viewerCommands.updateFieldInstanceValidation(fieldInstance, initialValue);
      }
    }, [fieldInstance, initialValidationTrigger, initialValue, viewerCommands]);
    const onBlur = q2(() => {
      const value2 = get(data, valuePath);
      if (initialValidationTrigger) {
        setInitialValidationTrigger(false);
        viewerCommands.updateFieldInstanceValidation(fieldInstance, value2);
      }
      eventBus.fire("formField.blur", {
        formField: field
      });
    }, [data, eventBus, field, fieldInstance, initialValidationTrigger, valuePath, viewerCommands]);
    const onFocus = q2(() => {
      eventBus.fire("formField.focus", {
        formField: field
      });
    }, [eventBus, field]);
    const onChange = q2((update) => {
      setInitialValidationTrigger(false);
      _onChange({
        field,
        indexes,
        fieldInstance,
        ...update
      });
    }, [_onChange, field, fieldInstance, indexes]);
    if (hidden) {
      return u2(Hidden, {
        field
      });
    }
    const domId = `${prefixId(field.id, formId, indexes)}`;
    const fieldErrors = get(errors, [field.id, ...Object.values(indexes || {})]) || [];
    const formFieldElement = u2(FormFieldComponent, {
      ...props,
      disabled,
      errors: fieldErrors,
      domId,
      onChange: disabled || readonly ? noop$1 : onChange,
      onBlur: disabled || readonly ? noop$1 : onBlur,
      onFocus: disabled || readonly ? noop$1 : onFocus,
      readonly,
      value,
      fieldInstance
    });
    if (fieldConfig.escapeGridRender) {
      return formFieldElement;
    }
    return u2(Column2, {
      field,
      class: gridColumnClasses(field),
      children: u2(Element3, {
        class: "fjs-element",
        field,
        children: formFieldElement
      })
    });
  }
  function ChildrenRenderer(props) {
    const {
      Children: Children2
    } = x2(FormRenderContext);
    const {
      field,
      Empty: Empty2
    } = props;
    const {
      id: id2
    } = field;
    const repeatRenderManager = useService("repeatRenderManager", false);
    const isRepeating = repeatRenderManager && repeatRenderManager.isFieldRepeating(id2);
    const Repeater = repeatRenderManager.Repeater;
    const RepeatFooter = repeatRenderManager.RepeatFooter;
    return isRepeating ? u2(RepeatChildrenRenderer, {
      ...props,
      ChildrenRoot: Children2,
      Empty: Empty2,
      Repeater,
      RepeatFooter,
      repeatRenderManager
    }) : u2(SimpleChildrenRenderer, {
      ...props,
      ChildrenRoot: Children2,
      Empty: Empty2
    });
  }
  function SimpleChildrenRenderer(props) {
    const {
      ChildrenRoot,
      Empty: Empty2,
      field
    } = props;
    const {
      components = []
    } = field;
    const isEmpty2 = !components.length;
    return u2(ChildrenRoot, {
      class: "fjs-vertical-layout fjs-children cds--grid cds--grid--condensed",
      field,
      children: [u2(RowsRenderer, {
        ...props
      }), isEmpty2 ? u2(Empty2, {
        field
      }) : null]
    });
  }
  function RepeatChildrenRenderer(props) {
    const {
      ChildrenRoot,
      repeatRenderManager,
      Empty: Empty2,
      field,
      ...restProps
    } = props;
    const {
      components = []
    } = field;
    const useSharedState = d2({
      isCollapsed: true
    });
    const Repeater = repeatRenderManager.Repeater;
    const RepeatFooter = repeatRenderManager.RepeatFooter;
    return u2(k, {
      children: [u2(ChildrenRoot, {
        class: "fjs-vertical-layout fjs-children cds--grid cds--grid--condensed",
        field,
        children: [Repeater ? u2(Repeater, {
          ...restProps,
          useSharedState,
          field,
          RowsRenderer
        }) : u2(RowsRenderer, {
          ...restProps,
          field
        }), !components.length ? u2(Empty2, {
          field
        }) : null]
      }), RepeatFooter ? u2(RepeatFooter, {
        ...restProps,
        useSharedState,
        field
      }) : null]
    });
  }
  function RowsRenderer(props) {
    const {
      field,
      indexes
    } = props;
    const {
      id: parentId,
      verticalAlignment = "start"
    } = field;
    const formLayouter = useService("formLayouter");
    const formFieldRegistry = useService("formFieldRegistry");
    const rows = formLayouter.getRows(parentId);
    const {
      Row: Row2
    } = x2(FormRenderContext);
    return u2(k, {
      children: [" ", rows.map((row) => {
        const {
          components = []
        } = row;
        if (!components.length) {
          return null;
        }
        return u2(Row2, {
          row,
          class: "fjs-layout-row cds--row",
          style: {
            alignItems: verticalAlignment
          },
          children: components.map((childId) => {
            const childField = formFieldRegistry.get(childId);
            if (!childField) {
              return null;
            }
            return _(FormField, {
              ...props,
              key: childId,
              field: childField,
              indexes
            });
          })
        }, row.id);
      }), " "]
    });
  }
  function Default(props) {
    const {
      Empty: Empty2
    } = x2(FormRenderContext);
    const fullProps = {
      ...props,
      Empty: Empty2
    };
    return u2(ChildrenRenderer, {
      ...fullProps
    });
  }
  Default.config = {
    type: "default",
    keyed: false,
    label: null,
    group: null,
    create: (options2 = {}) => ({
      components: [],
      ...options2
    }),
    getSubheading: (field) => field.id
  };
  var _path$z;
  function _extends$A() {
    return _extends$A = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$A.apply(null, arguments);
  }
  var SvgCalendar = function SvgCalendar2(props) {
    return /* @__PURE__ */ _("svg", _extends$A({
      xmlns: "http://www.w3.org/2000/svg",
      width: 14,
      height: 15,
      fill: "none",
      viewBox: "0 0 28 30"
    }, props), _path$z || (_path$z = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 2H9V0H7v2H2a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-5V0h-2zM7 7V4H2v5h24V4h-5v3h-2V4H9v3zm-5 4v17h24V11z",
      clipRule: "evenodd"
    })));
  };
  function getLocaleDateFormat(locale = "default") {
    const parts = new Intl.DateTimeFormat(locale).formatToParts(new Date(Date.UTC(2020, 5, 5)));
    return parts.map((part) => {
      const len = part.value.length;
      switch (part.type) {
        case "day":
          return "d".repeat(len);
        case "month":
          return "M".repeat(len);
        case "year":
          return "y".repeat(len);
        default:
          return part.value;
      }
    }).join("");
  }
  function getLocaleReadableDateFormat(locale) {
    let format = getLocaleDateFormat(locale).toLowerCase();
    if (!format.includes("mm")) {
      format = format.replace("m", "mm");
    }
    if (!format.includes("dd")) {
      format = format.replace("d", "dd");
    }
    return format;
  }
  function getLocaleDateFlatpickrConfig(locale) {
    return flatpickerizeDateFormat(getLocaleDateFormat(locale));
  }
  function flatpickerizeDateFormat(dateFormat) {
    const useLeadingZero = {
      day: dateFormat.includes("dd"),
      month: dateFormat.includes("MM"),
      year: dateFormat.includes("yyyy")
    };
    dateFormat = useLeadingZero.day ? dateFormat.replace("dd", "d") : dateFormat.replace("d", "j");
    dateFormat = useLeadingZero.month ? dateFormat.replace("MM", "m") : dateFormat.replace("M", "n");
    dateFormat = useLeadingZero.year ? dateFormat.replace("yyyy", "Y") : dateFormat.replace("yy", "y");
    return dateFormat;
  }
  function InputAdorner(props) {
    const {
      pre,
      post,
      rootRef,
      inputRef,
      children,
      disabled,
      readonly,
      hasErrors
    } = props;
    const onAdornmentClick = () => inputRef && inputRef.current && inputRef.current.focus();
    return u2("div", {
      class: (0, import_classnames.default)("fjs-input-group", {
        "fjs-disabled": disabled,
        "fjs-readonly": readonly
      }, {
        hasErrors
      }),
      ref: rootRef,
      children: [pre && u2("span", {
        class: "fjs-input-adornment border-right border-radius-left",
        onClick: onAdornmentClick,
        children: [" ", isString(pre) ? u2("span", {
          class: "fjs-input-adornment-text",
          children: pre
        }) : pre, " "]
      }), children, post && u2("span", {
        class: "fjs-input-adornment border-left border-radius-right",
        onClick: onAdornmentClick,
        children: [" ", isString(post) ? u2("span", {
          class: "fjs-input-adornment-text",
          children: post
        }) : post, " "]
      })]
    });
  }
  function Datepicker(props) {
    const {
      label,
      domId,
      collapseLabelOnEmpty,
      onDateTimeBlur,
      onDateTimeFocus,
      required,
      disabled,
      disallowPassedDates,
      date: dateObject,
      readonly,
      setDate
    } = props;
    const dateInputRef = A2();
    const focusScopeRef = A2();
    const [flatpickrInstance, setFlatpickrInstance] = d2(null);
    const [isInputDirty, setIsInputDirty] = d2(false);
    const [forceFocusCalendar, setForceFocusCalendar] = d2(false);
    const date3 = useDeepCompareMemoize(dateObject);
    y2(() => {
      if (!flatpickrInstance || !flatpickrInstance.config) return;
      flatpickrInstance.setDate(date3, true);
      setIsInputDirty(false);
    }, [flatpickrInstance, date3]);
    y2(() => {
      if (!forceFocusCalendar) return;
      focusRelevantFlatpickerDay(flatpickrInstance);
      setForceFocusCalendar(false);
    }, [flatpickrInstance, forceFocusCalendar]);
    y2(() => {
      let config2 = {
        allowInput: true,
        dateFormat: getLocaleDateFlatpickrConfig(),
        static: true,
        clickOpens: false,
        // TODO: support dates prior to 1900 (https://github.com/bpmn-io/form-js/issues/533)
        minDate: disallowPassedDates ? "today" : "01/01/1900",
        errorHandler: () => {
        }
      };
      const instance = esm_default(dateInputRef.current, config2);
      setFlatpickrInstance(instance);
      const onCalendarFocusOut = (e3) => {
        if (!instance.calendarContainer.contains(e3.relatedTarget) && e3.relatedTarget != dateInputRef.current) {
          instance.close();
        }
      };
      const onCalendarMouseDown = (e3) => {
        if (e3.target.classList.contains("flatpickr-day")) {
          setIsInputDirty(false);
        }
      };
      instance.config.onOpen = [() => instance.calendarContainer.addEventListener("focusout", onCalendarFocusOut), () => instance.calendarContainer.addEventListener("mousedown", onCalendarMouseDown)];
      instance.config.onClose = [() => instance.calendarContainer.removeEventListener("focusout", onCalendarFocusOut), () => instance.calendarContainer.removeEventListener("mousedown", onCalendarMouseDown)];
    }, [disallowPassedDates]);
    y2(() => {
      if (!flatpickrInstance || !flatpickrInstance.config) return;
      flatpickrInstance.config.onChange = [(date4) => setDate(new Date(date4)), () => setIsInputDirty(false)];
    }, [flatpickrInstance, setDate]);
    const onInputKeyDown = q2((e3) => {
      if (!flatpickrInstance) return;
      if (e3.code === "Escape") {
        flatpickrInstance.close();
      }
      if (e3.code === "ArrowDown") {
        if (isInputDirty) {
          dateInputRef.current.dispatchEvent(ENTER_KEYDOWN_EVENT);
          setIsInputDirty(false);
          setForceFocusCalendar(true);
        } else {
          focusRelevantFlatpickerDay(flatpickrInstance);
        }
        e3.preventDefault();
      }
      if (e3.code === "Enter") {
        setIsInputDirty(false);
      }
    }, [flatpickrInstance, isInputDirty]);
    const onInputFocus = q2((e3) => {
      if (!flatpickrInstance || focusScopeRef.current.contains(e3.relatedTarget) || readonly) return;
      flatpickrInstance.open();
      onDateTimeFocus(e3);
    }, [flatpickrInstance, readonly, onDateTimeFocus]);
    const onInputBlur = q2((e3) => {
      const isFalseBlur = e3.relatedTarget && e3.relatedTarget.classList.contains("flatpickr-day");
      if (isFalseBlur) return;
      if (isInputDirty) {
        dateInputRef.current.dispatchEvent(ENTER_KEYDOWN_EVENT);
        setIsInputDirty(false);
      }
      onDateTimeBlur(e3);
    }, [isInputDirty, onDateTimeBlur]);
    return u2("div", {
      class: "fjs-datetime-subsection",
      children: [u2(Label, {
        htmlFor: domId,
        label,
        collapseOnEmpty: collapseLabelOnEmpty,
        required
      }), u2(InputAdorner, {
        pre: u2(SvgCalendar, {}),
        disabled,
        readonly,
        rootRef: focusScopeRef,
        inputRef: dateInputRef,
        children: u2("div", {
          class: "fjs-datepicker",
          style: {
            width: "100%"
          },
          children: u2("input", {
            ref: dateInputRef,
            type: "text",
            id: domId,
            class: "fjs-input",
            disabled,
            readOnly: readonly,
            placeholder: getLocaleReadableDateFormat(),
            autoComplete: "off",
            onFocus: onInputFocus,
            onBlur: onInputBlur,
            onKeyDown: onInputKeyDown,
            onMouseDown: () => !flatpickrInstance.isOpen && !readonly && flatpickrInstance.open(),
            onInput: () => setIsInputDirty(true),
            "data-input": true,
            "aria-describedby": props["aria-describedby"]
          })
        })
      })]
    });
  }
  var _path$y;
  var _path2$4;
  function _extends$z() {
    return _extends$z = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$z.apply(null, arguments);
  }
  var SvgClock = function SvgClock2(props) {
    return /* @__PURE__ */ _("svg", _extends$z({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none",
      viewBox: "0 0 28 29"
    }, props), _path$y || (_path$y = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M13 14.41 18.59 20 20 18.59l-5-5.01V5h-2z"
    })), _path2$4 || (_path2$4 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M6.222 25.64A14 14 0 1 0 21.778 2.36 14 14 0 0 0 6.222 25.64M7.333 4.023a12 12 0 1 1 13.334 19.955A12 12 0 0 1 7.333 4.022Z",
      clipRule: "evenodd"
    })));
  };
  var DEFAULT_LABEL_GETTER = (value) => value;
  var NOOP = () => {
  };
  function DropdownList(props) {
    const {
      listenerElement = window,
      values: values2 = [],
      getLabel = DEFAULT_LABEL_GETTER,
      onValueSelected = NOOP,
      height = 235,
      emptyListMessage = "No results",
      initialFocusIndex = 0
    } = props;
    const [mouseControl, setMouseControl] = d2(false);
    const [focusedValueIndex, setFocusedValueIndex] = d2(initialFocusIndex);
    const [smoothScrolling, setSmoothScrolling] = d2(false);
    const dropdownContainer = A2();
    const mouseScreenPos = A2();
    const focusedItem = T2(() => values2.length ? values2[focusedValueIndex] : null, [focusedValueIndex, values2]);
    const changeFocusedValueIndex = q2((delta) => {
      setFocusedValueIndex((x3) => Math.min(Math.max(0, x3 + delta), values2.length - 1));
    }, [values2.length]);
    y2(() => {
      if (focusedValueIndex === 0) return;
      if (!focusedValueIndex || !values2.length) {
        setFocusedValueIndex(0);
      } else if (focusedValueIndex >= values2.length) {
        setFocusedValueIndex(values2.length - 1);
      }
    }, [focusedValueIndex, values2.length]);
    useKeyDownAction("ArrowUp", () => {
      if (values2.length) {
        changeFocusedValueIndex(-1);
        setMouseControl(false);
      }
    }, listenerElement);
    useKeyDownAction("ArrowDown", () => {
      if (values2.length) {
        changeFocusedValueIndex(1);
        setMouseControl(false);
      }
    }, listenerElement);
    useKeyDownAction("Enter", () => {
      if (focusedItem) {
        onValueSelected(focusedItem);
      }
    }, listenerElement);
    y2(() => {
      const individualEntries = dropdownContainer.current.children;
      if (individualEntries.length && !mouseControl) {
        const focusedEntry = individualEntries[focusedValueIndex];
        focusedEntry && focusedEntry.scrollIntoView({
          block: "nearest",
          inline: "nearest"
        });
      }
    }, [focusedValueIndex, mouseControl]);
    y2(() => {
      setSmoothScrolling(true);
    }, []);
    const onMouseMovedInKeyboardMode = (event2, valueIndex) => {
      const userMovedCursor = !mouseScreenPos.current || mouseScreenPos.current.x !== event2.screenX && mouseScreenPos.current.y !== event2.screenY;
      if (userMovedCursor) {
        mouseScreenPos.current = {
          x: event2.screenX,
          y: event2.screenY
        };
        setMouseControl(true);
        setFocusedValueIndex(valueIndex);
      }
    };
    return u2("div", {
      ref: dropdownContainer,
      tabIndex: -1,
      class: "fjs-dropdownlist",
      onMouseDown: (e3) => e3.preventDefault(),
      style: {
        maxHeight: height,
        scrollBehavior: smoothScrolling ? "smooth" : "auto"
      },
      children: [values2.length > 0 && values2.map((entry, index2) => {
        return u2("div", {
          class: (0, import_classnames.default)("fjs-dropdownlist-item", {
            focused: focusedValueIndex === index2
          }),
          onMouseMove: mouseControl ? void 0 : (e3) => onMouseMovedInKeyboardMode(e3, index2),
          onMouseEnter: mouseControl ? () => setFocusedValueIndex(index2) : void 0,
          onMouseDown: (e3) => onValueSelected(entry),
          children: getLabel(entry)
        }, entry.value);
      }), !values2.length && u2("div", {
        class: "fjs-dropdownlist-empty",
        children: emptyListMessage
      })]
    });
  }
  function Timepicker(props) {
    const {
      label,
      collapseLabelOnEmpty,
      onDateTimeBlur,
      onDateTimeFocus,
      domId,
      required,
      disabled,
      readonly,
      use24h = false,
      timeInterval,
      time,
      setTime
    } = props;
    const safeTimeInterval = T2(() => {
      const allowedIntervals = [1, 5, 10, 15, 30, 60];
      if (allowedIntervals.includes(timeInterval)) {
        return timeInterval;
      }
      return 15;
    }, [timeInterval]);
    const timeInputRef = A2();
    const [dropdownIsOpen, setDropdownIsOpen] = d2(false);
    const useDropdown = T2(() => safeTimeInterval !== 1, [safeTimeInterval]);
    const [rawValue, setRawValue] = d2("");
    y2(() => {
      if (time === null) {
        setRawValue("");
        return;
      }
      const intervalAdjustedTime = time - time % safeTimeInterval;
      setRawValue(formatTime(use24h, intervalAdjustedTime));
      if (intervalAdjustedTime != time) {
        setTime(intervalAdjustedTime);
      }
    }, [time, setTime, use24h, safeTimeInterval]);
    const propagateRawToMinute = q2((newRawValue) => {
      const localRawValue = newRawValue || rawValue;
      if (!localRawValue) {
        setTime(null);
        return;
      }
      const minutes = parseInputTime(localRawValue);
      if (!isNumber(minutes)) {
        setRawValue("");
        setTime(null);
        return;
      }
      const correctedMinutes = minutes - minutes % safeTimeInterval;
      setRawValue(formatTime(use24h, correctedMinutes));
      setTime(correctedMinutes);
    }, [rawValue, safeTimeInterval, use24h, setTime]);
    const timeOptions = T2(() => {
      const minutesInDay = 24 * 60;
      const intervalCount = Math.floor(minutesInDay / safeTimeInterval);
      return [...Array(intervalCount).keys()].map((intervalIndex) => formatTime(use24h, intervalIndex * safeTimeInterval));
    }, [safeTimeInterval, use24h]);
    const initialFocusIndex = T2(() => {
      if (!timeOptions || !safeTimeInterval) return null;
      if (time) return time / safeTimeInterval;
      const cacheTime = parseInputTime(rawValue);
      if (cacheTime) {
        const flooredCacheTime = cacheTime - cacheTime % safeTimeInterval;
        return flooredCacheTime / safeTimeInterval;
      }
      return Math.floor(timeOptions.length / 2);
    }, [rawValue, time, safeTimeInterval, timeOptions]);
    const onInputKeyDown = (e3) => {
      switch (e3.key) {
        case "ArrowUp":
          e3.preventDefault();
          break;
        case "ArrowDown":
          useDropdown && setDropdownIsOpen(true);
          e3.preventDefault();
          break;
        case "Escape":
          useDropdown && setDropdownIsOpen(false);
          break;
        case "Enter":
          !dropdownIsOpen && propagateRawToMinute();
          break;
      }
    };
    const onInputBlur = (e3) => {
      setDropdownIsOpen(false);
      propagateRawToMinute();
      onDateTimeBlur(e3);
    };
    const onInputFocus = (e3) => {
      onDateTimeFocus(e3);
      !readonly && useDropdown && setDropdownIsOpen(true);
    };
    const onDropdownValueSelected = (value) => {
      setDropdownIsOpen(false);
      propagateRawToMinute(value);
    };
    return u2("div", {
      class: "fjs-datetime-subsection",
      children: [u2(Label, {
        htmlFor: domId,
        label,
        collapseOnEmpty: collapseLabelOnEmpty,
        required
      }), u2(InputAdorner, {
        pre: u2(SvgClock, {}),
        inputRef: timeInputRef,
        disabled,
        readonly,
        children: u2("div", {
          class: "fjs-timepicker fjs-timepicker-anchor",
          children: [u2("input", {
            ref: timeInputRef,
            type: "text",
            id: domId,
            class: "fjs-input",
            value: rawValue,
            disabled,
            readOnly: readonly,
            placeholder: use24h ? "hh:mm" : "hh:mm --",
            autoComplete: "off",
            onInput: (e3) => {
              setRawValue(e3.target.value);
              useDropdown && setDropdownIsOpen(false);
            },
            onBlur: onInputBlur,
            onFocus: onInputFocus,
            onClick: () => !readonly && useDropdown && setDropdownIsOpen(true),
            onKeyDown: onInputKeyDown,
            "data-input": true,
            "aria-describedby": props["aria-describedby"]
          }), dropdownIsOpen && u2(DropdownList, {
            values: timeOptions,
            height: 150,
            onValueSelected: onDropdownValueSelected,
            listenerElement: timeInputRef.current,
            initialFocusIndex
          })]
        })
      })]
    });
  }
  var type$g = "datetime";
  function Datetime(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      onChange,
      readonly,
      value = ""
    } = props;
    const {
      description: description2,
      id: id2,
      dateLabel,
      timeLabel,
      validate: validate2 = {},
      subtype,
      use24h,
      disallowPassedDates,
      timeInterval,
      timeSerializingFormat
    } = field;
    const {
      required
    } = validate2;
    const {
      formId
    } = x2(FormContext);
    const dateTimeGroupRef = A2();
    const [dateTime, setDateTime] = d2(getNullDateTime());
    const [dateTimeUpdateRequest, setDateTimeUpdateRequest] = d2(null);
    const useDatePicker = T2(() => subtype === DATETIME_SUBTYPES.DATE || subtype === DATETIME_SUBTYPES.DATETIME, [subtype]);
    const useTimePicker = T2(() => subtype === DATETIME_SUBTYPES.TIME || subtype === DATETIME_SUBTYPES.DATETIME, [subtype]);
    const onDateTimeBlur = q2((e3) => {
      if (e3.relatedTarget && dateTimeGroupRef.current.contains(e3.relatedTarget)) {
        return;
      }
      onBlur && onBlur();
    }, [onBlur]);
    const onDateTimeFocus = q2((e3) => {
      if (e3.relatedTarget && dateTimeGroupRef.current.contains(e3.relatedTarget)) {
        return;
      }
      onFocus && onFocus();
    }, [onFocus]);
    y2(() => {
      let {
        date: date3,
        time
      } = getNullDateTime();
      switch (subtype) {
        case DATETIME_SUBTYPES.DATE: {
          date3 = typeof value === "string" ? DateTime.fromISO(value).toJSDate() : /* @__PURE__ */ new Date(NaN);
          break;
        }
        case DATETIME_SUBTYPES.TIME: {
          time = parseIsoTime(value);
          break;
        }
        case DATETIME_SUBTYPES.DATETIME: {
          date3 = new Date(Date.parse(value));
          time = isValidDate(date3) ? 60 * date3.getHours() + date3.getMinutes() : null;
          break;
        }
      }
      setDateTime({
        date: date3,
        time
      });
    }, [subtype, value]);
    const computeAndSetState = q2(({
      date: date3,
      time
    }) => {
      let newDateTimeValue = null;
      if (subtype === DATETIME_SUBTYPES.DATE && isValidDate(date3)) {
        newDateTimeValue = serializeDate(date3);
      } else if (subtype === DATETIME_SUBTYPES.TIME && isValidTime(time)) {
        newDateTimeValue = serializeTime(time, (/* @__PURE__ */ new Date()).getTimezoneOffset(), timeSerializingFormat);
      } else if (subtype === DATETIME_SUBTYPES.DATETIME && isValidDate(date3) && isValidTime(time)) {
        newDateTimeValue = serializeDateTime(date3, time, timeSerializingFormat);
      }
      if (value === newDateTimeValue) {
        return;
      }
      onChange({
        value: newDateTimeValue,
        field
      });
    }, [value, field, onChange, subtype, timeSerializingFormat]);
    y2(() => {
      if (dateTimeUpdateRequest) {
        if (dateTimeUpdateRequest.refreshOnly) {
          computeAndSetState(dateTime);
        } else {
          const newDateTime = {
            ...dateTime,
            ...dateTimeUpdateRequest
          };
          setDateTime(newDateTime);
          computeAndSetState(newDateTime);
        }
        setDateTimeUpdateRequest(null);
      }
    }, [computeAndSetState, dateTime, dateTimeUpdateRequest]);
    y2(() => {
      setDateTimeUpdateRequest({
        refreshOnly: true
      });
    }, [timeSerializingFormat]);
    const allErrors = T2(() => {
      if (required || subtype !== DATETIME_SUBTYPES.DATETIME) return errors;
      const isOnlyOneFieldSet = isValidDate(dateTime.date) && !isValidTime(dateTime.time) || !isValidDate(dateTime.date) && isValidTime(dateTime.time);
      return isOnlyOneFieldSet ? ["Date and time must both be entered.", ...errors] : errors;
    }, [required, subtype, dateTime, errors]);
    const setDate = q2((date3) => {
      setDateTimeUpdateRequest((prev) => prev ? {
        ...prev,
        date: date3
      } : {
        date: date3
      });
    }, []);
    const setTime = q2((time) => {
      setDateTimeUpdateRequest((prev) => prev ? {
        ...prev,
        time
      } : {
        time
      });
    }, []);
    const errorMessageId = allErrors.length === 0 ? void 0 : `${prefixId(id2, formId)}-error-message`;
    const descriptionId = `${prefixId(id2, formId)}-description`;
    const datePickerProps = {
      label: dateLabel,
      collapseLabelOnEmpty: !timeLabel,
      onDateTimeBlur,
      onDateTimeFocus,
      domId: `${domId}-date`,
      required,
      disabled,
      disallowPassedDates,
      date: dateTime.date,
      readonly,
      setDate,
      "aria-describedby": [descriptionId, errorMessageId].join(" ")
    };
    const timePickerProps = {
      label: timeLabel,
      collapseLabelOnEmpty: !dateLabel,
      onDateTimeBlur,
      onDateTimeFocus,
      domId: `${domId}-time`,
      required,
      disabled,
      readonly,
      use24h,
      timeInterval,
      time: dateTime.time,
      setTime,
      "aria-describedby": [descriptionId, errorMessageId].join(" ")
    };
    return u2("div", {
      class: formFieldClasses(type$g, {
        errors: allErrors,
        disabled,
        readonly
      }),
      children: [u2("div", {
        class: (0, import_classnames.default)("fjs-vertical-group"),
        ref: dateTimeGroupRef,
        children: [useDatePicker && u2(Datepicker, {
          ...datePickerProps
        }), useTimePicker && useDatePicker && u2("div", {
          class: "fjs-datetime-separator"
        }), useTimePicker && u2(Timepicker, {
          ...timePickerProps
        })]
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        errors: allErrors,
        id: errorMessageId
      })]
    });
  }
  Datetime.config = {
    type: type$g,
    keyed: true,
    name: "Date time",
    group: "basic-input",
    emptyValue: null,
    sanitizeValue: sanitizeDateTimePickerValue,
    create: (options2 = {}, isNewField) => {
      const defaults3 = {};
      set(defaults3, DATETIME_SUBTYPE_PATH, DATETIME_SUBTYPES.DATE);
      if (isNewField) {
        set(defaults3, DATE_LABEL_PATH, "Date");
      }
      return {
        ...defaults3,
        ...options2
      };
    },
    getSubheading: (field) => {
      return field.dateLabel || field.timeLabel;
    }
  };
  function Group(props) {
    const {
      field,
      domId
    } = props;
    const {
      label,
      type: type3,
      showOutline
    } = field;
    const {
      Empty: Empty2
    } = x2(FormRenderContext);
    const fullProps = {
      ...props,
      Empty: Empty2
    };
    return u2("div", {
      className: (0, import_classnames.default)(formFieldClasses(type3), "fjs-form-field-grouplike", {
        "fjs-outlined": showOutline
      }),
      role: "group",
      "aria-labelledby": domId,
      children: [u2(Label, {
        id: domId,
        label
      }), u2(ChildrenRenderer, {
        ...fullProps
      })]
    });
  }
  Group.config = {
    type: "group",
    pathed: true,
    name: "Group",
    group: "container",
    create: (options2 = {}) => ({
      label: "Group",
      components: [],
      showOutline: true,
      ...options2
    })
  };
  var type$f = "iframe";
  var DEFAULT_HEIGHT = 300;
  function IFrame(props) {
    const {
      field,
      disabled,
      readonly,
      domId
    } = props;
    const {
      height = DEFAULT_HEIGHT,
      label,
      url,
      security = {}
    } = field;
    const evaluatedUrl = useSingleLineTemplateEvaluation(url, {
      debug: true
    });
    const safeUrl = T2(() => sanitizeIFrameSource(evaluatedUrl), [evaluatedUrl]);
    const evaluatedLabel = useSingleLineTemplateEvaluation(label, {
      debug: true
    });
    const [sandbox, allow] = useSecurityAttributesMap(security);
    const [iframeRefresh, setIframeRefresh] = d2(0);
    y2(() => {
      setIframeRefresh((count) => count + 1);
    }, [sandbox, allow]);
    return u2("div", {
      class: formFieldClasses(type$f, {
        disabled,
        readonly
      }),
      children: [u2(Label, {
        htmlFor: domId,
        label: evaluatedLabel
      }), !evaluatedUrl && u2(IFramePlaceholder, {
        text: "No content to show."
      }), evaluatedUrl && safeUrl && u2("iframe", {
        src: safeUrl,
        title: evaluatedLabel,
        height,
        class: "fjs-iframe",
        id: domId,
        sandbox,
        allow
      }, "iframe-" + iframeRefresh), evaluatedUrl && !safeUrl && u2(IFramePlaceholder, {
        text: "External content couldn't be loaded."
      })]
    });
  }
  function IFramePlaceholder(props) {
    const {
      text: text2 = "iFrame"
    } = props;
    return u2("div", {
      class: "fjs-iframe-placeholder",
      children: u2("p", {
        class: "fjs-iframe-placeholder-text",
        children: text2
      })
    });
  }
  IFrame.config = {
    type: type$f,
    keyed: false,
    name: "iFrame",
    group: "container",
    create: (options2 = {}) => ({
      label: "iFrame",
      security: {
        allowScripts: true
      },
      ...options2
    })
  };
  var _path$x;
  function _extends$y() {
    return _extends$y = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$y.apply(null, arguments);
  }
  var SvgButton = function SvgButton2(props) {
    return /* @__PURE__ */ _("svg", _extends$y({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$x || (_path$x = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M45 17a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V20a3 3 0 0 1 3-3zm-9 8.889H18v2.222h18z"
    })));
  };
  var _path$w;
  function _extends$x() {
    return _extends$x = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$x.apply(null, arguments);
  }
  var SvgCheckbox = function SvgCheckbox2(props) {
    return /* @__PURE__ */ _("svg", _extends$x({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$w || (_path$w = /* @__PURE__ */ _("path", {
      d: "M34 18H20a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V20a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L25 29.17l7.59-7.59L34 23z"
    })));
  };
  var _path$v;
  function _extends$w() {
    return _extends$w = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$w.apply(null, arguments);
  }
  var SvgChecklist = function SvgChecklist2(props) {
    return /* @__PURE__ */ _("svg", _extends$w({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$v || (_path$v = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M14.35 24.75H19v4.65h-4.65zm-1.414-1.414a2 2 0 0 1 1.414-.586H19a2 2 0 0 1 2 2v4.65a2 2 0 0 1-2 2h-4.65a2 2 0 0 1-2-2v-4.65a2 2 0 0 1 .586-1.414M14.35 37.05H19v4.65h-4.65zm-1.414-1.414a2 2 0 0 1 1.414-.586H19a2 2 0 0 1 2 2v4.65a2 2 0 0 1-2 2h-4.65a2 2 0 0 1-2-2v-4.65a2 2 0 0 1 .586-1.414M14.35 12.45H19v4.65h-4.65zm-1.414-1.414a2 2 0 0 1 1.414-.586H19a2 2 0 0 1 2 2v4.65a2 2 0 0 1-2 2h-4.65a2 2 0 0 1-2-2v-4.65a2 2 0 0 1 .586-1.414m12.007 14.977a1 1 0 0 0-.293.707v.65a1 1 0 0 0 1 1h15a1 1 0 0 0 1-1v-.65a1 1 0 0 0-1-1h-15a1 1 0 0 0-.707.293m0 12.3a1 1 0 0 0-.293.707v.65a1 1 0 0 0 1 1h15a1 1 0 0 0 1-1v-.65a1 1 0 0 0-1-1h-15a1 1 0 0 0-.707.293m0-24.6a1 1 0 0 0-.293.707v.65a1 1 0 0 0 1 1h15a1 1 0 0 0 1-1v-.65a1 1 0 0 0-1-1h-15a1 1 0 0 0-.707.293",
      clipRule: "evenodd"
    })));
  };
  var _path$u;
  var _path2$3;
  var _path3;
  function _extends$v() {
    return _extends$v = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$v.apply(null, arguments);
  }
  var SvgDatetime = function SvgDatetime2(props) {
    return /* @__PURE__ */ _("svg", _extends$v({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$u || (_path$u = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M37.908 13.418h-5.004v-2.354h-1.766v2.354H21.13v-2.354h-1.766v2.354H14.36a2.07 2.07 0 0 0-2.06 2.06v23.549a2.07 2.07 0 0 0 2.06 2.06h6.77v-1.766h-6.358a.707.707 0 0 1-.706-.706V15.89c0-.39.316-.707.706-.707h4.592v2.355h1.766v-2.355h10.008v2.355h1.766v-2.355h4.592a.71.71 0 0 1 .707.707v6.358h1.765v-6.77c0-1.133-.927-2.06-2.06-2.06"
    })), _path2$3 || (_path2$3 = /* @__PURE__ */ _("path", {
      d: "m35.13 37.603 1.237-1.237-3.468-3.475v-5.926h-1.754v6.654l3.984 3.984Z"
    })), _path3 || (_path3 = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M23.08 36.962a9.678 9.678 0 1 0 17.883-7.408 9.678 9.678 0 0 0-17.882 7.408Zm4.54-10.292a7.924 7.924 0 1 1 8.805 13.177A7.924 7.924 0 0 1 27.62 26.67"
    })));
  };
  var _path$t;
  var _path2$2;
  function _extends$u() {
    return _extends$u = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$u.apply(null, arguments);
  }
  var SvgTaglist = function SvgTaglist2(props) {
    return /* @__PURE__ */ _("svg", _extends$u({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$t || (_path$t = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M45 16a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V19a3 3 0 0 1 3-3zm0 2H9a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h36a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1"
    })), _path2$2 || (_path2$2 = /* @__PURE__ */ _("path", {
      d: "M11 22a1 1 0 0 1 1-1h19a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H12a1 1 0 0 1-1-1z"
    })));
  };
  var _rect;
  var _rect2;
  var _rect3;
  function _extends$t() {
    return _extends$t = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$t.apply(null, arguments);
  }
  var SvgForm = function SvgForm2(props) {
    return /* @__PURE__ */ _("svg", _extends$t({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54
    }, props), _rect || (_rect = /* @__PURE__ */ _("rect", {
      width: 24,
      height: 4,
      x: 15,
      y: 17,
      rx: 1
    })), _rect2 || (_rect2 = /* @__PURE__ */ _("rect", {
      width: 24,
      height: 4,
      x: 15,
      y: 25,
      rx: 1
    })), _rect3 || (_rect3 = /* @__PURE__ */ _("rect", {
      width: 13,
      height: 4,
      x: 15,
      y: 33,
      rx: 1
    })));
  };
  var _path$s;
  function _extends$s() {
    return _extends$s = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$s.apply(null, arguments);
  }
  var SvgGroup = function SvgGroup2(props) {
    return /* @__PURE__ */ _("svg", _extends$s({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$s || (_path$s = /* @__PURE__ */ _("path", {
      fill: "#000",
      fillRule: "evenodd",
      d: "M4.05 42.132v1.164c0 .693.604 1.254 1.35 1.254h1.35v-2.507h-2.7v.09Zm0-2.328h2.7v-2.328h-2.7zm0-4.656h2.7V32.82h-2.7zm0-4.656h2.7v-2.328h-2.7zm0-4.656h2.7v-2.328h-2.7zm0-4.656h2.7v-2.328h-2.7zm0-4.656h2.7v-2.328h-2.7zm0-4.656v.09h2.7V9.45H5.4c-.746 0-1.35.561-1.35 1.254zm5.4-2.418v2.507h2.7V9.45zm5.4 0v2.507h2.7V9.45zm5.4 0v2.507h2.7V9.45zm5.4 0v2.507h2.7V9.45zm5.4 0v2.507h2.7V9.45zm5.4 0v2.507h2.7V9.45zm5.4 0v2.507h2.7V9.45zm5.4 0v2.507h2.7v-1.253c0-.693-.604-1.254-1.35-1.254zm2.7 4.746h-2.7v2.328h2.7zm0 4.656h-2.7v2.328h2.7zm0 4.656h-2.7v2.328h2.7zm0 4.656h-2.7v2.328h2.7zm0 4.656h-2.7v2.328h2.7zm0 4.656h-2.7v2.328h2.7zm0 4.656v-.09h-2.7v2.508h1.35c.746 0 1.35-.561 1.35-1.254zm-5.4 2.418v-2.507h-2.7v2.507zm-5.4 0v-2.507h-2.7v2.507zm-5.4 0v-2.507h-2.7v2.507zm-5.4 0v-2.507h-2.7v2.507zm-5.4 0v-2.507h-2.7v2.507zm-5.4 0v-2.507h-2.7v2.507zm-5.4 0v-2.507h-2.7v2.507z",
      clipRule: "evenodd"
    })));
  };
  var _path$r;
  function _extends$r() {
    return _extends$r = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$r.apply(null, arguments);
  }
  var SvgNumber = function SvgNumber2(props) {
    return /* @__PURE__ */ _("svg", _extends$r({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$r || (_path$r = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M45 16a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V19a3 3 0 0 1 3-3zm0 2H9a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h36a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1M35 28.444h7l-3.5 4zM35 26h7l-3.5-4z"
    })));
  };
  var _path$q;
  function _extends$q() {
    return _extends$q = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$q.apply(null, arguments);
  }
  var SvgRadio = function SvgRadio2(props) {
    return /* @__PURE__ */ _("svg", _extends$q({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$q || (_path$q = /* @__PURE__ */ _("path", {
      d: "M27 22c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5m0-5c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10m0 18a8 8 0 1 1 0-16 8 8 0 1 1 0 16"
    })));
  };
  var _path$p;
  function _extends$p() {
    return _extends$p = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$p.apply(null, arguments);
  }
  var SvgSelect = function SvgSelect2(props) {
    return /* @__PURE__ */ _("svg", _extends$p({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$p || (_path$p = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M45 16a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V19a3 3 0 0 1 3-3zm0 2H9a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h36a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1m-12 7h9l-4.5 6z"
    })));
  };
  var _path$o;
  function _extends$o() {
    return _extends$o = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$o.apply(null, arguments);
  }
  var SvgSeparator = function SvgSeparator2(props) {
    return /* @__PURE__ */ _("svg", _extends$o({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$o || (_path$o = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M26.293 16.293a1 1 0 0 1 1.414 0l4 4a1 1 0 0 1-1.414 1.414L27 18.414l-3.293 3.293a1 1 0 0 1-1.414-1.414zM9 26h36v2H9zm13.293 7.707 4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0-1.414-1.414L27 35.586l-3.293-3.293a1 1 0 0 0-1.414 1.414"
    })));
  };
  var _path$n;
  function _extends$n() {
    return _extends$n = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$n.apply(null, arguments);
  }
  var SvgSpacer = function SvgSpacer2(props) {
    return /* @__PURE__ */ _("svg", _extends$n({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$n || (_path$n = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M9 15v2h36v-2zm0 22v2h36v-2zm17.293-17.707a1 1 0 0 1 1.414 0l4 4a1 1 0 0 1-1.414 1.414L27 21.414l-3.293 3.293a1 1 0 0 1-1.414-1.414zm-4 11.414 4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0-1.414-1.414L27 32.586l-3.293-3.293a1 1 0 0 0-1.414 1.414"
    })));
  };
  var _path$m;
  function _extends$m() {
    return _extends$m = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$m.apply(null, arguments);
  }
  var SvgDynamicList = function SvgDynamicList2(props) {
    return /* @__PURE__ */ _("svg", _extends$m({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$m || (_path$m = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M2.7 43.296v1.254c0 .746.604 1.35 1.35 1.35h1.275v-1.795q.074.211.075.445v-1.254h-.075V43.2H4.05c.177 0 .347.034.502.096zm2.7-2.507v-2.507H2.7v2.507zm0-5.014v-2.507H2.7v2.507zm0-5.014v-2.507H2.7v2.507zm0-5.015V23.24H2.7v2.507h2.7Zm0-5.014v-2.507H2.7v2.507zm0-5.014V13.21H2.7v2.507zm-2.7-5.014h1.852a1.4 1.4 0 0 1-.502.096h1.275v-.096H5.4V9.45q0 .235-.075.445V8.1H4.05A1.35 1.35 0 0 0 2.7 9.45zm5.175.096h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1 0h2.55V8.1h-2.55zm5.1-2.7v1.795a1.4 1.4 0 0 1-.075-.445v1.254h.075v.096h1.275a1.4 1.4 0 0 1-.502-.096H51.3V9.45a1.35 1.35 0 0 0-1.35-1.35zm-.075 5.11v2.508h2.7V13.21zm0 5.015v2.507h2.7v-2.507zm0 5.014v2.507h2.7V23.24zm0 5.015v2.507h2.7v-2.507zm0 5.014v2.507h2.7v-2.507zm0 5.014v2.507h2.7v-2.507zm2.7 5.014h-1.852a1.4 1.4 0 0 1 .502-.096h-1.275v.096H48.6v1.254q0-.235.075-.445V45.9h1.275a1.35 1.35 0 0 0 1.35-1.35zm-5.175-.096h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zm-5.1 0h-2.55v2.7h2.55zM16.2 17.55a4.05 4.05 0 0 1 4.05 4.05v1.35A4.05 4.05 0 0 1 16.2 27h-1.35a4.05 4.05 0 0 1-4.05-4.05V21.6a4.05 4.05 0 0 1 4.05-4.05zm0 2.7h-1.35a1.35 1.35 0 0 0-1.35 1.35v1.35c0 .746.604 1.35 1.35 1.35h1.35a1.35 1.35 0 0 0 1.35-1.35V21.6a1.35 1.35 0 0 0-1.35-1.35m27 1.35a4.05 4.05 0 0 0-4.05-4.05H29.7a4.05 4.05 0 0 0-4.05 4.05v1.35A4.05 4.05 0 0 0 29.7 27h9.45a4.05 4.05 0 0 0 4.05-4.05zm-13.5-1.35h9.45c.746 0 1.35.604 1.35 1.35v1.35a1.35 1.35 0 0 1-1.35 1.35H29.7a1.35 1.35 0 0 1-1.35-1.35V21.6c0-.746.604-1.35 1.35-1.35M43.2 37.8a4.05 4.05 0 0 0-4.05-4.05H29.7a4.05 4.05 0 0 0-4.05 4.05v1.35h2.7V37.8c0-.746.604-1.35 1.35-1.35h9.45c.746 0 1.35.604 1.35 1.35v1.35h2.7zm-27-4.05a4.05 4.05 0 0 1 4.05 4.05v1.35h-2.7V37.8a1.35 1.35 0 0 0-1.35-1.35h-1.35a1.35 1.35 0 0 0-1.35 1.35v1.35h-2.7V37.8a4.05 4.05 0 0 1 4.05-4.05z",
      clipRule: "evenodd"
    })));
  };
  var _path$l;
  function _extends$l() {
    return _extends$l = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$l.apply(null, arguments);
  }
  var SvgText = function SvgText2(props) {
    return /* @__PURE__ */ _("svg", _extends$l({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$l || (_path$l = /* @__PURE__ */ _("path", {
      d: "M20.58 33.77h-3l-1.18-3.08H11l-1.1 3.08H7l5.27-13.54h2.89zm-5-5.36-1.86-5-1.83 5zM22 20.23h5.41a15.5 15.5 0 0 1 2.4.14 3.4 3.4 0 0 1 1.41.55 3.5 3.5 0 0 1 1 1.14 3 3 0 0 1 .42 1.58 3.26 3.26 0 0 1-1.91 2.94 3.63 3.63 0 0 1 1.91 1.22 3.28 3.28 0 0 1 .66 2 4 4 0 0 1-.43 1.8 3.6 3.6 0 0 1-1.09 1.4 3.9 3.9 0 0 1-1.83.65q-.69.07-3.3.09H22zm2.73 2.25v3.13h3.8a1.8 1.8 0 0 0 1.1-.49 1.4 1.4 0 0 0 .41-1 1.5 1.5 0 0 0-.35-1 1.54 1.54 0 0 0-1-.48c-.27 0-1.05-.05-2.34-.05zm0 5.39v3.62h2.57a11.5 11.5 0 0 0 1.88-.09 1.65 1.65 0 0 0 1-.54 1.6 1.6 0 0 0 .38-1.14 1.75 1.75 0 0 0-.29-1 1.7 1.7 0 0 0-.86-.62 9.3 9.3 0 0 0-2.41-.23zm19.62.92 2.65.84a5.94 5.94 0 0 1-2 3.29A5.74 5.74 0 0 1 41.38 34a5.87 5.87 0 0 1-4.44-1.84 7.1 7.1 0 0 1-1.73-5A7.43 7.43 0 0 1 37 21.87 6 6 0 0 1 41.54 20a5.64 5.64 0 0 1 4 1.47A5.33 5.33 0 0 1 47 24l-2.7.65a2.8 2.8 0 0 0-2.86-2.27A3.09 3.09 0 0 0 39 23.42a5.3 5.3 0 0 0-.93 3.5 5.62 5.62 0 0 0 .93 3.65 3 3 0 0 0 2.4 1.09 2.72 2.72 0 0 0 1.82-.66 4 4 0 0 0 1.13-2.21"
    })));
  };
  var _path$k;
  function _extends$k() {
    return _extends$k = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$k.apply(null, arguments);
  }
  var SvgHtml = function SvgHtml2(props) {
    return /* @__PURE__ */ _("svg", _extends$k({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$k || (_path$k = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M47.008 12.15c1.625 0 2.942 1.36 2.942 3.039v23.622c0 1.678-1.317 3.039-2.942 3.039H6.992c-1.625 0-2.942-1.36-2.942-3.039V15.189c0-1.678 1.317-3.039 2.942-3.039zm0 2.026H6.992c-.542 0-.98.454-.98 1.013V16.2h-.004v2.7h.003v19.911c0 .56.44 1.013.98 1.013h40.017c.542 0 .98-.453.98-1.013V18.9h.005v-2.7h-.004v-1.011c0-.56-.44-1.013-.98-1.013M14.934 26.055v-3.78h2.194v9.45h-2.194v-3.78h-3.29v3.78H9.45v-9.45h2.194v3.78zm4.388-1.89h2.194v7.56h2.193v-7.56h2.194v-1.89h-6.581zm14.26-1.89h2.193v9.45h-2.194V25.11l-1.645 3.78-1.645-3.78v6.615h-2.194v-9.45h2.194l1.645 3.78zm4.387 0h2.194v7.56h4.387v1.89h-6.581z",
      clipRule: "evenodd"
    })));
  };
  var _path$j;
  function _extends$j() {
    return _extends$j = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$j.apply(null, arguments);
  }
  var SvgExpressionField = function SvgExpressionField2(props) {
    return /* @__PURE__ */ _("svg", _extends$j({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$j || (_path$j = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      fillRule: "evenodd",
      d: "M12.78 16.2v6.75c0 1.619-.635 3.059-1.618 4.05.983.991 1.618 2.431 1.618 4.05v6.75h3.51v2.7h-3.51c-1.289 0-2.34-1.213-2.34-2.7v-6.75c0-1.487-1.051-2.7-2.34-2.7v-2.7c1.289 0 2.34-1.213 2.34-2.7V16.2c0-1.487 1.051-2.7 2.34-2.7h3.51v2.7zm30.78 0v6.75c0 1.487 1.051 2.7 2.34 2.7v2.7c-1.289 0-2.34 1.213-2.34 2.7v6.75c0 1.487-1.051 2.7-2.34 2.7h-3.51v-2.7h3.51v-6.75c0-1.619.635-3.059 1.618-4.05-.983-.991-1.618-2.431-1.618-4.05V16.2h-3.51v-2.7h3.51c1.289 0 2.34 1.213 2.34 2.7M21.8 34.531q.7-.569.959-1.758l1.788-8.34h1.585l.387-1.828h-1.585l.405-1.878h1.585l.387-1.827H25.69q-1.271 0-1.972.569-.681.569-.94 1.758l-.294 1.378H21.34l-.387 1.827h1.142l-1.898 8.841h-1.585l-.387 1.827h1.622q1.272 0 1.953-.569m7.248-7.686-3.797 4.808h2.599l2.12-3.016h.22l.885 3.016h2.599l-1.677-4.36 3.778-4.688h-2.599l-2.12 2.947h-.22l-.885-2.947h-2.599z",
      clipRule: "evenodd"
    })));
  };
  var _path$i;
  function _extends$i() {
    return _extends$i = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$i.apply(null, arguments);
  }
  var SvgTextfield = function SvgTextfield2(props) {
    return /* @__PURE__ */ _("svg", _extends$i({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$i || (_path$i = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M45 16a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V19a3 3 0 0 1 3-3zm0 2H9a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h36a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1m-32 4v10h-2V22z"
    })));
  };
  var _path$h;
  function _extends$h() {
    return _extends$h = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$h.apply(null, arguments);
  }
  var SvgTextarea = function SvgTextarea2(props) {
    return /* @__PURE__ */ _("svg", _extends$h({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$h || (_path$h = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M45 13a3 3 0 0 1 3 3v22a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V16a3 3 0 0 1 3-3zm0 2H9a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h36a1 1 0 0 0 1-1V16a1 1 0 0 0-1-1m-1.136 15.5.849.849-6.364 6.364-.849-.849zm.264 3.5.849.849-2.828 2.828-.849-.849zM13 19v10h-2V19z"
    })));
  };
  var _path$g;
  function _extends$g() {
    return _extends$g = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$g.apply(null, arguments);
  }
  var SvgIFrame = function SvgIFrame2(props) {
    return /* @__PURE__ */ _("svg", _extends$g({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$g || (_path$g = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M45.658 9.45c1.625 0 2.942 1.36 2.942 3.039V22.95h-1.961v-4.383H7.36V41.51c0 .56.44 1.013.98 1.013H27v2.026H8.342c-1.625 0-2.942-1.36-2.942-3.039V12.489c0-1.678 1.317-3.039 2.942-3.039zm0 2.026H8.342c-.542 0-.98.454-.98 1.013v4.052h39.277v-4.052c0-.56-.44-1.013-.98-1.013ZM31.05 35.775A8.77 8.77 0 0 1 39.825 27a8.77 8.77 0 0 1 8.775 8.775 8.77 8.77 0 0 1-8.775 8.775 8.77 8.77 0 0 1-8.775-8.775m12.388-.516h3.097c-.206-2.581-1.858-4.646-4.026-5.678.62 1.548.93 3.613.93 5.678Zm-5.162 2.065c.207 3.303 1.136 4.955 1.549 5.161.413-.206 1.239-1.858 1.445-5.161zm1.446-8.26c-.31.207-1.342 2.272-1.446 6.195h2.994c-.103-3.923-1.135-5.988-1.548-6.194Zm-3.51 6.195c.103-2.065.31-4.13.929-5.678-2.168 1.032-3.82 3.097-4.026 5.678zm0 2.065h-2.89c.515 2.064 1.96 3.82 3.819 4.645-.516-1.342-.826-2.994-.93-4.645Zm7.226 0q-.155 2.632-.929 4.645c1.858-.826 3.304-2.58 3.923-4.645z",
      clipRule: "evenodd"
    })));
  };
  var _path$f;
  var _path2$1;
  function _extends$f() {
    return _extends$f = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$f.apply(null, arguments);
  }
  var SvgImage = function SvgImage2(props) {
    return /* @__PURE__ */ _("svg", _extends$f({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "currentcolor"
    }, props), _path$f || (_path$f = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M34.636 21.91A3.818 3.818 0 1 1 27 21.908a3.818 3.818 0 0 1 7.636 0Zm-2 0A1.818 1.818 0 1 1 29 21.908a1.818 1.818 0 0 1 3.636 0Z",
      clipRule: "evenodd"
    })), _path2$1 || (_path2$1 = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M15 13a2 2 0 0 0-2 2v24a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V15a2 2 0 0 0-2-2zm24 2H15v12.45l4.71-4.709a1.91 1.91 0 0 1 2.702 0l6.695 6.695 2.656-1.77a1.91 1.91 0 0 1 2.411.239L39 32.73zM15 39v-8.754a1 1 0 0 0 .168-.135l5.893-5.893 6.684 6.685a1.91 1.91 0 0 0 2.41.238l2.657-1.77 6.02 6.02q.078.077.168.135V39z",
      clipRule: "evenodd"
    })));
  };
  var _path$e;
  function _extends$e() {
    return _extends$e = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$e.apply(null, arguments);
  }
  var SvgTable = function SvgTable2(props) {
    return /* @__PURE__ */ _("svg", _extends$e({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 54 54"
    }, props), _path$e || (_path$e = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      fillRule: "evenodd",
      d: "M42.545 12.273A2.455 2.455 0 0 1 45 14.727v24.546a2.455 2.455 0 0 1-2.455 2.454h-31.09A2.455 2.455 0 0 1 9 39.273V14.727a2.455 2.455 0 0 1 2.455-2.454zM27.818 40.09h14.727a.82.82 0 0 0 .819-.818v-4.91H27.818Zm-1.636-5.727v5.727H11.455a.82.82 0 0 1-.819-.818v-4.91zm1.636-1.637h15.546V27H27.818ZM26.182 27v5.727H10.636V27zm1.636-1.636h15.546v-5.728H27.818Zm-1.636-5.728v5.728H10.636v-5.728z",
      clipRule: "evenodd"
    })));
  };
  var _path$d;
  function _extends$d() {
    return _extends$d = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$d.apply(null, arguments);
  }
  var SvgFilePicker = function SvgFilePicker2(props) {
    return /* @__PURE__ */ _("svg", _extends$d({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$d || (_path$d = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      fillRule: "evenodd",
      d: "M17.55 41.175H27v2.362h-9.45a2.37 2.37 0 0 1-2.363-2.362v-28.35a2.37 2.37 0 0 1 2.363-2.363h11.813a1.07 1.07 0 0 1 .826.355l8.27 8.269a1.07 1.07 0 0 1 .353.826v5.907H36.45v-3.544h-7.088A2.37 2.37 0 0 1 27 19.912v-7.087h-9.45zm18.427-21.263-6.614-6.615v6.615zm4.253 18.664 3.308 3.308-1.654 1.653-3.308-3.307a6.35 6.35 0 0 1-3.307.945c-3.308 0-5.906-2.599-5.906-5.906 0-3.308 2.598-5.907 5.906-5.907s5.906 2.6 5.906 5.907a6.35 6.35 0 0 1-.945 3.307m-4.961-6.851c-2.008 0-3.544 1.536-3.544 3.544s1.536 3.543 3.544 3.543 3.544-1.535 3.544-3.543-1.536-3.544-3.544-3.544",
      clipRule: "evenodd"
    })));
  };
  var _path$c;
  function _extends$c() {
    return _extends$c = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$c.apply(null, arguments);
  }
  var SvgDocumentPreview = function SvgDocumentPreview2(props) {
    return /* @__PURE__ */ _("svg", _extends$c({
      xmlns: "http://www.w3.org/2000/svg",
      width: 54,
      height: 54,
      fill: "none"
    }, props), _path$c || (_path$c = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      fillRule: "evenodd",
      d: "M17.55 41.175h6.75v2.363h-6.75a2.37 2.37 0 0 1-2.363-2.363v-28.35a2.37 2.37 0 0 1 2.363-2.362h11.813a1.07 1.07 0 0 1 .826.354l8.27 8.269a1.07 1.07 0 0 1 .353.827v7.256H36.45v-4.894h-7.088A2.37 2.37 0 0 1 27 19.913v-7.088h-9.45zm18.427-21.262-6.614-6.616v6.616zm-2.212 10.564-.015-.001h-.015a8.86 8.86 0 0 0-7.926 5.656l-.003.008a.9.9 0 0 0 0 .62l.003.008a8.85 8.85 0 0 0 7.926 5.655l.015.001h.015a8.86 8.86 0 0 0 7.926-5.656l.003-.008a.9.9 0 0 0 0-.62l-.003-.008a8.85 8.85 0 0 0-7.926-5.655M33.75 40.6c-2.456 0-5.088-1.802-6.107-4.151 1.019-2.349 3.651-4.151 6.107-4.151s5.088 1.802 6.107 4.151c-1.019 2.349-3.65 4.151-6.107 4.151m0-7.593a3.443 3.443 0 1 0 0 6.885 3.443 3.443 0 0 0 0-6.886Zm-.316 1.853a1.62 1.62 0 1 1 .632 3.178 1.62 1.62 0 0 1-.632-3.178",
      clipRule: "evenodd"
    })));
  };
  var iconsByType = (type3) => {
    return {
      button: SvgButton,
      checkbox: SvgCheckbox,
      checklist: SvgChecklist,
      columns: SvgGroup,
      datetime: SvgDatetime,
      group: SvgGroup,
      iframe: SvgIFrame,
      image: SvgImage,
      number: SvgNumber,
      expression: SvgExpressionField,
      radio: SvgRadio,
      select: SvgSelect,
      separator: SvgSeparator,
      spacer: SvgSpacer,
      dynamiclist: SvgDynamicList,
      taglist: SvgTaglist,
      text: SvgText,
      html: SvgHtml,
      textfield: SvgTextfield,
      textarea: SvgTextarea,
      table: SvgTable,
      filepicker: SvgFilePicker,
      documentPreview: SvgDocumentPreview,
      default: SvgForm
    }[type3];
  };
  var type$e = "image";
  function Image2(props) {
    const {
      field
    } = props;
    const {
      alt,
      id: id2,
      source
    } = field;
    const Icon = iconsByType(field.type);
    const evaluatedImageSource = useSingleLineTemplateEvaluation(source, {
      debug: true
    });
    const safeSource = T2(() => sanitizeImageSource(evaluatedImageSource), [evaluatedImageSource]);
    const altText = useSingleLineTemplateEvaluation(alt, {
      debug: true
    });
    const {
      formId
    } = x2(FormContext);
    return u2("div", {
      class: formFieldClasses(type$e),
      children: [safeSource && u2("div", {
        class: "fjs-image-container",
        children: u2("img", {
          alt: altText,
          src: safeSource,
          class: "fjs-image",
          id: prefixId(id2, formId)
        })
      }), !safeSource && u2("div", {
        class: "fjs-image-placeholder",
        children: u2("span", {
          class: "fjs-image-placeholder-inner",
          children: u2(Icon, {
            alt: "This is an image placeholder",
            width: "32",
            height: "32",
            viewBox: "0 0 56 56"
          })
        })
      })]
    });
  }
  Image2.config = {
    type: type$e,
    keyed: false,
    name: "Image view",
    group: "presentation",
    create: (options2 = {}) => options2,
    getSubheading: (field) => field.alt
  };
  function TemplatedInputAdorner(props) {
    const {
      pre,
      post
    } = props;
    const evaluatedPre = useSingleLineTemplateEvaluation(pre, {
      debug: true
    });
    const evaluatedPost = useSingleLineTemplateEvaluation(post, {
      debug: true
    });
    return u2(InputAdorner, {
      ...props,
      pre: evaluatedPre,
      post: evaluatedPost
    });
  }
  var _path$b;
  function _extends$b() {
    return _extends$b = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$b.apply(null, arguments);
  }
  var SvgAngelDown = function SvgAngelDown2(props) {
    return /* @__PURE__ */ _("svg", _extends$b({
      xmlns: "http://www.w3.org/2000/svg",
      width: 8,
      height: 8
    }, props), _path$b || (_path$b = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      stroke: "currentColor",
      strokeWidth: 0.5,
      d: "M7.75 1.336 4 6.125.258 1.335 0 1.54l4 5.125L8 1.54Zm0 0",
      clipRule: "evenodd"
    })));
  };
  var _path$a;
  function _extends$a() {
    return _extends$a = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$a.apply(null, arguments);
  }
  var SvgAngelUp = function SvgAngelUp2(props) {
    return /* @__PURE__ */ _("svg", _extends$a({
      xmlns: "http://www.w3.org/2000/svg",
      width: 8,
      height: 8
    }, props), _path$a || (_path$a = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      stroke: "currentColor",
      strokeWidth: 0.5,
      d: "M7.75 6.664 4 1.875.258 6.665 0 6.46l4-5.125L8 6.46Zm0 0",
      clipRule: "evenodd"
    })));
  };
  function countDecimals(number2) {
    const num = big_default(number2);
    if (num.toString() === num.toFixed(0)) return 0;
    return num.toFixed().split(".")[1].length || 0;
  }
  function isValidNumber(value) {
    return (typeof value === "number" || typeof value === "string") && value !== "" && !isNaN(Number(value));
  }
  function willKeyProduceValidNumber(key, previousValue, caretIndex, selectionWidth, decimalDigits) {
    if (previousValue === "NaN") {
      return false;
    }
    previousValue = previousValue.replace(",", ".");
    const isFirstDot = !previousValue.includes(".") && (key === "." || key === ",");
    const isFirstMinus = !previousValue.includes("-") && key === "-" && caretIndex === 0;
    const keypressIsNumeric = /^[0-9]$/i.test(key);
    const dotIndex = previousValue === void 0 ? -1 : previousValue.indexOf(".");
    const overflowsDecimalSpace = typeof decimalDigits === "number" && selectionWidth === 0 && dotIndex !== -1 && previousValue.includes(".") && previousValue.split(".")[1].length >= decimalDigits && caretIndex > dotIndex;
    const keypressIsAllowedChar = keypressIsNumeric || decimalDigits !== 0 && isFirstDot || isFirstMinus;
    return keypressIsAllowedChar && !overflowsDecimalSpace;
  }
  function isNullEquivalentValue(value) {
    return value === void 0 || value === null || value === "";
  }
  var type$d = "number";
  function Numberfield(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      value,
      readonly
    } = props;
    const {
      description: description2,
      label,
      appearance = {},
      validate: validate2 = {},
      decimalDigits,
      increment: incrementValue
    } = field;
    const {
      prefixAdorner,
      suffixAdorner
    } = appearance;
    const {
      required
    } = validate2;
    const inputRef = A2();
    const [cachedValue, setCachedValue] = d2(value);
    const [displayValue, setDisplayValue] = d2(value);
    const sanitize = q2((value2) => Numberfield.config.sanitizeValue({
      value: value2,
      formField: field
    }), [field]);
    const [debouncedOnChange, flushOnChange] = useFlushDebounce(props.onChange);
    const previousCachedValue = usePrevious(value);
    if (previousCachedValue !== cachedValue) {
      debouncedOnChange({
        field,
        value: cachedValue
      });
    }
    const onInputBlur = () => {
      flushOnChange && flushOnChange();
      onBlur && onBlur();
    };
    const onInputFocus = () => {
      onFocus && onFocus();
    };
    const setValue = q2((stringValue) => {
      if (isNullEquivalentValue(stringValue)) {
        setDisplayValue("");
        setCachedValue(null);
        return;
      }
      stringValue = stringValue.replaceAll(",", ".");
      if (stringValue === "-") {
        setDisplayValue("-");
        return;
      }
      if (isNaN(Number(stringValue))) {
        setDisplayValue("NaN");
        setCachedValue(null);
        return;
      }
      setDisplayValue(stringValue);
      setCachedValue(sanitize(stringValue));
    }, [sanitize]);
    const previousValue = usePrevious(value);
    const outerValueChanged = previousValue != value;
    const outerValueEqualsCache = sanitize(value) === sanitize(cachedValue);
    if (outerValueChanged && !outerValueEqualsCache) {
      setValue(value && value.toString() || "");
    }
    const incrementAmount = T2(() => {
      if (incrementValue) return big_default(incrementValue);
      if (decimalDigits) return big_default(`1e-${decimalDigits}`);
      return big_default("1");
    }, [decimalDigits, incrementValue]);
    const increment = () => {
      if (readonly) {
        return;
      }
      const base2 = isValidNumber(cachedValue) ? big_default(cachedValue) : big_default(0);
      const stepFlooredValue = base2.minus(base2.mod(incrementAmount));
      setValue(stepFlooredValue.plus(incrementAmount).toFixed());
    };
    const decrement = () => {
      if (readonly) {
        return;
      }
      const base2 = isValidNumber(cachedValue) ? big_default(cachedValue) : big_default(0);
      const offset2 = base2.mod(incrementAmount);
      if (offset2.cmp(0) === 0) {
        setValue(base2.minus(incrementAmount).toFixed());
      } else {
        const stepFlooredValue = base2.minus(base2.mod(incrementAmount));
        setValue(stepFlooredValue.toFixed());
      }
    };
    const onKeyDown = (e3) => {
      if (displayValue === "NaN" && (e3.code === "Backspace" || e3.code === "Delete")) {
        setValue("");
        e3.preventDefault();
        return;
      }
      if (e3.code === "ArrowUp") {
        increment();
        e3.preventDefault();
        return;
      }
      if (e3.code === "ArrowDown") {
        decrement();
        e3.preventDefault();
        return;
      }
    };
    const onKeyPress = (e3) => {
      const caretIndex = inputRef.current.selectionStart;
      const selectionWidth = inputRef.current.selectionStart - inputRef.current.selectionEnd;
      const previousValue2 = inputRef.current.value;
      if (!willKeyProduceValidNumber(e3.key, previousValue2, caretIndex, selectionWidth, decimalDigits)) {
        e3.preventDefault();
      }
    };
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      class: formFieldClasses(type$d, {
        errors,
        disabled,
        readonly
      }),
      children: [u2(Label, {
        htmlFor: domId,
        label,
        required
      }), u2(TemplatedInputAdorner, {
        disabled,
        readonly,
        pre: prefixAdorner,
        post: suffixAdorner,
        children: u2("div", {
          class: (0, import_classnames.default)("fjs-vertical-group", {
            "fjs-disabled": disabled,
            "fjs-readonly": readonly
          }, {
            hasErrors: errors.length
          }),
          children: [u2("input", {
            ref: inputRef,
            class: "fjs-input",
            disabled,
            readOnly: readonly,
            id: domId,
            onKeyDown,
            onKeyPress,
            onBlur: onInputBlur,
            onFocus: onInputFocus,
            onInput: (e3) => setValue(e3.target.value, true),
            onPaste: (e3) => displayValue === "NaN" && e3.preventDefault(),
            type: "text",
            autoComplete: "off",
            step: incrementAmount,
            value: displayValue,
            "aria-describedby": [descriptionId, errorMessageId].join(" "),
            required,
            "aria-invalid": errors.length > 0
          }), u2("div", {
            class: (0, import_classnames.default)("fjs-number-arrow-container", {
              "fjs-disabled": disabled,
              "fjs-readonly": readonly
            }),
            children: [u2("button", {
              type: "button",
              class: "fjs-number-arrow-up",
              "aria-label": "Increment",
              onClick: () => increment(),
              tabIndex: -1,
              children: u2(SvgAngelUp, {})
            }), u2("div", {
              class: "fjs-number-arrow-separator"
            }), u2("button", {
              type: "button",
              class: "fjs-number-arrow-down",
              "aria-label": "Decrement",
              onClick: () => decrement(),
              tabIndex: -1,
              children: u2(SvgAngelDown, {})
            })]
          })]
        })
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Numberfield.config = {
    type: type$d,
    keyed: true,
    name: "Number",
    group: "basic-input",
    emptyValue: null,
    sanitizeValue: ({
      value,
      formField
    }) => {
      if (isNullEquivalentValue(value) || !isValidNumber(value)) return null;
      return formField.serializeToString ? value.toString() : Number(value);
    },
    create: (options2 = {}) => ({
      label: "Number",
      ...options2
    })
  };
  var type$c = "radio";
  function Radio(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      readonly,
      value
    } = props;
    const {
      description: description2,
      label,
      validate: validate2 = {}
    } = field;
    const outerDivRef = A2();
    const {
      required
    } = validate2;
    const onChange = (v4) => {
      props.onChange({
        value: v4
      });
    };
    const onRadioBlur = (e3) => {
      if (outerDivRef.current.contains(e3.relatedTarget)) {
        return;
      }
      onBlur && onBlur();
    };
    const onRadioFocus = (e3) => {
      if (outerDivRef.current.contains(e3.relatedTarget)) {
        return;
      }
      onFocus && onFocus();
    };
    const {
      loadState,
      options: options2
    } = useOptionsAsync(field);
    useCleanupSingleSelectValue({
      field,
      loadState,
      options: options2,
      value,
      onChange: props.onChange
    });
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      class: formFieldClasses(type$c, {
        errors,
        disabled,
        readonly
      }),
      ref: outerDivRef,
      children: [u2(Label, {
        label,
        required
      }), loadState == LOAD_STATES.LOADED && options2.map((option, index2) => {
        const itemDomId = `${domId}-${index2}`;
        const isChecked = (0, import_isEqual.default)(option.value, value);
        return u2("div", {
          className: (0, import_classnames.default)("fjs-inline-label", {
            "fjs-checked": isChecked
          }),
          children: [u2("input", {
            checked: isChecked,
            class: "fjs-input",
            disabled,
            readOnly: readonly,
            name: domId,
            id: itemDomId,
            type: "radio",
            onClick: () => onChange(option.value),
            onBlur: onRadioBlur,
            onFocus: onRadioFocus,
            "aria-describedby": [descriptionId, errorMessageId].join(" "),
            required,
            "aria-invalid": errors.length > 0
          }), u2(Label, {
            htmlFor: itemDomId,
            label: option.label,
            class: (0, import_classnames.default)({
              "fjs-checked": isChecked
            }),
            required: false
          })]
        }, option.value);
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Radio.config = {
    type: type$c,
    keyed: true,
    name: "Radio group",
    group: "selection",
    emptyValue: null,
    sanitizeValue: sanitizeSingleSelectValue,
    create: (options2 = {}) => ({
      label: "Radio group",
      ...createEmptyOptions(options2)
    })
  };
  var _path$9;
  function _extends$9() {
    return _extends$9 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$9.apply(null, arguments);
  }
  var SvgXMark = function SvgXMark2(props) {
    return /* @__PURE__ */ _("svg", _extends$9({
      xmlns: "http://www.w3.org/2000/svg",
      width: 8,
      height: 8
    }, props), _path$9 || (_path$9 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      stroke: "currentColor",
      strokeWidth: 0.5,
      d: "M4 3.766 7.43.336l.234.234L4.234 4l3.43 3.43-.234.234L4 4.234.57 7.664.336 7.43 3.766 4 .336.57.57.336Zm0 0",
      clipRule: "evenodd"
    })));
  };
  function SearchableSelect(props) {
    const {
      domId,
      disabled,
      errors,
      onBlur,
      onFocus,
      field,
      readonly,
      value
    } = props;
    const [filter, setFilter] = d2("");
    const [isDropdownExpanded, setIsDropdownExpanded] = d2(false);
    const [isFilterActive, setIsFilterActive] = d2(true);
    const [isEscapeClosed, setIsEscapeClose] = d2(false);
    const searchbarRef = A2();
    const eventBus = useService("eventBus");
    const {
      loadState,
      options: options2
    } = useOptionsAsync(field);
    useCleanupSingleSelectValue({
      field,
      loadState,
      options: options2,
      value,
      onChange: props.onChange
    });
    const getLabelCorrelation = useGetLabelCorrelation(options2);
    const label = T2(() => value && getLabelCorrelation(value), [value, getLabelCorrelation]);
    y2(() => {
      setFilter(label || "");
    }, [label]);
    const filteredOptions = T2(() => {
      if (loadState !== LOAD_STATES.LOADED) {
        return [];
      }
      if (!filter || !isFilterActive) {
        return options2;
      }
      return options2.filter((option) => option.label && option.value && option.label.toLowerCase().includes(filter.toLowerCase()));
    }, [filter, loadState, options2, isFilterActive]);
    const pickOption = q2((option) => {
      setFilter(option && option.label || "");
      props.onChange({
        value: option && option.value || null
      });
    }, [props]);
    const displayState = T2(() => {
      const ds = {};
      ds.componentReady = !disabled && !readonly && loadState === LOAD_STATES.LOADED;
      ds.displayCross = ds.componentReady && value !== null && value !== void 0;
      ds.displayDropdown = !disabled && !readonly && isDropdownExpanded && !isEscapeClosed;
      return ds;
    }, [disabled, isDropdownExpanded, isEscapeClosed, loadState, readonly, value]);
    const onAngelMouseDown = q2((e3) => {
      setIsEscapeClose(false);
      setIsDropdownExpanded(!isDropdownExpanded);
      const searchbar = searchbarRef.current;
      isDropdownExpanded ? searchbar.blur() : searchbar.focus();
      e3.preventDefault();
    }, [isDropdownExpanded]);
    const onInputChange = ({
      target
    }) => {
      setIsEscapeClose(false);
      setIsDropdownExpanded(true);
      setIsFilterActive(true);
      setFilter(target.value || "");
      eventBus.fire("formField.search", {
        formField: field,
        value: target.value || ""
      });
    };
    const onInputKeyDown = q2((keyDownEvent) => {
      switch (keyDownEvent.key) {
        case "ArrowUp":
          keyDownEvent.preventDefault();
          break;
        case "ArrowDown": {
          if (!isDropdownExpanded) {
            setIsDropdownExpanded(true);
            setIsFilterActive(false);
          }
          keyDownEvent.preventDefault();
          break;
        }
        case "Escape":
          setIsEscapeClose(true);
          break;
        case "Enter":
          if (isEscapeClosed) {
            setIsEscapeClose(false);
          }
          break;
      }
    }, [isDropdownExpanded, isEscapeClosed]);
    const onInputMouseDown = q2(() => {
      setIsEscapeClose(false);
      setIsDropdownExpanded(true);
      setIsFilterActive(false);
    }, []);
    const onInputFocus = q2(() => {
      setIsEscapeClose(false);
      setIsDropdownExpanded(true);
      onFocus && onFocus();
    }, [onFocus]);
    const onInputBlur = q2(() => {
      setIsDropdownExpanded(false);
      setFilter(label || "");
      onBlur && onBlur();
    }, [onBlur, label]);
    return u2(k, {
      children: [u2("div", {
        class: (0, import_classnames.default)("fjs-input-group", {
          disabled,
          readonly
        }, {
          hasErrors: errors.length
        }),
        children: [u2("input", {
          disabled,
          readOnly: readonly,
          class: "fjs-input",
          ref: searchbarRef,
          id: domId,
          onChange: onInputChange,
          type: "text",
          value: filter,
          placeholder: "Search",
          autoComplete: "off",
          onKeyDown: onInputKeyDown,
          onMouseDown: onInputMouseDown,
          onFocus: onInputFocus,
          onBlur: onInputBlur,
          "aria-describedby": props["aria-describedby"]
        }), displayState.displayCross && u2("span", {
          class: "fjs-select-cross",
          onMouseDown: (e3) => {
            pickOption(null);
            e3.preventDefault();
          },
          children: [u2(SvgXMark, {}), " "]
        }), u2("span", {
          class: "fjs-select-arrow",
          onMouseDown: (e3) => onAngelMouseDown(e3),
          children: displayState.displayDropdown ? u2(SvgAngelUp, {}) : u2(SvgAngelDown, {})
        })]
      }), u2("div", {
        class: "fjs-select-anchor",
        children: displayState.displayDropdown && u2(DropdownList, {
          values: filteredOptions,
          getLabel: (option) => option.label,
          onValueSelected: (option) => {
            pickOption(option);
            setIsDropdownExpanded(false);
          },
          listenerElement: searchbarRef.current
        })
      })]
    });
  }
  function SimpleSelect(props) {
    const {
      domId,
      disabled,
      errors,
      onBlur,
      onFocus,
      field,
      readonly,
      value
    } = props;
    const [isDropdownExpanded, setIsDropdownExpanded] = d2(false);
    const selectRef = A2();
    const inputRef = A2();
    const {
      loadState,
      options: options2
    } = useOptionsAsync(field);
    useCleanupSingleSelectValue({
      field,
      loadState,
      options: options2,
      value,
      onChange: props.onChange
    });
    const getLabelCorrelation = useGetLabelCorrelation(options2);
    const valueLabel = T2(() => value && getLabelCorrelation(value), [value, getLabelCorrelation]);
    const pickOption = q2((option) => {
      props.onChange({
        value: option && option.value || null
      });
    }, [props]);
    const displayState = T2(() => {
      const ds = {};
      ds.componentReady = !disabled && !readonly && loadState === LOAD_STATES.LOADED;
      ds.displayCross = ds.componentReady && value !== null && value !== void 0;
      ds.displayDropdown = !disabled && !readonly && isDropdownExpanded;
      return ds;
    }, [disabled, isDropdownExpanded, loadState, readonly, value]);
    const onMouseDown = q2((e3) => {
      const input = inputRef.current;
      if (disabled || !input) {
        return;
      }
      setIsDropdownExpanded(!isDropdownExpanded);
      if (isDropdownExpanded) {
        input.blur();
      } else {
        input.focus();
      }
      e3.preventDefault();
    }, [disabled, isDropdownExpanded]);
    const initialFocusIndex = T2(() => value && findIndex(options2, (option) => option.value === value) || 0, [options2, value]);
    const onInputFocus = q2(() => {
      if (!readonly) {
        setIsDropdownExpanded(true);
        onFocus && onFocus();
      }
    }, [onFocus, readonly]);
    const onInputBlur = q2(() => {
      if (!readonly) {
        setIsDropdownExpanded(false);
        onBlur && onBlur();
      }
    }, [onBlur, readonly]);
    return u2(k, {
      children: [u2("div", {
        ref: selectRef,
        class: (0, import_classnames.default)("fjs-input-group", {
          disabled,
          readonly
        }, {
          hasErrors: errors.length
        }),
        onFocus: onInputFocus,
        onBlur: onInputBlur,
        onMouseDown,
        children: [u2("div", {
          class: (0, import_classnames.default)("fjs-select-display", {
            "fjs-select-placeholder": !value
          }),
          id: `${domId}-display`,
          children: valueLabel || "Select"
        }), !disabled && u2("input", {
          ref: inputRef,
          id: domId,
          class: "fjs-select-hidden-input",
          value: valueLabel,
          onFocus: onInputFocus,
          onBlur: onInputBlur,
          "aria-describedby": props["aria-describedby"]
        }), displayState.displayCross && u2("span", {
          class: "fjs-select-cross",
          onMouseDown: (e3) => {
            pickOption(null);
            e3.stopPropagation();
          },
          children: u2(SvgXMark, {})
        }), u2("span", {
          class: "fjs-select-arrow",
          children: displayState.displayDropdown ? u2(SvgAngelUp, {}) : u2(SvgAngelDown, {})
        })]
      }), u2("div", {
        class: "fjs-select-anchor",
        children: displayState.displayDropdown && u2(DropdownList, {
          values: options2,
          getLabel: (option) => option.label,
          initialFocusIndex,
          onValueSelected: (option) => {
            pickOption(option);
            setIsDropdownExpanded(false);
          },
          listenerElement: selectRef.current
        })
      })]
    });
  }
  var type$b = "select";
  function Select(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      onChange,
      readonly,
      value
    } = props;
    const {
      description: description2,
      label,
      searchable = false,
      validate: validate2 = {}
    } = field;
    const {
      required
    } = validate2;
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    const selectProps = {
      domId,
      disabled,
      errors,
      onBlur,
      onFocus,
      field,
      value,
      onChange,
      readonly,
      required,
      "aria-invalid": errors.length > 0,
      "aria-describedby": [descriptionId, errorMessageId].join(" ")
    };
    return u2("div", {
      class: formFieldClasses(type$b, {
        errors,
        disabled,
        readonly
      }),
      onKeyDown: (event2) => {
        if (event2.key === "Enter") {
          event2.preventDefault();
          event2.stopPropagation();
        }
      },
      children: [u2(Label, {
        htmlFor: domId,
        label,
        required
      }), searchable ? u2(SearchableSelect, {
        ...selectProps
      }) : u2(SimpleSelect, {
        ...selectProps
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Select.config = {
    type: type$b,
    keyed: true,
    name: "Select",
    group: "selection",
    emptyValue: null,
    sanitizeValue: sanitizeSingleSelectValue,
    create: (options2 = {}) => ({
      label: "Select",
      ...createEmptyOptions(options2)
    })
  };
  var type$a = "separator";
  function Separator() {
    return u2("div", {
      class: formFieldClasses(type$a),
      children: u2("hr", {})
    });
  }
  Separator.config = {
    type: type$a,
    keyed: false,
    name: "Separator",
    group: "presentation",
    create: (options2 = {}) => ({
      ...options2
    })
  };
  var type$9 = "spacer";
  function Spacer(props) {
    const {
      field
    } = props;
    const {
      height = 60
    } = field;
    return u2("div", {
      class: formFieldClasses(type$9),
      style: {
        height
      }
    });
  }
  Spacer.config = {
    type: type$9,
    keyed: false,
    name: "Spacer",
    group: "presentation",
    create: (options2 = {}) => ({
      height: 60,
      ...options2
    })
  };
  function DynamicList(props) {
    const {
      field,
      domId,
      readonly
    } = props;
    const {
      label,
      type: type3,
      showOutline
    } = field;
    const {
      Empty: Empty2
    } = x2(FormRenderContext);
    const fullProps = {
      ...props,
      Empty: Empty2
    };
    return u2("div", {
      className: (0, import_classnames.default)(formFieldClasses(type3, {
        readonly
      }), "fjs-form-field-grouplike", {
        "fjs-outlined": showOutline
      }),
      role: "group",
      "aria-labelledby": domId,
      children: [u2(Label, {
        id: domId,
        label
      }), u2(ChildrenRenderer, {
        ...fullProps
      })]
    });
  }
  DynamicList.config = {
    type: "dynamiclist",
    pathed: true,
    repeatable: true,
    name: "Dynamic list",
    group: "container",
    create: (options2 = {}) => ({
      label: "Dynamic list",
      components: [],
      showOutline: true,
      isRepeating: true,
      allowAddRemove: true,
      defaultRepetitions: 1,
      ...options2
    })
  };
  function SkipLink(props) {
    const {
      className,
      label,
      onSkip
    } = props;
    const onKeyDown = q2((event2) => {
      if (event2.key === "Enter") {
        event2.preventDefault();
        event2.stopPropagation();
        onSkip();
      }
    }, [onSkip]);
    return u2("a", {
      href: "#",
      class: (0, import_classnames.default)("fjs-skip-link", className),
      onKeyDown,
      children: label
    });
  }
  var type$8 = "taglist";
  function Taglist(props) {
    const {
      disabled,
      errors = [],
      onFocus,
      domId,
      onBlur,
      field,
      readonly,
      value
    } = props;
    const {
      description: description2,
      label,
      validate: validate2 = {}
    } = field;
    const {
      required
    } = validate2;
    const [filter, setFilter] = d2("");
    const [isDropdownExpanded, setIsDropdownExpanded] = d2(false);
    const [isEscapeClosed, setIsEscapeClose] = d2(false);
    const focusScopeRef = A2();
    const inputRef = A2();
    const eventBus = useService("eventBus");
    const {
      loadState,
      options: options2
    } = useOptionsAsync(field);
    const values2 = useDeepCompareMemoize(value || []);
    useCleanupMultiSelectValue({
      field,
      loadState,
      options: options2,
      values: values2,
      onChange: props.onChange
    });
    const getLabelCorrelation = useGetLabelCorrelation(options2);
    const hasOptionsLeft = T2(() => options2.length > values2.length, [options2.length, values2.length]);
    const filteredOptions = T2(() => {
      if (loadState !== LOAD_STATES.LOADED) {
        return [];
      }
      const isValidFilteredOption = (option) => {
        const filterMatches = option.label.toLowerCase().includes(filter.toLowerCase());
        return filterMatches && !hasEqualValue(option.value, values2);
      };
      return options2.filter(isValidFilteredOption);
    }, [filter, options2, values2, loadState]);
    const selectValue = (value2) => {
      setFilter("");
      if (values2.at(-1) === value2) {
        return;
      }
      props.onChange({
        value: [...values2, value2]
      });
    };
    const deselectValue = (value2) => {
      const newValues = values2.filter((v4) => !(0, import_isEqual.default)(v4, value2));
      props.onChange({
        value: newValues
      });
    };
    const onInputChange = ({
      target
    }) => {
      setIsEscapeClose(false);
      setFilter(target.value || "");
      eventBus.fire("formField.search", {
        formField: field,
        value: target.value || ""
      });
    };
    const onInputKeyDown = (e3) => {
      switch (e3.key) {
        case "ArrowUp":
        case "ArrowDown":
          e3.preventDefault();
          break;
        case "Backspace":
          if (!filter && values2.length) {
            deselectValue(values2[values2.length - 1]);
          }
          break;
        case "Escape":
          setIsEscapeClose(true);
          break;
        case "Enter":
          if (isEscapeClosed) {
            setIsEscapeClose(false);
          }
          break;
      }
    };
    const onElementBlur = (e3) => {
      if (focusScopeRef.current.contains(e3.relatedTarget)) return;
      onBlur && onBlur();
    };
    const onElementFocus = (e3) => {
      if (focusScopeRef.current.contains(e3.relatedTarget)) return;
      onFocus && onFocus();
    };
    const onInputBlur = (e3) => {
      if (!readonly) {
        setIsDropdownExpanded(false);
        setFilter("");
      }
      onElementBlur(e3);
    };
    const onInputFocus = (e3) => {
      if (!readonly) {
        setIsDropdownExpanded(true);
      }
      onElementFocus(e3);
    };
    const onTagRemoveClick = (event2, value2) => {
      const {
        target
      } = event2;
      deselectValue(value2);
      const nextTag = target.closest(".fjs-taglist-tag").nextSibling;
      if (!nextTag) {
        inputRef.current.focus();
      }
    };
    const onSkipToSearch = () => {
      inputRef.current.focus();
    };
    const shouldDisplayDropdown = T2(() => !disabled && loadState === LOAD_STATES.LOADED && isDropdownExpanded && !isEscapeClosed, [disabled, isDropdownExpanded, isEscapeClosed, loadState]);
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      ref: focusScopeRef,
      class: formFieldClasses(type$8, {
        errors,
        disabled,
        readonly
      }),
      onKeyDown: (event2) => {
        if (event2.key === "Enter") {
          event2.stopPropagation();
          event2.preventDefault();
        }
      },
      children: [u2(Label, {
        label,
        required,
        htmlFor: domId
      }), !disabled && !readonly && !!values2.length && u2(SkipLink, {
        className: "fjs-taglist-skip-link",
        label: "Skip to search",
        onSkip: onSkipToSearch
      }), u2("div", {
        class: (0, import_classnames.default)("fjs-taglist", {
          "fjs-disabled": disabled,
          "fjs-readonly": readonly
        }),
        children: [loadState === LOAD_STATES.LOADED && u2("div", {
          class: "fjs-taglist-tags",
          children: values2.map((entry) => {
            return u2("div", {
              class: (0, import_classnames.default)("fjs-taglist-tag", {
                "fjs-disabled": disabled,
                "fjs-readonly": readonly
              }),
              onMouseDown: (e3) => e3.preventDefault(),
              children: [u2("span", {
                class: "fjs-taglist-tag-label",
                children: getLabelCorrelation(entry)
              }), !disabled && !readonly && u2("button", {
                type: "button",
                title: "Remove tag",
                class: "fjs-taglist-tag-remove",
                onFocus: onElementFocus,
                onBlur: onElementBlur,
                onClick: (event2) => onTagRemoveClick(event2, entry),
                children: u2(SvgXMark, {})
              })]
            }, entry);
          })
        }), u2("input", {
          disabled,
          readOnly: readonly,
          class: "fjs-taglist-input",
          ref: inputRef,
          id: domId,
          onChange: onInputChange,
          type: "text",
          value: filter,
          placeholder: disabled || readonly ? void 0 : "Search",
          autoComplete: "off",
          onKeyDown: onInputKeyDown,
          onMouseDown: () => setIsEscapeClose(false),
          onFocus: onInputFocus,
          onBlur: onInputBlur,
          "aria-describedby": [descriptionId, errorMessageId].join(" "),
          required,
          "aria-invalid": errors.length > 0
        })]
      }), u2("div", {
        class: "fjs-taglist-anchor",
        children: shouldDisplayDropdown && u2(DropdownList, {
          values: filteredOptions,
          getLabel: (option) => option.label,
          onValueSelected: (option) => selectValue(option.value),
          emptyListMessage: hasOptionsLeft ? "No results" : "All values selected",
          listenerElement: inputRef.current
        })
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Taglist.config = {
    type: type$8,
    keyed: true,
    name: "Tag list",
    group: "selection",
    emptyValue: [],
    sanitizeValue: sanitizeMultiSelectValue,
    create: (options2 = {}) => ({
      label: "Tag list",
      ...createEmptyOptions(options2)
    })
  };
  var NODE_TYPE_TEXT = 3;
  var NODE_TYPE_ELEMENT = 1;
  var ALLOWED_NODES = ["h1", "h2", "h3", "h4", "h5", "h6", "span", "em", "a", "p", "div", "ul", "ol", "li", "hr", "blockquote", "img", "pre", "code", "br", "strong", "table", "thead", "tbody", "tr", "th", "td"];
  var ALLOWED_ATTRIBUTES = ["align", "alt", "class", "href", "id", "name", "rel", "target", "src"];
  var ALLOWED_URI_PATTERN = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
  var ATTR_WHITESPACE_PATTERN = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
  var FORM_ELEMENT = document.createElement("form");
  function sanitizeHTML(html3) {
    const doc2 = new DOMParser().parseFromString(`<!DOCTYPE html>
<html><body><div>${html3}`, "text/html");
    doc2.normalize();
    const element = doc2.body.firstChild;
    if (element) {
      sanitizeNode(
        /** @type Element */
        element
      );
      return (
        /** @type Element */
        element.innerHTML
      );
    } else {
      return "";
    }
  }
  function sanitizeNode(node) {
    if (node.nodeType === NODE_TYPE_TEXT) {
      return;
    }
    if (node.nodeType !== NODE_TYPE_ELEMENT) {
      return node.remove();
    }
    const lcTag = node.tagName.toLowerCase();
    if (!ALLOWED_NODES.includes(lcTag)) {
      return node.remove();
    }
    const attributes = node.attributes;
    for (let i4 = attributes.length; i4--; ) {
      const attribute = attributes[i4];
      const name2 = attribute.name;
      const lcName = name2.toLowerCase();
      const value = attribute.value.trim();
      node.removeAttribute(name2);
      const valid = isValidAttribute(lcTag, lcName, value);
      if (valid) {
        node.setAttribute(name2, value);
      }
    }
    if (lcTag === "a" && node.getAttribute("target") === "_blank" && node.getAttribute("rel") !== "noopener") {
      node.setAttribute("rel", "noopener");
    }
    for (let i4 = node.childNodes.length; i4--; ) {
      sanitizeNode(
        /** @type Element */
        node.childNodes[i4]
      );
    }
  }
  function isValidAttribute(lcTag, lcName, value) {
    if (!ALLOWED_ATTRIBUTES.includes(lcName)) {
      return false;
    }
    if ((lcName === "id" || lcName === "name") && (value in document || value in FORM_ELEMENT)) {
      return false;
    }
    if (lcName === "target" && value !== "_blank") {
      return false;
    }
    if (lcName === "href" && !ALLOWED_URI_PATTERN.test(value.replace(ATTR_WHITESPACE_PATTERN, ""))) {
      return false;
    }
    return true;
  }
  var type$7 = "text";
  function Text2(props) {
    const form = useService("form");
    const {
      textLinkTarget
    } = form._getState().properties;
    const {
      field,
      disableLinks
    } = props;
    const {
      text: text2 = "",
      strict = false
    } = field;
    const markdownRenderer = useService("markdownRenderer");
    const markdown = useTemplateEvaluation(text2, {
      debug: true,
      strict
    });
    const html3 = T2(() => markdownRenderer.render(markdown), [markdownRenderer, markdown]);
    const sanitizeAndTransformLinks = q2((unsafeHtml) => {
      const html4 = sanitizeHTML(unsafeHtml);
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = html4;
      const links = tempDiv.querySelectorAll("a");
      links.forEach((link2) => {
        if (disableLinks) {
          link2.setAttribute("class", "fjs-disabled-link");
          link2.setAttribute("tabIndex", "-1");
        }
        if (textLinkTarget) {
          link2.setAttribute("target", textLinkTarget);
        }
      });
      return tempDiv.innerHTML;
    }, [disableLinks, textLinkTarget]);
    const dangerouslySetInnerHTML = useDangerousHTMLWrapper({
      html: html3,
      transform: sanitizeAndTransformLinks,
      sanitize: false,
      sanitizeStyleTags: false
    });
    return u2("div", {
      class: formFieldClasses(type$7),
      dangerouslySetInnerHTML
    });
  }
  Text2.config = {
    type: type$7,
    keyed: false,
    name: "Text view",
    group: "presentation",
    create: (options2 = {}) => ({
      text: "# Text",
      ...options2
    }),
    getSubheading: (field) => {
      textToLabel(field.text);
    }
  };
  var type$6 = "html";
  function Html(props) {
    const form = useService("form");
    const {
      textLinkTarget
    } = form._getState().properties;
    const {
      field,
      disableLinks,
      domId
    } = props;
    const {
      content: content2 = "",
      strict = false
    } = field;
    const styleScope = `${domId}-style-scope`;
    const html3 = useTemplateEvaluation(content2, {
      debug: true,
      strict,
      sanitizer: escapeHTML
    });
    const transform = q2((html4) => {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = html4;
      const links = tempDiv.querySelectorAll("a");
      links.forEach((link2) => {
        if (disableLinks) {
          link2.setAttribute("class", "fjs-disabled-link");
          link2.setAttribute("tabIndex", "-1");
        }
        if (textLinkTarget) {
          link2.setAttribute("target", textLinkTarget);
        }
      });
      wrapCSSStyles(tempDiv, `.${styleScope}`);
      return tempDiv.innerHTML;
    }, [disableLinks, styleScope, textLinkTarget]);
    const dangerouslySetInnerHTML = useDangerousHTMLWrapper({
      html: html3,
      transform,
      sanitize: true,
      sanitizeStyleTags: false
    });
    return u2("div", {
      class: (0, import_classnames.default)(formFieldClasses(type$6), styleScope),
      dangerouslySetInnerHTML
    });
  }
  Html.config = {
    type: type$6,
    keyed: false,
    name: "HTML view",
    group: "presentation",
    create: (options2 = {}) => ({
      content: "",
      ...options2
    })
  };
  var type$5 = "expression";
  function ExpressionField(props) {
    const {
      field,
      onChange,
      value
    } = props;
    const {
      computeOn,
      expression
    } = field;
    const evaluation = useExpressionEvaluation(expression);
    const evaluationMemo = useDeepCompareMemoize(evaluation);
    const eventBus = useService("eventBus");
    const expressionLoopPreventer = useService("expressionLoopPreventer");
    const sendValue = q2(() => {
      onChange && onChange({
        field,
        value: evaluationMemo,
        shouldNotRecompute: true
      });
    }, [field, evaluationMemo, onChange]);
    y2(() => {
      if (computeOn !== "change" || (0, import_lodash.isEqual)(evaluationMemo, value) || !expressionLoopPreventer.registerExpressionExecution(this)) {
        return;
      }
      sendValue();
    });
    y2(() => {
      if (computeOn === "presubmit") {
        eventBus.on("presubmit", sendValue);
        return () => eventBus.off("presubmit", sendValue);
      }
    }, [computeOn, sendValue, eventBus]);
    return null;
  }
  ExpressionField.config = {
    type: type$5,
    name: "Expression",
    group: "basic-input",
    keyed: true,
    emptyValue: null,
    escapeGridRender: true,
    create: (options2 = {}) => ({
      computeOn: "change",
      ...options2
    })
  };
  var type$4 = "textfield";
  function Textfield(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      readonly,
      value = ""
    } = props;
    const {
      description: description2,
      label,
      appearance = {},
      validate: validate2 = {}
    } = field;
    const {
      prefixAdorner,
      suffixAdorner
    } = appearance;
    const {
      required
    } = validate2;
    const [onInputChange, flushOnChange] = useFlushDebounce(({
      target
    }) => {
      props.onChange({
        value: target.value
      });
    });
    const onInputBlur = () => {
      flushOnChange && flushOnChange();
      onBlur && onBlur();
    };
    const onInputFocus = () => {
      onFocus && onFocus();
    };
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      class: formFieldClasses(type$4, {
        errors,
        disabled,
        readonly
      }),
      children: [u2(Label, {
        htmlFor: domId,
        label,
        required
      }), u2(TemplatedInputAdorner, {
        disabled,
        readonly,
        pre: prefixAdorner,
        post: suffixAdorner,
        children: u2("input", {
          class: "fjs-input",
          disabled,
          readOnly: readonly,
          id: domId,
          onInput: onInputChange,
          onBlur: onInputBlur,
          onFocus: onInputFocus,
          type: "text",
          value,
          "aria-describedby": [descriptionId, errorMessageId].join(" "),
          required,
          "aria-invalid": errors.length > 0
        })
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Textfield.config = {
    type: type$4,
    keyed: true,
    name: "Text field",
    group: "basic-input",
    emptyValue: "",
    sanitizeValue: ({
      value
    }) => {
      if (isArray(value) || isObject(value) || isNil(value)) {
        return "";
      }
      if (typeof value === "string") {
        return value.replace(/[\r\n\t]/g, " ");
      }
      return String(value);
    },
    create: (options2 = {}) => ({
      label: "Text field",
      ...options2
    })
  };
  var type$3 = "textarea";
  function Textarea(props) {
    const {
      disabled,
      errors = [],
      domId,
      onBlur,
      onFocus,
      field,
      readonly,
      value = ""
    } = props;
    const {
      description: description2,
      label,
      validate: validate2 = {}
    } = field;
    const {
      required
    } = validate2;
    const textareaRef = A2();
    const [onChange, flushOnChange] = useFlushDebounce(({
      target
    }) => {
      props.onChange({
        value: target.value
      });
    });
    const onInputBlur = () => {
      flushOnChange && flushOnChange();
      onBlur && onBlur();
    };
    const onInputFocus = () => {
      onFocus && onFocus();
    };
    const onInputChange = (event2) => {
      onChange({
        target: event2.target
      });
      autoSizeTextarea(textareaRef.current);
    };
    _2(() => {
      autoSizeTextarea(textareaRef.current);
    }, [value]);
    y2(() => {
      autoSizeTextarea(textareaRef.current);
    }, []);
    const descriptionId = `${domId}-description`;
    const errorMessageId = `${domId}-error-message`;
    return u2("div", {
      class: formFieldClasses(type$3, {
        errors,
        disabled,
        readonly
      }),
      children: [u2(Label, {
        htmlFor: domId,
        label,
        required
      }), u2("textarea", {
        class: "fjs-textarea",
        disabled,
        readOnly: readonly,
        id: domId,
        onInput: onInputChange,
        onBlur: onInputBlur,
        onFocus: onInputFocus,
        value,
        ref: textareaRef,
        "aria-describedby": [descriptionId, errorMessageId].join(" "),
        required,
        "aria-invalid": errors.length > 0
      }), u2(Description, {
        id: descriptionId,
        description: description2
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  Textarea.config = {
    type: type$3,
    keyed: true,
    name: "Text area",
    group: "basic-input",
    emptyValue: "",
    sanitizeValue: ({
      value
    }) => isArray(value) || isObject(value) || isNil(value) ? "" : String(value),
    create: (options2 = {}) => ({
      label: "Text area",
      ...options2
    })
  };
  var autoSizeTextarea = (textarea) => {
    textarea.style.height = "0px";
    const computed = window.getComputedStyle(textarea);
    const heightFromLines = () => {
      const lineHeight = parseInt(computed.getPropertyValue("line-height").replace("px", "")) || 0;
      const lines = textarea.value ? textarea.value.toString().split("\n").length : 0;
      return lines * lineHeight;
    };
    const calculatedHeight = parseInt(computed.getPropertyValue("border-top-width")) + parseInt(computed.getPropertyValue("padding-top")) + (textarea.scrollHeight || heightFromLines()) + parseInt(computed.getPropertyValue("padding-bottom")) + parseInt(computed.getPropertyValue("border-bottom-width"));
    const minHeight = 75;
    const maxHeight = 350;
    const displayHeight = Math.max(Math.min(calculatedHeight || 0, maxHeight), minHeight);
    textarea.style.height = `${displayHeight}px`;
    textarea.style.overflow = calculatedHeight > maxHeight ? "visible" : "hidden";
  };
  var _path$8;
  function _extends$8() {
    return _extends$8 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$8.apply(null, arguments);
  }
  var SvgArrowDown = function SvgArrowDown2(props) {
    return /* @__PURE__ */ _("svg", _extends$8({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32"
    }, props), _path$8 || (_path$8 = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      d: "M24.59 16.59 17 24.17V4h-2v20.17l-7.59-7.58L6 18l10 10 10-10z"
    })));
  };
  var _path$7;
  function _extends$7() {
    return _extends$7 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$7.apply(null, arguments);
  }
  var SvgArrowUp = function SvgArrowUp2(props) {
    return /* @__PURE__ */ _("svg", _extends$7({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32"
    }, props), _path$7 || (_path$7 = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      d: "M16 4 6 14l1.41 1.41L15 7.83V28h2V7.83l7.59 7.58L26 14z"
    })));
  };
  var _path$6;
  function _extends$6() {
    return _extends$6 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$6.apply(null, arguments);
  }
  var SvgCaretLeft = function SvgCaretLeft2(props) {
    return /* @__PURE__ */ _("svg", _extends$6({
      xmlns: "http://www.w3.org/2000/svg",
      xmlSpace: "preserve",
      viewBox: "0 0 32 32"
    }, props), _path$6 || (_path$6 = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      d: "m20 24-10-8 10-8z"
    })));
  };
  var _path$5;
  function _extends$5() {
    return _extends$5 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$5.apply(null, arguments);
  }
  var SvgCaretRight = function SvgCaretRight2(props) {
    return /* @__PURE__ */ _("svg", _extends$5({
      xmlns: "http://www.w3.org/2000/svg",
      xmlSpace: "preserve",
      viewBox: "0 0 32 32"
    }, props), _path$5 || (_path$5 = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      d: "m12 8 10 8-10 8z"
    })));
  };
  var type$2 = "table";
  function Table2(props) {
    const {
      field
    } = props;
    const {
      columns = [],
      columnsExpression,
      dataSource = "",
      rowCount,
      id: id2,
      label
    } = field;
    const [sortBy, setSortBy] = d2(
      /** @type {Sorting | null} */
      null
    );
    const evaluatedColumns = useEvaluatedColumns(columnsExpression || "", columns);
    const columnKeys = evaluatedColumns.map(({
      key
    }) => key);
    const evaluatedDataSource = useExpressionEvaluation(dataSource);
    const data = Array.isArray(evaluatedDataSource) ? evaluatedDataSource.filter((entry) => !isNil(entry) || typeof entry !== "object") : [];
    const sortedData = sortBy === null ? data : sortByColumn(data, sortBy.key, sortBy.direction);
    const chunkedData = isNumber(rowCount) ? chunk(sortedData, rowCount) : [sortedData];
    const [currentPage, setCurrentPage] = d2(0);
    const currentChunk = chunkedData[currentPage] || [];
    y2(() => {
      setCurrentPage(0);
    }, [rowCount, sortBy]);
    function toggleSortBy(key) {
      setSortBy((current) => {
        if (current === null || current.key !== key) {
          return {
            key,
            direction: "asc"
          };
        }
        if (current.direction === "desc") {
          return null;
        }
        return {
          key,
          direction: "desc"
        };
      });
    }
    return u2("div", {
      class: formFieldClasses(type$2),
      children: [u2(Label, {
        htmlFor: prefixId(id2),
        label
      }), u2("div", {
        class: (0, import_classnames.default)("fjs-table-middle-container", {
          "fjs-table-empty": evaluatedColumns.length === 0
        }),
        children: [evaluatedColumns.length === 0 ? "Nothing to show." : u2("div", {
          class: "fjs-table-inner-container",
          children: u2("table", {
            class: "fjs-table",
            id: prefixId(id2),
            children: [u2("thead", {
              class: "fjs-table-head",
              children: u2("tr", {
                class: "fjs-table-tr",
                children: evaluatedColumns.map(({
                  key,
                  label: label2
                }) => {
                  const displayLabel = label2 || key;
                  return u2("th", {
                    tabIndex: 0,
                    class: "fjs-table-th",
                    onClick: () => {
                      toggleSortBy(key);
                    },
                    onKeyDown: (event2) => {
                      if (["Enter", "Space"].includes(event2.code)) {
                        toggleSortBy(key);
                      }
                    },
                    "aria-label": getHeaderAriaLabel(sortBy, key, displayLabel),
                    children: u2("span", {
                      class: "fjs-table-th-label",
                      children: [displayLabel, sortBy !== null && sortBy.key === key ? u2(k, {
                        children: sortBy.direction === "asc" ? u2(SvgArrowUp, {
                          class: "fjs-table-sort-icon-asc"
                        }) : u2(SvgArrowDown, {
                          class: "fjs-table-sort-icon-desc"
                        })
                      }) : null]
                    })
                  }, key);
                })
              })
            }), currentChunk.length === 0 ? u2("tbody", {
              class: "fjs-table-body",
              children: u2("tr", {
                class: "fjs-table-tr",
                children: u2("td", {
                  class: "fjs-table-td",
                  colSpan: evaluatedColumns.length,
                  children: "Nothing to show."
                })
              })
            }) : u2("tbody", {
              class: "fjs-table-body",
              children: currentChunk.map((row, index2) => u2("tr", {
                class: "fjs-table-tr",
                children: columnKeys.map((key) => u2("td", {
                  class: "fjs-table-td",
                  children: serializeCellData(row[key])
                }, key))
              }, index2))
            })]
          })
        }), isNumber(rowCount) && chunkedData.length > 1 && evaluatedColumns.length > 0 ? u2("nav", {
          class: "fjs-table-nav",
          children: [u2("span", {
            class: "fjs-table-nav-label",
            children: [currentPage + 1, " of ", chunkedData.length]
          }), u2("button", {
            type: "button",
            class: "fjs-table-nav-button",
            onClick: () => {
              setCurrentPage((page) => Math.max(page - 1, 0));
            },
            disabled: currentPage === 0,
            "aria-label": "Previous page",
            children: u2(SvgCaretLeft, {})
          }), u2("button", {
            type: "button",
            class: "fjs-table-nav-button",
            onClick: () => {
              setCurrentPage((page) => Math.min(page + 1, chunkedData.length - 1));
            },
            disabled: currentPage >= chunkedData.length - 1,
            "aria-label": "Next page",
            children: u2(SvgCaretRight, {})
          })]
        }) : null]
      })]
    });
  }
  Table2.config = {
    type: type$2,
    keyed: false,
    name: "Table",
    group: "presentation",
    create: (options2 = {}) => {
      const {
        id: id2,
        columnsExpression,
        columns,
        rowCount,
        ...remainingOptions
      } = options2;
      if (isDefined(id2) && isNumber(rowCount)) {
        remainingOptions["rowCount"] = rowCount;
      }
      if (isString(columnsExpression)) {
        return {
          ...remainingOptions,
          id: id2,
          columnsExpression
        };
      }
      if (Array.isArray(columns) && columns.every(isColumn)) {
        return {
          ...remainingOptions,
          id: id2,
          columns
        };
      }
      return {
        ...remainingOptions,
        label: "Table",
        rowCount: 10,
        columns: [{
          label: "ID",
          key: "id"
        }, {
          label: "Name",
          key: "name"
        }, {
          label: "Date",
          key: "date"
        }]
      };
    },
    /**
     * @experimental
     *
     * A function that generates demo data for a new field on the form playground.
     * @param {Field} field
     */
    generateInitialDemoData: (field) => {
      const demoData = [{
        id: 1,
        name: "John Doe",
        date: "31.01.2023"
      }, {
        id: 2,
        name: "Erika Muller",
        date: "20.02.2023"
      }, {
        id: 3,
        name: "Dominic Leaf",
        date: "11.03.2023"
      }];
      const demoDataKeys = Object.keys(demoData[0]);
      const {
        columns,
        id: id2,
        dataSource
      } = field;
      if (!Array.isArray(columns) || columns.length === 0 || dataSource !== `=${id2}`) {
        return;
      }
      if (!columns.map(({
        key
      }) => key).every((key) => demoDataKeys.includes(key))) {
        return;
      }
      return demoData;
    }
  };
  function useEvaluatedColumns(columnsExpression, fallbackColumns) {
    const evaluation = useExpressionEvaluation(columnsExpression || "");
    return Array.isArray(evaluation) && evaluation.every(isColumn) ? evaluation : fallbackColumns;
  }
  function isColumn(column) {
    return isObject(column) && isString(column["label"]) && isString(column["key"]);
  }
  function chunk(array, size) {
    return array.reduce((chunks, item, index2) => {
      if (index2 % size === 0) {
        chunks.push([item]);
      } else {
        chunks[chunks.length - 1].push(item);
      }
      return chunks;
    }, []);
  }
  function sortByColumn(array, key, direction) {
    return [...array].sort((a3, b2) => {
      if (!isObject(a3) || !isObject(b2)) {
        return 0;
      }
      if (direction === "asc") {
        return a3[key] > b2[key] ? 1 : -1;
      }
      return a3[key] < b2[key] ? 1 : -1;
    });
  }
  function getHeaderAriaLabel(sortBy, key, label) {
    if (sortBy === null || sortBy.key !== key) {
      return `Click to sort by ${label} descending`;
    }
    if (sortBy.direction === "asc") {
      return "Click to remove sorting";
    }
    return `Click to sort by ${label} ascending`;
  }
  function serializeCellData(cellData) {
    if (cellData !== null && typeof cellData === "object") {
      return JSON.stringify(cellData);
    }
    return `${cellData || ""}`;
  }
  var FILE_PICKER_FILE_KEY_PREFIX = "files::";
  var type$1 = "filepicker";
  var ids$1 = new index_esm_default();
  var EMPTY_ARRAY$1 = [];
  function FilePicker(props) {
    const fileInputRef = A2(null);
    const fileRegistry2 = useService("fileRegistry", false);
    const {
      field,
      onChange,
      domId,
      errors = [],
      disabled,
      readonly,
      value: filesKey = ""
    } = props;
    const {
      label,
      multiple = false,
      accept = "",
      validate: validate2 = {}
    } = field;
    const evaluatedAccept = useSingleLineTemplateEvaluation(accept, {
      debug: true
    });
    const evaluatedMultiple = useBooleanExpressionEvaluation(multiple);
    const errorMessageId = `${domId}-error-message`;
    const selectedFiles = fileRegistry2 === null ? EMPTY_ARRAY$1 : fileRegistry2.getFiles(filesKey);
    y2(() => {
      if (filesKey && fileRegistry2 !== null && !fileRegistry2.hasKey(filesKey)) {
        onChange({
          value: null
        });
      }
    }, [fileRegistry2, filesKey, onChange, selectedFiles.length]);
    y2(() => {
      const data = new DataTransfer();
      selectedFiles.forEach((file) => data.items.add(file));
      fileInputRef.current.files = data.files;
    }, [selectedFiles]);
    const onFileChange = (event2) => {
      const input = (
        /** @type {HTMLInputElement} */
        event2.target
      );
      if ((input.files === null || input.files.length === 0) && filesKey !== "") {
        fileRegistry2.deleteFiles(filesKey);
        onChange({
          value: null
        });
        return;
      }
      const files = Array.from(input.files);
      const updatedFilesKey = filesKey || ids$1.nextPrefixed(FILE_PICKER_FILE_KEY_PREFIX);
      fileRegistry2.setFiles(updatedFilesKey, files);
      onChange({
        value: updatedFilesKey
      });
    };
    const isInputDisabled = disabled || readonly || fileRegistry2 === null;
    return u2("div", {
      className: formFieldClasses(type$1, {
        errors,
        disabled,
        readonly
      }),
      children: [u2(Label, {
        htmlFor: domId,
        label,
        required: validate2.required
      }), u2("input", {
        type: "file",
        className: "fjs-hidden",
        ref: fileInputRef,
        id: domId,
        name: domId,
        disabled: isInputDisabled,
        multiple: evaluatedMultiple || void 0,
        accept: evaluatedAccept || void 0,
        onChange: onFileChange,
        required: validate2.required
      }), u2("div", {
        className: "fjs-filepicker-container",
        children: [u2("button", {
          type: "button",
          disabled: isInputDisabled,
          readOnly: readonly,
          className: "fjs-button fjs-filepicker-button",
          onClick: () => {
            fileInputRef.current.click();
          },
          children: "Browse"
        }), u2("span", {
          className: "fjs-form-field-label",
          children: getSelectedFilesLabel(selectedFiles)
        })]
      }), u2(Errors, {
        id: errorMessageId,
        errors
      })]
    });
  }
  FilePicker.config = {
    type: "filepicker",
    keyed: true,
    label: "File picker",
    group: "basic-input",
    emptyValue: null,
    create: (options2 = {}) => ({
      ...options2
    })
  };
  function getSelectedFilesLabel(files) {
    if (files.length === 0) {
      return "No files selected";
    }
    if (files.length === 1) {
      return files[0].name;
    }
    return `${files.length} files selected`;
  }
  var _path$4;
  function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$4.apply(null, arguments);
  }
  var SvgDownload = function SvgDownload2(props) {
    return /* @__PURE__ */ _("svg", _extends$4({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16
    }, props), _path$4 || (_path$4 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M13 12v2H3v-2H2v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2zm0-5-.705-.705-3.795 3.79V1h-1v9.085l-3.795-3.79L3 7l5 5z"
    })), /* @__PURE__ */ _("path", {
      d: "M0 0h16v16H0z",
      style: {
        fill: "none"
      }
    }));
  };
  var type = "documentPreview";
  function DocumentPreview(props) {
    const documentEndpointBuilder = useService("documentEndpointBuilder", false);
    const {
      field,
      domId
    } = props;
    const {
      dataSource,
      maxHeight,
      label
    } = field;
    const errorMessageId = `${domId}-error-message`;
    const data = useValidDocumentData(dataSource || "");
    const evaluatedLabel = useSingleLineTemplateEvaluation(label, {
      debug: true
    });
    return u2("div", {
      class: formFieldClasses(type),
      children: [u2(Label, {
        htmlFor: domId,
        label: evaluatedLabel
      }), u2("div", {
        class: `fjs-${type}-document-container`,
        id: domId,
        children: data.map((document2, index2) => {
          const finalEndpoint = tryCatch(() => documentEndpointBuilder?.buildUrl(document2)) ?? document2.endpoint;
          return isValidDocumentEndpoint(finalEndpoint) ? u2(DocumentRenderer, {
            documentMetadata: document2,
            endpoint: finalEndpoint,
            maxHeight,
            domId: `${domId}-${index2}`
          }, document2.documentId) : null;
        })
      }), u2(Errors, {
        id: errorMessageId,
        errors: getErrors({
          dataSource
        })
      })]
    });
  }
  DocumentPreview.config = {
    type,
    keyed: false,
    group: "presentation",
    name: "Document preview",
    create: (options2 = {}) => ({
      label: "Document preview",
      ...options2
    })
  };
  function getErrors(options2) {
    const {
      dataSource
    } = options2;
    let errors = [];
    if (!isString(dataSource) || dataSource.length < 1) {
      errors.push("Document reference is not defined.");
    }
    return errors;
  }
  function isValidDocumentEndpoint(endpoint) {
    return typeof endpoint === "string" && URL.canParse(endpoint);
  }
  function isValidDocument(document2) {
    return typeof document2 === "object" && document2 !== null && "documentId" in document2 && "metadata" in document2 && typeof document2.metadata === "object" && "fileName" in document2.metadata;
  }
  function useValidDocumentData(dataSource) {
    const data = useExpressionEvaluation(dataSource);
    if (!Array.isArray(data)) {
      return [];
    }
    return data.filter(isValidDocument);
  }
  function PdfRenderer(props) {
    const {
      url,
      onError,
      errorMessageId
    } = props;
    const [pdfObjectUrl, setPdfObjectUrl] = d2(null);
    const [hasError, setHasError] = d2(false);
    y2(() => {
      let objectUrl = null;
      const fetchPdf = async () => {
        try {
          const response = await fetch(url);
          if (!response.ok) {
            setHasError(true);
            onError();
            return;
          }
          const blob = await response.blob();
          objectUrl = URL.createObjectURL(blob);
          setPdfObjectUrl(objectUrl);
        } catch {
          setHasError(true);
          onError();
        }
      };
      fetchPdf();
      return () => {
        if (objectUrl) {
          URL.revokeObjectURL(objectUrl);
        }
      };
    }, [url, onError]);
    return u2(k, {
      children: [pdfObjectUrl !== null ? u2("embed", {
        src: pdfObjectUrl,
        type: "application/pdf",
        class: `fjs-${type}-pdf-viewer`
      }) : null, hasError ? u2(Errors, {
        id: errorMessageId,
        errors: ["Unable to download document"]
      }) : null]
    });
  }
  function DocumentRenderer(props) {
    const {
      documentMetadata,
      endpoint,
      maxHeight,
      domId
    } = props;
    const {
      metadata
    } = documentMetadata;
    const [hasError, setHasError] = d2(false);
    const ref = A2(null);
    const isInViewport = useInViewport(ref);
    const singleDocumentContainerClassName = `fjs-${type}-single-document-container`;
    const errorMessageId = `${domId}-error-message`;
    const errorMessage = "Unable to download document";
    const isContentTypePresent = typeof metadata.contentType === "string";
    if (isContentTypePresent && metadata.contentType.toLowerCase().startsWith("image/") && isInViewport) {
      return u2("div", {
        class: singleDocumentContainerClassName,
        style: {
          maxHeight
        },
        "aria-describedby": hasError ? errorMessageId : void 0,
        children: [u2("img", {
          src: endpoint,
          alt: metadata.fileName,
          class: `fjs-${type}-image`
        }), u2(DownloadButton, {
          endpoint,
          fileName: metadata.fileName,
          onDownloadError: () => {
            setHasError(true);
          }
        }), hasError ? u2(Errors, {
          id: errorMessageId,
          errors: [errorMessage]
        }) : null]
      });
    }
    if (isContentTypePresent && metadata.contentType.toLowerCase() === "application/pdf" && isInViewport) {
      return u2("div", {
        class: singleDocumentContainerClassName,
        style: {
          maxHeight
        },
        "aria-describedby": hasError ? errorMessageId : void 0,
        children: u2(PdfRenderer, {
          url: endpoint,
          fileName: metadata.fileName,
          onError: () => setHasError(true),
          errorMessageId
        })
      });
    }
    return u2("div", {
      class: (0, import_classnames.default)(`fjs-${type}-non-preview-item`, `fjs-${type}-single-document-container`),
      ref,
      "aria-describedby": hasError ? errorMessageId : void 0,
      children: [u2("div", {
        children: [u2("div", {
          class: "fjs-document-preview-title",
          children: metadata.fileName
        }), hasError ? u2(Errors, {
          id: errorMessageId,
          errors: [errorMessage]
        }) : null]
      }), u2(DownloadButton, {
        endpoint,
        fileName: metadata.fileName,
        onDownloadError: () => {
          setHasError(true);
        }
      })]
    });
  }
  function DownloadButton(props) {
    const {
      endpoint,
      fileName,
      onDownloadError
    } = props;
    const handleDownload = async () => {
      try {
        const response = await fetch(endpoint);
        if (!response.ok) {
          onDownloadError();
          return;
        }
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const link2 = document.createElement("a");
        link2.href = url;
        link2.download = fileName;
        link2.click();
        window.URL.revokeObjectURL(url);
      } catch {
        onDownloadError();
      }
    };
    return u2("button", {
      type: "button",
      onClick: handleDownload,
      class: (0, import_classnames.default)(`fjs-${type}-download-button`),
      "aria-label": `Download ${fileName}`,
      children: u2(SvgDownload, {})
    });
  }
  function useInViewport(ref) {
    const [isInViewport, setIsInViewport] = d2(false);
    y2(() => {
      const container = ref.current;
      if (!container) {
        return;
      }
      const observer = new IntersectionObserver(([entry]) => {
        if (entry.isIntersecting) {
          setIsInViewport(true);
        }
      }, {
        threshold: 0
      });
      observer.observe(container);
      return () => {
        if (container) {
          observer.unobserve(container);
        }
      };
    }, [ref]);
    return isInViewport;
  }
  var tryCatch = (fn4) => {
    try {
      return fn4();
    } catch (error2) {
      console.error(error2);
      return null;
    }
  };
  function Logo() {
    return u2("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 14.02 5.57",
      width: "53",
      height: "21",
      style: "vertical-align:middle",
      children: [u2("path", {
        fill: "currentColor",
        d: "M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"
      }), u2("path", {
        fill: "currentColor",
        d: "M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"
      })]
    });
  }
  function Lightbox(props) {
    const {
      open
    } = props;
    if (!open) {
      return null;
    }
    return u2("div", {
      class: "fjs-powered-by-lightbox",
      style: "z-index: 100; position: fixed; top: 0; left: 0;right: 0; bottom: 0",
      children: [u2("div", {
        class: "backdrop",
        style: "width: 100%; height: 100%; background: rgba(40 40 40 / 20%)",
        onClick: props.onBackdropClick
      }), u2("div", {
        class: "notice",
        style: "position: absolute; left: 50%; top: 40%; transform: translate(-50%); width: 260px; padding: 10px; background: white; box-shadow: 0  1px 4px rgba(0 0 0 / 30%); font-family: Helvetica, Arial, sans-serif; font-size: 14px; display: flex; line-height: 1.3",
        children: [u2("a", {
          href: "https://bpmn.io",
          target: "_blank",
          rel: "noopener noreferrer",
          style: "margin: 15px 20px 15px 10px; align-self: center; color: var(--cds-icon-primary, #404040)",
          children: u2(Logo, {})
        }), u2("span", {
          children: ["Web-based tooling for BPMN, DMN, and forms powered by", " ", u2("a", {
            href: "https://bpmn.io",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "bpmn.io"
          }), "."]
        })]
      })]
    });
  }
  function Link(props) {
    return u2("div", {
      class: "fjs-powered-by fjs-form-field",
      style: "text-align: right",
      children: u2("a", {
        href: "https://bpmn.io",
        target: "_blank",
        rel: "noopener noreferrer",
        class: "fjs-powered-by-link",
        title: "Powered by bpmn.io",
        style: "color: var(--cds-text-primary, #404040)",
        onClick: props.onClick,
        children: u2(Logo, {})
      })
    });
  }
  function PoweredBy(props) {
    const [open, setOpen] = d2(false);
    function toggleOpen(open2) {
      return (event2) => {
        event2.preventDefault();
        setOpen(open2);
      };
    }
    return u2(k, {
      children: [$2(u2(Lightbox, {
        open,
        onBackdropClick: toggleOpen(false)
      }), document.body), u2(Link, {
        onClick: toggleOpen(true)
      })]
    });
  }
  var noop = () => {
  };
  function FormComponent(props) {
    const form = useService("form");
    const {
      schema,
      properties
    } = form._getState();
    const {
      ariaLabel
    } = properties;
    const {
      onSubmit = noop,
      onReset = noop,
      onChange = noop
    } = props;
    const handleSubmit = (event2) => {
      event2.preventDefault();
      onSubmit();
    };
    const handleReset = (event2) => {
      event2.preventDefault();
      onReset();
    };
    const filteredFormData = useFilteredFormData();
    const localExpressionContext = T2(() => ({
      data: filteredFormData,
      parent: null,
      this: filteredFormData,
      i: []
    }), [filteredFormData]);
    return u2("form", {
      class: "fjs-form",
      onSubmit: handleSubmit,
      onReset: handleReset,
      "aria-label": ariaLabel,
      noValidate: true,
      children: [u2(LocalExpressionContext.Provider, {
        value: localExpressionContext,
        children: u2(FormField, {
          field: schema,
          onChange
        })
      }), u2(PoweredBy, {})]
    });
  }
  var formFields = [
    /* Input */
    Textfield,
    Textarea,
    Numberfield,
    Datetime,
    ExpressionField,
    FilePicker,
    /* Selection */
    Checkbox,
    Checklist,
    Radio,
    Select,
    Taglist,
    /* Presentation */
    Text2,
    Image2,
    Table2,
    Html,
    DocumentPreview,
    Spacer,
    Separator,
    /* Containers */
    Group,
    DynamicList,
    IFrame,
    /* Other */
    Button,
    Default
  ];
  var FormFields = class {
    constructor() {
      this._formFields = {};
      formFields.forEach((formField) => {
        this.register(formField.config.type, formField);
      });
    }
    register(type3, formField) {
      this._formFields[type3] = formField;
    }
    get(type3) {
      return this._formFields[type3];
    }
  };
  var EXPRESSION_PROPERTIES = ["alt", "appearance.prefixAdorner", "appearance.suffixAdorner", "conditional.hide", "description", "label", "source", "readonly", "text", "validate.min", "validate.max", "validate.minLength", "validate.maxLength", "valuesExpression", "url", "dataSource", "columnsExpression", "expression", "multiple", "accept", "title"];
  var TEMPLATE_PROPERTIES = ["alt", "appearance.prefixAdorner", "appearance.suffixAdorner", "description", "label", "source", "text", "content", "url", "title"];
  function getSchemaVariables(schema, options2 = {}) {
    const {
      formFields: formFields2 = new FormFields(),
      expressionLanguage: expressionLanguage2 = new FeelExpressionLanguage(null),
      templating = new FeelersTemplating(),
      inputs = true,
      outputs = true
    } = options2;
    if (!schema.components) {
      return [];
    }
    const getAllComponents = (node) => {
      const components = [];
      if (node.components) {
        node.components.forEach((component) => {
          components.push(component);
          components.push(...getAllComponents(component));
        });
      }
      return components;
    };
    const variables = getAllComponents(schema).reduce((variables2, component) => {
      const {
        valuesKey
      } = component;
      if (inputs) {
        if (valuesKey) {
          variables2 = [...variables2, valuesKey];
        }
        EXPRESSION_PROPERTIES.forEach((prop) => {
          const property = get(component, prop.split("."));
          if (property && expressionLanguage2.isExpression(property)) {
            const expressionVariables = expressionLanguage2.getVariableNames(property, {
              type: "expression"
            });
            variables2 = [...variables2, ...expressionVariables];
          }
        });
        TEMPLATE_PROPERTIES.forEach((prop) => {
          const property = get(component, prop.split("."));
          if (property && !expressionLanguage2.isExpression(property) && templating.isTemplate(property)) {
            const templateVariables = templating.getVariableNames(property);
            variables2 = [...variables2, ...templateVariables];
          }
        });
      }
      return variables2.filter((variable) => typeof variable === "string");
    }, []);
    const getBindingVariables = (node) => {
      const bindingVariable = [];
      const formField = formFields2.get(node.type);
      if (formField && formField.config.keyed && node.key) {
        return [node.key.split(".")[0]];
      } else if (formField && formField.config.pathed && node.path) {
        return [node.path.split(".")[0]];
      } else if (node.components) {
        node.components.forEach((component) => {
          bindingVariable.push(...getBindingVariables(component));
        });
      }
      return bindingVariable;
    };
    if (inputs || outputs) {
      variables.push(...getBindingVariables(schema));
    }
    return Array.from(new Set(variables));
  }
  var getAncestryList = (formFieldId, formFieldRegistry) => {
    const ids3 = [];
    let currentFormField = formFieldRegistry.get(formFieldId);
    while (currentFormField) {
      ids3.push(currentFormField.id);
      currentFormField = formFieldRegistry.get(currentFormField._parent);
    }
    return ids3;
  };
  var ConditionChecker = class {
    constructor(formFieldRegistry, pathRegistry, eventBus) {
      this._formFieldRegistry = formFieldRegistry;
      this._pathRegistry = pathRegistry;
      this._eventBus = eventBus;
    }
    /**
     * For given data, remove properties based on condition.
     *
     * @param {Object<string, any>} data
     * @param {Object<string, any>} contextData
     * @param {Object} [options]
     * @param {Function} [options.getFilterPath]
     * @param {boolean} [options.leafNodeDeletionOnly]
     */
    applyConditions(data, contextData = {}, options2 = {}) {
      const workingData = clone4(data);
      const {
        getFilterPath = (field, indexes) => this._pathRegistry.getValuePath(field, {
          indexes
        })
      } = options2;
      const _applyConditionsWithinScope = (rootField, scopeContext, startHidden = false) => {
        const {
          indexes = {},
          expressionIndexes = [],
          scopeData = contextData,
          parentScopeData = null
        } = scopeContext;
        this._pathRegistry.executeRecursivelyOnFields(rootField, ({
          field,
          isClosed,
          isRepeatable,
          context
        }) => {
          const {
            conditional,
            components,
            id: id2
          } = field;
          const localExpressionContext = buildExpressionContext({
            this: scopeData,
            data: contextData,
            i: expressionIndexes,
            parent: parentScopeData
          });
          context.isHidden = startHidden || context.isHidden || conditional && this._checkHideCondition(conditional, localExpressionContext);
          if (isRepeatable && !context.isHidden) {
            context.preventRecursion = true;
            const repeaterValuePath = this._pathRegistry.getValuePath(field, {
              indexes
            });
            const repeaterValue = get(contextData, repeaterValuePath);
            if (!Array.isArray(repeaterValue) || !repeaterValue.length || !Array.isArray(components) || !components.length) {
              return;
            }
            for (let i4 = 0; i4 < repeaterValue.length; i4++) {
              const newScopeContext = {
                indexes: {
                  ...indexes,
                  [id2]: i4
                },
                expressionIndexes: [...expressionIndexes, i4 + 1],
                scopeData: repeaterValue[i4],
                parentScopeData: scopeData
              };
              components.forEach((component) => {
                _applyConditionsWithinScope(component, newScopeContext, context.isHidden);
              });
            }
          }
          if (context.isHidden && isRepeatable) {
            context.preventRecursion = true;
            this._eventBus.fire("conditionChecker.remove", {
              item: {
                [field.key]: get(workingData, getFilterPath(field, indexes))
              }
            });
            this._cleanlyClearDataAtPath(getFilterPath(field, indexes), workingData);
          }
          if (context.isHidden && isClosed) {
            this._eventBus.fire("conditionChecker.remove", {
              item: {
                [field.key]: get(workingData, getFilterPath(field, indexes))
              }
            });
            this._cleanlyClearDataAtPath(getFilterPath(field, indexes), workingData);
          }
        });
      };
      const form = this._formFieldRegistry.getForm();
      if (!form) {
        throw new Error("form field registry has no form");
      }
      _applyConditionsWithinScope(form, {
        scopeData: contextData
      });
      return workingData;
    }
    /**
     * Check if given condition is met. Returns null for invalid/missing conditions.
     *
     * @param {string} condition
     * @param {import('../../types').Data} [data]
     *
     * @returns {boolean|null}
     */
    check(condition, data = {}) {
      if (!condition) {
        return null;
      }
      if (!isString(condition) || !condition.startsWith("=")) {
        return null;
      }
      try {
        const result = unaryTest(condition.slice(1), data);
        return result;
      } catch (error2) {
        this._eventBus.fire("error", {
          error: error2
        });
        return null;
      }
    }
    /**
     * Check if hide condition is met.
     *
     * @param {Condition} condition
     * @param {Object<string, any>} data
     * @returns {boolean}
     */
    _checkHideCondition(condition, data) {
      if (!condition.hide) {
        return false;
      }
      const result = this.check(condition.hide, data);
      return result === true;
    }
    _cleanlyClearDataAtPath(valuePath, obj) {
      const workingValuePath = [...valuePath];
      let recurse = false;
      do {
        set(obj, workingValuePath, void 0);
        workingValuePath.pop();
        const parentObject = get(obj, workingValuePath);
        recurse = !!workingValuePath.length && (this._isEmptyObject(parentObject) || this._isEmptyArray(parentObject));
      } while (recurse);
    }
    _isEmptyObject(parentObject) {
      return isObject(parentObject) && !values(parentObject).length;
    }
    _isEmptyArray(parentObject) {
      return Array.isArray(parentObject) && (!parentObject.length || parentObject.every((item) => item === void 0));
    }
  };
  ConditionChecker.$inject = ["formFieldRegistry", "pathRegistry", "eventBus"];
  var ExpressionLoopPreventer = class {
    constructor(eventBus) {
      this._computedExpressions = [];
      eventBus.on("field.updated", ({
        shouldNotRecompute
      }) => {
        if (shouldNotRecompute) {
          return;
        }
        this.reset();
      });
      eventBus.on("import.done", this.reset.bind(this));
      eventBus.on("reset", this.reset.bind(this));
    }
    /**
     * Checks if the expression field has already been computed, and registers it if not.
     *
     * @param {any} expressionField
     * @returns {boolean} - whether the expression field has already been computed within the current cycle
     */
    registerExpressionExecution(expressionField) {
      if (this._computedExpressions.includes(expressionField)) {
        return false;
      }
      this._computedExpressions.push(expressionField);
      return true;
    }
    /**
     * Resets the list of computed expressions.
     */
    reset() {
      this._computedExpressions = [];
    }
  };
  ExpressionLoopPreventer.$inject = ["eventBus"];
  var MarkdownRenderer = class {
    /**
     * Render markdown to HTML.
     *
     * @param {string} markdown - The markdown to render
     *
     * @returns {string} HTML
     */
    render(markdown) {
      return marked.parse(markdown, {
        gfm: true,
        breaks: true
      });
    }
  };
  MarkdownRenderer.$inject = [];
  var MarkdownRendererModule = {
    __init__: ["markdownRenderer"],
    markdownRenderer: ["type", MarkdownRenderer]
  };
  function CommandStack(eventBus, injector) {
    this._handlerMap = {};
    this._stack = [];
    this._stackIdx = -1;
    this._currentExecution = {
      actions: [],
      dirty: [],
      trigger: null
    };
    this._injector = injector;
    this._eventBus = eventBus;
    this._uid = 1;
    eventBus.on(["diagram.destroy", "diagram.clear"], function() {
      this.clear(false);
    }, this);
  }
  CommandStack.$inject = ["eventBus", "injector"];
  CommandStack.prototype.execute = function(command2, context) {
    if (!command2) {
      throw new Error("command required");
    }
    this._currentExecution.trigger = "execute";
    const action = {
      command: command2,
      context
    };
    this._pushAction(action);
    this._internalExecute(action);
    this._popAction();
  };
  CommandStack.prototype.canExecute = function(command2, context) {
    const action = {
      command: command2,
      context
    };
    const handler = this._getHandler(command2);
    let result = this._fire(command2, "canExecute", action);
    if (result === void 0) {
      if (!handler) {
        return false;
      }
      if (handler.canExecute) {
        result = handler.canExecute(context);
      }
    }
    return result;
  };
  CommandStack.prototype.clear = function(emit) {
    this._stack.length = 0;
    this._stackIdx = -1;
    if (emit !== false) {
      this._fire("changed", {
        trigger: "clear"
      });
    }
  };
  CommandStack.prototype.undo = function() {
    let action = this._getUndoAction(), next;
    if (action) {
      this._currentExecution.trigger = "undo";
      this._pushAction(action);
      while (action) {
        this._internalUndo(action);
        next = this._getUndoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };
  CommandStack.prototype.redo = function() {
    let action = this._getRedoAction(), next;
    if (action) {
      this._currentExecution.trigger = "redo";
      this._pushAction(action);
      while (action) {
        this._internalExecute(action, true);
        next = this._getRedoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };
  CommandStack.prototype.register = function(command2, handler) {
    this._setHandler(command2, handler);
  };
  CommandStack.prototype.registerHandler = function(command2, handlerCls) {
    if (!command2 || !handlerCls) {
      throw new Error("command and handlerCls must be defined");
    }
    const handler = this._injector.instantiate(handlerCls);
    this.register(command2, handler);
  };
  CommandStack.prototype.canUndo = function() {
    return !!this._getUndoAction();
  };
  CommandStack.prototype.canRedo = function() {
    return !!this._getRedoAction();
  };
  CommandStack.prototype._getRedoAction = function() {
    return this._stack[this._stackIdx + 1];
  };
  CommandStack.prototype._getUndoAction = function() {
    return this._stack[this._stackIdx];
  };
  CommandStack.prototype._internalUndo = function(action) {
    const command2 = action.command, context = action.context;
    const handler = this._getHandler(command2);
    this._atomicDo(() => {
      this._fire(command2, "revert", action);
      if (handler.revert) {
        this._markDirty(handler.revert(context));
      }
      this._revertedAction(action);
      this._fire(command2, "reverted", action);
    });
  };
  CommandStack.prototype._fire = function(command2, qualifier, event2) {
    if (arguments.length < 3) {
      event2 = qualifier;
      qualifier = null;
    }
    const names = qualifier ? [command2 + "." + qualifier, qualifier] : [command2];
    let result;
    event2 = this._eventBus.createEvent(event2);
    for (const name2 of names) {
      result = this._eventBus.fire("commandStack." + name2, event2);
      if (event2.cancelBubble) {
        break;
      }
    }
    return result;
  };
  CommandStack.prototype._createId = function() {
    return this._uid++;
  };
  CommandStack.prototype._atomicDo = function(fn4) {
    const execution = this._currentExecution;
    execution.atomic = true;
    try {
      fn4();
    } finally {
      execution.atomic = false;
    }
  };
  CommandStack.prototype._internalExecute = function(action, redo) {
    const command2 = action.command, context = action.context;
    const handler = this._getHandler(command2);
    if (!handler) {
      throw new Error("no command handler registered for <" + command2 + ">");
    }
    this._pushAction(action);
    if (!redo) {
      this._fire(command2, "preExecute", action);
      if (handler.preExecute) {
        handler.preExecute(context);
      }
      this._fire(command2, "preExecuted", action);
    }
    this._atomicDo(() => {
      this._fire(command2, "execute", action);
      if (handler.execute) {
        this._markDirty(handler.execute(context));
      }
      this._executedAction(action, redo);
      this._fire(command2, "executed", action);
    });
    if (!redo) {
      this._fire(command2, "postExecute", action);
      if (handler.postExecute) {
        handler.postExecute(context);
      }
      this._fire(command2, "postExecuted", action);
    }
    this._popAction();
  };
  CommandStack.prototype._pushAction = function(action) {
    const execution = this._currentExecution, actions = execution.actions;
    const baseAction = actions[0];
    if (execution.atomic) {
      throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
    }
    if (!action.id) {
      action.id = baseAction && baseAction.id || this._createId();
    }
    actions.push(action);
  };
  CommandStack.prototype._popAction = function() {
    const execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
    actions.pop();
    if (!actions.length) {
      this._eventBus.fire("elements.changed", {
        elements: uniqueBy("id", dirty.reverse())
      });
      dirty.length = 0;
      this._fire("changed", {
        trigger
      });
      execution.trigger = null;
    }
  };
  CommandStack.prototype._markDirty = function(elements) {
    const execution = this._currentExecution;
    if (!elements) {
      return;
    }
    elements = isArray(elements) ? elements : [elements];
    execution.dirty = execution.dirty.concat(elements);
  };
  CommandStack.prototype._executedAction = function(action, redo) {
    const stackIdx = ++this._stackIdx;
    if (!redo) {
      this._stack.splice(stackIdx, this._stack.length, action);
    }
  };
  CommandStack.prototype._revertedAction = function(action) {
    this._stackIdx--;
  };
  CommandStack.prototype._getHandler = function(command2) {
    return this._handlerMap[command2];
  };
  CommandStack.prototype._setHandler = function(command2, handler) {
    if (!command2 || !handler) {
      throw new Error("command and handler required");
    }
    if (this._handlerMap[command2]) {
      throw new Error("overriding handler for command <" + command2 + ">");
    }
    this._handlerMap[command2] = handler;
  };
  var UpdateFieldValidationHandler = class {
    constructor(form, validator) {
      this._form = form;
      this._validator = validator;
    }
    execute(context) {
      const {
        field,
        value,
        indexes
      } = context;
      const {
        errors
      } = this._form._getState();
      context.oldErrors = clone4(errors);
      const fieldErrors = this._validator.validateField(field, value);
      const updatedErrors = set(errors, [field.id, ...Object.values(indexes || {})], fieldErrors.length ? fieldErrors : void 0);
      this._form._setState({
        errors: updatedErrors
      });
    }
    revert(context) {
      this._form._setState({
        errors: context.oldErrors
      });
    }
  };
  UpdateFieldValidationHandler.$inject = ["form", "validator"];
  var UpdateFieldInstanceValidationHandler = class {
    constructor(form, validator) {
      this._form = form;
      this._validator = validator;
    }
    execute(context) {
      const {
        fieldInstance,
        value
      } = context;
      const {
        id: id2,
        indexes
      } = fieldInstance;
      const {
        errors
      } = this._form._getState();
      context.oldErrors = clone4(errors);
      const fieldErrors = this._validator.validateFieldInstance(fieldInstance, value);
      const updatedErrors = set(errors, [id2, ...Object.values(indexes || {})], fieldErrors.length ? fieldErrors : void 0);
      this._form._setState({
        errors: updatedErrors
      });
    }
    revert(context) {
      this._form._setState({
        errors: context.oldErrors
      });
    }
  };
  UpdateFieldInstanceValidationHandler.$inject = ["form", "validator"];
  var ViewerCommands = class {
    constructor(commandStack, eventBus) {
      this._commandStack = commandStack;
      eventBus.on("form.init", () => {
        this.registerHandlers();
      });
    }
    registerHandlers() {
      Object.entries(this.getHandlers()).forEach(([id2, handler]) => {
        this._commandStack.registerHandler(id2, handler);
      });
    }
    getHandlers() {
      return {
        "formField.validation.update": UpdateFieldValidationHandler,
        "formFieldInstance.validation.update": UpdateFieldInstanceValidationHandler
      };
    }
    /**
     * @deprecated
     */
    updateFieldValidation(field, value, indexes) {
      const context = {
        field,
        value,
        indexes
      };
      this._commandStack.execute("formField.validation.update", context);
    }
    updateFieldInstanceValidation(fieldInstance, value) {
      const context = {
        fieldInstance,
        value
      };
      this._commandStack.execute("formFieldInstance.validation.update", context);
    }
  };
  ViewerCommands.$inject = ["commandStack", "eventBus"];
  var _path$3;
  function _extends$3() {
    return _extends$3 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$3.apply(null, arguments);
  }
  var SvgExpand = function SvgExpand2(props) {
    return /* @__PURE__ */ _("svg", _extends$3({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none"
    }, props), _path$3 || (_path$3 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M2 9h5.5v3.086l-1.293-1.293-.707.707L8 14l2.5-2.5-.707-.707L8.5 12.086V9H14V8H2zm11-7H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1m0 3H3V3h10z"
    })));
  };
  var _path$2;
  function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$2.apply(null, arguments);
  }
  var SvgCollapse = function SvgCollapse2(props) {
    return /* @__PURE__ */ _("svg", _extends$2({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none"
    }, props), _path$2 || (_path$2 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M13 10H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1m0 3H3v-2h10zM8.5 3.914l1.293 1.293.707-.707L8 2 5.5 4.5l.707.707L7.5 3.914V7H2v1h12V7H8.5z"
    })));
  };
  var _path$1;
  var _path2;
  function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$1.apply(null, arguments);
  }
  var SvgAdd = function SvgAdd2(props) {
    return /* @__PURE__ */ _("svg", _extends$1({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none"
    }, props), _path$1 || (_path$1 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M8 2c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6 2.7-6 6-6m0-1C4.15 1 1 4.15 1 8s3.15 7 7 7 7-3.15 7-7-3.15-7-7-7"
    })), _path2 || (_path2 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M12 7.5H8.5V4h-1v3.5H4v1h3.5V12h1V8.5H12z"
    })));
  };
  var _path;
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends.apply(null, arguments);
  }
  var SvgDelete = function SvgDelete2(props) {
    return /* @__PURE__ */ _("svg", _extends({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none"
    }, props), _path || (_path = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "m12 4.7-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"
    })));
  };
  var RepeatRenderManager = class {
    constructor(form, formFields2, formFieldRegistry, pathRegistry, eventBus) {
      this._form = form;
      this._formFields = formFields2;
      this._formFieldRegistry = formFieldRegistry;
      this._pathRegistry = pathRegistry;
      this._eventBus = eventBus;
      this.Repeater = this.Repeater.bind(this);
      this.RepeatFooter = this.RepeatFooter.bind(this);
    }
    /**
     * Checks whether a field is currently repeating its children.
     *
     * @param {string} id - The id of the field to check
     * @returns {boolean} - True if repeatable, false otherwise
     */
    isFieldRepeating(id2) {
      if (!id2) {
        return false;
      }
      const formField = this._formFieldRegistry.get(id2);
      const formFieldDefinition = this._formFields.get(formField.type);
      return formFieldDefinition.config.repeatable && formField.isRepeating;
    }
    Repeater(props) {
      const {
        RowsRenderer: RowsRenderer2,
        indexes,
        useSharedState,
        ...restProps
      } = props;
      const [sharedRepeatState] = useSharedState;
      const {
        data
      } = this._form._getState();
      const repeaterField = props.field;
      const dataPath = this._pathRegistry.getValuePath(repeaterField, {
        indexes
      });
      const values2 = get(data, dataPath) || [];
      const nonCollapsedItems = this._getNonCollapsedItems(repeaterField);
      const collapseEnabled = !repeaterField.disableCollapse && values2.length > nonCollapsedItems;
      const isCollapsed = collapseEnabled && sharedRepeatState.isCollapsed;
      const hasChildren = repeaterField.components && repeaterField.components.length > 0;
      const showRemove = repeaterField.allowAddRemove && hasChildren;
      const onDeleteItem = (index2) => {
        const updatedValues = values2.slice();
        const removedItem = updatedValues.splice(index2, 1)[0];
        this._eventBus.fire("repeatRenderManager.remove", {
          dataPath,
          index: index2,
          item: removedItem
        });
        props.onChange({
          field: repeaterField,
          value: updatedValues,
          indexes
        });
      };
      const parentExpressionContextInfo = x2(LocalExpressionContext);
      return u2(k, {
        children: values2.map((itemValue, itemIndex) => u2("div", {
          class: (0, import_classnames.default)({
            "fjs-repeat-row-collapsed": isCollapsed ? itemIndex >= nonCollapsedItems : false
          }),
          children: u2(RepetitionScaffold, {
            itemIndex,
            itemValue,
            parentExpressionContextInfo,
            repeaterField,
            RowsRenderer: RowsRenderer2,
            indexes,
            onDeleteItem,
            showRemove,
            ...restProps
          })
        }, itemIndex))
      });
    }
    RepeatFooter(props) {
      const addButtonRef = A2(null);
      const {
        useSharedState,
        indexes,
        field: repeaterField,
        readonly,
        disabled
      } = props;
      const [sharedRepeatState, setSharedRepeatState] = useSharedState;
      const {
        data
      } = this._form._getState();
      const dataPath = this._pathRegistry.getValuePath(repeaterField, {
        indexes
      });
      const values2 = get(data, dataPath) || [];
      const nonCollapsedItems = this._getNonCollapsedItems(repeaterField);
      const collapseEnabled = !repeaterField.disableCollapse && values2.length > nonCollapsedItems;
      const isCollapsed = collapseEnabled && sharedRepeatState.isCollapsed;
      const hasChildren = repeaterField.components && repeaterField.components.length > 0;
      const showAdd = repeaterField.allowAddRemove && hasChildren;
      const toggle = () => {
        setSharedRepeatState((state) => ({
          ...state,
          isCollapsed: !isCollapsed
        }));
      };
      const shouldScroll = A2(false);
      const onAddItem = () => {
        const updatedValues = values2.slice();
        const newItem = this._form._getInitializedFieldData(this._form._getState().data, {
          container: repeaterField,
          indexes: {
            ...indexes,
            [repeaterField.id]: updatedValues.length
          }
        });
        updatedValues.push(newItem);
        shouldScroll.current = true;
        this._eventBus.fire("repeatRenderManager.add", {
          dataPath,
          index: updatedValues.length - 1,
          item: newItem
        });
        props.onChange({
          value: updatedValues
        });
        setSharedRepeatState((state) => ({
          ...state,
          isCollapsed: false
        }));
      };
      useScrollIntoView(addButtonRef, [values2.length], {
        align: "bottom",
        behavior: "auto",
        offset: 20
      }, [shouldScroll]);
      return u2("div", {
        className: (0, import_classnames.default)("fjs-repeat-render-footer", {
          "fjs-remove-allowed": repeaterField.allowAddRemove
        }),
        children: [showAdd ? u2("button", {
          type: "button",
          readOnly: readonly,
          disabled: disabled || readonly,
          class: "fjs-repeat-render-add",
          ref: addButtonRef,
          onClick: onAddItem,
          children: u2(k, {
            children: [u2(SvgAdd, {}), " ", "Add new"]
          })
        }) : null, collapseEnabled ? u2("button", {
          type: "button",
          class: "fjs-repeat-render-collapse",
          onClick: toggle,
          children: isCollapsed ? u2(k, {
            children: [u2(SvgExpand, {}), " ", `Expand all (${values2.length - 1})`]
          }) : u2(k, {
            children: [u2(SvgCollapse, {}), " ", "Collapse"]
          })
        }) : null]
      });
    }
    _getNonCollapsedItems(field) {
      const DEFAULT_NON_COLLAPSED_ITEMS = 5;
      const {
        nonCollapsedItems
      } = field;
      return nonCollapsedItems ? nonCollapsedItems : DEFAULT_NON_COLLAPSED_ITEMS;
    }
  };
  var RepetitionScaffold = (props) => {
    const {
      itemIndex,
      itemValue,
      parentExpressionContextInfo,
      repeaterField,
      RowsRenderer: RowsRenderer2,
      indexes,
      onDeleteItem,
      showRemove,
      ...restProps
    } = props;
    const elementProps = T2(() => ({
      ...restProps,
      indexes: {
        ...indexes || {},
        [repeaterField.id]: itemIndex
      }
    }), [itemIndex, indexes, repeaterField.id, restProps]);
    const localExpressionContextInfo = T2(() => ({
      data: parentExpressionContextInfo.data,
      this: itemValue,
      parent: buildExpressionContext({
        ...parentExpressionContextInfo,
        data: parentExpressionContextInfo.this
      }),
      i: [...parentExpressionContextInfo.i, itemIndex + 1]
    }), [itemIndex, parentExpressionContextInfo, itemValue]);
    return !showRemove ? u2(LocalExpressionContext.Provider, {
      value: localExpressionContextInfo,
      children: u2(RowsRenderer2, {
        ...elementProps
      })
    }) : u2("div", {
      class: "fjs-repeat-row-container",
      children: [u2("div", {
        class: "fjs-repeat-row-rows",
        children: u2(LocalExpressionContext.Provider, {
          value: localExpressionContextInfo,
          children: u2(RowsRenderer2, {
            ...elementProps
          })
        })
      }), u2("button", {
        type: "button",
        class: "fjs-repeat-row-remove",
        "aria-label": `Remove list item ${itemIndex + 1}`,
        onClick: () => onDeleteItem(itemIndex),
        children: u2("div", {
          class: "fjs-repeat-row-remove-icon-container",
          children: u2(SvgDelete, {})
        })
      })]
    });
  };
  RepeatRenderManager.$inject = ["form", "formFields", "formFieldRegistry", "pathRegistry", "eventBus"];
  var FN_REF = "__fn";
  var DEFAULT_PRIORITY = 1e3;
  var slice = Array.prototype.slice;
  function EventBus() {
    this._listeners = {};
    this.on("diagram.destroy", 1, this._destroy, this);
  }
  EventBus.prototype.on = function(events, priority, callback, that) {
    events = isArray(events) ? events : [events];
    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY;
    }
    if (!isNumber(priority)) {
      throw new Error("priority must be a number");
    }
    var actualCallback = callback;
    if (that) {
      actualCallback = bind(callback, that);
      actualCallback[FN_REF] = callback[FN_REF] || callback;
    }
    var self2 = this;
    events.forEach(function(e3) {
      self2._addListener(e3, {
        priority,
        callback: actualCallback,
        next: null
      });
    });
  };
  EventBus.prototype.once = function(events, priority, callback, that) {
    var self2 = this;
    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY;
    }
    if (!isNumber(priority)) {
      throw new Error("priority must be a number");
    }
    function wrappedCallback() {
      wrappedCallback.__isTomb = true;
      var result = callback.apply(that, arguments);
      self2.off(events, wrappedCallback);
      return result;
    }
    wrappedCallback[FN_REF] = callback;
    this.on(events, priority, wrappedCallback);
  };
  EventBus.prototype.off = function(events, callback) {
    events = isArray(events) ? events : [events];
    var self2 = this;
    events.forEach(function(event2) {
      self2._removeListener(event2, callback);
    });
  };
  EventBus.prototype.createEvent = function(data) {
    var event2 = new InternalEvent();
    event2.init(data);
    return event2;
  };
  EventBus.prototype.fire = function(type3, data) {
    var event2, firstListener, returnValue, args;
    args = slice.call(arguments);
    if (typeof type3 === "object") {
      data = type3;
      type3 = data.type;
    }
    if (!type3) {
      throw new Error("no event type specified");
    }
    firstListener = this._listeners[type3];
    if (!firstListener) {
      return;
    }
    if (data instanceof InternalEvent) {
      event2 = data;
    } else {
      event2 = this.createEvent(data);
    }
    args[0] = event2;
    var originalType = event2.type;
    if (type3 !== originalType) {
      event2.type = type3;
    }
    try {
      returnValue = this._invokeListeners(event2, args, firstListener);
    } finally {
      if (type3 !== originalType) {
        event2.type = originalType;
      }
    }
    if (returnValue === void 0 && event2.defaultPrevented) {
      returnValue = false;
    }
    return returnValue;
  };
  EventBus.prototype.handleError = function(error2) {
    return this.fire("error", {
      error: error2
    }) === false;
  };
  EventBus.prototype._destroy = function() {
    this._listeners = {};
  };
  EventBus.prototype._invokeListeners = function(event2, args, listener) {
    var returnValue;
    while (listener) {
      if (event2.cancelBubble) {
        break;
      }
      returnValue = this._invokeListener(event2, args, listener);
      listener = listener.next;
    }
    return returnValue;
  };
  EventBus.prototype._invokeListener = function(event2, args, listener) {
    var returnValue;
    if (listener.callback.__isTomb) {
      return returnValue;
    }
    try {
      returnValue = invokeFunction(listener.callback, args);
      if (returnValue !== void 0) {
        event2.returnValue = returnValue;
        event2.stopPropagation();
      }
      if (returnValue === false) {
        event2.preventDefault();
      }
    } catch (error2) {
      if (!this.handleError(error2)) {
        console.error("unhandled error in event listener", error2);
        throw error2;
      }
    }
    return returnValue;
  };
  EventBus.prototype._addListener = function(event2, newListener) {
    var listener = this._getListeners(event2), previousListener;
    if (!listener) {
      this._setListeners(event2, newListener);
      return;
    }
    while (listener) {
      if (listener.priority < newListener.priority) {
        newListener.next = listener;
        if (previousListener) {
          previousListener.next = newListener;
        } else {
          this._setListeners(event2, newListener);
        }
        return;
      }
      previousListener = listener;
      listener = listener.next;
    }
    previousListener.next = newListener;
  };
  EventBus.prototype._getListeners = function(name2) {
    return this._listeners[name2];
  };
  EventBus.prototype._setListeners = function(name2, listener) {
    this._listeners[name2] = listener;
  };
  EventBus.prototype._removeListener = function(event2, callback) {
    var listener = this._getListeners(event2), nextListener, previousListener, listenerCallback;
    if (!callback) {
      this._setListeners(event2, null);
      return;
    }
    while (listener) {
      nextListener = listener.next;
      listenerCallback = listener.callback;
      if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
        if (previousListener) {
          previousListener.next = nextListener;
        } else {
          this._setListeners(event2, nextListener);
        }
      }
      previousListener = listener;
      listener = nextListener;
    }
  };
  function InternalEvent() {
  }
  InternalEvent.prototype.stopPropagation = function() {
    this.cancelBubble = true;
  };
  InternalEvent.prototype.preventDefault = function() {
    this.defaultPrevented = true;
  };
  InternalEvent.prototype.init = function(data) {
    assign(this, data || {});
  };
  function invokeFunction(fn4, args) {
    return fn4.apply(null, args);
  }
  var EMAIL_PATTERN = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var PHONE_PATTERN = /(\+|00)(297|93|244|1264|358|355|376|971|54|374|1684|1268|61|43|994|257|32|229|226|880|359|973|1242|387|590|375|501|1441|591|55|1246|673|975|267|236|1|61|41|56|86|225|237|243|242|682|57|269|238|506|53|5999|61|1345|357|420|49|253|1767|45|1809|1829|1849|213|593|20|291|212|34|372|251|358|679|500|33|298|691|241|44|995|44|233|350|224|590|220|245|240|30|1473|299|502|594|1671|592|852|504|385|509|36|62|44|91|246|353|98|964|354|972|39|1876|44|962|81|76|77|254|996|855|686|1869|82|383|965|856|961|231|218|1758|423|94|266|370|352|371|853|590|212|377|373|261|960|52|692|389|223|356|95|382|976|1670|258|222|1664|596|230|265|60|262|264|687|227|672|234|505|683|31|47|977|674|64|968|92|507|64|51|63|680|675|48|1787|1939|850|351|595|970|689|974|262|40|7|250|966|249|221|65|500|4779|677|232|503|378|252|508|381|211|239|597|421|386|46|268|1721|248|963|1649|235|228|66|992|690|993|670|676|1868|216|90|688|886|255|256|380|598|1|998|3906698|379|1784|58|1284|1340|84|678|681|685|967|27|260|263)(9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)\d{4,20}$/;
  var VALIDATE_FEEL_PROPERTIES = ["min", "max", "minLength", "maxLength"];
  var Validator = class {
    constructor(expressionLanguage2, conditionChecker, form, formFieldRegistry) {
      this._expressionLanguage = expressionLanguage2;
      this._conditionChecker = conditionChecker;
      this._form = form;
      this._formFieldRegistry = formFieldRegistry;
    }
    /**
     * Validate against a field definition, does not support proper expression evaluation.
     *
     * @deprecated use validateFieldInstance instead
     */
    validateField(field, value) {
      const {
        type: type3,
        validate: validate2
      } = field;
      let errors = [];
      if (type3 === "number") {
        errors = [...errors, ...runNumberValidation(field, value)];
      }
      if (!validate2) {
        return errors;
      }
      const evaluatedValidation = oldEvaluateFEELValues(validate2, this._expressionLanguage, this._conditionChecker, this._form);
      errors = [...errors, ...runPresetValidation(field, evaluatedValidation, value)];
      return errors;
    }
    /**
     * Validate a field instance.
     *
     * @param {Object} fieldInstance
     * @param {string} value
     *
     * @returns {Array<string>}
     */
    validateFieldInstance(fieldInstance, value) {
      const {
        id: id2,
        expressionContextInfo
      } = fieldInstance;
      const field = this._formFieldRegistry.get(id2);
      if (!field) {
        return [];
      }
      const {
        type: type3,
        validate: validate2
      } = field;
      let errors = [];
      if (type3 === "number") {
        errors = [...errors, ...runNumberValidation(field, value)];
      }
      if (!validate2) {
        return errors;
      }
      const evaluatedValidation = evaluateFEELValues(validate2, this._expressionLanguage, expressionContextInfo);
      errors = [...errors, ...runPresetValidation(field, evaluatedValidation, value)];
      return errors;
    }
  };
  Validator.$inject = ["expressionLanguage", "conditionChecker", "form", "formFieldRegistry"];
  function runNumberValidation(field, value) {
    const {
      decimalDigits,
      increment
    } = field;
    const errors = [];
    if (value === "NaN") {
      errors.push("Value is not a number.");
    } else if (value) {
      if (decimalDigits >= 0 && countDecimals(value) > decimalDigits) {
        errors.push("Value is expected to " + (decimalDigits === 0 ? "be an integer" : `have at most ${decimalDigits} decimal digit${decimalDigits > 1 ? "s" : ""}`) + ".");
      }
      if (increment) {
        const bigValue = big_default(value);
        const bigIncrement = big_default(increment);
        const offset2 = bigValue.mod(bigIncrement);
        if (offset2.cmp(0) !== 0) {
          const previousValue = bigValue.minus(offset2);
          const nextValue = previousValue.plus(bigIncrement);
          errors.push(`Please select a valid value, the two nearest valid values are ${previousValue} and ${nextValue}.`);
        }
      }
    }
    return errors;
  }
  function runPresetValidation(field, validation, value) {
    const errors = [];
    if (validation.pattern && value && !new RegExp(validation.pattern).test(value)) {
      errors.push(`Field must match pattern ${validation.pattern}.`);
    }
    if (validation.required) {
      const isUncheckedCheckbox = field.type === "checkbox" && value === false;
      const isUnsetValue = isNil(value) || value === "";
      const isEmptyMultiselect = Array.isArray(value) && value.length === 0;
      if (isUncheckedCheckbox || isUnsetValue || isEmptyMultiselect) {
        errors.push("Field is required.");
      }
    }
    if ("min" in validation && (value || value === 0) && value < validation.min) {
      errors.push(`Field must have minimum value of ${validation.min}.`);
    }
    if ("max" in validation && (value || value === 0) && value > validation.max) {
      errors.push(`Field must have maximum value of ${validation.max}.`);
    }
    if ("minLength" in validation && value && value.trim().length < validation.minLength) {
      errors.push(`Field must have minimum length of ${validation.minLength}.`);
    }
    if ("maxLength" in validation && value && value.trim().length > validation.maxLength) {
      errors.push(`Field must have maximum length of ${validation.maxLength}.`);
    }
    if ("validationType" in validation && value && validation.validationType === "phone" && !PHONE_PATTERN.test(value)) {
      errors.push("Field must be a valid  international phone number. (e.g. +4930664040900)");
    }
    if ("validationType" in validation && value && validation.validationType === "email" && !EMAIL_PATTERN.test(value)) {
      errors.push("Field must be a valid email.");
    }
    return errors;
  }
  function evaluateFEELValues(validate2, expressionLanguage2, expressionContextInfo) {
    const evaluatedValidate = {
      ...validate2
    };
    VALIDATE_FEEL_PROPERTIES.forEach((property) => {
      const path2 = property.split(".");
      const value = get(evaluatedValidate, path2);
      const evaluatedValue = runExpressionEvaluation(expressionLanguage2, value, expressionContextInfo);
      set(evaluatedValidate, path2, evaluatedValue === null ? void 0 : evaluatedValue);
    });
    return evaluatedValidate;
  }
  function oldEvaluateFEELValues(validate2, expressionLanguage2, conditionChecker, form) {
    const evaluatedValidate = {
      ...validate2
    };
    VALIDATE_FEEL_PROPERTIES.forEach((property) => {
      const path2 = property.split(".");
      const value = get(evaluatedValidate, path2);
      if (!expressionLanguage2 || !expressionLanguage2.isExpression(value)) {
        return value;
      }
      const {
        initialData,
        data
      } = form._getState();
      const newData = conditionChecker ? conditionChecker.applyConditions(data, data) : data;
      const filteredData = {
        ...initialData,
        ...newData
      };
      const evaluatedValue = expressionLanguage2.evaluate(value, filteredData);
      if (evaluatedValue) {
        set(evaluatedValidate, path2, evaluatedValue);
      }
    });
    return evaluatedValidate;
  }
  var Importer = class {
    /**
     * @constructor
     * @param { import('./FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     * @param { import('./PathRegistry').PathRegistry } pathRegistry
     * @param { import('./FieldFactory').FieldFactory } fieldFactory
     * @param { import('./FormLayouter').FormLayouter } formLayouter
     */
    constructor(formFieldRegistry, pathRegistry, fieldFactory, formLayouter) {
      this._formFieldRegistry = formFieldRegistry;
      this._pathRegistry = pathRegistry;
      this._fieldFactory = fieldFactory;
      this._formLayouter = formLayouter;
    }
    /**
     * Import schema creating rows, fields, attaching additional
     * information to each field and adding fields to the
     * field registry.
     *
     * Additional information attached:
     *
     *   * `id` (unless present)
     *   * `_parent`
     *   * `_path`
     *
     * @param {any} schema
     *
     * @typedef {{ warnings: Error[], schema: any }} ImportResult
     * @returns {ImportResult}
     */
    importSchema(schema) {
      const warnings = [];
      try {
        this._cleanup();
        const importedSchema = this.importFormField(clone4(schema));
        this._formLayouter.calculateLayout(clone4(importedSchema));
        return {
          schema: importedSchema,
          warnings
        };
      } catch (err) {
        this._cleanup();
        err.warnings = warnings;
        throw err;
      }
    }
    _cleanup() {
      this._formLayouter.clear();
      this._formFieldRegistry.clear();
      this._pathRegistry.clear();
    }
    /**
     * @param {{[x: string]: any}} fieldAttrs
     * @param {String} [parentId]
     * @param {number} [index]
     *
     * @return {any} field
     */
    importFormField(fieldAttrs, parentId, index2) {
      const {
        components
      } = fieldAttrs;
      let parent, path2;
      if (parentId) {
        parent = this._formFieldRegistry.get(parentId);
      }
      path2 = parent ? [...parent._path, "components", index2] : [];
      const field = this._fieldFactory.create({
        ...fieldAttrs,
        _path: path2,
        _parent: parentId
      }, false);
      this._formFieldRegistry.add(field);
      if (components) {
        field.components = this.importFormFields(components, field.id);
      }
      return field;
    }
    /**
     * @param {Array<any>} components
     * @param {string} parentId
     *
     * @return {Array<any>} imported components
     */
    importFormFields(components, parentId) {
      return components.map((component, index2) => {
        return this.importFormField(component, parentId, index2);
      });
    }
  };
  Importer.$inject = ["formFieldRegistry", "pathRegistry", "fieldFactory", "formLayouter"];
  var FieldFactory = class {
    /**
     * @constructor
     *
     * @param  formFieldRegistry
     * @param  formFields
     */
    constructor(formFieldRegistry, pathRegistry, formFields2) {
      this._formFieldRegistry = formFieldRegistry;
      this._pathRegistry = pathRegistry;
      this._formFields = formFields2;
    }
    create(attrs, isNewField = true) {
      const {
        id: id2,
        type: type3,
        key,
        path: path2,
        _parent
      } = attrs;
      const fieldDefinition = this._formFields.get(type3);
      if (!fieldDefinition) {
        throw new Error(`form field of type <${type3}> not supported`);
      }
      const {
        config: config2
      } = fieldDefinition;
      if (!config2) {
        throw new Error(`form field of type <${type3}> has no config`);
      }
      if (id2 && this._formFieldRegistry._ids.assigned(id2)) {
        throw new Error(`form field with id <${id2}> already exists`);
      }
      const parent = _parent && this._formFieldRegistry.get(_parent);
      const parentPath = parent && this._pathRegistry.getValuePath(parent) || [];
      const knownAncestorIds = getAncestryList(_parent, this._formFieldRegistry);
      if (config2.keyed && key && !this._pathRegistry.canClaimPath([...parentPath, ...key.split(".")], {
        isClosed: true,
        knownAncestorIds
      })) {
        throw new Error(`binding path '${[...parentPath, key].join(".")}' is already claimed`);
      }
      if (config2.pathed && path2 && !this._pathRegistry.canClaimPath([...parentPath, ...path2.split(".")], {
        isRepeatable: config2.repeatable,
        knownAncestorIds
      })) {
        throw new Error(`binding path '${[...parentPath, ...path2.split(".")].join(".")}' is already claimed`);
      }
      const field = config2.create({
        ...config2.label ? {
          label: config2.label
        } : {},
        ...attrs
      }, isNewField);
      this._ensureId(field);
      if (config2.keyed) {
        this._ensureKey(field);
        this._pathRegistry.claimPath(this._pathRegistry.getValuePath(field), {
          isClosed: true,
          claimerId: field.id,
          knownAncestorIds: getAncestryList(_parent, this._formFieldRegistry)
        });
      }
      if (config2.pathed) {
        if (config2.repeatable) {
          this._enforceDefaultPath(field);
        }
        this._pathRegistry.claimPath(this._pathRegistry.getValuePath(field), {
          isRepeatable: config2.repeatable,
          claimerId: field.id,
          knownAncestorIds: getAncestryList(_parent, this._formFieldRegistry)
        });
      }
      return field;
    }
    _ensureId(field) {
      if (field.id) {
        this._formFieldRegistry._ids.claim(field.id, field);
        return;
      }
      let prefix2 = "Field";
      if (field.type === "default") {
        prefix2 = "Form";
      }
      field.id = this._formFieldRegistry._ids.nextPrefixed(`${prefix2}_`, field);
    }
    _ensureKey(field) {
      if (!field.key) {
        field.key = this._getUniqueKeyPath(field);
      }
    }
    _enforceDefaultPath(field) {
      if (!field.path) {
        field.path = this._getUniqueKeyPath(field);
      }
    }
    _getUniqueKeyPath(field) {
      let random;
      const parent = this._formFieldRegistry.get(field._parent);
      do {
        random = Math.random().toString(36).substring(7);
      } while (parent && parent.components.some((child) => child.key === random));
      return `${field.type}_${random}`;
    }
  };
  FieldFactory.$inject = ["formFieldRegistry", "pathRegistry", "formFields"];
  var PathRegistry = class {
    constructor(formFieldRegistry, formFields2, injector) {
      this._formFieldRegistry = formFieldRegistry;
      this._formFields = formFields2;
      this._injector = injector;
      this._dataPaths = [];
    }
    canClaimPath(path2, options2 = {}) {
      const {
        isClosed = false,
        isRepeatable = false,
        skipAncestryCheck = false,
        claimerId = null,
        knownAncestorIds = []
      } = options2;
      let node = {
        children: this._dataPaths
      };
      for (const segment of path2) {
        node = _getNextSegment(node, segment);
        if (!node) {
          return true;
        }
        if (node.isRepeatable && !skipAncestryCheck) {
          if (!(claimerId || knownAncestorIds.length)) {
            throw new Error("cannot claim a path that contains a repeater without specifying a claimerId or knownAncestorIds");
          }
          const isValidRepeatClaim = knownAncestorIds.includes(node.repeaterId) || claimerId && getAncestryList(claimerId, this._formFieldRegistry).includes(node.repeaterId);
          if (!isValidRepeatClaim) {
            return false;
          }
        }
        if (node.children === null) {
          return false;
        }
      }
      return !(isClosed || isRepeatable);
    }
    claimPath(path2, options2 = {}) {
      const {
        isClosed = false,
        isRepeatable = false,
        claimerId = null,
        knownAncestorIds = []
      } = options2;
      if (!this.canClaimPath(path2, {
        isClosed,
        isRepeatable,
        claimerId,
        knownAncestorIds
      })) {
        throw new Error(`cannot claim path '${path2.join(".")}'`);
      }
      let node = {
        children: this._dataPaths
      };
      for (const segment of path2) {
        let child = _getNextSegment(node, segment);
        if (!child) {
          child = {
            segment,
            claimCount: 1,
            children: []
          };
          node.children.push(child);
        } else {
          child.claimCount++;
        }
        node = child;
      }
      if (isClosed) {
        node.children = null;
      }
      if (isRepeatable) {
        node.isRepeatable = true;
        node.repeaterId = claimerId;
      }
    }
    unclaimPath(path2) {
      let node = {
        children: this._dataPaths
      };
      for (const segment of path2) {
        const child = _getNextSegment(node, segment);
        if (!child) {
          throw new Error(`no open path found for '${path2.join(".")}'`);
        }
        node = child;
      }
      node = {
        children: this._dataPaths
      };
      for (const segment of path2) {
        const child = _getNextSegment(node, segment);
        child.claimCount--;
        if (child.claimCount === 0) {
          node.children.splice(node.children.indexOf(child), 1);
          break;
        }
        node = child;
      }
    }
    /**
     * Applies a function (fn) recursively on a given field and its children.
     *
     * - `field`: Starting field object.
     * - `fn`: Function to apply.
     * - `context`: Optional object for passing data between calls.
     *
     * Stops early if `fn` returns `false`. Useful for traversing the form field tree.
     *
     * @returns {boolean} Success status based on function execution.
     */
    executeRecursivelyOnFields(field, fn4, context = {}) {
      let result = true;
      const formFieldConfig = this._formFields.get(field.type).config;
      if (formFieldConfig.keyed) {
        const callResult = fn4({
          field,
          isClosed: true,
          isRepeatable: false,
          context
        });
        return result && callResult;
      } else if (formFieldConfig.pathed) {
        const callResult = fn4({
          field,
          isClosed: false,
          isRepeatable: formFieldConfig.repeatable,
          context
        });
        result = result && callResult;
      }
      if (result === false || context.preventRecursion) {
        return result;
      }
      if (Array.isArray(field.components)) {
        for (const child of field.components) {
          const callResult = this.executeRecursivelyOnFields(child, fn4, clone4(context));
          result = result && callResult;
          if (result === false) {
            return result;
          }
        }
      }
      return result;
    }
    /**
     * Generates an array representing the binding path to an underlying data object for a form field.
     *
     * @param {Object} field - The field object with properties: `key`, `path`, `id`, and optionally `_parent`.
     * @param {Object} [options={}] - Configuration options.
     * @param {Object} [options.replacements={}] - A map of field IDs to alternative path arrays.
     * @param {Object} [options.indexes=null] - A map of parent IDs to the index of the field within said parent, leave null to get an unindexed path.
     * @param {Object} [options.cutoffNode] - The ID of the parent field at which to stop generating the path.
     *
     * @returns {(Array<string>|undefined)} An array of strings representing the binding path, or undefined if not determinable.
     */
    getValuePath(field, options2 = {}) {
      const {
        replacements = {},
        indexes = null,
        cutoffNode = null
      } = options2;
      let localValuePath = [];
      const hasReplacement = Object.prototype.hasOwnProperty.call(replacements, field.id);
      const formFieldConfig = this._formFields.get(field.type).config;
      if (hasReplacement) {
        const replacement = replacements[field.id];
        if (replacement === null || replacement === void 0 || replacement === "") {
          localValuePath = [];
        } else if (typeof replacement === "string") {
          localValuePath = replacement.split(".");
        } else if (Array.isArray(replacement)) {
          localValuePath = replacement;
        } else {
          throw new Error(`replacements for field ${field.id} must be a string, array or null/undefined`);
        }
      } else if (formFieldConfig.keyed) {
        localValuePath = field.key.split(".");
      } else if (formFieldConfig.pathed && field.path) {
        localValuePath = field.path.split(".");
      }
      if (indexes) {
        localValuePath = this._addIndexes(localValuePath, field, indexes);
      }
      if (field._parent && field._parent !== cutoffNode) {
        const parent = this._formFieldRegistry.get(field._parent);
        return [...this.getValuePath(parent, options2) || [], ...localValuePath];
      }
      return localValuePath;
    }
    clear() {
      this._dataPaths = [];
    }
    _addIndexes(localValuePath, field, indexes) {
      const repeatRenderManager = this._injector.get("repeatRenderManager", false);
      if (repeatRenderManager && repeatRenderManager.isFieldRepeating(field._parent)) {
        return [indexes[field._parent], ...localValuePath];
      }
      return localValuePath;
    }
  };
  var _getNextSegment = (node, segment) => {
    if (isArray(node.children)) {
      return node.children.find((node2) => node2.segment === segment) || null;
    }
    return null;
  };
  PathRegistry.$inject = ["formFieldRegistry", "formFields", "injector"];
  var FormLayouter = class {
    constructor(eventBus) {
      this._rows = [];
      this._ids = new index_esm_default([32, 36, 1]);
      this._eventBus = eventBus;
    }
    /**
     * @param {FormRow} row
     */
    addRow(formFieldId, row) {
      let rowsPerComponent = this._rows.find((r3) => r3.formFieldId === formFieldId);
      if (!rowsPerComponent) {
        rowsPerComponent = {
          formFieldId,
          rows: []
        };
        this._rows.push(rowsPerComponent);
      }
      rowsPerComponent.rows.push(row);
    }
    /**
     * @param {String} id
     * @returns {FormRow}
     */
    getRow(id2) {
      const rows = allRows(this._rows);
      return rows.find((r3) => r3.id === id2);
    }
    /**
     * @param {any} formField
     * @returns {FormRow}
     */
    getRowForField(formField) {
      return allRows(this._rows).find((r3) => {
        const {
          components
        } = r3;
        return components.includes(formField.id);
      });
    }
    /**
     * @param {String} formFieldId
     * @returns { Array<FormRow> }
     */
    getRows(formFieldId) {
      const rowsForField = this._rows.find((r3) => formFieldId === r3.formFieldId);
      if (!rowsForField) {
        return [];
      }
      return rowsForField.rows;
    }
    /**
     * @returns {string}
     */
    nextRowId() {
      return this._ids.nextPrefixed("Row_");
    }
    /**
     * @param {any} formField
     */
    calculateLayout(formField) {
      const {
        type: type3,
        components
      } = formField;
      if (!["default", "group", "dynamiclist"].includes(type3) || !components) {
        return;
      }
      const rowsInOrder = groupByRow(components, this._ids);
      Object.entries(rowsInOrder).forEach(([id2, components2]) => {
        this.addRow(formField.id, {
          id: id2,
          components: components2.map((c3) => c3.id)
        });
      });
      components.forEach((field) => this.calculateLayout(field));
      this._eventBus.fire("form.layoutCalculated", {
        rows: this._rows
      });
    }
    clear() {
      this._rows = [];
      this._ids.clear();
      this._eventBus.fire("form.layoutCleared");
    }
  };
  FormLayouter.$inject = ["eventBus"];
  function groupByRow(components, ids3) {
    return groupBy(components, (c3) => {
      const {
        layout
      } = c3;
      if (!layout || !layout.row) {
        return ids3.nextPrefixed("Row_");
      }
      return layout.row;
    });
  }
  function allRows(formRows) {
    return formRows.map((r3) => r3.rows).flat();
  }
  var FormFieldRegistry = class {
    constructor(eventBus) {
      this._eventBus = eventBus;
      this._formFields = {};
      eventBus.on("form.clear", () => this.clear());
      this._ids = new index_esm_default([32, 36, 1]);
    }
    add(formField) {
      const {
        id: id2
      } = formField;
      if (this._formFields[id2]) {
        throw new Error(`form field with ID ${id2} already exists`);
      }
      this._eventBus.fire("formField.add", {
        formField
      });
      this._formFields[id2] = formField;
    }
    remove(formField) {
      const {
        id: id2
      } = formField;
      if (!this._formFields[id2]) {
        return;
      }
      this._eventBus.fire("formField.remove", {
        formField
      });
      delete this._formFields[id2];
    }
    get(id2) {
      return this._formFields[id2];
    }
    getAll() {
      return Object.values(this._formFields);
    }
    getForm() {
      return this.getAll().find((formField) => formField.type === "default");
    }
    forEach(callback) {
      this.getAll().forEach((formField) => callback(formField));
    }
    clear() {
      this._formFields = {};
      this._ids.clear();
    }
  };
  FormFieldRegistry.$inject = ["eventBus"];
  var FormFieldInstanceRegistry = class {
    constructor(eventBus, formFieldRegistry, formFields2) {
      this._eventBus = eventBus;
      this._formFieldRegistry = formFieldRegistry;
      this._formFields = formFields2;
      this._formFieldInstances = {};
      eventBus.on("form.clear", () => this.clear());
    }
    syncInstance(instanceId, formFieldInfo) {
      const {
        hidden,
        ...restInfo
      } = formFieldInfo;
      const isInstanceExpected = !hidden;
      const doesInstanceExist = this._formFieldInstances[instanceId];
      if (isInstanceExpected && !doesInstanceExist) {
        this._formFieldInstances[instanceId] = {
          instanceId,
          ...restInfo
        };
        this._eventBus.fire("formFieldInstance.added", {
          instanceId
        });
      } else if (!isInstanceExpected && doesInstanceExist) {
        delete this._formFieldInstances[instanceId];
        this._eventBus.fire("formFieldInstance.removed", {
          instanceId
        });
      } else if (isInstanceExpected && doesInstanceExist) {
        const wasInstanceChanged = Object.keys(restInfo).some((key) => {
          return this._formFieldInstances[instanceId][key] !== restInfo[key];
        });
        if (wasInstanceChanged) {
          this._formFieldInstances[instanceId] = {
            instanceId,
            ...restInfo
          };
          this._eventBus.fire("formFieldInstance.changed", {
            instanceId
          });
        }
      }
      return instanceId;
    }
    cleanupInstance(instanceId) {
      if (this._formFieldInstances[instanceId]) {
        delete this._formFieldInstances[instanceId];
        this._eventBus.fire("formFieldInstance.removed", {
          instanceId
        });
      }
    }
    get(instanceId) {
      return this._formFieldInstances[instanceId];
    }
    getAll() {
      return Object.values(this._formFieldInstances);
    }
    getAllKeyed() {
      return this.getAll().filter(({
        id: id2
      }) => {
        const formFieldDefinition = this._formFieldRegistry.get(id2);
        if (!formFieldDefinition) {
          return false;
        }
        const {
          type: type3
        } = formFieldDefinition;
        const {
          config: config2
        } = this._formFields.get(type3);
        return config2.keyed;
      });
    }
    clear() {
      this._formFieldInstances = {};
    }
  };
  FormFieldInstanceRegistry.$inject = ["eventBus", "formFieldRegistry", "formFields"];
  function Renderer(config2, eventBus, form, injector) {
    const App = () => {
      const [state, setState] = d2(form._getState());
      const formContext = {
        getService(type3, strict = true) {
          return injector.get(type3, strict);
        },
        formId: form._id
      };
      eventBus.on("changed", (newState) => {
        setState(newState);
      });
      const onChange = q2((update) => form._update(update), []);
      const {
        properties
      } = state;
      const {
        readOnly: readOnly2
      } = properties;
      const onSubmit = q2(() => {
        if (!readOnly2) {
          form.submit();
        }
      }, [readOnly2]);
      const onReset = q2(() => form.reset(), []);
      const {
        schema
      } = state;
      if (!schema) {
        return null;
      }
      return u2(FormContext.Provider, {
        value: formContext,
        children: u2(FormComponent, {
          onChange,
          onSubmit,
          onReset
        })
      });
    };
    const {
      container
    } = config2;
    eventBus.on("form.init", () => {
      E(u2(App, {}), container);
    });
    eventBus.on("form.destroy", () => {
      E(null, container);
    });
  }
  Renderer.$inject = ["config.renderer", "eventBus", "form", "injector"];
  var extractFileReferencesFromRemovedData = (removedData) => {
    const fileReferences = [];
    if (removedData === null) {
      return fileReferences;
    }
    Object.values(removedData).forEach((value) => {
      if (value === null) {
        return;
      }
      if (typeof value === "object") {
        fileReferences.push(...extractFileReferencesFromRemovedData(
          /** @type {RemovedData} */
          value
        ));
      } else if (Array.isArray(value)) {
        fileReferences.push(...value.map(extractFileReferencesFromRemovedData).flat());
      } else if (typeof value === "string" && value.startsWith(FILE_PICKER_FILE_KEY_PREFIX)) {
        fileReferences.push(value);
      }
    });
    return fileReferences;
  };
  var fileRegistry = Symbol("fileRegistry");
  var eventBusSymbol = Symbol("eventBus");
  var formFieldRegistrySymbol = Symbol("formFieldRegistry");
  var formFieldInstanceRegistrySymbol = Symbol("formFieldInstanceRegistry");
  var EMPTY_ARRAY = [];
  var FileRegistry = class {
    /**
     * @param {import('../core/EventBus').EventBus} eventBus
     * @param {import('../core/FormFieldRegistry').FormFieldRegistry} formFieldRegistry
     * @param {import('../core/FormFieldInstanceRegistry').FormFieldInstanceRegistry} formFieldInstanceRegistry
     */
    constructor(eventBus, formFieldRegistry, formFieldInstanceRegistry) {
      this[fileRegistry] = /* @__PURE__ */ new Map();
      this[eventBusSymbol] = eventBus;
      this[formFieldRegistrySymbol] = formFieldRegistry;
      this[formFieldInstanceRegistrySymbol] = formFieldInstanceRegistry;
      const removeFileHandler = ({
        item
      }) => {
        const fileReferences = extractFileReferencesFromRemovedData(item);
        fileReferences.forEach((fileReference) => {
          this.deleteFiles(fileReference);
        });
      };
      eventBus.on("form.clear", () => this.clear());
      eventBus.on("conditionChecker.remove", removeFileHandler);
      eventBus.on("repeatRenderManager.remove", removeFileHandler);
    }
    /**
     * @param {string} id
     * @param {File[]} files
     */
    setFiles(id2, files) {
      this[fileRegistry].set(id2, files);
    }
    /**
     * @param {string} id
     * @returns {File[]}
     */
    getFiles(id2) {
      return this[fileRegistry].get(id2) || EMPTY_ARRAY;
    }
    /**
     * @returns {string[]}
     */
    getKeys() {
      return Array.from(this[fileRegistry].keys());
    }
    /**
     * @param {string} id
     * @returns {boolean}
     */
    hasKey(id2) {
      return this[fileRegistry].has(id2);
    }
    /**
     * @param {string} id
     */
    deleteFiles(id2) {
      this[fileRegistry].delete(id2);
    }
    /**
     * @returns {Map<string, File[]>}
     */
    getAllFiles() {
      return new Map(this[fileRegistry]);
    }
    clear() {
      this[fileRegistry].clear();
    }
  };
  FileRegistry.$inject = ["eventBus", "formFieldRegistry", "formFieldInstanceRegistry"];
  var ids = new index_esm_default([32, 36, 1]);
  var schemaVersion = 18;

  // node_modules/@bpmn-io/form-js-editor/dist/index.es.js
  var import_classnames2 = __toESM(require_classnames());

  // node_modules/@bpmn-io/draggle/dist/draggle.js
  function _e(t4) {
    return t4 && t4.__esModule && Object.prototype.hasOwnProperty.call(t4, "default") ? t4.default : t4;
  }
  var Ne = function(n3, o3) {
    return Array.prototype.slice.call(n3, o3);
  };
  var Be = typeof setImmediate == "function";
  var z3;
  Be ? z3 = function(t4) {
    setImmediate(t4);
  } : z3 = function(t4) {
    setTimeout(t4, 0);
  };
  var Me = z3;
  var Xe = Me;
  var Ie = function(n3, o3, l4) {
    n3 && Xe(function() {
      n3.apply(l4 || null, o3 || []);
    });
  };
  var ee = Ne;
  var Te = Ie;
  var Ye = function(n3, o3) {
    var l4 = o3 || {}, c3 = {};
    return n3 === void 0 && (n3 = {}), n3.on = function(d3, h3) {
      return c3[d3] ? c3[d3].push(h3) : c3[d3] = [h3], n3;
    }, n3.once = function(d3, h3) {
      return h3._once = true, n3.on(d3, h3), n3;
    }, n3.off = function(d3, h3) {
      var S2 = arguments.length;
      if (S2 === 1)
        delete c3[d3];
      else if (S2 === 0)
        c3 = {};
      else {
        var C4 = c3[d3];
        if (!C4)
          return n3;
        C4.splice(C4.indexOf(h3), 1);
      }
      return n3;
    }, n3.emit = function() {
      var d3 = ee(arguments);
      return n3.emitterSnapshot(d3.shift()).apply(this, d3);
    }, n3.emitterSnapshot = function(d3) {
      var h3 = (c3[d3] || []).slice(0);
      return function() {
        var S2 = ee(arguments), C4 = this || n3;
        if (d3 === "error" && l4.throws !== false && !h3.length)
          throw S2.length === 1 ? S2[0] : S2;
        return h3.forEach(function(E3) {
          l4.async ? Te(E3, S2, C4) : E3.apply(C4, S2), E3._once && n3.off(d3, E3);
        }), n3;
      };
    }, n3;
  };
  var Le = /* @__PURE__ */ _e(Ye);
  var te = {};
  var xe = "(?:^|\\s)";
  var Re = "(?:\\s|$)";
  function le(t4) {
    let n3 = te[t4];
    return n3 ? n3.lastIndex = 0 : te[t4] = n3 = new RegExp(xe + t4 + Re, "g"), n3;
  }
  function Y2(t4, n3) {
    const o3 = t4.className;
    o3.length ? le(n3).test(o3) || (t4.className += " " + n3) : t4.className = n3;
  }
  function L2(t4, n3) {
    t4.className = t4.className.replace(le(n3), " ").trim();
  }
  var ke = (t4, n3) => ({
    containers: n3,
    moves: () => true,
    accepts: () => true,
    invalid: () => false,
    isContainer: () => false,
    transformOffset: (o3) => o3,
    copy: false,
    copySortSource: false,
    revertOnSpill: false,
    removeOnSpill: false,
    direction: "vertical",
    ignoreInputTextSelection: true,
    mirrorContainer: document.body,
    ...t4
  });
  function ne(t4) {
    if (t4.touches !== void 0)
      return t4.touches.length;
    if (t4.which !== void 0 && t4.which !== 0)
      return t4.which;
    if (t4.buttons !== void 0)
      return t4.buttons;
    const n3 = t4.button;
    if (n3 !== void 0)
      return n3 & 1 ? 1 : n3 & 2 ? 3 : n3 & 4 ? 2 : 0;
  }
  var Ae = (t4) => {
    const n3 = t4.getBoundingClientRect();
    return {
      left: n3.left + re("scrollLeft", "pageXOffset"),
      top: n3.top + re("scrollTop", "pageYOffset")
    };
  };
  var re = (t4, n3) => typeof global[n3] < "u" ? global[n3] : document.documentElement.clientHeight ? document.documentElement[t4] : document.body[t4];
  var ie3 = (t4 = {}, n3, o3) => {
    const l4 = t4.className || "";
    t4.className += " gu-hide";
    const c3 = document.elementFromPoint(n3, o3);
    return t4.className = l4, c3;
  };
  var oe = (t4) => t4.width || t4.right - t4.left;
  var ce = (t4) => t4.height || t4.bottom - t4.top;
  var v3 = (t4) => t4.parentNode === document ? null : t4.parentNode;
  var ue = (t4) => ["INPUT", "TEXTAREA", "SELECT"].includes(t4.tagName) || se(t4);
  var se = (t4) => !t4 || t4.contentEditable === "false" ? false : t4.contentEditable === "true" ? true : se(v3(t4));
  var T4 = (t4) => {
    const n3 = () => {
      let o3 = t4;
      do
        o3 = o3.nextSibling;
      while (o3 && o3.nodeType !== 1);
      return o3;
    };
    return t4.nextElementSibling || n3();
  };
  window.global || (window.global = window);
  var fe = document;
  var M2 = fe.documentElement;
  function De(t4 = [], n3 = {}) {
    Array.isArray(t4) || (n3 = t4, t4 = []);
    let o3, l4, c3, d3, h3, S2, C4, X2, E3, a3, x3, N3, I2;
    const s4 = ke(n3, t4), f4 = Le({
      containers: s4.containers,
      start: ve,
      end: G3,
      cancel: q4,
      remove: W2,
      destroy: ae,
      canMove: ge,
      dragging: false
    });
    return s4.removeOnSpill && f4.on("over", he).on("out", be), j4(), f4;
    function R(e3) {
      return f4.containers.indexOf(e3) !== -1 || s4.isContainer(e3);
    }
    function j4(e3) {
      const r3 = e3 ? "removeEventListener" : "addEventListener";
      M2[r3]("pointerdown", me, true), M2[r3]("pointerup", D4, true);
    }
    function k3(e3) {
      M2[e3 ? "removeEventListener" : "addEventListener"]("pointermove", pe, true);
    }
    function H3(e3) {
      M2[e3 ? "removeEventListener" : "addEventListener"]("click", de, true);
    }
    function ae() {
      j4(true), D4({});
    }
    function de(e3) {
      I2 && e3.preventDefault();
    }
    function me(e3) {
      if (S2 = e3.clientX, C4 = e3.clientY, ne(e3) !== 1 || e3.metaKey || e3.ctrlKey)
        return;
      const i4 = e3.target, u4 = A4(i4);
      u4 && (I2 = u4, k3(), e3.type === "pointerdown" && (ue(i4) ? i4.focus() : e3.preventDefault()));
    }
    function pe(e3) {
      if (!I2)
        return;
      if (ne(e3) === 0) {
        D4({});
        return;
      }
      if (e3.clientX !== void 0 && Math.abs(e3.clientX - S2) <= (s4.slideFactorX || 0) && e3.clientY !== void 0 && Math.abs(e3.clientY - C4) <= (s4.slideFactorY || 0))
        return;
      if (s4.ignoreInputTextSelection) {
        const {
          clientX: O2 = 0,
          clientY: m3 = 0
        } = e3, w3 = fe.elementFromPoint(O2, m3);
        if (ue(w3))
          return;
      }
      const r3 = I2;
      k3(true), H3(), G3(), K3(r3);
      const i4 = Ae(c3), u4 = s4.transformOffset(i4, e3, c3), {
        pageX: g4 = 0,
        pageY: p3 = 0
      } = e3;
      d3 = g4 - u4.left, h3 = p3 - u4.top, Y2(a3 || c3, "gu-transit"), ye(), $3(e3);
    }
    function A4(e3) {
      if (f4.dragging && o3 || R(e3))
        return;
      const r3 = e3;
      for (; v3(e3) && R(v3(e3)) === false; )
        if (s4.invalid(e3, r3) || (e3 = v3(e3), !e3))
          return;
      const i4 = v3(e3);
      if (!(!i4 || s4.invalid(e3, r3) || !s4.moves(e3, i4, r3, T4(e3))))
        return {
          item: e3,
          source: i4
        };
    }
    function ge(e3) {
      return !!A4(e3);
    }
    function ve(e3) {
      const r3 = A4(e3);
      r3 && K3(r3);
    }
    function K3(e3) {
      Ee(e3.item, e3.source) && (a3 = e3.item.cloneNode(true), f4.emit("cloned", a3, e3.item, "copy")), l4 = e3.source, c3 = e3.item, X2 = E3 = T4(e3.item), f4.dragging = true, f4.emit("drag", c3, l4);
    }
    function G3() {
      if (!f4.dragging)
        return;
      const e3 = a3 || c3;
      V3(e3, v3(e3));
    }
    function U2() {
      I2 = false, k3(true), H3(true);
    }
    function D4(e3) {
      if (U2(), !f4.dragging)
        return;
      const r3 = a3 || c3, {
        clientX: i4 = 0,
        clientY: u4 = 0
      } = e3, g4 = ie3(o3, i4, u4), p3 = J3(g4, i4, u4);
      p3 && (a3 && s4.copySortSource || !a3 || p3 !== l4) ? V3(r3, p3) : s4.removeOnSpill ? W2() : q4();
    }
    function V3(e3, r3) {
      const i4 = v3(e3);
      a3 && s4.copySortSource && r3 === l4 && i4.removeChild(c3), P5(r3) ? f4.emit("cancel", e3, l4, l4) : f4.emit("drop", e3, r3, l4, E3), F4();
    }
    function W2() {
      if (!f4.dragging)
        return;
      const e3 = a3 || c3, r3 = v3(e3);
      r3 && r3.removeChild(e3), f4.emit(a3 ? "cancel" : "remove", e3, r3, l4), F4();
    }
    function q4(e3) {
      if (!f4.dragging)
        return;
      const r3 = arguments.length > 0 ? e3 : s4.revertOnSpill, i4 = a3 || c3, u4 = v3(i4), g4 = P5(u4);
      g4 === false && r3 && (a3 ? u4 && u4.removeChild(a3) : l4.insertBefore(i4, X2)), g4 || r3 ? f4.emit("cancel", i4, l4, l4) : f4.emit("drop", i4, u4, l4, E3), F4();
    }
    function F4() {
      const e3 = a3 || c3;
      U2(), Se(), e3 && L2(e3, "gu-transit"), x3 && clearTimeout(x3), f4.dragging = false, N3 && f4.emit("out", e3, N3, l4), f4.emit("dragend", e3), l4 = c3 = a3 = X2 = E3 = x3 = N3 = null;
    }
    function P5(e3, r3) {
      let i4;
      return r3 !== void 0 ? i4 = r3 : o3 ? i4 = E3 : i4 = T4(a3 || c3), e3 === l4 && i4 === X2;
    }
    function J3(e3, r3, i4) {
      let u4 = e3;
      for (; u4 && !g4(); )
        u4 = v3(u4);
      return u4;
      function g4() {
        if (R(u4) === false)
          return false;
        const O2 = Q2(u4, e3), m3 = Z2(u4, O2, r3, i4);
        return P5(u4, m3) ? true : s4.accepts(c3, u4, l4, m3);
      }
    }
    function $3(e3) {
      if (!o3)
        return;
      e3.preventDefault();
      const {
        clientX: r3 = 0,
        clientY: i4 = 0
      } = e3, u4 = r3 - d3, g4 = i4 - h3;
      o3.style.left = u4 + "px", o3.style.top = g4 + "px";
      const p3 = a3 || c3, O2 = ie3(o3, r3, i4);
      let m3 = J3(O2, r3, i4);
      const w3 = m3 !== null && m3 !== N3;
      (w3 || m3 === null) && (we(), N3 = m3, Ce());
      const b2 = v3(p3);
      if (m3 === l4 && a3 && !s4.copySortSource) {
        b2 && b2.removeChild(p3);
        return;
      }
      let y3;
      const B4 = Q2(m3, O2);
      if (B4 !== null)
        y3 = Z2(m3, B4, r3, i4);
      else if (s4.revertOnSpill === true && !a3)
        y3 = X2, m3 = l4;
      else {
        a3 && b2 && b2.removeChild(p3);
        return;
      }
      (y3 === null && w3 || y3 !== p3 && y3 !== T4(p3)) && (E3 = y3, m3.insertBefore(p3, y3), f4.emit("shadow", p3, m3, l4));
      function _3(Oe) {
        f4.emit(Oe, p3, N3, l4);
      }
      function Ce() {
        w3 && _3("over");
      }
      function we() {
        N3 && _3("out");
      }
    }
    function he(e3) {
      L2(e3, "gu-hide");
    }
    function be(e3) {
      f4.dragging && Y2(e3, "gu-hide");
    }
    function ye() {
      if (o3)
        return;
      const e3 = c3.getBoundingClientRect();
      o3 = c3.cloneNode(true), o3.style.width = oe(e3) + "px", o3.style.height = ce(e3) + "px", L2(o3, "gu-transit"), Y2(o3, "gu-mirror"), s4.mirrorContainer.appendChild(o3), M2.addEventListener("pointermove", $3), Y2(s4.mirrorContainer, "gu-unselectable"), f4.emit("cloned", o3, c3, "mirror");
    }
    function Se() {
      o3 && (L2(s4.mirrorContainer, "gu-unselectable"), M2.removeEventListener("pointermove", $3), v3(o3).removeChild(o3), o3 = null);
    }
    function Q2(e3, r3) {
      let i4 = r3;
      for (; i4 !== e3 && v3(i4) !== e3; )
        i4 = v3(i4);
      return i4 === M2 ? null : i4;
    }
    function Z2(e3, r3, i4, u4) {
      const g4 = (typeof s4.direction == "function" ? s4.direction(c3, e3, l4) : s4.direction) === "horizontal";
      return r3 !== e3 ? m3() : O2();
      function O2() {
        const b2 = e3.children.length;
        let y3, B4, _3;
        for (y3 = 0; y3 < b2; y3++)
          if (B4 = e3.children[y3], _3 = B4.getBoundingClientRect(), g4 && _3.left + _3.width / 2 > i4 || !g4 && _3.top + _3.height / 2 > u4)
            return B4;
        return null;
      }
      function m3() {
        const b2 = r3.getBoundingClientRect();
        return w3(g4 ? i4 > b2.left + oe(b2) / 2 : u4 > b2.top + ce(b2) / 2);
      }
      function w3(b2) {
        return b2 ? T4(r3) : r3;
      }
    }
    function Ee(e3, r3) {
      return typeof s4.copy == "boolean" ? s4.copy : s4.copy(e3, r3);
    }
  }

  // node_modules/min-dom/dist/index.esm.js
  function _mergeNamespaces(n3, m3) {
    m3.forEach(function(e3) {
      e3 && typeof e3 !== "string" && !Array.isArray(e3) && Object.keys(e3).forEach(function(k3) {
        if (k3 !== "default" && !(k3 in n3)) {
          var d3 = Object.getOwnPropertyDescriptor(e3, k3);
          Object.defineProperty(n3, k3, d3.get ? d3 : {
            enumerable: true,
            get: function() {
              return e3[k3];
            }
          });
        }
      });
    });
    return Object.freeze(n3);
  }
  var toString3 = Object.prototype.toString;
  function classes(el) {
    return new ClassList(el);
  }
  function ClassList(el) {
    if (!el || !el.nodeType) {
      throw new Error("A DOM element reference is required");
    }
    this.el = el;
    this.list = el.classList;
  }
  ClassList.prototype.add = function(name2) {
    this.list.add(name2);
    return this;
  };
  ClassList.prototype.remove = function(name2) {
    if ("[object RegExp]" == toString3.call(name2)) {
      return this.removeMatching(name2);
    }
    this.list.remove(name2);
    return this;
  };
  ClassList.prototype.removeMatching = function(re2) {
    const arr = this.array();
    for (let i4 = 0; i4 < arr.length; i4++) {
      if (re2.test(arr[i4])) {
        this.remove(arr[i4]);
      }
    }
    return this;
  };
  ClassList.prototype.toggle = function(name2, force) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name2, force)) {
        this.list.toggle(name2);
      }
    } else {
      this.list.toggle(name2);
    }
    return this;
  };
  ClassList.prototype.array = function() {
    return Array.from(this.list);
  };
  ClassList.prototype.has = ClassList.prototype.contains = function(name2) {
    return this.list.contains(name2);
  };
  var componentEvent = {};
  var bind$1;
  var unbind$1;
  var prefix;
  function detect() {
    bind$1 = window.addEventListener ? "addEventListener" : "attachEvent";
    unbind$1 = window.removeEventListener ? "removeEventListener" : "detachEvent";
    prefix = bind$1 !== "addEventListener" ? "on" : "";
  }
  var bind_1 = componentEvent.bind = function(el, type3, fn4, capture) {
    if (!bind$1) detect();
    el[bind$1](prefix + type3, fn4, capture || false);
    return fn4;
  };
  var unbind_1 = componentEvent.unbind = function(el, type3, fn4, capture) {
    if (!unbind$1) detect();
    el[unbind$1](prefix + type3, fn4, capture || false);
    return fn4;
  };
  var event = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    bind: bind_1,
    unbind: unbind_1,
    "default": componentEvent
  }, [componentEvent]);
  var domify = parse3;
  var innerHTMLBug = false;
  var bugTestDiv;
  if (typeof document !== "undefined") {
    bugTestDiv = document.createElement("div");
    bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
    innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length;
    bugTestDiv = void 0;
  }
  var map2 = {
    legend: [1, "<fieldset>", "</fieldset>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
    // for script/link/style tags to work in IE6-8, you have to wrap
    // in a div with a non-whitespace character in front, ha!
    _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
  };
  map2.td = map2.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
  map2.option = map2.optgroup = [1, '<select multiple="multiple">', "</select>"];
  map2.thead = map2.tbody = map2.colgroup = map2.caption = map2.tfoot = [1, "<table>", "</table>"];
  map2.polyline = map2.ellipse = map2.polygon = map2.circle = map2.text = map2.line = map2.path = map2.rect = map2.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"];
  function parse3(html3, doc2) {
    if ("string" != typeof html3) throw new TypeError("String expected");
    if (!doc2) doc2 = document;
    var m3 = /<([\w:]+)/.exec(html3);
    if (!m3) return doc2.createTextNode(html3);
    html3 = html3.replace(/^\s+|\s+$/g, "");
    var tag4 = m3[1];
    if (tag4 == "body") {
      var el = doc2.createElement("html");
      el.innerHTML = html3;
      return el.removeChild(el.lastChild);
    }
    var wrap2 = Object.prototype.hasOwnProperty.call(map2, tag4) ? map2[tag4] : map2._default;
    var depth = wrap2[0];
    var prefix2 = wrap2[1];
    var suffix = wrap2[2];
    var el = doc2.createElement("div");
    el.innerHTML = prefix2 + html3 + suffix;
    while (depth--) el = el.lastChild;
    if (el.firstChild == el.lastChild) {
      return el.removeChild(el.firstChild);
    }
    var fragment = doc2.createDocumentFragment();
    while (el.firstChild) {
      fragment.appendChild(el.removeChild(el.firstChild));
    }
    return fragment;
  }
  var domify$1 = domify;
  function query(selector, el) {
    el = el || document;
    return el.querySelector(selector);
  }

  // node_modules/array-move/index.js
  function arrayMoveMutable(array, fromIndex, toIndex) {
    const startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;
    if (startIndex >= 0 && startIndex < array.length) {
      const endIndex = toIndex < 0 ? array.length + toIndex : toIndex;
      const [item] = array.splice(fromIndex, 1);
      array.splice(endIndex, 0, item);
    }
  }

  // node_modules/lang-feel/dist/index.js
  var snippets = [snippetCompletion("function(${params}) ${body}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }), snippetCompletion("for ${var} in ${collection} return ${value}", {
    label: "for",
    detail: "expression",
    type: "keyword"
  }), snippetCompletion("every ${var} in ${collection} satisfies ${condition}", {
    label: "every",
    detail: "quantified expression",
    type: "keyword"
  }), snippetCompletion("some ${var} in ${collection} satisfies ${condition}", {
    label: "some",
    detail: "quantified expression",
    type: "keyword"
  }), snippetCompletion("if ${condition} then ${value} else ${other value}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }), snippetCompletion("{ ${key}: ${value} }", {
    label: "context",
    detail: "block",
    type: "keyword"
  }), snippetCompletion("null", {
    label: "null",
    detail: "literal",
    type: "keyword"
  }), snippetCompletion("true", {
    label: "true",
    detail: "literal",
    type: "keyword"
  }), snippetCompletion("false", {
    label: "false",
    detail: "literal",
    type: "keyword"
  })];
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function contextualKeyword(options2) {
    const {
      context: nodes,
      after,
      before: before3,
      keyword: keyword2
    } = options2;
    return ifInside({
      nodes,
      before: before3,
      after,
      keyword: keyword2
    }, completeFromList([{
      label: keyword2,
      type: "keyword",
      boost: 10
    }]));
  }
  var keywordCompletions = [contextualKeyword({
    context: "InExpression",
    keyword: "in"
  }), contextualKeyword({
    context: "IfExpression",
    keyword: "then",
    after: "if",
    before: "else"
  }), contextualKeyword({
    context: "IfExpression",
    keyword: "else",
    after: "then"
  }), contextualKeyword({
    context: "QuantifiedExpression",
    keyword: "satisfies"
  }), contextualKeyword({
    context: "ForExpression",
    after: "InExpressions",
    keyword: "return"
  })];
  var dontComplete = ["StringLiteral", "Identifier", "LineComment", "BlockComment", "PathExpression", "Context", "Key", "ParameterName"];
  var doComplete = ["Expr", "ContextEntry"];
  function ifExpression(completionSource) {
    const allNodes = [...dontComplete, ...doComplete];
    return (context) => {
      const {
        state,
        pos
      } = context;
      const match2 = matchUp(syntaxTree(state).resolveInner(pos, -1), allNodes);
      if (match2) {
        const [_3, name2] = match2;
        if (dontComplete.includes(name2)) {
          return null;
        }
      }
      return completionSource(context);
    };
  }
  function snippetCompletion2(snippets2) {
    return ifExpression(completeFromList(snippets2.map((s4) => _extends2({}, s4, {
      type: "text"
    }))));
  }
  function matchLeft(node, position, nodes) {
    return matchChildren(node, position, nodes, -1);
  }
  function matchRight(node, position, nodes) {
    return matchChildren(node, position, nodes, 1);
  }
  function matchChildren(node, position, nodes, direction) {
    let child = node[direction > 0 ? "childAfter" : "childBefore"](position);
    while (child) {
      if (nodes.includes(child.name)) {
        return child;
      }
      if (child.type.isError && child.firstChild) {
        if (nodes.includes(child.firstChild.name)) {
          return child.firstChild;
        }
      }
      child = child[direction > 0 ? "nextSibling" : "prevSibling"];
    }
    return null;
  }
  function matchUp(node, nodeNames) {
    if (!Array.isArray(nodeNames)) {
      nodeNames = [nodeNames];
    }
    for (; node; node = node.parent) {
      const nodeType = node.type;
      const matchedName = nodeNames.find((name2) => name2 && nodeType.is(name2));
      if (matchedName) {
        return [node, matchedName];
      }
      if (nodeType.isTop) {
        break;
      }
    }
    return null;
  }
  function ifInside(options2, source) {
    const {
      nodes,
      before: before3,
      after,
      keyword: keyword2
    } = options2;
    return (context) => {
      const {
        state,
        pos
      } = context;
      const match2 = matchUp(syntaxTree(state).resolveInner(pos, -1), nodes);
      if (!match2) {
        return null;
      }
      const [node] = match2;
      if (matchLeft(node, pos, [keyword2, before3])) {
        return null;
      }
      if (matchRight(node, pos, [keyword2, after])) {
        return null;
      }
      if (after && !matchLeft(node, pos, [after])) {
        return null;
      }
      return source(context);
    };
  }
  var feelLanguage = LRLanguage.define({
    parser: parser.configure({
      props: [indentNodeProp.add({
        "Context": delimitedIndent({
          closing: "}"
        }),
        "List FilterExpression": delimitedIndent({
          closing: "]"
        }),
        "ParenthesizedExpression FunctionInvocation": continuedIndent({
          except: /^\s*\)/
        }),
        "ForExpression QuantifiedExpression IfExpression": continuedIndent({
          except: /^\s*(then|else|return|satisfies)\b/
        }),
        "FunctionDefinition": continuedIndent({
          except: /^\s*(\(|\))/
        })
      }), foldNodeProp.add({
        Context: foldInside,
        List: foldInside,
        ParenthesizedExpression: foldInside,
        FunctionDefinition(node) {
          const last2 = node.getChild(")");
          if (!last2) return null;
          return {
            from: last2.to,
            to: node.to
          };
        }
      })]
    }),
    languageData: {
      indentOnInput: /^\s*(\)|\}|\]|then|else|return|satisfies)$/,
      commentTokens: {
        line: "//",
        block: {
          open: "/*",
          close: "*/"
        }
      }
    }
  });
  var unaryTestsLanguage = feelLanguage.configure({
    top: "UnaryTests"
  }, "FEEL unary tests");
  var expressionLanguage = feelLanguage.configure({
    top: "Expression"
  }, "FEEL expression");
  function feel2(config2 = {}) {
    const language3 = config2.dialect === "unaryTests" ? unaryTestsLanguage : expressionLanguage;
    const dialect = config2.parserDialect;
    const contextTracker = trackVariables(config2.context);
    const contextualLang = language3.configure({
      contextTracker,
      dialect
    });
    const completions2 = config2.completions || [snippetCompletion2(snippets), keywordCompletions].flat();
    return new LanguageSupport(contextualLang, [...completions2.map((autocomplete) => contextualLang.data.of({
      autocomplete
    }))]);
  }

  // node_modules/@bpmn-io/feel-editor/dist/index.es.js
  var linter2 = [linter(cmFeelLinter())];
  var baseTheme5 = EditorView.theme({
    "& .cm-content": {
      padding: "0px"
    },
    "& .cm-line": {
      padding: "0px"
    },
    "&.cm-editor.cm-focused": {
      outline: "none"
    },
    "& .cm-completionInfo": {
      whiteSpace: "pre-wrap",
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    "&.cm-editor": {
      height: "100%"
    },
    // Don't wrap whitespace for custom HTML
    "& .cm-completionInfo > *": {
      whiteSpace: "normal"
    },
    "& .cm-completionInfo ul": {
      margin: 0,
      paddingLeft: "15px"
    },
    "& .cm-completionInfo pre": {
      marginBottom: 0,
      whiteSpace: "pre-wrap"
    },
    "& .cm-completionInfo p": {
      marginTop: 0
    },
    "& .cm-completionInfo p:not(:last-of-type)": {
      marginBottom: 0
    }
  });
  var highlightTheme = EditorView.baseTheme({
    "& .variableName": {
      color: "#10f"
    },
    "& .number": {
      color: "#164"
    },
    "& .string": {
      color: "#a11"
    },
    "& .bool": {
      color: "#219"
    },
    "& .function": {
      color: "#aa3731",
      fontWeight: "bold"
    },
    "& .control": {
      color: "#708"
    }
  });
  var syntaxClasses = syntaxHighlighting(
    HighlightStyle.define([
      { tag: tags.variableName, class: "variableName" },
      { tag: tags.name, class: "variableName" },
      { tag: tags.number, class: "number" },
      { tag: tags.string, class: "string" },
      { tag: tags.bool, class: "bool" },
      { tag: tags.function(tags.variableName), class: "function" },
      { tag: tags.function(tags.special(tags.variableName)), class: "function" },
      { tag: tags.controlKeyword, class: "control" },
      { tag: tags.operatorKeyword, class: "control" }
    ])
  );
  var theme3 = [baseTheme5, highlightTheme, syntaxClasses];
  function _isEmpty(node) {
    return node && node.from === node.to;
  }
  function isEmpty(node, pos) {
    const nextNode = node.nextSibling;
    return _isEmpty(node) || nextNode && nextNode.from === pos && _isEmpty(nextNode);
  }
  function isVariableName(node) {
    return node && node.parent && node.parent.name === "VariableName";
  }
  function isPathExpression(node) {
    if (!node) {
      return false;
    }
    if (node.name === "PathExpression") {
      return true;
    }
    return isPathExpression(node.parent);
  }
  function pathExpressionCompletion({ variables }) {
    return (context) => {
      const nodeBefore = syntaxTree(context.state).resolve(context.pos, -1);
      if (!isPathExpression(nodeBefore)) {
        return;
      }
      const expression = findPathExpression(nodeBefore);
      const from = nodeBefore === expression ? context.pos : nodeBefore.from;
      const path2 = getPath(expression, context);
      let options2 = variables;
      for (var i4 = 0; i4 < path2.length - 1; i4++) {
        var childVar = options2.find((val) => val.name === path2[i4].name);
        if (!childVar) {
          return null;
        }
        if (childVar.isList !== "optional" && !!childVar.isList !== path2[i4].isList) {
          return;
        }
        options2 = childVar.entries;
      }
      if (!options2) return;
      options2 = options2.map((v4) => ({
        label: v4.name,
        type: "variable",
        info: v4.info,
        detail: v4.detail
      }));
      const result = {
        from,
        options: options2
      };
      return result;
    };
  }
  function findPathExpression(node) {
    while (node) {
      if (node.name === "PathExpression") {
        return node;
      }
      node = node.parent;
    }
  }
  function getPath(node, context) {
    let path2 = [];
    for (let child = node.firstChild; child; child = child.nextSibling) {
      if (child.name === "PathExpression") {
        path2.push(...getPath(child, context));
      } else if (child.name === "FilterExpression") {
        path2.push(...getFilter(child, context));
      } else {
        path2.push({
          name: getNodeContent(child, context),
          isList: false
        });
      }
    }
    return path2;
  }
  function getFilter(node, context) {
    const list2 = node.firstChild;
    if (list2.name === "PathExpression") {
      const path2 = getPath(list2, context);
      const last2 = path2[path2.length - 1];
      last2.isList = true;
      return path2;
    }
    return [{
      name: getNodeContent(list2, context),
      isList: true
    }];
  }
  function getNodeContent(node, context) {
    return context.state.sliceDoc(node.from, node.to);
  }
  function variableCompletion({ variables = [], builtins: builtins3 = [] }) {
    const options2 = getVariableSuggestions(variables, builtins3);
    if (!options2.length) {
      return (context) => null;
    }
    return (context) => {
      const {
        pos,
        state
      } = context;
      const nodeBefore = syntaxTree(state).resolve(pos, -1);
      if (isEmpty(nodeBefore, pos)) {
        return context.explicit ? {
          from: pos,
          options: options2
        } : null;
      }
      if (!isVariableName(nodeBefore) || isPathExpression(nodeBefore)) {
        return null;
      }
      return {
        from: nodeBefore.from,
        options: options2
      };
    };
  }
  function getVariableSuggestions(variables, builtins3) {
    return [].concat(
      variables.map((v4) => createVariableSuggestion(v4)),
      builtins3.map((b2) => createVariableSuggestion(b2))
    );
  }
  function createVariableSuggestion(variable, boost) {
    if (variable.type === "function") {
      return createFunctionVariable(variable, boost);
    }
    return {
      label: variable.name,
      type: "variable",
      info: variable.info,
      detail: variable.detail,
      boost
    };
  }
  function createFunctionVariable(variable, boost) {
    const {
      name: name2,
      info,
      detail,
      params = []
    } = variable;
    const paramsWithNames = params.map(({ name: name3, type: type3 }, index2) => ({
      name: name3 || `param ${index2 + 1}`,
      type: type3
    }));
    const template = `${name2}(${paramsWithNames.map((p3) => "${" + p3.name + "}").join(", ")})`;
    const paramsSignature = paramsWithNames.map(({ name: name3, type: type3 }) => type3 ? `${name3}: ${type3}` : name3).join(", ");
    const label = `${name2}(${paramsSignature})`;
    return snippetCompletion(template, {
      label,
      type: "function",
      info,
      detail,
      boost
    });
  }
  function completions({ variables = [], builtins: builtins3 = [] }) {
    return [
      pathExpressionCompletion({ variables }),
      variableCompletion({ variables, builtins: builtins3 }),
      snippetCompletion2(snippets.map((snippet2) => ({ ...snippet2, boost: -1 }))),
      ...keywordCompletions
    ];
  }
  function language2(options2) {
    return feel2(options2);
  }
  function createContext(variables) {
    return variables.slice().reverse().reduce((context, builtin) => {
      context[builtin.name] = () => {
      };
      return context;
    }, {});
  }
  var builtinsFacet = Facet.define();
  var variablesFacet = Facet.define();
  var dialectFacet = Facet.define();
  var parserDialectFacet = Facet.define();
  function configure({
    dialect = "expression",
    parserDialect,
    variables = [],
    builtins: builtins3 = [],
    completions: completions$1 = completions({ builtins: builtins3, variables })
  }) {
    const context = createContext([...variables, ...builtins3]);
    return [
      dialectFacet.of(dialect),
      builtinsFacet.of(builtins3),
      variablesFacet.of(variables),
      parserDialectFacet.of(parserDialect),
      language2({
        dialect,
        parserDialect,
        context,
        completions: completions$1
      })
    ];
  }
  function get2(state) {
    const builtins3 = state.facet(builtinsFacet)[0];
    const variables = state.facet(variablesFacet)[0];
    const dialect = state.facet(dialectFacet)[0];
    const parserDialect = state.facet(parserDialectFacet)[0];
    return {
      builtins: builtins3,
      variables,
      dialect,
      parserDialect
    };
  }
  var camundaTags = [
    {
      name: "not(negand)",
      description: '<p>Returns the logical negation of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">not(negand: boolean): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">not(true)\n// false\n\nnot(null)\n// null\n</code></pre>\n'
    },
    {
      name: "is defined(value)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Checks if a given value is not <code>null</code>. If the value is <code>null</code> then the function returns <code>false</code>.\nOtherwise, the function returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is defined(value: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is defined(1)\n// true\n\nis defined(null)\n// false\n\nis defined(x)\n// false - if no variable &quot;x&quot; exists\n\nis defined(x.y)\n// false - if no variable &quot;x&quot; exists or it doesn&#39;t have a property &quot;y&quot;\n</code></pre>\n<p>:::caution Breaking change</p>\n<p>This function worked differently in previous versions. It returned <code>true</code> if the value was <code>null</code>.\nSince this version, the function returns <code>false</code> if the value is <code>null</code>.</p>\n<p>:::</p>\n'
    },
    {
      name: "get or else(value, default)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Return the provided value parameter if not <code>null</code>, otherwise return the default parameter</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get or else(value: Any, default: Any): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get or else(&quot;this&quot;, &quot;default&quot;)\n// &quot;this&quot;\n\nget or else(null, &quot;default&quot;)\n// &quot;default&quot;\n\nget or else(null, null)\n// null\n</code></pre>\n'
    },
    {
      name: "assert(value, condition)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">assert(value: Any, condition: Any)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">assert(x, x != null)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0)\n// 4 - if x is 4\n// error - if x is less than zero\n</code></pre>\n'
    },
    {
      name: "assert(value, condition, cause)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error containing the given message.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">assert(value: Any, condition: Any, cause: String)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">assert(x, x != null, &quot;&#39;x&#39; should not be null&quot;)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error(&#39;x&#39; should not be null) - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0, &quot;&#39;x&#39; should be positive&quot;)\n// 4 - if x is 4\n// error(&#39;x&#39; should be positive) - if x is less than zero\n</code></pre>\n'
    },
    {
      name: "get value(context, key)",
      description: '<p>Returns the value of the context entry with the given key.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get value(context: context, key: string): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get value({foo: 123}, &quot;foo&quot;)\n// 123\n\nget value({a: 1}, &quot;b&quot;)\n// null\n</code></pre>\n'
    },
    {
      name: "get value(context, keys)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns the value of the context entry for a context path defined by the given keys.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it returns the value at the nested entry <code>k1.k2</code> of the context.</p>\n<p>If <code>keys</code> are empty or the nested entry defined by the keys doesn&#39;t exist in the context, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get value(context: context, keys: list&lt;string&gt;): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get value({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;])\n// 0\n\nget value({x: {y: {z:0}}}, [&quot;x&quot;, &quot;y&quot;])\n// {z:0}\n\nget value({a: {b: 3}}, [&quot;b&quot;])\n// null\n</code></pre>\n'
    },
    {
      name: "get entries(context)",
      description: '<p>Returns the entries of the context as a list of key-value-pairs.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get entries(context: context): list&lt;context&gt;\n</code></pre>\n<p>The return value is a list of contexts. Each context contains two entries for &quot;key&quot; and &quot;value&quot;.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get entries({foo: 123})\n// [{key: &quot;foo&quot;, value: 123}]\n</code></pre>\n'
    },
    {
      name: "context put(context, key, value)",
      description: '<p>Adds a new entry with the given key and value to the context. Returns a new context that includes the entry.</p>\n<p>If an entry for the same key already exists in the context, it overrides the value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context put(context: context, key: string, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context put({x:1}, &quot;y&quot;, 2)\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context put()</code> replaced the previous function <code>put()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n'
    },
    {
      name: "context put(context, keys, value)",
      description: '<p>Adds a new entry with the given value to the context. The path of the entry is defined by the keys. Returns a new context that includes the entry.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it adds the nested entry <code>k1.k2 = value</code> to the context.</p>\n<p>If an entry for the same keys already exists in the context, it overrides the value.</p>\n<p>If <code>keys</code> are empty, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context put(context: context, keys: list&lt;string&gt;, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context put({x:1}, [&quot;y&quot;], 2)\n// {x:1, y:2}\n\ncontext put({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n\ncontext put({x:1}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n</code></pre>\n'
    },
    {
      name: "context merge(contexts)",
      description: '<p>Union the given contexts. Returns a new context that includes all entries of the given contexts.</p>\n<p>If an entry for the same key already exists in a context, it overrides the value. The entries are overridden in the same order as in the list of contexts.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context merge(contexts: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context merge([{x:1}, {y:2}])\n// {x:1, y:2}\n\ncontext merge([{x:1, y: 0}, {y:2}])\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context merge()</code> replaced the previous function <code>put all()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n'
    },
    {
      name: "string(from)",
      description: '<p>Returns the given value as a string representation.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string(from: Any): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string(1.1)\n// &quot;1.1&quot;\n\nstring(date(&quot;2012-12-25&quot;))\n// &quot;2012-12-25&quot;\n</code></pre>\n'
    },
    {
      name: "number(from)",
      description: '<p>Parses the given string to a number.</p>\n<p>Returns <code>null</code> if the string is not a number.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">number(from: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">number(&quot;1500.5&quot;)\n// 1500.5\n</code></pre>\n'
    },
    {
      name: "context(entries)",
      description: '<p>Constructs a context of the given list of key-value pairs. It is the reverse function to <a href="feel-built-in-functions-context.md#get-entriescontext">get entries()</a>.</p>\n<p>Each key-value pair must be a context with two entries: <code>key</code> and <code>value</code>. The entry with name <code>key</code> must have a value of the type <code>string</code>.</p>\n<p>It might override context entries if the keys are equal. The entries are overridden in the same order as the contexts in the given list.</p>\n<p>Returns <code>null</code> if one of the entries is not a context or if a context doesn&#39;t contain the required entries.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context(entries: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context([{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1}, {&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}])\n// {a:1, b:2}\n</code></pre>\n'
    },
    {
      name: "date(from)",
      description: '<p>Returns a date from the given value.</p>\n<p>Returns <code>null</code> if the string is not a valid calendar date. For example, <code>&quot;2024-06-31&quot;</code> is invalid because June has\nonly 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date(from: string): date\n</code></pre>\n<p>Parses the given string into a date.</p>\n<pre><code class="language-feel">date(from: date and time): date\n</code></pre>\n<p>Extracts the date component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date(&quot;2018-04-29&quot;)\n// date(&quot;2018-04-29&quot;)\n\ndate(date and time(&quot;2012-12-25T11:00:00&quot;))\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
    },
    {
      name: "date(year, month, day)",
      description: '<p>Returns a date from the given components.</p>\n<p>Returns <code>null</code> if the components don&#39;t represent a valid calendar date. For example, <code>2024,6,31</code> is invalid because\nJune has only 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date(year: number, month: number, day: number): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date(2012, 12, 25)\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
    },
    {
      name: "time(from)",
      description: '<p>Returns a time from the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(from: string): time\n</code></pre>\n<p>Parses the given string into a time.</p>\n<pre><code class="language-feel">time(from: date and time): time\n</code></pre>\n<p>Extracts the time component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(&quot;12:00:00&quot;)\n// time(&quot;12:00:00&quot;)\n\ntime(date and time(&quot;2012-12-25T11:00:00&quot;))\n// time(&quot;11:00:00&quot;)\n</code></pre>\n'
    },
    {
      name: "time(hour, minute, second)",
      description: '<p>Returns a time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(hour: number, minute: number, second: number): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(23, 59, 0)\n// time(&quot;23:59:00&quot;)\n</code></pre>\n'
    },
    {
      name: "time(hour, minute, second, offset)",
      description: '<p>Returns a time from the given components, including a timezone offset.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(hour: number, minute: number, second: number, offset: days and time duration): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(14, 30, 0, duration(&quot;PT1H&quot;))\n// time(&quot;14:30:00+01:00&quot;)\n</code></pre>\n'
    },
    {
      name: "date and time(from)",
      description: '<p>Parses the given string into a date and time.</p>\n<p>Returns <code>null</code> if the string is not a valid calendar date. For example, <code>&quot;2024-06-31T10:00:00&quot;</code> is invalid because\nJune has only 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(from: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(&quot;2018-04-29T09:30:00&quot;)\n// date and time(&quot;2018-04-29T09:30:00&quot;)\n</code></pre>\n'
    },
    {
      name: "date and time(date, time)",
      description: '<p>Returns a date and time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(date: date, time: time): date and time\n</code></pre>\n<pre><code class="language-feel">date and time(date: date and time, time: time): date and time\n</code></pre>\n<p>Returns a date and time value that consists of the date component of <code>date</code> combined with <code>time</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(date(&quot;2012-12-24&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-24T23:59:00&quot;)\n\ndate and time(date and time(&quot;2012-12-25T11:00:00&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-25T23:59:00&quot;)\n</code></pre>\n'
    },
    {
      name: "date and time(date, timezone)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given date and time value at the given timezone.</p>\n<p>If <code>date</code> has a different timezone than <code>timezone</code> then it adjusts the time to match the local time of <code>timezone</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(date: date and time, timezone: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(@&quot;2020-07-31T14:27:30@Europe/Berlin&quot;, &quot;America/Los_Angeles&quot;)\n// date and time(&quot;2020-07-31T05:27:30@America/Los_Angeles&quot;)\n\ndate and time(@&quot;2020-07-31T14:27:30&quot;, &quot;Z&quot;)\n// date and time(&quot;2020-07-31T12:27:30Z&quot;)\n</code></pre>\n'
    },
    {
      name: "duration(from)",
      description: '<p>Parses the given string into a duration. The duration is either a days and time duration or a years and months duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">duration(from: string): days and time duration\n</code></pre>\n<pre><code class="language-feel">duration(from: string): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">duration(&quot;P5D&quot;)\n// duration(&quot;P5D&quot;)\n\nduration(&quot;P32Y&quot;)\n// duration(&quot;P32Y&quot;)\n</code></pre>\n'
    },
    {
      name: "years and months duration(from, to)",
      description: '<p>Returns the years and months duration between <code>from</code> and <code>to</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">years and months duration(from: date, to: date): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">years and months duration(date(&quot;2011-12-22&quot;), date(&quot;2013-08-24&quot;))\n// duration(&quot;P1Y8M&quot;)\n</code></pre>\n'
    },
    {
      name: "list contains(list, element)",
      description: '<p>Returns <code>true</code> if the given list contains the element. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">list contains(list: list, element: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">list contains([1,2,3], 2)\n// true\n</code></pre>\n'
    },
    {
      name: "count(list)",
      description: '<p>Returns the number of elements of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">count(list: list): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">count([1,2,3])\n// 3\n</code></pre>\n'
    },
    {
      name: "min(list)",
      description: '<p>Returns the minimum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">min(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">min([1,2,3])\n// 1\n\nmin(1,2,3)\n// 1\n</code></pre>\n'
    },
    {
      name: "max(list)",
      description: '<p>Returns the maximum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">max(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">max([1,2,3])\n// 3\n\nmax(1,2,3)\n// 3\n</code></pre>\n'
    },
    {
      name: "sum(list)",
      description: '<p>Returns the sum of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sum(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sum([1,2,3])\n// 6\n\nsum(1,2,3)\n// 6\n</code></pre>\n'
    },
    {
      name: "product(list)",
      description: '<p>Returns the product of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">product(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">product([2, 3, 4])\n// 24\n\nproduct(2, 3, 4)\n// 24\n</code></pre>\n'
    },
    {
      name: "mean(list)",
      description: '<p>Returns the arithmetic mean (i.e. average) of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">mean(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">mean([1,2,3])\n// 2\n\nmean(1,2,3)\n// 2\n</code></pre>\n'
    },
    {
      name: "median(list)",
      description: '<p>Returns the median element of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">median(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">median(8, 2, 5, 3, 4)\n// 4\n\nmedian([6, 1, 2, 3])\n// 2.5\n</code></pre>\n'
    },
    {
      name: "stddev(list)",
      description: '<p>Returns the standard deviation of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">stddev(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">stddev(2, 4, 7, 5)\n// 2.0816659994661326\n\nstddev([2, 4, 7, 5])\n// 2.0816659994661326\n</code></pre>\n'
    },
    {
      name: "mode(list)",
      description: '<p>Returns the mode of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">mode(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">mode(6, 3, 9, 6, 6)\n// [6]\n\nmode([6, 1, 9, 6, 1])\n// [1, 6]\n</code></pre>\n'
    },
    {
      name: "all(list)",
      description: '<p>Returns <code>false</code> if any element of the given list is <code>false</code>. Otherwise, returns <code>true</code>.</p>\n<p>If the given list is empty, it returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">all(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">all([true,false])\n// false\n\nall(false,null,true)\n// false\n</code></pre>\n<p>:::info\nThe function <code>all()</code> replaced the previous function <code>and()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n'
    },
    {
      name: "any(list)",
      description: '<p>Returns <code>true</code> if any element of the given list is <code>true</code>. Otherwise, returns <code>false</code>.</p>\n<p>If the given list is empty, it returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">any(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">any([false,true])\n// true\n\nany(false,null,true)\n// true\n</code></pre>\n<p>:::info\nThe function <code>any()</code> replaced the previous function <code>or()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n'
    },
    {
      name: "sublist(list, start position)",
      description: '<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sublist(list: list, start position: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sublist([1,2,3], 2)\n// [2,3]\n</code></pre>\n'
    },
    {
      name: "sublist(list, start position, length)",
      description: '<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sublist(list: list, start position: number, length: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sublist([1,2,3], 1, 2)\n// [1,2]\n</code></pre>\n'
    },
    {
      name: "append(list, items)",
      description: '<p>Returns the given list with all <code>items</code> appended.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">append(list: list, items: Any): list\n</code></pre>\n<p>The parameter <code>items</code> can be a single element or a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">append([1], 2, 3)\n// [1,2,3]\n</code></pre>\n'
    },
    {
      name: "concatenate(lists)",
      description: '<p>Returns a list that includes all elements of the given lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">concatenate(lists: list): list\n</code></pre>\n<p>The parameter <code>lists</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">concatenate([1,2],[3])\n// [1,2,3]\n\nconcatenate([1],[2],[3])\n// [1,2,3]\n</code></pre>\n'
    },
    {
      name: "insert before(list, position, newItem)",
      description: '<p>Returns the given list with <code>newItem</code> inserted at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">insert before(list: list, position: number, newItem: Any): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">insert before([1,3],1,2)\n// [2,1,3]\n</code></pre>\n'
    },
    {
      name: "remove(list, position)",
      description: '<p>Returns the given list without the element at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">remove(list: list, position: number): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">remove([1,2,3], 2)\n// [1,3]\n</code></pre>\n'
    },
    {
      name: "reverse(list)",
      description: '<p>Returns the given list in revered order.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">reverse(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">reverse([1,2,3])\n// [3,2,1]\n</code></pre>\n'
    },
    {
      name: "index of(list, match)",
      description: '<p>Returns an ascending list of positions containing <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">index of(list: list, match: Any): list&lt;number&gt;\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">index of([1,2,3,2],2)\n// [2,4]\n</code></pre>\n'
    },
    {
      name: "union(list)",
      description: '<p>Returns a list that includes all elements of the given lists without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">union(list: list): list\n</code></pre>\n<p>The parameter <code>list</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">union([1,2],[2,3])\n// [1,2,3]\n</code></pre>\n'
    },
    {
      name: "distinct values(list)",
      description: '<p>Returns the given list without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">distinct values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">distinct values([1,2,3,2,1])\n// [1,2,3]\n</code></pre>\n'
    },
    {
      name: "duplicate values(list)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns all duplicate values of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">duplicate values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">duplicate values([1,2,3,2,1])\n// [1,2]\n</code></pre>\n'
    },
    {
      name: "flatten(list)",
      description: '<p>Returns a list that includes all elements of the given list without nested lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">flatten(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">flatten([[1,2],[[3]], 4])\n// [1,2,3,4]\n</code></pre>\n'
    },
    {
      name: "sort(list, precedes)",
      description: '<p>Returns the given list sorted by the <code>precedes</code> function.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sort(list: list, precedes: function&lt;(Any, Any) -&gt; boolean&gt;): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sort(list: [3,1,4,5,2], precedes: function(x,y) x &lt; y)\n// [1,2,3,4,5]\n</code></pre>\n'
    },
    {
      name: "string join(list)",
      description: '<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])\n// &quot;abc&quot;\n\nstring join([&quot;a&quot;,null,&quot;c&quot;])\n// &quot;ac&quot;\n\nstring join([])\n// &quot;&quot;\n</code></pre>\n'
    },
    {
      name: "string join(list, delimiter)",
      description: '<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string contains a <code>delimiter</code> between each element.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;, delimiter: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;], &quot;X&quot;)\n// &quot;a&quot;\n\nstring join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;)\n// &quot;a, b, c&quot;\n</code></pre>\n'
    },
    {
      name: "string join(list, delimiter, prefix, suffix)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string starts with <code>prefix</code>, contains a <code>delimiter</code> between each element, and ends\nwith <code>suffix</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;, delimiter: string, prefix: string, suffix: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;, &quot;[&quot;, &quot;]&quot;)\n// &quot;[a, b, c]&quot;\n</code></pre>\n'
    },
    {
      name: "is empty(list)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns <code>true</code> if the given list is empty. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is empty(list: list): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is empty([])\n// true\n\nis empty([1,2,3])\n// false\n</code></pre>\n'
    },
    {
      name: "partition(list\uFF0C size)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns consecutive sublists of a list, each of the same size (the final list may be smaller).</p>\n<p>If <code>size</code> is less than <code>0</code>, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">partition(list: list, size: number): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">partition([1,2,3,4,5], 2)\n// [[1,2], [3,4], [5]]\n\npartition([], 2)\n// []\n\npartition([1,2], 0)\n// null\n</code></pre>\n'
    },
    {
      name: "decimal(n, scale)",
      description: '<p>Rounds the given value at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">decimal(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">decimal(1/3, 2)\n// .33\n\ndecimal(1.5, 0)\n// 2\n</code></pre>\n'
    },
    {
      name: "floor(n)",
      description: '<p>Rounds the given value with rounding mode flooring.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">floor(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">floor(1.5)\n// 1\n\nfloor(-1.5)\n// -2\n</code></pre>\n'
    },
    {
      name: "floor(n, scale)",
      description: '<p>Rounds the given value with rounding mode flooring at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">floor(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">floor(-1.56, 1)\n// -1.6\n</code></pre>\n'
    },
    {
      name: "ceiling(n)",
      description: '<p>Rounds the given value with rounding mode ceiling.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ceiling(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ceiling(1.5)\n// 2\n\nceiling(-1.5)\n// -1\n</code></pre>\n'
    },
    {
      name: "ceiling(n, scale)",
      description: '<p>Rounds the given value with rounding mode ceiling at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ceiling(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ceiling(-1.56, 1)\n// -1.5\n</code></pre>\n'
    },
    {
      name: "round up(n, scale)",
      description: '<p>Rounds the given value with the rounding mode round-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round up(5.5)\n// 6\n\nround up(-5.5)\n// -6\n\nround up(1.121, 2)\n// 1.13\n\nround up(-1.126, 2)\n// -1.13\n</code></pre>\n'
    },
    {
      name: "round down(n, scale)",
      description: '<p>Rounds the given value with the rounding mode round-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round down(5.5, 0)\n// 5\n\nround down (-5.5, 0)\n// -5\n\nround down (1.121, 2)\n// 1.12\n\nround down (-1.126, 2)\n// -1.12\n</code></pre>\n'
    },
    {
      name: "round half up(n, scale)",
      description: '<p>Rounds the given value with the rounding mode round-half-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round half up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round half up(5.5, 0)\n// 6\n\nround half up(-5.5, 0)\n// -6\n\nround half up(1.121, 2)\n// 1.12\n\nround half up(-1.126, 2)\n// -1.13\n</code></pre>\n'
    },
    {
      name: "round half down(n, scale)",
      description: '<p>Rounds the given value with the rounding mode round-half-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round half down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round half down (5.5, 0)\n// 5\n\nround half down (-5.5, 0)\n// -5\n\nround half down (1.121, 2)\n// 1.12\n\nround half down (-1.126, 2)\n// -1.13\n</code></pre>\n'
    },
    {
      name: "abs(number)",
      description: '<p>Returns the absolute value of the given numeric value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">abs(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">abs(10)\n// 10\n\nabs(-10)\n// 10\n</code></pre>\n'
    },
    {
      name: "modulo(dividend, divisor)",
      description: '<p>Returns the remainder of the division of dividend by divisor.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">modulo(dividend: number, divisor: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">modulo(12, 5)\n// 2\n</code></pre>\n'
    },
    {
      name: "sqrt(number)",
      description: '<p>Returns the square root of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sqrt(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sqrt(16)\n// 4\n</code></pre>\n'
    },
    {
      name: "log(number)",
      description: '<p>Returns the natural logarithm (base e) of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">log(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">log(10)\n// 2.302585092994046\n</code></pre>\n'
    },
    {
      name: "exp(number)",
      description: '<p>Returns the Euler\u2019s number e raised to the power of the given number .</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">exp(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">exp(5)\n// 148.4131591025766\n</code></pre>\n'
    },
    {
      name: "odd(number)",
      description: '<p>Returns <code>true</code> if the given value is odd. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">odd(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">odd(5)\n// true\n\nodd(2)\n// false\n</code></pre>\n'
    },
    {
      name: "even(number)",
      description: '<p>Returns <code>true</code> if the given is even. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">even(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">even(5)\n// false\n\neven(2)\n// true\n</code></pre>\n'
    },
    {
      name: "random number()",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns a random number between <code>0</code> and <code>1</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">random number(): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">random number()\n// 0.9701618132579795\n</code></pre>\n'
    },
    {
      name: "before(point1, point2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before(1, 10)\n// true\n\nbefore(10, 1)\n// false\n</code></pre>\n'
    },
    {
      name: "before(range, point)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before([1..5], 10)\n// true\n</code></pre>\n'
    },
    {
      name: "before(point, range)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before(1, [2..5])\n// true\n</code></pre>\n'
    },
    {
      name: "before(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before([1..5], [6..10])\n// true\n\nbefore([1..5),[5..10])\n// true\n</code></pre>\n'
    },
    {
      name: "after(point1, point2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after(10, 1)\n// true\n\nafter(1, 10)\n// false\n</code></pre>\n'
    },
    {
      name: "after(range, point)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after([1..5], 10)\n// false\n</code></pre>\n'
    },
    {
      name: "after(point, range)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after(12, [2..5])\n// true\n</code></pre>\n'
    },
    {
      name: "after(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after([6..10], [1..5])\n// true\n\nafter([5..10], [1..5))\n// true\n</code></pre>\n'
    },
    {
      name: "meets(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">meets(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">meets([1..5], [5..10])\n// true\n\nmeets([1..3], [4..6])\n// false\n\nmeets([1..3], [3..5])\n// true\n\nmeets([1..5], (5..8])\n// false\n</code></pre>\n'
    },
    {
      name: "met by(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">met by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">met by([5..10], [1..5])\n// true\n\nmet by([3..4], [1..2])\n// false\n\nmet by([3..5], [1..3])\n// true\n\nmet by((5..8], [1..5))\n// false\n\nmet by([5..10], [1..5))\n// false\n</code></pre>\n'
    },
    {
      name: "overlaps(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps([5..10], [1..6])\n// true\n\noverlaps((3..7], [1..4])\n// true\n\noverlaps([1..3], (3..6])\n// false\n\noverlaps((5..8], [1..5))\n// false\n\noverlaps([4..10], [1..5))\n// true\n</code></pre>\n'
    },
    {
      name: "overlaps before(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps before([1..5], [4..10])\n// true\n\noverlaps before([3..4], [1..2])\n// false\n\noverlaps before([1..3], (3..5])\n// false\n\noverlaps before([1..5), (3..8])\n// true\n\noverlaps before([1..5), [5..10])\n// false\n</code></pre>\n'
    },
    {
      name: "overlaps after(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps after([4..10], [1..5])\n// true\n\noverlaps after([3..4], [1..2])\n// false\n\noverlaps after([3..5], [1..3))\n// false\n\noverlaps after((5..8], [1..5))\n// false\n\noverlaps after([4..10], [1..5))\n// true\n</code></pre>\n'
    },
    {
      name: "finishes(point, range)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finishes(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finishes(5, [1..5])\n// true\n\nfinishes(10, [1..7])\n// false\n</code></pre>\n'
    },
    {
      name: "finishes(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finishes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finishes([3..5], [1..5])\n// true\n\nfinishes((1..5], [1..5))\n// false\n\nfinishes([5..10], [1..10))\n// false\n</code></pre>\n'
    },
    {
      name: "finished by(range, point)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finished by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finished by([5..10], 10)\n// true\n\nfinished by([3..4], 2)\n// false\n</code></pre>\n'
    },
    {
      name: "finished by(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finished by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finished by([1..5], [3..5])\n// true\n\nfinished by((5..8], [1..5))\n// false\n\nfinished by([5..10], (1..10))\n// false\n</code></pre>\n'
    },
    {
      name: "includes(range, point)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">includes(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">includes([5..10], 6)\n// true\n\nincludes([3..4], 5)\n// false\n</code></pre>\n'
    },
    {
      name: "includes(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">includes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">includes([1..10], [4..6])\n// true\n\nincludes((5..8], [1..5))\n// false\n\nincludes([1..10], [1..5))\n// true\n</code></pre>\n'
    },
    {
      name: "during(point, range)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">during(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">during(5, [1..10])\n// true\n\nduring(12, [1..10])\n// false\n\nduring(1, (1..10])\n// false\n</code></pre>\n'
    },
    {
      name: "during(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">during(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">during([4..6], [1..10))\n// true\n\nduring((1..5], (1..10])\n// true\n</code></pre>\n'
    },
    {
      name: "starts(point, range)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts(1, [1..5])\n// true\n\nstarts(1, (1..8])\n// false\n</code></pre>\n'
    },
    {
      name: "starts(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts((1..5], [1..5])\n// false\n\nstarts([1..10], [1..5])\n// false\n\nstarts((1..5), (1..10))\n// true\n</code></pre>\n'
    },
    {
      name: "started by(range, point)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">started by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">started by([1..10], 1)\n// true\n\nstarted by((1..10], 1)\n// false\n</code></pre>\n'
    },
    {
      name: "started by(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">started by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">started by([1..10], [1..5])\n// true\n\nstarted by((1..10], [1..5))\n// false\n\nstarted by([1..10], [1..10))\n// true\n</code></pre>\n'
    },
    {
      name: "coincides(point1, point2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">coincides(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">coincides(5, 5)\n// true\n\ncoincides(3, 4)\n// false\n</code></pre>\n'
    },
    {
      name: "coincides(range1, range2)",
      description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">coincides(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">coincides([1..5], [1..5])\n// true\n\ncoincides((1..5], [1..5))\n// false\n\ncoincides([1..5], [2..6])\n// false\n</code></pre>\n'
    },
    {
      name: "substring(string, start position)",
      description: '<p>Returns a substring of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring(string: string, start position: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring(&quot;foobar&quot;, 3)\n// &quot;obar&quot;\n\nsubstring(&quot;foobar&quot;, -2)\n// &quot;ar&quot;\n</code></pre>\n'
    },
    {
      name: "substring(string, start position, length)",
      description: '<p>Returns a substring of the given value, starting at <code>start position</code> with the given <code>length</code>. If <code>length</code> is greater than\nthe remaining characters of the value, it returns all characters from <code>start position</code> until the end.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring(string: string, start position: number, length: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring(&quot;foobar&quot;, 3, 3)\n// &quot;oba&quot;\n\nsubstring(&quot;foobar&quot;, -3, 2)\n// &quot;ba&quot;\n\nsubstring(&quot;foobar&quot;, 3, 10)\n// &quot;obar&quot;\n</code></pre>\n'
    },
    {
      name: "string length(string)",
      description: '<p>Returns the number of characters in the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string length(string: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string length(&quot;foo&quot;)\n// 3\n</code></pre>\n'
    },
    {
      name: "upper case(string)",
      description: '<p>Returns the given value with all characters are uppercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">upper case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">upper case(&quot;aBc4&quot;)\n// &quot;ABC4&quot;\n</code></pre>\n'
    },
    {
      name: "lower case(string)",
      description: '<p>Returns the given value with all characters are lowercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">lower case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">lower case(&quot;aBc4&quot;)\n// &quot;abc4&quot;\n</code></pre>\n'
    },
    {
      name: "substring before(string, match)",
      description: '<p>Returns a substring of the given value that contains all characters before <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring before(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring before(&quot;foobar&quot;, &quot;bar&quot;)\n// &quot;foo&quot;\n</code></pre>\n'
    },
    {
      name: "substring after(string, match)",
      description: '<p>Returns a substring of the given value that contains all characters after <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring after(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring after(&quot;foobar&quot;, &quot;ob&quot;)\n// &quot;ar&quot;\n</code></pre>\n'
    },
    {
      name: "contains(string, match)",
      description: '<p>Returns <code>true</code> if the given value contains the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">contains(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">contains(&quot;foobar&quot;, &quot;of&quot;)\n// false\n</code></pre>\n'
    },
    {
      name: "starts with(string, match)",
      description: '<p>Returns <code>true</code> if the given value starts with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts with(&quot;foobar&quot;, &quot;fo&quot;)\n// true\n</code></pre>\n'
    },
    {
      name: "ends with(string, match)",
      description: '<p>Returns <code>true</code> if the given value ends with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ends with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ends with(&quot;foobar&quot;, &quot;r&quot;)\n// true\n</code></pre>\n'
    },
    {
      name: "matches(input, pattern)",
      description: '<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">matches(input: string, pattern: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">matches(&quot;foobar&quot;, &quot;^fo*bar&quot;)\n// true\n</code></pre>\n'
    },
    {
      name: "matches(input, pattern, flags)",
      description: '<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">matches(input: string, pattern: string, flags: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">matches(&quot;FooBar&quot;, &quot;foo&quot;, &quot;i&quot;)\n// true\n</code></pre>\n'
    },
    {
      name: "replace(input, pattern, replacement)",
      description: '<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">replace(input: string, pattern: string, replacement: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">replace(&quot;abcd&quot;, &quot;(ab)|(a)&quot;, &quot;[1=$1][2=$2]&quot;)\n// &quot;[1=ab][2=]cd&quot;\n\nreplace(&quot;0123456789&quot;, &quot;(\\d{3})(\\d{3})(\\d{4})&quot;, &quot;($1) $2-$3&quot;)\n// &quot;(012) 345-6789&quot;\n</code></pre>\n'
    },
    {
      name: "replace(input, pattern, replacement, flags)",
      description: '<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">replace(input: string, pattern: string, replacement: string, flags: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">replace(&quot;How do you feel?&quot;, &quot;Feel&quot;, &quot;FEEL&quot;, &quot;i&quot;)\n// &quot;How do you FEEL?&quot;\n</code></pre>\n'
    },
    {
      name: "split(string, delimiter)",
      description: '<p>Splits the given value into a list of substrings, breaking at each occurrence of the <code>delimiter</code> pattern.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">split(string: string, delimiter: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>delimiter</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">split(&quot;John Doe&quot;, &quot;\\s&quot; )\n// [&quot;John&quot;, &quot;Doe&quot;]\n\nsplit(&quot;a;b;c;;&quot;, &quot;;&quot;)\n// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]\n</code></pre>\n'
    },
    {
      name: "extract(string, pattern)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns all matches of the pattern in the given string. Returns an empty list if the pattern doesn&#39;t\nmatch.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">extract(string: string, pattern: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">extract(&quot;references are 1234, 1256, 1378&quot;, &quot;12[0-9]*&quot;)\n// [&quot;1234&quot;,&quot;1256&quot;]\n</code></pre>\n'
    },
    {
      name: "trim(string)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given string without leading and trailing spaces.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">trim(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">trim(&quot;  hello world  &quot;)\n// &quot;hello world&quot;\n\ntrim(&quot;hello   world &quot;)\n// &quot;hello   world&quot;\n</code></pre>\n'
    },
    {
      name: "uuid()",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns a UUID (Universally Unique Identifier) with 36 characters.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">uuid(): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">uuid()\n// &quot;7793aab1-d761-4d38-916b-b7270e309894&quot;\n</code></pre>\n'
    },
    {
      name: "to base64(value)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given string encoded in Base64 format.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">to base64(value: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">to base64(&quot;FEEL&quot;)\n// &quot;RkVFTA==&quot;\n</code></pre>\n'
    },
    {
      name: "is blank(string)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Returns <code>true</code> if the given string is blank (empty or contains only whitespaces).</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is blank(string: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is blank(&quot;&quot;)\n// true\n\nis blank(&quot; &quot;)\n// true\n\nis blank(&quot;hello world&quot;)\n// false\n</code></pre>\n'
    },
    {
      name: "now()",
      description: '<p>Returns the current date and time including the timezone.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">now(): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">now()\n// date and time(&quot;2020-07-31T14:27:30@Europe/Berlin&quot;)\n</code></pre>\n'
    },
    {
      name: "today()",
      description: '<p>Returns the current date.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">today(): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">today()\n// date(&quot;2020-07-31&quot;)\n</code></pre>\n'
    },
    {
      name: "day of week(date)",
      description: '<p>Returns the day of the week according to the Gregorian calendar. Note that it always returns the English name of the day.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">day of week(date: date): string\n</code></pre>\n<pre><code class="language-feel">day of week(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">day of week(date(&quot;2019-09-17&quot;))\n// &quot;Tuesday&quot;\n\nday of week(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;Tuesday&quot;\n</code></pre>\n'
    },
    {
      name: "day of year(date)",
      description: '<p>Returns the Gregorian number of the day within the year.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">day of year(date: date): number\n</code></pre>\n<pre><code class="language-feel">day of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">day of year(date(&quot;2019-09-17&quot;))\n// 260\n\nday of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 260\n</code></pre>\n'
    },
    {
      name: "week of year(date)",
      description: '<p>Returns the Gregorian number of the week within the year, according to ISO 8601.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">week of year(date: date): number\n</code></pre>\n<pre><code class="language-feel">week of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">week of year(date(&quot;2019-09-17&quot;))\n// 38\n\nweek of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 38\n</code></pre>\n'
    },
    {
      name: "month of year(date)",
      description: '<p>Returns the month of the year according to the Gregorian calendar. Note that it always returns the English name of the month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">month of year(date: date): string\n</code></pre>\n<pre><code class="language-feel">month of year(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">month of year(date(&quot;2019-09-17&quot;))\n// &quot;September&quot;\n\nmonth of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;September&quot;\n</code></pre>\n'
    },
    {
      name: "abs(n)",
      description: '<p>Returns the absolute value of a given duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">abs(n: days and time duration): days and time duration\n</code></pre>\n<pre><code class="language-feel">abs(n: years and months duration): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">abs(duration(&quot;-PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;-P2M&quot;))\n// duration(&quot;P2M&quot;)\n</code></pre>\n'
    },
    {
      name: "last day of month(date)",
      description: '<p><em>Camunda Extension</em></p>\n<p>Takes the month of the given date or date-time value and returns the last day of this month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">last day of month(date: date): date\n</code></pre>\n<pre><code class="language-feel">last day of month(date: date and time): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">last day of month(date(&quot;2022-10-01&quot;))\n// date(&quot;2022-10-31&quot;))\n\nlast day of month(date and time(&quot;2022-10-16T12:00:00&quot;))\n// date(&quot;2022-10-31&quot;))\n</code></pre>\n'
    }
  ];
  function parseBuiltins(builtins3) {
    return builtins3.map(parseBuiltin);
  }
  function parseBuiltin(builtin) {
    const {
      name: name2,
      description: description2
    } = builtin;
    const match2 = name2.match(/^([\w\s]+)\((.*)\)$/);
    const functionName = match2[1];
    const functionArguments = match2[2];
    const params = functionArguments ? functionArguments.split(", ").map((name3) => ({ name: name3 })) : [];
    return {
      name: functionName,
      type: "function",
      params,
      info: () => {
        return domify$1(`<div class="description">${description2}<div>`);
      },
      boost: 0
    };
  }
  var camunda = parseBuiltins(camundaTags);
  var coreConf = new Compartment();
  var placeholderConf = new Compartment();
  function FeelEditor({
    extensions: editorExtensions = [],
    dialect = "expression",
    parserDialect,
    container,
    contentAttributes: contentAttributes2 = {},
    tooltipContainer,
    onChange = () => {
    },
    onKeyDown = () => {
    },
    onLint = () => {
    },
    placeholder: placeholder$1 = "",
    readOnly: readOnly2 = false,
    value = "",
    builtins: builtins3 = camunda,
    variables = []
  }) {
    const changeHandler = EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        onChange(update.state.doc.toString());
      }
    });
    const lintHandler = EditorView.updateListener.of((update) => {
      const diagnosticEffects = update.transactions.flatMap((t4) => t4.effects).filter((effect) => effect.is(setDiagnosticsEffect));
      if (!diagnosticEffects.length) {
        return;
      }
      const messages = diagnosticEffects.flatMap((effect) => effect.value);
      onLint(messages);
    });
    const keyHandler = EditorView.domEventHandlers(
      {
        keydown: onKeyDown
      }
    );
    if (typeof tooltipContainer === "string") {
      tooltipContainer = document.querySelector(tooltipContainer);
    }
    const tooltipLayout = tooltipContainer ? tooltips({
      tooltipSpace: function() {
        return tooltipContainer.getBoundingClientRect();
      }
    }) : [];
    const extensions = [
      autocompletion(),
      coreConf.of(configure({
        dialect,
        builtins: builtins3,
        variables,
        parserDialect
      })),
      bracketMatching(),
      indentOnInput(),
      closeBrackets(),
      EditorView.contentAttributes.of(contentAttributes2),
      changeHandler,
      keyHandler,
      keymap.of([
        ...defaultKeymap
      ]),
      linter2,
      lintHandler,
      tooltipLayout,
      placeholderConf.of(placeholder(placeholder$1)),
      theme3,
      ...editorExtensions
    ];
    if (readOnly2) {
      extensions.push(EditorView.editable.of(false));
    }
    this._cmEditor = new EditorView({
      state: EditorState.create({
        doc: value,
        extensions
      }),
      parent: container
    });
    return this;
  }
  FeelEditor.prototype.setValue = function(value) {
    this._cmEditor.dispatch({
      changes: {
        from: 0,
        to: this._cmEditor.state.doc.length,
        insert: value
      }
    });
  };
  FeelEditor.prototype.focus = function(position) {
    const cmEditor = this._cmEditor;
    cmEditor.contentDOM.focus();
    cmEditor.focus();
    if (typeof position === "number") {
      const end = cmEditor.state.doc.length;
      cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
    }
  };
  FeelEditor.prototype.getSelection = function() {
    return this._cmEditor.state.selection;
  };
  FeelEditor.prototype.setVariables = function(variables) {
    const config2 = get2(this._cmEditor.state);
    this._cmEditor.dispatch({
      effects: [
        coreConf.reconfigure(configure({
          ...config2,
          variables
        }))
      ]
    });
  };
  FeelEditor.prototype.setPlaceholder = function(placeholder$1) {
    this._cmEditor.dispatch({
      effects: placeholderConf.reconfigure(placeholder(placeholder$1))
    });
  };

  // node_modules/tabbable/dist/index.esm.js
  var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches3 = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    var _element$getRootNode;
    return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
  } : function(element) {
    return element === null || element === void 0 ? void 0 : element.ownerDocument;
  };
  var isInert = function isInert2(node, lookUp) {
    var _node$getAttribute;
    if (lookUp === void 0) {
      lookUp = true;
    }
    var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
    var inert = inertAtt === "" || inertAtt === "true";
    var result = inert || lookUp && node && isInert2(node.parentNode);
    return result;
  };
  var isContentEditable = function isContentEditable2(node) {
    var _node$getAttribute2;
    var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
    return attValue === "" || attValue === "true";
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    if (isInert(el)) {
      return [];
    }
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches3.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options2) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (isInert(element, false)) {
        continue;
      }
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content2 = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content2, true, options2);
        if (options2.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches3.call(element, candidateSelector);
        if (validCandidate && options2.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element);
        var validShadowRoot = !isInert(shadowRoot, false) && (!options2.shadowRootFilter || options2.shadowRootFilter(element));
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options2);
          if (options2.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var hasTabIndex = function hasTabIndex2(node) {
    return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
  };
  var getTabIndex = function getTabIndex2(node) {
    if (!node) {
      throw new Error("No node provided");
    }
    if (node.tabIndex < 0) {
      if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
    var tabIndex = getTabIndex(node);
    if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
      return 0;
    }
    return tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a3, b2) {
    return a3.tabIndex === b2.tabIndex ? a3.documentOrder - b2.documentOrder : a3.tabIndex - b2.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r3 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r3;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i4 = 0; i4 < nodes.length; i4++) {
      if (nodes[i4].checked && nodes[i4].form === form) {
        return nodes[i4];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name2) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isNodeAttached = function isNodeAttached2(node) {
    var _nodeRoot;
    var nodeRoot = node && getRootNode(node);
    var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
    var attached = false;
    if (nodeRoot && nodeRoot !== node) {
      var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
      attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
      while (!attached && nodeRootHost) {
        var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
        nodeRoot = getRootNode(nodeRootHost);
        nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
      }
    }
    return attached;
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches3.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches3.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (isNodeAttached(node)) {
        return !node.getClientRects().length;
      }
      if (displayCheck !== "legacy-full") {
        return true;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i4 = 0; i4 < parentNode.children.length; i4++) {
            var child = parentNode.children.item(i4);
            if (child.tagName === "LEGEND") {
              return matches3.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options2, node) {
    if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
    //  because we're limited in the type of selectors we can use in JSDom (see related
    //  note related to `candidateSelectors`)
    isInert(node) || isHiddenInput(node) || isHidden(node, options2) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options2, node) {
    if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options2, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i4) {
      var isScope = !!item.scopeParent;
      var element = isScope ? item.scopeParent : item;
      var candidateTabindex = getSortOrderTabIndex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i4,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(container, options2) {
    options2 = options2 || {};
    var candidates;
    if (options2.getShadowRoot) {
      candidates = getCandidatesIteratively([container], options2.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options2),
        flatten: false,
        getShadowRoot: options2.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(container, options2) {
    options2 = options2 || {};
    var candidates;
    if (options2.getShadowRoot) {
      candidates = getCandidatesIteratively([container], options2.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options2),
        flatten: true,
        getShadowRoot: options2.getShadowRoot
      });
    } else {
      candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options2));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options2) {
    options2 = options2 || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches3.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options2, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options2) {
    options2 = options2 || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches3.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options2, node);
  };

  // node_modules/focus-trap/dist/focus-trap.esm.js
  function _arrayLikeToArray(r3, a3) {
    (null == a3 || a3 > r3.length) && (a3 = r3.length);
    for (var e3 = 0, n3 = Array(a3); e3 < a3; e3++) n3[e3] = r3[e3];
    return n3;
  }
  function _arrayWithoutHoles(r3) {
    if (Array.isArray(r3)) return _arrayLikeToArray(r3);
  }
  function _defineProperty(e3, r3, t4) {
    return (r3 = _toPropertyKey(r3)) in e3 ? Object.defineProperty(e3, r3, {
      value: t4,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e3[r3] = t4, e3;
  }
  function _iterableToArray(r3) {
    if ("undefined" != typeof Symbol && null != r3[Symbol.iterator] || null != r3["@@iterator"]) return Array.from(r3);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e3, r3) {
    var t4 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o3 = Object.getOwnPropertySymbols(e3);
      r3 && (o3 = o3.filter(function(r4) {
        return Object.getOwnPropertyDescriptor(e3, r4).enumerable;
      })), t4.push.apply(t4, o3);
    }
    return t4;
  }
  function _objectSpread2(e3) {
    for (var r3 = 1; r3 < arguments.length; r3++) {
      var t4 = null != arguments[r3] ? arguments[r3] : {};
      r3 % 2 ? ownKeys(Object(t4), true).forEach(function(r4) {
        _defineProperty(e3, r4, t4[r4]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r4) {
        Object.defineProperty(e3, r4, Object.getOwnPropertyDescriptor(t4, r4));
      });
    }
    return e3;
  }
  function _toConsumableArray(r3) {
    return _arrayWithoutHoles(r3) || _iterableToArray(r3) || _unsupportedIterableToArray(r3) || _nonIterableSpread();
  }
  function _toPrimitive(t4, r3) {
    if ("object" != typeof t4 || !t4) return t4;
    var e3 = t4[Symbol.toPrimitive];
    if (void 0 !== e3) {
      var i4 = e3.call(t4, r3 || "default");
      if ("object" != typeof i4) return i4;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r3 ? String : Number)(t4);
  }
  function _toPropertyKey(t4) {
    var i4 = _toPrimitive(t4, "string");
    return "symbol" == typeof i4 ? i4 : i4 + "";
  }
  function _unsupportedIterableToArray(r3, a3) {
    if (r3) {
      if ("string" == typeof r3) return _arrayLikeToArray(r3, a3);
      var t4 = {}.toString.call(r3).slice(8, -1);
      return "Object" === t4 && r3.constructor && (t4 = r3.constructor.name), "Map" === t4 || "Set" === t4 ? Array.from(r3) : "Arguments" === t4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t4) ? _arrayLikeToArray(r3, a3) : void 0;
    }
  }
  var activeFocusTraps = {
    activateTrap: function activateTrap(trapStack, trap) {
      if (trapStack.length > 0) {
        var activeTrap = trapStack[trapStack.length - 1];
        if (activeTrap !== trap) {
          activeTrap._setPausedState(true);
        }
      }
      var trapIndex = trapStack.indexOf(trap);
      if (trapIndex === -1) {
        trapStack.push(trap);
      } else {
        trapStack.splice(trapIndex, 1);
        trapStack.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trapStack, trap) {
      var trapIndex = trapStack.indexOf(trap);
      if (trapIndex !== -1) {
        trapStack.splice(trapIndex, 1);
      }
      if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
        trapStack[trapStack.length - 1]._setPausedState(false);
      }
    }
  };
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e3) {
    return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Escape" || (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Esc" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 27;
  };
  var isTabEvent = function isTabEvent2(e3) {
    return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Tab" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 9;
  };
  var isKeyForward = function isKeyForward2(e3) {
    return isTabEvent(e3) && !e3.shiftKey;
  };
  var isKeyBackward = function isKeyBackward2(e3) {
    return isTabEvent(e3) && e3.shiftKey;
  };
  var delay = function delay2(fn4) {
    return setTimeout(fn4, 0);
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event2) {
    return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
  };
  var internalTrapStack = [];
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc2 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
    var config2 = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward,
      isKeyBackward
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   posTabIndexesFound: boolean,
      //   firstTabbableNode: HTMLElement|undefined,
      //   lastTabbableNode: HTMLElement|undefined,
      //   firstDomTabbableNode: HTMLElement|undefined,
      //   lastDomTabbableNode: HTMLElement|undefined,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      manuallyPaused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0,
      // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
      recentNavEvent: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element, event2) {
      var composedPath = typeof (event2 === null || event2 === void 0 ? void 0 : event2.composedPath) === "function" ? event2.composedPath() : void 0;
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
      var optionValue = config2[optionName];
      if (typeof optionValue === "function") {
        optionValue = optionValue.apply(void 0, _toConsumableArray(params));
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = doc2.querySelector(optionValue);
        } catch (err) {
          throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus", {
        hasFallback: true
      });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node, config2.tabbableOptions)) {
        if (findContainerIndex(doc2.activeElement) >= 0) {
          node = doc2.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config2.tabbableOptions);
        var focusableNodes = focusable(container, config2.tabbableOptions);
        var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
        var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
        var firstDomTabbableNode = focusableNodes.find(function(node) {
          return isTabbable(node);
        });
        var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
          return isTabbable(node);
        });
        var posTabIndexesFound = !!tabbableNodes.find(function(node) {
          return getTabIndex(node) > 0;
        });
        return {
          container,
          tabbableNodes,
          focusableNodes,
          /** True if at least one node with positive `tabindex` was found in this container. */
          posTabIndexesFound,
          /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
          firstTabbableNode,
          /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
          lastTabbableNode,
          // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
          //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
          //  because that API doesn't work with Shadow DOM as well as it should (@see
          //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
          //  to address an edge case related to positive tabindex support, this seems like a much easier,
          //  "close enough most of the time" alternative for positive tabindexes which should generally
          //  be avoided anyway...
          /** First tabbable node in container, __DOM__ order; `undefined` if none. */
          firstDomTabbableNode,
          /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
          lastDomTabbableNode,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = tabbableNodes.indexOf(node);
            if (nodeIdx < 0) {
              if (forward) {
                return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                  return isTabbable(el);
                });
              }
              return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                return isTabbable(el);
              });
            }
            return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
      if (state.containerGroups.find(function(g4) {
        return g4.posTabIndexesFound;
      }) && state.containerGroups.length > 1) {
        throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
      }
    };
    var _getActiveElement = function getActiveElement(el) {
      var activeElement = el.activeElement;
      if (!activeElement) {
        return;
      }
      if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
        return _getActiveElement(activeElement.shadowRoot);
      }
      return activeElement;
    };
    var _tryFocus = function tryFocus(node) {
      if (node === false) {
        return;
      }
      if (node === _getActiveElement(document)) {
        return;
      }
      if (!node || !node.focus) {
        _tryFocus(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config2.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    };
    var findNextNavNode = function findNextNavNode2(_ref3) {
      var target = _ref3.target, event2 = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
      target = target || getActualTarget(event2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target, event2);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
            var firstTabbableNode = _ref4.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event2)) {
            destinationNode = containerGroup.nextTabbableNode(target, false);
          }
        } else {
          var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
            var lastTabbableNode = _ref5.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event2)) {
            destinationNode = containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    };
    var checkPointerDown = function checkPointerDown2(e3) {
      var target = getActualTarget(e3);
      if (findContainerIndex(target, e3) >= 0) {
        return;
      }
      if (valueOrHandler(config2.clickOutsideDeactivates, e3)) {
        trap.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: config2.returnFocusOnDeactivate
        });
        return;
      }
      if (valueOrHandler(config2.allowOutsideClick, e3)) {
        return;
      }
      e3.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(event2) {
      var target = getActualTarget(event2);
      var targetContained = findContainerIndex(target, event2) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        event2.stopImmediatePropagation();
        var nextNode;
        var navAcrossContainers = true;
        if (state.mostRecentlyFocusedNode) {
          if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
            var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
            var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
            if (tabbableNodes.length > 0) {
              var mruTabIdx = tabbableNodes.findIndex(function(node) {
                return node === state.mostRecentlyFocusedNode;
              });
              if (mruTabIdx >= 0) {
                if (config2.isKeyForward(state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!state.containerGroups.some(function(g4) {
              return g4.tabbableNodes.some(function(n3) {
                return getTabIndex(n3) > 0;
              });
            })) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: state.mostRecentlyFocusedNode,
            isBackward: config2.isKeyBackward(state.recentNavEvent)
          });
        }
        if (nextNode) {
          _tryFocus(nextNode);
        } else {
          _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
        }
      }
      state.recentNavEvent = void 0;
    };
    var checkKeyNav = function checkKeyNav2(event2) {
      var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      state.recentNavEvent = event2;
      var destinationNode = findNextNavNode({
        event: event2,
        isBackward
      });
      if (destinationNode) {
        if (isTabEvent(event2)) {
          event2.preventDefault();
        }
        _tryFocus(destinationNode);
      }
    };
    var checkTabKey = function checkTabKey2(event2) {
      if (config2.isKeyForward(event2) || config2.isKeyBackward(event2)) {
        checkKeyNav(event2, config2.isKeyBackward(event2));
      }
    };
    var checkEscapeKey = function checkEscapeKey2(event2) {
      if (isEscapeEvent(event2) && valueOrHandler(config2.escapeDeactivates, event2) !== false) {
        event2.preventDefault();
        trap.deactivate();
      }
    };
    var checkClick = function checkClick2(e3) {
      var target = getActualTarget(e3);
      if (findContainerIndex(target, e3) >= 0) {
        return;
      }
      if (valueOrHandler(config2.clickOutsideDeactivates, e3)) {
        return;
      }
      if (valueOrHandler(config2.allowOutsideClick, e3)) {
        return;
      }
      e3.preventDefault();
      e3.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trapStack, trap);
      state.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
        _tryFocus(getInitialFocusNode());
      }) : _tryFocus(getInitialFocusNode());
      doc2.addEventListener("focusin", checkFocusIn, true);
      doc2.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("keydown", checkTabKey, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("keydown", checkEscapeKey);
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc2.removeEventListener("focusin", checkFocusIn, true);
      doc2.removeEventListener("mousedown", checkPointerDown, true);
      doc2.removeEventListener("touchstart", checkPointerDown, true);
      doc2.removeEventListener("click", checkClick, true);
      doc2.removeEventListener("keydown", checkTabKey, true);
      doc2.removeEventListener("keydown", checkEscapeKey);
      return trap;
    };
    var checkDomRemoval = function checkDomRemoval2(mutations) {
      var isFocusedNodeRemoved = mutations.some(function(mutation) {
        var removedNodes = Array.from(mutation.removedNodes);
        return removedNodes.some(function(node) {
          return node === state.mostRecentlyFocusedNode;
        });
      });
      if (isFocusedNodeRemoved) {
        _tryFocus(getInitialFocusNode());
      }
    };
    var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
    var updateObservedNodes = function updateObservedNodes2() {
      if (!mutationObserver) {
        return;
      }
      mutationObserver.disconnect();
      if (state.active && !state.paused) {
        state.containers.map(function(container) {
          mutationObserver.observe(container, {
            subtree: true,
            childList: true
          });
        });
      }
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc2.activeElement;
        onActivate === null || onActivate === void 0 || onActivate();
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          updateObservedNodes();
          onPostActivate === null || onPostActivate === void 0 || onPostActivate();
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options2 = _objectSpread2({
          onDeactivate: config2.onDeactivate,
          onPostDeactivate: config2.onPostDeactivate,
          checkCanReturnFocus: config2.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        updateObservedNodes();
        activeFocusTraps.deactivateTrap(trapStack, trap);
        var onDeactivate = getOption(options2, "onDeactivate");
        var onPostDeactivate = getOption(options2, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options2, "checkCanReturnFocus");
        var returnFocus = getOption(options2, "returnFocus", "returnFocusOnDeactivate");
        onDeactivate === null || onDeactivate === void 0 || onDeactivate();
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause(pauseOptions) {
        if (!state.active) {
          return this;
        }
        state.manuallyPaused = true;
        return this._setPausedState(true, pauseOptions);
      },
      unpause: function unpause(unpauseOptions) {
        if (!state.active) {
          return this;
        }
        state.manuallyPaused = false;
        if (trapStack[trapStack.length - 1] !== this) {
          return this;
        }
        return this._setPausedState(false, unpauseOptions);
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc2.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        updateObservedNodes();
        return this;
      }
    };
    Object.defineProperties(trap, {
      _isManuallyPaused: {
        value: function value() {
          return state.manuallyPaused;
        }
      },
      _setPausedState: {
        value: function value(paused, options2) {
          if (state.paused === paused) {
            return this;
          }
          state.paused = paused;
          if (paused) {
            var onPause = getOption(options2, "onPause");
            var onPostPause = getOption(options2, "onPostPause");
            onPause === null || onPause === void 0 || onPause();
            removeListeners();
            updateObservedNodes();
            onPostPause === null || onPostPause === void 0 || onPostPause();
          } else {
            var onUnpause = getOption(options2, "onUnpause");
            var onPostUnpause = getOption(options2, "onPostUnpause");
            onUnpause === null || onUnpause === void 0 || onUnpause();
            updateTabbableNodes();
            addListeners();
            updateObservedNodes();
            onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          }
          return this;
        }
      }
    });
    trap.updateContainerElements(elements);
    return trap;
  };

  // node_modules/@bpmn-io/form-js-editor/dist/index.es.js
  var FN_REF2 = "__fn";
  var DEFAULT_PRIORITY$3 = 1e3;
  var slice2 = Array.prototype.slice;
  function EventBus2() {
    this._listeners = {};
    this.on("diagram.destroy", 1, this._destroy, this);
  }
  EventBus2.prototype.on = function(events, priority, callback, that) {
    events = isArray(events) ? events : [events];
    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY$3;
    }
    if (!isNumber(priority)) {
      throw new Error("priority must be a number");
    }
    var actualCallback = callback;
    if (that) {
      actualCallback = bind(callback, that);
      actualCallback[FN_REF2] = callback[FN_REF2] || callback;
    }
    var self2 = this;
    events.forEach(function(e3) {
      self2._addListener(e3, {
        priority,
        callback: actualCallback,
        next: null
      });
    });
  };
  EventBus2.prototype.once = function(events, priority, callback, that) {
    var self2 = this;
    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY$3;
    }
    if (!isNumber(priority)) {
      throw new Error("priority must be a number");
    }
    function wrappedCallback() {
      wrappedCallback.__isTomb = true;
      var result = callback.apply(that, arguments);
      self2.off(events, wrappedCallback);
      return result;
    }
    wrappedCallback[FN_REF2] = callback;
    this.on(events, priority, wrappedCallback);
  };
  EventBus2.prototype.off = function(events, callback) {
    events = isArray(events) ? events : [events];
    var self2 = this;
    events.forEach(function(event2) {
      self2._removeListener(event2, callback);
    });
  };
  EventBus2.prototype.createEvent = function(data) {
    var event2 = new InternalEvent2();
    event2.init(data);
    return event2;
  };
  EventBus2.prototype.fire = function(type3, data) {
    var event2, firstListener, returnValue, args;
    args = slice2.call(arguments);
    if (typeof type3 === "object") {
      data = type3;
      type3 = data.type;
    }
    if (!type3) {
      throw new Error("no event type specified");
    }
    firstListener = this._listeners[type3];
    if (!firstListener) {
      return;
    }
    if (data instanceof InternalEvent2) {
      event2 = data;
    } else {
      event2 = this.createEvent(data);
    }
    args[0] = event2;
    var originalType = event2.type;
    if (type3 !== originalType) {
      event2.type = type3;
    }
    try {
      returnValue = this._invokeListeners(event2, args, firstListener);
    } finally {
      if (type3 !== originalType) {
        event2.type = originalType;
      }
    }
    if (returnValue === void 0 && event2.defaultPrevented) {
      returnValue = false;
    }
    return returnValue;
  };
  EventBus2.prototype.handleError = function(error2) {
    return this.fire("error", {
      error: error2
    }) === false;
  };
  EventBus2.prototype._destroy = function() {
    this._listeners = {};
  };
  EventBus2.prototype._invokeListeners = function(event2, args, listener) {
    var returnValue;
    while (listener) {
      if (event2.cancelBubble) {
        break;
      }
      returnValue = this._invokeListener(event2, args, listener);
      listener = listener.next;
    }
    return returnValue;
  };
  EventBus2.prototype._invokeListener = function(event2, args, listener) {
    var returnValue;
    if (listener.callback.__isTomb) {
      return returnValue;
    }
    try {
      returnValue = invokeFunction2(listener.callback, args);
      if (returnValue !== void 0) {
        event2.returnValue = returnValue;
        event2.stopPropagation();
      }
      if (returnValue === false) {
        event2.preventDefault();
      }
    } catch (error2) {
      if (!this.handleError(error2)) {
        console.error("unhandled error in event listener", error2);
        throw error2;
      }
    }
    return returnValue;
  };
  EventBus2.prototype._addListener = function(event2, newListener) {
    var listener = this._getListeners(event2), previousListener;
    if (!listener) {
      this._setListeners(event2, newListener);
      return;
    }
    while (listener) {
      if (listener.priority < newListener.priority) {
        newListener.next = listener;
        if (previousListener) {
          previousListener.next = newListener;
        } else {
          this._setListeners(event2, newListener);
        }
        return;
      }
      previousListener = listener;
      listener = listener.next;
    }
    previousListener.next = newListener;
  };
  EventBus2.prototype._getListeners = function(name2) {
    return this._listeners[name2];
  };
  EventBus2.prototype._setListeners = function(name2, listener) {
    this._listeners[name2] = listener;
  };
  EventBus2.prototype._removeListener = function(event2, callback) {
    var listener = this._getListeners(event2), nextListener, previousListener, listenerCallback;
    if (!callback) {
      this._setListeners(event2, null);
      return;
    }
    while (listener) {
      nextListener = listener.next;
      listenerCallback = listener.callback;
      if (listenerCallback === callback || listenerCallback[FN_REF2] === callback) {
        if (previousListener) {
          previousListener.next = nextListener;
        } else {
          this._setListeners(event2, nextListener);
        }
      }
      previousListener = listener;
      listener = nextListener;
    }
  };
  function InternalEvent2() {
  }
  InternalEvent2.prototype.stopPropagation = function() {
    this.cancelBubble = true;
  };
  InternalEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
  };
  InternalEvent2.prototype.init = function(data) {
    assign(this, data || {});
  };
  function invokeFunction2(fn4, args) {
    return fn4.apply(null, args);
  }
  function DebounceFactory(config2 = true) {
    const timeout = typeof config2 === "number" ? config2 : config2 ? 300 : 0;
    if (timeout) {
      return (fn4) => debounce(fn4, timeout);
    } else {
      return (fn4) => fn4;
    }
  }
  DebounceFactory.$inject = ["config.debounce"];
  var FormFieldRegistry2 = class extends FormFieldRegistry {
    /**
     * Updates a form fields id.
     *
     * @param {Object} formField
     * @param {string} newId
     */
    updateId(formField, newId) {
      this._validateId(newId);
      this._eventBus.fire("formField.updateId", {
        formField,
        newId
      });
      this.remove(formField);
      formField.id = newId;
      this.add(formField);
      if ("components" in formField) {
        for (const component of formField.components) {
          component._parent = newId;
        }
      }
    }
    /**
     * Validate the suitability of the given id and signals a problem
     * with an exception.
     *
     * @param {string} id
     *
     * @throws {Error} if id is empty or already assigned
     */
    _validateId(id2) {
      if (!id2) {
        throw new Error("formField must have an id");
      }
      if (this.get(id2)) {
        throw new Error("formField with id " + id2 + " already added");
      }
    }
  };
  var MAX_COLUMNS_PER_ROW = 16;
  var MAX_COLUMNS = 16;
  var MIN_COLUMNS = 2;
  var MAX_FIELDS_PER_ROW = 4;
  var FormLayoutValidator = class {
    /**
     * @constructor
     *
     * @param { import('./FormLayouter').FormLayouter } formLayouter
     * @param { import('./FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     */
    constructor(formLayouter, formFieldRegistry) {
      this._formLayouter = formLayouter;
      this._formFieldRegistry = formFieldRegistry;
    }
    validateField(field = {}, columns, row) {
      if (Number.isInteger(columns)) {
        if (columns < MIN_COLUMNS) {
          return `Minimum ${MIN_COLUMNS} columns are allowed`;
        }
        if (columns > MAX_COLUMNS) {
          return `Maximum ${MAX_COLUMNS} columns are allowed`;
        }
      }
      if (!row) {
        row = this._formLayouter.getRowForField(field);
      }
      let sumColumns = parseInt(columns) || 0;
      let sumFields = 1;
      let sumAutoCols = columns ? 0 : 1;
      row.components.forEach((id2) => {
        if (field.id === id2) {
          return;
        }
        const component = this._formFieldRegistry.get(id2);
        const cols = (component.layout || {}).columns;
        if (!cols) {
          sumAutoCols++;
        }
        sumColumns += parseInt(cols) || 0;
        sumFields++;
      });
      if (sumColumns > MAX_COLUMNS_PER_ROW || sumAutoCols > 0 && sumColumns > calculateMaxColumnsWithAuto(sumAutoCols) || columns === MAX_COLUMNS_PER_ROW && sumFields > 1) {
        return `New value exceeds the maximum of ${MAX_COLUMNS_PER_ROW} columns per row`;
      }
      if (sumFields > MAX_FIELDS_PER_ROW) {
        return `Maximum ${MAX_FIELDS_PER_ROW} fields per row are allowed`;
      }
      return null;
    }
  };
  FormLayoutValidator.$inject = ["formLayouter", "formFieldRegistry"];
  function calculateMaxColumnsWithAuto(autoCols) {
    return MAX_COLUMNS_PER_ROW - autoCols * 2;
  }
  var emptyImage = createEmptyImage();
  function editorFormFieldClasses(type3, {
    disabled = false
  } = {}) {
    if (!type3) {
      throw new Error("type required");
    }
    return (0, import_classnames2.default)("fjs-form-field", `fjs-form-field-${type3}`, {
      "fjs-disabled": disabled
    });
  }
  function createDragger$1(fn4) {
    let self2;
    let startX, startY;
    function onDragStart(event2) {
      self2 = this;
      startX = event2.clientX;
      startY = event2.clientY;
      if (event2.dataTransfer) {
        event2.dataTransfer.setDragImage(emptyImage, 0, 0);
      }
      document.addEventListener("dragover", onDrag);
      document.addEventListener("dragend", onEnd);
      document.addEventListener("drop", preventDefault$1);
    }
    function onDrag(event2) {
      const delta = {
        x: event2.clientX - startX,
        y: event2.clientY - startY
      };
      return fn4.call(self2, event2, delta);
    }
    function onEnd() {
      document.removeEventListener("dragover", onDrag);
      document.removeEventListener("dragend", onEnd);
      document.removeEventListener("drop", preventDefault$1);
    }
    return onDragStart;
  }
  function throttle(fn4) {
    let active = false;
    let lastArgs = [];
    let lastThis = void 0;
    return function(...args) {
      lastArgs = args;
      lastThis = this;
      if (active) {
        return;
      }
      active = true;
      fn4.apply(lastThis, lastArgs);
      window.requestAnimationFrame(function() {
        lastArgs = lastThis = active = void 0;
      });
    };
  }
  function preventDefault$1(event2) {
    event2.preventDefault();
    event2.stopPropagation();
  }
  function createEmptyImage() {
    const img = new Image();
    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    return img;
  }
  function EditorIFrame(props) {
    const {
      field,
      domId
    } = props;
    const {
      label
    } = field;
    const Icon = iconsByType(field.type);
    return u2("div", {
      class: editorFormFieldClasses(field.type),
      children: [u2(Label, {
        id: domId,
        label
      }), u2("div", {
        class: "fjs-iframe-placeholder",
        id: domId,
        children: u2("p", {
          class: "fjs-iframe-placeholder-text",
          children: [u2(Icon, {
            width: "32",
            height: "24",
            viewBox: "0 0 56 56"
          }), "iFrame"]
        })
      })]
    });
  }
  EditorIFrame.config = IFrame.config;
  var DragAndDropContext = K({
    drake: null
  });
  function getService$1(type3, strict) {
  }
  var FormEditorContext = K({
    getService: getService$1
  });
  function useService$1(type3, strict) {
    const {
      getService: getService3
    } = x2(FormEditorContext);
    return getService3(type3, strict);
  }
  var _path$52;
  function _extends$52() {
    return _extends$52 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$52.apply(null, arguments);
  }
  var SvgClose = function SvgClose2(props) {
    return /* @__PURE__ */ _("svg", _extends$52({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "currentColor"
    }, props), _path$52 || (_path$52 = /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "m12 4.7-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z",
      clipRule: "evenodd"
    })));
  };
  var _path$42;
  var _path2$12;
  function _extends$42() {
    return _extends$42 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$42.apply(null, arguments);
  }
  var SvgDelete3 = function SvgDelete4(props) {
    return /* @__PURE__ */ _("svg", _extends$42({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none"
    }, props), /* @__PURE__ */ _("rect", {
      width: 16,
      height: 16,
      x: 0.536,
      fill: "#fff",
      rx: 3,
      style: {
        mixBlendMode: "multiply"
      }
    }), /* @__PURE__ */ _("path", {
      fill: "#fff",
      d: "M0 0h16v16H0z",
      style: {
        mixBlendMode: "multiply"
      },
      transform: "translate(.536)"
    }), _path$42 || (_path$42 = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      d: "M7.536 6h-1v6h1zm3 0h-1v6h1z"
    })), _path2$12 || (_path2$12 = /* @__PURE__ */ _("path", {
      fill: "currentcolor",
      d: "M2.536 3v1h1v10a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4h1V3zm2 11V4h8v10zm6-13h-4v1h4z"
    })));
  };
  var _path$32;
  function _extends$32() {
    return _extends$32 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$32.apply(null, arguments);
  }
  var SvgDraggable = function SvgDraggable2(props) {
    return /* @__PURE__ */ _("svg", _extends$32({
      xmlns: "http://www.w3.org/2000/svg",
      xmlSpace: "preserve",
      width: 16,
      height: 16,
      fill: "currentcolor",
      viewBox: "0 0 32 32"
    }, props), _path$32 || (_path$32 = /* @__PURE__ */ _("path", {
      d: "M10 6h4v4h-4zm8 0h4v4h-4zm-8 8h4v4h-4zm8 0h4v4h-4zm-8 8h4v4h-4zm8 0h4v4h-4z"
    })), /* @__PURE__ */ _("path", {
      d: "M0 0h32v32H0z",
      style: {
        fill: "none"
      }
    }));
  };
  var _path$22;
  function _extends$22() {
    return _extends$22 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$22.apply(null, arguments);
  }
  var SvgSearch = function SvgSearch2(props) {
    return /* @__PURE__ */ _("svg", _extends$22({
      xmlns: "http://www.w3.org/2000/svg",
      width: 15,
      height: 15,
      fill: "none"
    }, props), _path$22 || (_path$22 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "m14.5 13.793-3.776-3.776a5.508 5.508 0 1 0-.707.707l3.776 3.776zM2 6.5a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0"
    })));
  };
  var _path$12;
  var _rect4;
  var _mask;
  var _path22;
  var _path32;
  var _path4;
  var _path5;
  var _path6;
  function _extends$12() {
    return _extends$12 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends$12.apply(null, arguments);
  }
  var SvgEmptyForm = function SvgEmptyForm2(props) {
    return /* @__PURE__ */ _("svg", _extends$12({
      xmlns: "http://www.w3.org/2000/svg",
      width: 126,
      height: 96,
      fill: "none"
    }, props), _path$12 || (_path$12 = /* @__PURE__ */ _("path", {
      fill: "#FF832B",
      fillRule: "evenodd",
      d: "M70 78v8a3 3 0 0 1-3 3h-8v-5h6v-6zm0-16h-5V46h5zm0-32h-5v-6h-6v-5h8a3 3 0 0 1 3 3zM43 19v5H27v-5zm-32 0v5H5v6H0v-8a3 3 0 0 1 3-3zM0 46h5v16H0zm0 32h5v6h6v5H3a3 3 0 0 1-3-3zm27 11v-5h16v5z",
      clipRule: "evenodd"
    })), _rect4 || (_rect4 = /* @__PURE__ */ _("rect", {
      width: 70,
      height: 70,
      fill: "#E5E5E5",
      rx: 3,
      transform: "matrix(-1 0 0 1 94 0)"
    })), _mask || (_mask = /* @__PURE__ */ _("mask", {
      id: "EmptyForm_svg__a",
      fill: "#fff"
    }, /* @__PURE__ */ _("path", {
      fillRule: "evenodd",
      d: "M87.085 88.684 75.43 45.185l43.499 11.656-11.044 8.072 8.557 8.556-12.728 12.728-8.557-8.556z",
      clipRule: "evenodd"
    }))), _path22 || (_path22 = /* @__PURE__ */ _("path", {
      fill: "#393939",
      fillRule: "evenodd",
      d: "M87.085 88.684 75.43 45.185l43.499 11.656-11.044 8.072 8.557 8.556-12.728 12.728-8.557-8.556z",
      clipRule: "evenodd"
    })), _path32 || (_path32 = /* @__PURE__ */ _("path", {
      fill: "#393939",
      d: "M75.43 45.185 70.6 46.48l-2.241-8.365 8.365 2.242zm11.655 43.499 4.037 2.95-6.163 8.432-2.704-10.088zm31.844-31.843 1.294-4.83 10.088 2.703-8.432 6.163zm-11.044 8.072-3.535 3.535-4.128-4.127 4.713-3.445zm8.557 8.556 3.535-3.535 3.536 3.535-3.536 3.536zm-12.728 12.728 3.536 3.536-3.536 3.535-3.536-3.535zm-8.557-8.556-4.036-2.951 3.444-4.713 4.128 4.128zM80.26 43.89 91.915 87.39l-9.66 2.588L70.6 46.48zm37.375 17.78L74.136 50.014l2.588-9.66 43.499 11.656zm-12.699-.795 11.043-8.072 5.901 8.073-11.043 8.072zm7.971 16.129-8.556-8.557 7.071-7.07 8.556 8.556zm-12.728 5.657 12.728-12.728 7.071 7.07-12.727 12.729zm-1.485-8.557 8.557 8.557-7.072 7.07-8.556-8.556zM83.049 85.733 91.12 74.69l8.073 5.901-8.072 11.044z",
      mask: "url(#EmptyForm_svg__a)"
    })), _path4 || (_path4 = /* @__PURE__ */ _("path", {
      stroke: "#000",
      strokeLinecap: "round",
      strokeWidth: 3,
      d: "m69.431 39.163-9.192-9.192"
    })), _path5 || (_path5 = /* @__PURE__ */ _("path", {
      stroke: "#000",
      strokeLinecap: "round",
      strokeWidth: 3,
      d: "M1.5-1.5h8",
      transform: "matrix(-1 0 0 1 68.213 50.123)"
    })), _path6 || (_path6 = /* @__PURE__ */ _("path", {
      stroke: "#000",
      strokeLinecap: "round",
      strokeWidth: 3,
      d: "M78.969 36.367v-8"
    })));
  };
  function EditorText(props) {
    const {
      type: type3,
      text: text2 = ""
    } = props.field;
    const Icon = iconsByType("text");
    const templating = useService$1("templating");
    const expressionLanguage2 = useService$1("expressionLanguage");
    if (!text2 || !text2.trim()) {
      return u2("div", {
        class: editorFormFieldClasses(type3),
        children: u2("div", {
          class: "fjs-form-field-placeholder",
          children: [u2(Icon, {
            viewBox: "0 0 54 54"
          }), "Text view is empty"]
        })
      });
    }
    if (expressionLanguage2.isExpression(text2)) {
      return u2("div", {
        class: editorFormFieldClasses(type3),
        children: u2("div", {
          class: "fjs-form-field-placeholder",
          children: [u2(Icon, {
            viewBox: "0 0 54 54"
          }), "Text view is populated by an expression"]
        })
      });
    }
    if (templating.isTemplate(text2)) {
      return u2("div", {
        class: editorFormFieldClasses(type3),
        children: u2("div", {
          class: "fjs-form-field-placeholder",
          children: [u2(Icon, {
            viewBox: "0 0 54 54"
          }), "Text view is templated"]
        })
      });
    }
    return u2(Text2, {
      ...props,
      disableLinks: true
    });
  }
  EditorText.config = Text2.config;
  function EditorHtml(props) {
    const {
      type: type3,
      content: content2 = ""
    } = props.field;
    const Icon = iconsByType(type3);
    const templating = useService$1("templating");
    const expressionLanguage2 = useService$1("expressionLanguage");
    if (!content2 || !content2.trim()) {
      return u2("div", {
        class: editorFormFieldClasses(type3),
        children: u2("div", {
          class: "fjs-form-field-placeholder",
          children: [u2(Icon, {
            viewBox: "0 0 54 54"
          }), "Html view is empty"]
        })
      });
    }
    if (expressionLanguage2.isExpression(content2)) {
      return u2("div", {
        class: editorFormFieldClasses(type3),
        children: u2("div", {
          class: "fjs-form-field-placeholder",
          children: [u2(Icon, {
            viewBox: "0 0 54 54"
          }), "Html view is populated by an expression"]
        })
      });
    }
    if (templating.isTemplate(content2)) {
      return u2("div", {
        class: editorFormFieldClasses(type3),
        children: u2("div", {
          class: "fjs-form-field-placeholder",
          children: [u2(Icon, {
            viewBox: "0 0 54 54"
          }), "Html view is templated"]
        })
      });
    }
    return u2(Html, {
      ...props,
      disableLinks: true
    });
  }
  EditorHtml.config = Html.config;
  function EditorTable(props) {
    const {
      columnsExpression,
      columns,
      id: id2,
      label
    } = props.field;
    const shouldUseMockColumns = typeof columnsExpression === "string" && columnsExpression.length > 0 || Array.isArray(columns) && columns.length === 0;
    const editorColumns = shouldUseMockColumns ? [{
      key: "1",
      label: "Column 1"
    }, {
      key: "2",
      label: "Column 2"
    }, {
      key: "3",
      label: "Column 3"
    }] : columns;
    const prefixId3 = `fjs-form-${id2}`;
    return u2("div", {
      class: editorFormFieldClasses("table", {
        disabled: true
      }),
      children: [u2(Label, {
        id: prefixId3,
        label
      }), u2("div", {
        class: "fjs-table-middle-container",
        children: u2("div", {
          class: "fjs-table-inner-container",
          children: u2("table", {
            class: (0, import_classnames2.default)("fjs-table", "fjs-disabled"),
            id: prefixId3,
            children: [u2("thead", {
              class: "fjs-table-head",
              children: u2("tr", {
                class: "fjs-table-tr",
                children: editorColumns.map(({
                  key,
                  label: label2
                }) => u2("th", {
                  class: "fjs-table-th",
                  children: label2
                }, key))
              })
            }), u2("tbody", {
              class: "fjs-table-body",
              children: u2("tr", {
                class: "fjs-table-tr",
                children: editorColumns.map(({
                  key
                }) => u2("td", {
                  class: "fjs-table-td",
                  children: "Content"
                }, key))
              })
            })]
          })
        })
      })]
    });
  }
  EditorTable.config = Table2.config;
  var type2 = "expression";
  function EditorExpressionField(props) {
    const {
      field
    } = props;
    const {
      expression = "",
      key
    } = field;
    const Icon = iconsByType("expression");
    const expressionLanguage2 = useService$1("expressionLanguage");
    let placeholderContent = "Expression is empty";
    if (expression.trim() && expressionLanguage2.isExpression(expression)) {
      placeholderContent = `Expression for '${key}'`;
    }
    return u2("div", {
      class: editorFormFieldClasses(type2),
      children: u2("div", {
        class: "fjs-form-field-placeholder",
        children: [u2(Icon, {
          viewBox: "0 0 54 54"
        }), placeholderContent]
      })
    });
  }
  EditorExpressionField.config = {
    ...ExpressionField.config,
    escapeGridRender: false
  };
  function EditorDocumentPreview(props) {
    const {
      field,
      domId
    } = props;
    const {
      label
    } = field;
    const Icon = iconsByType(field.type);
    return u2("div", {
      class: editorFormFieldClasses(field.type),
      children: [u2(Label, {
        id: domId,
        label
      }), u2("div", {
        class: "fjs-documentPreview-placeholder",
        id: domId,
        children: u2("p", {
          class: "fjs-documentPreview-placeholder-text",
          children: [u2(Icon, {
            width: "32",
            height: "24",
            viewBox: "0 0 56 56"
          }), "Document preview"]
        })
      })]
    });
  }
  EditorDocumentPreview.config = DocumentPreview.config;
  var editorFormFields = [EditorIFrame, EditorText, EditorHtml, EditorTable, EditorExpressionField, EditorDocumentPreview];
  var EditorFormFields = class extends FormFields {
    constructor() {
      super();
      editorFormFields.forEach((formField) => {
        this.register(formField.config.type, formField);
      });
    }
  };
  var ModularSection = (props) => {
    const {
      rootClass,
      RootElement,
      section,
      children
    } = props;
    const eventBus = useService$1("eventBus");
    const sectionConfig = useService$1(`config.${section}`);
    const [parent, setParent] = d2(sectionConfig && sectionConfig.parent || null);
    const [shouldRender, setShouldRender] = d2(true);
    const ParentElement = T2(() => {
      if (parent === null) {
        return null;
      }
      if (typeof parent === "string") {
        const element = document.querySelector(parent);
        if (!element) {
          throw new Error(`Target root element with selector '${parent}' not found for section '${section}'`);
        }
        return document.querySelector(parent);
      }
      if (!(parent instanceof Element)) {
        throw new Error(`Target root element for section '${section}' must be a valid selector or DOM element`);
      }
      return parent;
    }, [section, parent]);
    y2(() => {
      const onAttach = ({
        container
      }) => {
        setParent(container);
        setShouldRender(true);
      };
      const onDetach = () => {
        setParent(null);
        setShouldRender(false);
      };
      const onReset = () => {
        setParent(null);
        setShouldRender(true);
      };
      eventBus.on(`${section}.attach`, onAttach);
      eventBus.on(`${section}.detach`, onDetach);
      eventBus.on(`${section}.reset`, onReset);
      eventBus.fire(`${section}.section.rendered`);
      return () => {
        eventBus.off(`${section}.attach`, onAttach);
        eventBus.off(`${section}.detach`, onDetach);
        eventBus.off(`${section}.reset`, onReset);
        eventBus.fire(`${section}.section.destroyed`);
      };
    }, [eventBus, section]);
    y2(() => {
      if (shouldRender) {
        eventBus.fire(`${section}.rendered`, {
          element: ParentElement
        });
        return () => {
          eventBus.fire(`${section}.destroyed`, {
            element: ParentElement
          });
        };
      }
    }, [eventBus, section, shouldRender, ParentElement]);
    const Root = q2(({
      children: children2
    }) => RootElement ? u2(RootElement, {
      children: children2
    }) : u2("div", {
      className: rootClass,
      children: children2
    }), [rootClass, RootElement]);
    return shouldRender ? parent ? $2(u2(Root, {
      children
    }), ParentElement) : u2(Root, {
      children
    }) : null;
  };
  var FillContext = K({
    addFill(uid, props) {
      throw new Error("FillContext.addFill() uninitialized");
    },
    removeFill(uid) {
      throw new Error("FillContext.addFill() uninitialized");
    }
  });
  var Fill = (props) => {
    const uid = A2(Symbol("fill_uid"));
    const fillContext = x2(FillContext);
    y2(() => {
      if (!fillContext) {
        return;
      }
      fillContext.addFill({
        id: uid,
        ...props
      });
      return () => {
        fillContext.removeFill(uid);
      };
    }, [fillContext, props]);
    return null;
  };
  var SlotContext = K({
    fills: []
  });
  var Slot = (props) => {
    const {
      name: name2,
      fillRoot = FillFragment,
      groupFn = _groupByGroupName,
      separatorFn = (key) => null,
      limit
    } = props;
    const {
      fills
    } = x2(SlotContext);
    const filtered = T2(() => fills.filter((fill) => fill.slot === name2), [fills, name2]);
    const cropped = T2(() => limit ? filtered.slice(0, limit) : filtered, [filtered, limit]);
    const groups = T2(() => groupFn(cropped), [cropped, groupFn]);
    const fillsAndSeparators = T2(() => {
      return buildFills(groups, fillRoot, separatorFn);
    }, [groups, fillRoot, separatorFn]);
    return fillsAndSeparators;
  };
  var FillFragment = (fill) => u2(k, {
    children: fill.children
  }, fill.id);
  var buildFills = (groups, fillRenderer, separatorRenderer) => {
    const result = [];
    groups.forEach((array, idx) => {
      if (idx !== 0) {
        const separator = separatorRenderer(`__separator_${idx}`);
        if (separator) {
          result.push(separator);
        }
      }
      array.forEach((fill) => {
        result.push(fillRenderer(fill));
      });
    });
    return result;
  };
  var _groupByGroupName = (fills) => {
    const groups = [];
    const groupsById = {};
    fills.forEach(function(fill) {
      const {
        group: groupName = "z_default"
      } = fill;
      let group = groupsById[groupName];
      if (!group) {
        groupsById[groupName] = group = [];
        groups.push(group);
      }
      group.push(fill);
    });
    groups.forEach((group) => group.sort(_comparePriority));
    return Object.keys(groupsById).sort().map((id2) => groupsById[id2]);
  };
  var _comparePriority = (a3, b2) => {
    return (b2.priority || 0) - (a3.priority || 0);
  };
  var noop2 = () => {
  };
  var SlotFillRoot = (props) => {
    const [fills, setFills] = d2([]);
    const {
      onSetFill = noop2,
      onRemoveFill = noop2
    } = props;
    const fillContext = T2(() => ({
      addFill: (fill) => {
        setFills((fills2) => [...fills2.filter((f4) => f4.id !== fill.id), fill]);
        onSetFill(fill);
      },
      removeFill: (id2) => {
        setFills((fills2) => fills2.filter((f4) => f4.id !== id2));
        onRemoveFill(id2);
      }
    }), [onRemoveFill, onSetFill]);
    const slotContext = T2(() => ({
      fills
    }), [fills]);
    return u2(SlotContext.Provider, {
      value: slotContext,
      children: u2(FillContext.Provider, {
        value: fillContext,
        children: props.children
      })
    });
  };
  function PaletteEntry(props) {
    const {
      type: type3,
      label,
      icon,
      iconUrl,
      getPaletteIcon: getPaletteIcon2
    } = props;
    const modeling = useService$1("modeling");
    const formEditor = useService$1("formEditor");
    const Icon = getPaletteIcon2({
      icon,
      iconUrl,
      label,
      type: type3
    });
    const onKeyDown = (event2) => {
      if (event2.code === "Enter") {
        const {
          fieldType: type4
        } = event2.target.dataset;
        const {
          schema
        } = formEditor._getState();
        modeling.addFormField({
          type: type4
        }, schema, schema.components.length);
      }
    };
    return u2("button", {
      type: "button",
      class: "fjs-palette-field fjs-drag-copy fjs-no-drop",
      "data-field-type": type3,
      title: `Create ${getIndefiniteArticle(type3)} ${label} element`,
      onKeyDown,
      children: [Icon ? u2(Icon, {
        class: "fjs-palette-field-icon",
        width: "36",
        height: "36",
        viewBox: "0 0 54 54"
      }) : null, u2("span", {
        class: "fjs-palette-field-text",
        children: label
      })]
    });
  }
  function getIndefiniteArticle(type3) {
    if (["image"].includes(type3)) {
      return "an";
    }
    return "a";
  }
  var PALETTE_GROUPS = [{
    label: "Input",
    id: "basic-input"
  }, {
    label: "Selection",
    id: "selection"
  }, {
    label: "Presentation",
    id: "presentation"
  }, {
    label: "Containers",
    id: "container"
  }, {
    label: "Action",
    id: "action"
  }];
  function Palette(props) {
    const formFields2 = useService$1("formFields");
    const initialPaletteEntries = A2(collectPaletteEntries(formFields2));
    const [paletteEntries, setPaletteEntries] = d2(initialPaletteEntries.current);
    const [searchTerm, setSearchTerm] = d2("");
    const inputRef = A2();
    const groups = groupEntries(paletteEntries);
    const simplifyString = q2((str) => {
      return str.toLowerCase().replace(/\s+/g, "");
    }, []);
    const filter = q2((entry) => {
      const simplifiedSearchTerm = simplifyString(searchTerm);
      if (!simplifiedSearchTerm) {
        return true;
      }
      const simplifiedEntryLabel = simplifyString(entry.label);
      const simplifiedEntryType = simplifyString(entry.type);
      return simplifiedEntryLabel.includes(simplifiedSearchTerm) || simplifiedEntryType.includes(simplifiedSearchTerm);
    }, [searchTerm, simplifyString]);
    y2(() => {
      const entries2 = initialPaletteEntries.current.filter(filter);
      setPaletteEntries(entries2);
    }, [filter, searchTerm]);
    const handleInput = q2((event2) => {
      setSearchTerm(() => event2.target.value);
    }, [setSearchTerm]);
    const handleClear = q2((event2) => {
      setSearchTerm("");
      inputRef.current.focus();
    }, [inputRef, setSearchTerm]);
    return u2("div", {
      class: "fjs-palette",
      children: [u2("div", {
        class: "fjs-palette-header",
        title: "Components",
        children: "Components"
      }), u2("div", {
        class: "fjs-palette-search-container",
        children: [u2("span", {
          class: "fjs-palette-search-icon",
          children: u2(SvgSearch, {})
        }), u2("input", {
          class: "fjs-palette-search",
          ref: inputRef,
          type: "text",
          placeholder: "Search components",
          value: searchTerm,
          onInput: handleInput
        }), searchTerm && u2("button", {
          type: "button",
          title: "Clear content",
          class: "fjs-palette-search-clear",
          onClick: handleClear,
          children: u2(SvgClose, {})
        })]
      }), u2("div", {
        class: "fjs-palette-entries",
        children: [groups.map(({
          label,
          entries: entries2,
          id: id2
        }) => u2("div", {
          class: "fjs-palette-group",
          "data-group-id": id2,
          children: [u2("span", {
            class: "fjs-palette-group-title",
            children: label
          }), u2("div", {
            class: "fjs-palette-fields fjs-drag-container fjs-no-drop",
            children: entries2.map((entry) => {
              return u2(PaletteEntry, {
                getPaletteIcon,
                ...entry
              }, entry.type);
            })
          })]
        }, id2)), groups.length == 0 && u2("div", {
          class: "fjs-palette-no-entries",
          children: "No components found."
        })]
      }), u2("div", {
        class: "fjs-palette-footer",
        children: u2(Slot, {
          name: "editor-palette__footer",
          fillRoot: FillRoot
        })
      })]
    });
  }
  var FillRoot = (fill) => u2("div", {
    className: "fjs-palette-footer-fill",
    children: fill.children
  });
  function groupEntries(entries2) {
    const groups = PALETTE_GROUPS.map((group) => {
      return {
        ...group,
        entries: []
      };
    });
    const getGroup = (id2) => groups.find((group) => id2 === group.id);
    entries2.forEach((entry) => {
      const {
        group
      } = entry;
      getGroup(group).entries.push(entry);
    });
    return groups.filter((g4) => g4.entries.length);
  }
  function collectPaletteEntries(formFields2) {
    return Object.entries(formFields2._formFields).map(([type3, formField]) => {
      const {
        config: fieldConfig
      } = formField;
      return {
        // fieldConfig.label is used to maintain backwards compatibility with custom form fields
        label: fieldConfig.name || fieldConfig.label,
        type: type3,
        group: fieldConfig.group,
        icon: fieldConfig.icon,
        iconUrl: fieldConfig.iconUrl
      };
    }).filter(({
      type: type3
    }) => type3 !== "default");
  }
  function getPaletteIcon(entry) {
    const {
      icon,
      iconUrl,
      type: type3,
      label
    } = entry;
    let Icon;
    if (iconUrl) {
      Icon = function Icon2() {
        return u2("img", {
          class: "fjs-field-icon-image",
          width: 36,
          style: {
            margin: "auto"
          },
          alt: label,
          src: sanitizeImageSource(iconUrl)
        });
      };
    } else {
      Icon = icon || iconsByType(type3);
    }
    return Icon;
  }
  var InjectedRendersRoot = () => {
    const renderInjector = useService$1("renderInjector");
    const injectedRenderers = renderInjector.fetchRenderers();
    const injectedProps = T2(() => ({
      useService: useService$1,
      components: {
        Fill,
        Slot
      }
    }), []);
    return u2(k, {
      children: injectedRenderers.map(({
        Renderer: Renderer3
      }, index2) => u2(Renderer3, {
        ...injectedProps
      }, index2))
    });
  };
  var CURSOR_CLS_PATTERN = /^fjs-cursor-.*$/;
  function set2(mode3) {
    const classes$1 = classes(document.body);
    classes$1.removeMatching(CURSOR_CLS_PATTERN);
    if (mode3) {
      classes$1.add("fjs-cursor-" + mode3);
    }
  }
  function unset() {
    set2(null);
  }
  var DRAG_CONTAINER_CLS = "fjs-drag-container";
  var DROP_CONTAINER_VERTICAL_CLS = "fjs-drop-container-vertical";
  var DROP_CONTAINER_HORIZONTAL_CLS = "fjs-drop-container-horizontal";
  var DRAG_MOVE_CLS = "fjs-drag-move";
  var DRAG_ROW_MOVE_CLS = "fjs-drag-row-move";
  var DRAG_COPY_CLS = "fjs-drag-copy";
  var DRAG_NO_DROP_CLS = "fjs-no-drop";
  var DRAG_NO_MOVE_CLS = "fjs-no-move";
  var ERROR_DROP_CLS = "fjs-error-drop";
  var Dragging = class {
    /**
     * @constructor
     *
     * @param { import('../../core/FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     * @param { import('../../core/FormLayouter').FormLayouter } formLayouter
     * @param { import('../../core/FormLayoutValidator').FormLayoutValidator } formLayoutValidator
     * @param { import('../../core/EventBus').EventBus } eventBus
     * @param { import('../modeling/Modeling').Modeling } modeling
     * @param { import('@bpmn-io/form-js-viewer').PathRegistry } pathRegistry
     */
    constructor(formFieldRegistry, formLayouter, formLayoutValidator, eventBus, modeling, pathRegistry) {
      this._formFieldRegistry = formFieldRegistry;
      this._formLayouter = formLayouter;
      this._formLayoutValidator = formLayoutValidator;
      this._eventBus = eventBus;
      this._modeling = modeling;
      this._pathRegistry = pathRegistry;
    }
    /**
     * Calculates position in form schema given the dropped place.
     *
     * @param { FormRow } targetRow
     * @param { any } targetFormField
     * @param { HTMLElement } sibling
     * @returns { number }
     */
    getTargetIndex(targetRow, targetFormField, sibling) {
      const siblingFormFieldNode = sibling && sibling.querySelector(".fjs-element");
      const siblingFormField = siblingFormFieldNode && this._formFieldRegistry.get(siblingFormFieldNode.dataset.id);
      if (siblingFormField) {
        return getFormFieldIndex$1(targetFormField, siblingFormField);
      }
      if (targetRow) {
        return getFormFieldIndex$1(targetFormField, this._formFieldRegistry.get(targetRow.components[targetRow.components.length - 1])) + 1;
      }
      return targetFormField.components.length;
    }
    validateDrop(element, target) {
      const formFieldNode = element.querySelector(".fjs-element");
      const targetRow = this._formLayouter.getRow(target.dataset.rowId);
      let columns;
      let formField;
      let targetParentId;
      if (formFieldNode) {
        formField = this._formFieldRegistry.get(formFieldNode.dataset.id);
        if (!formField) {
          return "No associated form field in the registry";
        }
        columns = (formField.layout || {}).columns;
        if (isRow(target)) {
          targetParentId = getFormParent(target).dataset.id;
          const rowError = this._formLayoutValidator.validateField(formField, columns, targetRow);
          if (rowError) {
            return rowError;
          }
        } else {
          targetParentId = target.dataset.id;
        }
        if (!targetParentId) {
          return "Drop is not a valid target";
        }
        const targetParentFormField = this._formFieldRegistry.get(targetParentId);
        const currentParentFormField = this._formFieldRegistry.get(formField._parent);
        if (targetParentFormField !== currentParentFormField) {
          const targetParentPath = this._pathRegistry.getValuePath(targetParentFormField);
          const currentParentPath = this._pathRegistry.getValuePath(currentParentFormField);
          if (targetParentPath.join(".") !== currentParentPath.join(".")) {
            const isDropAllowedByPathRegistry = this._pathRegistry.executeRecursivelyOnFields(formField, ({
              field,
              isClosed,
              isRepeatable
            }) => {
              const options2 = {
                cutoffNode: currentParentFormField.id
              };
              const fieldPath = this._pathRegistry.getValuePath(field, options2);
              return this._pathRegistry.canClaimPath([...targetParentPath, ...fieldPath], {
                isClosed,
                isRepeatable,
                knownAncestorIds: getAncestryList(targetParentId, this._formFieldRegistry)
              });
            });
            if (!isDropAllowedByPathRegistry) {
              return "Drop not allowed by path registry";
            }
          }
        }
      }
    }
    moveField(element, source, targetRow, targetFormField, targetIndex) {
      const formFieldNode = element.querySelector(".fjs-element");
      const formField = this._formFieldRegistry.get(formFieldNode.dataset.id);
      const sourceParent = getFormParent(source);
      const sourceFormField = this._formFieldRegistry.get(sourceParent.dataset.id);
      const sourceIndex = getFormFieldIndex$1(sourceFormField, formField);
      const sourceRow = this._formLayouter.getRowForField(formField);
      this._modeling.moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex, sourceRow, targetRow);
    }
    createNewField(element, targetRow, targetFormField, targetIndex) {
      const type3 = element.dataset.fieldType;
      let attrs = {
        type: type3
      };
      attrs = {
        ...attrs,
        _parent: targetFormField.id,
        layout: {
          row: targetRow ? targetRow.id : this._formLayouter.nextRowId(),
          // enable auto columns
          columns: null
        }
      };
      this._modeling.addFormField(attrs, targetFormField, targetIndex);
    }
    handleRowDrop(el, target, source, sibling) {
      const targetFormField = this._formFieldRegistry.get(target.dataset.id);
      const rowNode = el.querySelector(".fjs-layout-row");
      const row = this._formLayouter.getRow(rowNode.dataset.rowId);
      row.components.forEach((id2, index2) => {
        const formField = this._formFieldRegistry.get(id2);
        const sourceParent = getFormParent(source);
        const sourceFormField = this._formFieldRegistry.get(sourceParent.dataset.id);
        const siblingRowNode = sibling && sibling.querySelector(".fjs-layout-row");
        const siblingRow = siblingRowNode && this._formLayouter.getRow(siblingRowNode.dataset.rowId);
        const siblingFormField = sibling && this._formFieldRegistry.get(siblingRow.components[0]);
        const sourceIndex = getFormFieldIndex$1(sourceFormField, formField);
        const targetIndex = (siblingRowNode ? getFormFieldIndex$1(targetFormField, siblingFormField) : targetFormField.components.length) + index2;
        this._modeling.moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex, row, row);
      });
    }
    handleElementDrop(el, target, source, sibling, drake) {
      const targetFormField = this._formFieldRegistry.get(getFormParent(target).dataset.id);
      let targetRow;
      if (isRow(target)) {
        targetRow = this._formLayouter.getRow(target.dataset.rowId);
      }
      const validationError = this.validateDrop(el, target);
      if (validationError) {
        return drake.cancel(true);
      }
      drake.remove();
      const targetIndex = this.getTargetIndex(targetRow, targetFormField, sibling);
      if (isPalette(source)) {
        this.createNewField(el, targetRow, targetFormField, targetIndex);
      } else {
        this.moveField(el, source, targetRow, targetFormField, targetIndex);
      }
    }
    /**
     * @param { { container: Array<string>, direction: string, mirrorContainer: string } } options
     */
    createDragulaInstance(options2) {
      const {
        container,
        mirrorContainer
      } = options2 || {};
      let dragulaOptions = {
        direction: function(el, target) {
          if (isRow(target)) {
            return "horizontal";
          }
          return "vertical";
        },
        mirrorContainer,
        isContainer(el) {
          return container.some((cls) => el.classList.contains(cls));
        },
        moves(el, source, handle) {
          return !handle.classList.contains(DRAG_NO_MOVE_CLS) && (el.classList.contains(DRAG_MOVE_CLS) || el.classList.contains(DRAG_COPY_CLS) || el.classList.contains(DRAG_ROW_MOVE_CLS));
        },
        copy(el) {
          return el.classList.contains(DRAG_COPY_CLS);
        },
        accepts: (el, target) => {
          unsetDropNotAllowed(target);
          if (el.classList.contains(DRAG_ROW_MOVE_CLS)) {
            return !target.classList.contains(DROP_CONTAINER_HORIZONTAL_CLS);
          }
          const validationError = this.validateDrop(el, target);
          if (validationError) {
            setDropNotAllowed(target);
          }
          return !target.classList.contains(DRAG_NO_DROP_CLS);
        },
        transformOffset: (offset2, event2, element) => {
          if (element.classList.contains(DRAG_ROW_MOVE_CLS)) {
            const rowOffset = {
              x: -5,
              y: -60
            };
            return {
              left: event2.clientX + rowOffset.x,
              top: event2.clientY + rowOffset.y
            };
          }
          if (element.classList.contains(DRAG_MOVE_CLS)) {
            const iconOffset = {
              x: -5,
              y: -15
            };
            return {
              left: event2.clientX + iconOffset.x,
              top: event2.clientY + iconOffset.y
            };
          }
          return offset2;
        },
        slideFactorX: 10,
        slideFactorY: 5
      };
      const dragulaInstance = De(dragulaOptions);
      dragulaInstance.on("drag", (element, source) => {
        this.emit("drag.start", {
          element,
          source
        });
      });
      dragulaInstance.on("dragend", (element) => {
        this.emit("drag.end", {
          element
        });
      });
      dragulaInstance.on("drop", (element, target, source, sibling) => {
        this.emit("drag.drop", {
          element,
          target,
          source,
          sibling
        });
      });
      dragulaInstance.on("over", (element, container2, source) => {
        this.emit("drag.hover", {
          element,
          container: container2,
          source
        });
      });
      dragulaInstance.on("out", (element, container2, source) => {
        this.emit("drag.out", {
          element,
          container: container2,
          source
        });
      });
      dragulaInstance.on("cancel", (element, container2, source) => {
        this.emit("drag.cancel", {
          element,
          container: container2,
          source
        });
      });
      dragulaInstance.on("drop", (el, target, source, sibling) => {
        if (!target) {
          dragulaInstance.remove();
          return;
        }
        if (isDragRow(el)) {
          this.handleRowDrop(el, target, source, sibling);
        } else {
          this.handleElementDrop(el, target, source, sibling, dragulaInstance);
        }
      });
      this.emit("dragula.created", dragulaInstance);
      return dragulaInstance;
    }
    emit(event2, context) {
      this._eventBus.fire(event2, context);
    }
  };
  Dragging.$inject = ["formFieldRegistry", "formLayouter", "formLayoutValidator", "eventBus", "modeling", "pathRegistry"];
  function getFormFieldIndex$1(parent, formField) {
    let fieldFormIndex = parent.components.length;
    parent.components.forEach(({
      id: id2
    }, index2) => {
      if (id2 === formField.id) {
        fieldFormIndex = index2;
      }
    });
    return fieldFormIndex;
  }
  function isRow(node) {
    return node.classList.contains("fjs-layout-row");
  }
  function isDragRow(node) {
    return node.classList.contains(DRAG_ROW_MOVE_CLS);
  }
  function isPalette(node) {
    return node.classList.contains("fjs-palette-fields");
  }
  function getFormParent(node) {
    return node.closest(".fjs-element");
  }
  function setDropNotAllowed(node) {
    node.classList.add(ERROR_DROP_CLS);
    set2("not-allowed");
  }
  function unsetDropNotAllowed(node) {
    node.classList.remove(ERROR_DROP_CLS);
    set2("grabbing");
  }
  function FieldDragPreview(props) {
    const {
      class: className,
      Icon,
      label
    } = props;
    return u2("div", {
      class: (0, import_classnames2.default)("fjs-field-preview", className),
      children: [u2(Icon, {
        class: "fjs-field-preview-icon",
        width: "36",
        height: "36",
        viewBox: "0 0 54 54"
      }), u2("span", {
        class: "fjs-field-preview-text",
        children: label
      })]
    });
  }
  var COLUMNS_REGEX = /^cds--col(-lg)?/;
  var ELEMENT_RESIZING_CLS = "fjs-element-resizing";
  var GRID_OFFSET_PX = 16;
  function FieldResizer(props) {
    const {
      field,
      position
    } = props;
    const ref = A2(null);
    const formLayoutValidator = useService$1("formLayoutValidator");
    const modeling = useService$1("modeling");
    const context = A2({
      startColumns: 0,
      newColumns: 0
    });
    const onResize = throttle((_3, delta) => {
      const {
        x: dx
      } = delta;
      const {
        layout = {}
      } = field;
      const newColumns = calculateNewColumns(ref.current, layout.columns || context.current.startColumns, dx, position);
      const errorMessage = formLayoutValidator.validateField(field, newColumns);
      if (!errorMessage) {
        context.current.newColumns = newColumns;
        const columnNode = ref.current.closest(".fjs-layout-column");
        removeMatching(columnNode, COLUMNS_REGEX);
        columnNode.classList.add(`cds--col-lg-${newColumns}`);
      }
    });
    const onResizeStart = (event2) => {
      const target = getElementNode(field);
      const parent = getParent(target);
      const onDragStart = createDragger$1(onResize);
      onDragStart(event2);
      const columnNode = getColumnNode(target);
      const startWidth = columnNode.getBoundingClientRect().width + GRID_OFFSET_PX;
      context.current.startColumns = asColumns(startWidth, parent);
      setResizing(target, position);
    };
    const onResizeEnd = () => {
      const {
        layout = {}
      } = field;
      if (context.current.newColumns) {
        modeling.editFormField(field, "layout", {
          ...layout,
          columns: context.current.newColumns
        });
      }
      const target = getElementNode(field);
      unsetResizing(target, position);
      context.current.newColumns = null;
    };
    if (field.type === "default") {
      return null;
    }
    return u2("div", {
      ref,
      class: (0, import_classnames2.default)("fjs-field-resize-handle", "fjs-field-resize-handle-" + position, DRAG_NO_MOVE_CLS),
      draggable: true,
      onDragStart: onResizeStart,
      onDragEnd: onResizeEnd
    });
  }
  function asColumns(width, parent) {
    const totalWidth = parent.getBoundingClientRect().width;
    const oneColumn = 1 / 16 * totalWidth;
    return Math.round(width / oneColumn);
  }
  function calculateNewColumns(node, currentColumns, deltaX, position) {
    const parent = getParent(node);
    if (position === "left") {
      deltaX = deltaX * -1;
    }
    const deltaColumns = asColumns(deltaX, parent);
    return currentColumns + deltaColumns;
  }
  function getParent(node) {
    return node.closest(".fjs-layout-row");
  }
  function removeMatching(node, regex) {
    return classes(node).removeMatching(regex);
  }
  function getColumnNode(node) {
    return node.closest(".fjs-layout-column");
  }
  function getElementNode(field) {
    return query('.fjs-element[data-id="' + field.id + '"]');
  }
  function setResizing(node, position) {
    classes(node).add(ELEMENT_RESIZING_CLS + "-" + position);
  }
  function unsetResizing(node, position) {
    classes(node).remove(ELEMENT_RESIZING_CLS + "-" + position);
  }
  function ContextPad(props) {
    if (!props.children) {
      return null;
    }
    return u2("div", {
      class: "fjs-context-pad",
      children: props.children
    });
  }
  function EmptyGroup() {
    return u2("div", {
      class: "fjs-empty-component",
      children: u2("span", {
        class: "fjs-empty-component-text",
        children: "Drag and drop components here."
      })
    });
  }
  function EmptyForm() {
    return u2("div", {
      class: "fjs-empty-editor",
      children: u2("div", {
        class: "fjs-empty-editor-card",
        children: [u2(SvgEmptyForm, {}), u2("h2", {
          children: "Build your form"
        }), u2("span", {
          children: "Drag and drop components here to start designing."
        }), u2("span", {
          children: "Use the preview window to test your form."
        })]
      })
    });
  }
  function Empty(props) {
    if (["group", "dynamiclist"].includes(props.field.type)) {
      return u2(EmptyGroup, {});
    }
    if (props.field.type === "default") {
      return u2(EmptyForm, {});
    }
    return null;
  }
  function Element$1(props) {
    const eventBus = useService$1("eventBus"), formFieldRegistry = useService$1("formFieldRegistry"), formFields2 = useService$1("formFields"), modeling = useService$1("modeling"), selection2 = useService$1("selection");
    const {
      hoverInfo
    } = x2(FormRenderContext);
    const {
      field
    } = props;
    const {
      id: id2,
      type: type3,
      showOutline
    } = field;
    const ref = A2();
    const [hovered, setHovered] = d2(false);
    y2(() => {
      function scrollIntoView3({
        selection: selection3
      }) {
        const scrollContainer = getScrollContainer(ref.current);
        if (!selection3 || selection3.type === "default" || selection3.id !== id2 || !scrollContainer || !ref.current) {
          return;
        }
        const elementBounds = ref.current.getBoundingClientRect();
        const scrollContainerBounds = scrollContainer.getBoundingClientRect();
        const isElementLarger = elementBounds.height > scrollContainerBounds.height;
        const isNotFullyVisible = elementBounds.bottom > scrollContainerBounds.bottom || elementBounds.top < scrollContainerBounds.top;
        if (isNotFullyVisible && !isElementLarger) {
          ref.current.scrollIntoView({
            behavior: "auto",
            block: "nearest"
          });
        }
      }
      eventBus.on("selection.changed", scrollIntoView3);
      return () => eventBus.off("selection.changed", scrollIntoView3);
    }, [eventBus, id2]);
    _2(() => {
      if (selection2.isSelected(field)) {
        ref.current.focus();
      }
    }, [selection2, field]);
    const onClick = q2((event2) => {
      const fieldEl = event2.target.closest("[data-id]");
      if (!fieldEl) {
        return;
      }
      const id3 = fieldEl.dataset.id;
      if (id3 === field.id) {
        selection2.toggle(field);
      }
    }, [field, selection2]);
    const isSelected = selection2.isSelected(field);
    const classString = T2(() => {
      const classes2 = [];
      if (props.class) {
        classes2.push(...props.class.split(" "));
      }
      if (isSelected) {
        classes2.push("fjs-editor-selected");
      }
      const grouplike = ["group", "dynamiclist"].includes(type3);
      if (grouplike) {
        classes2.push(showOutline ? "fjs-outlined" : "fjs-dashed-outlined");
      }
      if (hovered) {
        classes2.push("fjs-editor-hovered");
      }
      return classes2.join(" ");
    }, [hovered, isSelected, props.class, showOutline, type3]);
    const onRemove = (event2) => {
      event2.stopPropagation();
      const parentField = formFieldRegistry.get(field._parent);
      const index2 = getFormFieldIndex(parentField, field);
      modeling.removeFormField(field, parentField, index2);
    };
    const onKeyPress = (event2) => {
      if (event2.key === "Enter") {
        event2.stopPropagation();
        selection2.toggle(field);
      }
    };
    return u2("div", {
      class: classString,
      "data-id": id2,
      "data-field-type": type3,
      tabIndex: type3 === "default" ? -1 : 0,
      onClick,
      onKeyPress,
      onMouseOver: (e3) => {
        if (hoverInfo.cleanup) {
          hoverInfo.cleanup();
        }
        setHovered(true);
        hoverInfo.cleanup = () => setHovered(false);
        e3.stopPropagation();
      },
      ref,
      children: [u2(DebugColumns, {
        field
      }), u2(ContextPad, {
        children: selection2.isSelected(field) && field.type !== "default" ? u2("button", {
          type: "button",
          title: getRemoveButtonTitle(field, formFields2),
          class: "fjs-context-pad-item",
          onClick: onRemove,
          children: u2(SvgDelete3, {})
        }) : null
      }), props.children, u2(FieldResizer, {
        position: "left",
        field
      }), u2(FieldResizer, {
        position: "right",
        field
      })]
    });
  }
  function DebugColumns(props) {
    const {
      field
    } = props;
    const debugColumnsConfig = useService$1("config.debugColumns");
    if (!debugColumnsConfig || field.type == "default") {
      return null;
    }
    return u2("div", {
      style: "width: fit-content; padding: 2px 6px; height: 16px; background: var(--color-blue-205-100-95); display: flex; justify-content: center; align-items: center; position: absolute; bottom: -2px; z-index: 2; font-size: 10px; right: 3px;",
      class: "fjs-debug-columns",
      children: (field.layout || {}).columns || "auto"
    });
  }
  function Children(props) {
    const {
      field
    } = props;
    const {
      id: id2
    } = field;
    const classes2 = ["fjs-children", DROP_CONTAINER_VERTICAL_CLS];
    if (props.class) {
      classes2.push(...props.class.split(" "));
    }
    return u2("div", {
      class: classes2.join(" "),
      "data-id": id2,
      children: props.children
    });
  }
  function Row(props) {
    const {
      row
    } = props;
    const {
      id: id2
    } = row;
    const classes2 = [DROP_CONTAINER_HORIZONTAL_CLS];
    if (props.class) {
      classes2.push(...props.class.split(" "));
    }
    return u2("div", {
      class: (0, import_classnames2.default)(DRAG_ROW_MOVE_CLS),
      children: [u2("span", {
        class: "fjs-row-dragger",
        children: u2(SvgDraggable, {})
      }), u2("div", {
        class: classes2.join(" "),
        style: props.style,
        "data-row-id": id2,
        children: props.children
      })]
    });
  }
  function Column(props) {
    const {
      field
    } = props;
    const classes2 = [DRAG_MOVE_CLS];
    if (field.type === "default") {
      return props.children;
    }
    if (props.class) {
      classes2.push(...props.class.split(" "));
    }
    return u2("div", {
      "data-field-type": field.type,
      class: classes2.join(" "),
      children: props.children
    });
  }
  function FormEditor$1() {
    const dragging = useService$1("dragging"), eventBus = useService$1("eventBus"), formEditor = useService$1("formEditor"), injector = useService$1("injector"), selection2 = useService$1("selection"), propertiesPanel = useService$1("propertiesPanel"), propertiesPanelConfig = useService$1("config.propertiesPanel");
    const {
      schema,
      properties
    } = formEditor._getState();
    const {
      ariaLabel
    } = properties;
    const formContainerRef = A2(null);
    const propertiesPanelRef = A2(null);
    const [, setSelection] = d2(schema);
    const [hasInitialized, setHasInitialized] = d2(false);
    y2(() => {
      function handleSelectionChanged(event2) {
        setSelection(event2.selection || schema);
      }
      eventBus.on("selection.changed", handleSelectionChanged);
      return () => {
        eventBus.off("selection.changed", handleSelectionChanged);
      };
    }, [eventBus, schema]);
    y2(() => {
      setSelection(selection2.get() || schema);
    }, [selection2, schema]);
    const [drake, setDrake] = d2(null);
    const dragAndDropContext = {
      drake
    };
    y2(() => {
      let dragulaInstance = dragging.createDragulaInstance({
        container: [DRAG_CONTAINER_CLS, DROP_CONTAINER_VERTICAL_CLS, DROP_CONTAINER_HORIZONTAL_CLS],
        mirrorContainer: formContainerRef.current
      });
      setDrake(dragulaInstance);
      const onDetach = () => {
        if (dragulaInstance) {
          dragulaInstance.destroy();
          eventBus.fire("dragula.destroyed");
        }
      };
      const onAttach = () => {
        onDetach();
        dragulaInstance = dragging.createDragulaInstance({
          container: [DRAG_CONTAINER_CLS, DROP_CONTAINER_VERTICAL_CLS, DROP_CONTAINER_HORIZONTAL_CLS],
          mirrorContainer: formContainerRef.current
        });
        setDrake(dragulaInstance);
      };
      const onCreate = (drake2) => {
        setDrake(drake2);
      };
      const onDragStart = () => {
        set2("grabbing");
      };
      const onDragEnd = () => {
        unset();
      };
      eventBus.on("attach", onAttach);
      eventBus.on("detach", onDetach);
      eventBus.on("dragula.created", onCreate);
      eventBus.on("drag.start", onDragStart);
      eventBus.on("drag.end", onDragEnd);
      return () => {
        onDetach();
        eventBus.off("attach", onAttach);
        eventBus.off("detach", onDetach);
        eventBus.off("dragula.created", onCreate);
        eventBus.off("drag.start", onDragStart);
        eventBus.off("drag.end", onDragEnd);
      };
    }, [dragging, eventBus]);
    y2(() => {
      if (hasInitialized) {
        return;
      }
      setHasInitialized(true);
      eventBus.fire("rendered");
      eventBus.fire("formEditor.rendered");
    }, [eventBus, hasInitialized]);
    const formRenderContext = T2(() => ({
      Children,
      Column,
      Element: Element$1,
      Empty,
      Row,
      hoverInfo: {}
    }), []);
    const formContext = T2(() => ({
      getService(type3, strict = true) {
        if (type3 === "form") {
          return {
            _getState() {
              return {
                data: {},
                errors: {},
                properties: {
                  ariaLabel,
                  disabled: true
                },
                schema
              };
            }
          };
        }
        return injector.get(type3, strict);
      },
      formId: formEditor._id
    }), [ariaLabel, formEditor, injector, schema]);
    const onSubmit = q2(() => {
    }, []);
    const onReset = q2(() => {
    }, []);
    const hasDefaultPropertiesPanel = defaultPropertiesPanel(propertiesPanelConfig);
    y2(() => {
      if (hasDefaultPropertiesPanel) {
        propertiesPanel.attachTo(propertiesPanelRef.current);
      }
    }, [propertiesPanelRef, propertiesPanel, hasDefaultPropertiesPanel]);
    return u2("div", {
      class: "fjs-form-editor",
      children: u2(SlotFillRoot, {
        children: [u2(DragAndDropContext.Provider, {
          value: dragAndDropContext,
          children: [u2(ModularSection, {
            rootClass: "fjs-palette-container",
            section: "palette",
            children: u2(Palette, {})
          }), u2("div", {
            ref: formContainerRef,
            class: "fjs-form-container",
            children: u2(FormContext.Provider, {
              value: formContext,
              children: u2(FormRenderContext.Provider, {
                // @ts-ignore
                value: formRenderContext,
                children: u2(FormComponent, {
                  onSubmit,
                  onReset
                })
              })
            })
          }), u2(CreatePreview, {})]
        }), hasDefaultPropertiesPanel && u2("div", {
          class: "fjs-editor-properties-container",
          ref: propertiesPanelRef
        }), u2(ModularSection, {
          rootClass: "fjs-render-injector-container",
          section: "renderInjector",
          children: u2(InjectedRendersRoot, {})
        })]
      })
    });
  }
  function getFormFieldIndex(parent, formField) {
    let fieldFormIndex = parent.components.length;
    parent.components.forEach(({
      id: id2
    }, index2) => {
      if (id2 === formField.id) {
        fieldFormIndex = index2;
      }
    });
    return fieldFormIndex;
  }
  function CreatePreview(props) {
    const {
      drake
    } = x2(DragAndDropContext);
    const formFields2 = useService$1("formFields");
    y2(() => {
      if (!drake) {
        return;
      }
      function handleCloned(clone5, original, type3) {
        const fieldType = clone5.dataset.fieldType;
        if (fieldType) {
          const paletteEntry = findPaletteEntry(fieldType, formFields2);
          if (!paletteEntry) {
            return;
          }
          const {
            label
          } = paletteEntry;
          const Icon = getPaletteIcon(paletteEntry);
          clone5.innerHTML = "";
          clone5.class = "gu-mirror";
          clone5.classList.add("fjs-field-preview-container");
          if (original.classList.contains("fjs-palette-field")) {
            clone5.classList.add("cds--col");
          }
          E(u2(FieldDragPreview, {
            label,
            Icon
          }), clone5);
        } else {
          ["fjs-context-pad", "fjs-row-dragger", "fjs-debug-columns"].forEach((cls) => {
            const cloneNode = clone5.querySelectorAll("." + cls);
            cloneNode.length && cloneNode.forEach((e3) => e3.remove());
          });
          clone5.classList.add("cds--grid");
          clone5.classList.add("cds--grid--condensed");
        }
      }
      drake.on("cloned", handleCloned);
      return () => drake.off("cloned", handleCloned);
    }, [drake, formFields2]);
    return null;
  }
  function findPaletteEntry(type3, formFields2) {
    return collectPaletteEntries(formFields2).find((entry) => entry.type === type3);
  }
  function defaultPropertiesPanel(propertiesPanelConfig) {
    return !(propertiesPanelConfig && propertiesPanelConfig.parent);
  }
  function getRemoveButtonTitle(formField, formFields2) {
    const entry = findPaletteEntry(formField.type, formFields2);
    if (!entry) {
      return "Remove form field";
    }
    return `Remove ${entry.label}`;
  }
  var Renderer2 = class {
    constructor(renderConfig, eventBus, formEditor, injector) {
      const {
        container,
        compact = false
      } = renderConfig;
      eventBus.on("form.init", function() {
        eventBus.fire("canvas.init", {
          svg: container,
          viewport: null
        });
      });
      container.addEventListener("mouseover", function() {
        if (document.activeElement === document.body) {
          container.focus({
            preventScroll: true
          });
        }
      });
      container.addEventListener("click", function(event2) {
        if (!container.contains(document.activeElement)) {
          container.focus({
            preventScroll: true
          });
        }
      });
      const App = () => {
        const [state, setState] = d2(formEditor._getState());
        const formEditorContext = {
          getService(type3, strict = true) {
            return injector.get(type3, strict);
          }
        };
        formEditor.on("changed", (newState) => {
          setState(newState);
        });
        const {
          schema
        } = state;
        if (!schema) {
          return null;
        }
        return u2("div", {
          class: `fjs-container fjs-editor-container ${compact ? "fjs-editor-compact" : ""}`,
          children: u2(FormEditorContext.Provider, {
            value: formEditorContext,
            children: u2(FormEditor$1, {})
          })
        });
      };
      eventBus.on("form.init", () => {
        E(u2(App, {}), container);
      });
      eventBus.on("form.destroy", () => {
        E(null, container);
      });
    }
  };
  Renderer2.$inject = ["config.renderer", "eventBus", "formEditor", "injector"];
  var RenderModule = {
    __init__: ["formFields", "renderer"],
    formFields: ["type", EditorFormFields],
    renderer: ["type", Renderer2]
  };
  var CoreModule = {
    __depends__: [RenderModule],
    debounce: ["factory", DebounceFactory],
    eventBus: ["type", EventBus2],
    importer: ["type", Importer],
    formFieldRegistry: ["type", FormFieldRegistry2],
    pathRegistry: ["type", PathRegistry],
    formLayouter: ["type", FormLayouter],
    formLayoutValidator: ["type", FormLayoutValidator],
    fieldFactory: ["type", FieldFactory]
  };
  var NOT_REGISTERED_ERROR = "is not a registered action";
  var IS_REGISTERED_ERROR = "is already registered";
  function EditorActions(eventBus, injector) {
    this._actions = {};
    var self2 = this;
    eventBus.on("diagram.init", function() {
      self2._registerDefaultActions(injector);
      eventBus.fire("editorActions.init", {
        editorActions: self2
      });
    });
  }
  EditorActions.$inject = ["eventBus", "injector"];
  EditorActions.prototype._registerDefaultActions = function(injector) {
    var commandStack = injector.get("commandStack", false);
    var modeling = injector.get("modeling", false);
    var selection2 = injector.get("selection", false);
    var zoomScroll = injector.get("zoomScroll", false);
    var copyPaste = injector.get("copyPaste", false);
    var canvas = injector.get("canvas", false);
    var rules = injector.get("rules", false);
    var keyboardMove = injector.get("keyboardMove", false);
    var keyboardMoveSelection = injector.get("keyboardMoveSelection", false);
    if (commandStack) {
      this.register("undo", function() {
        commandStack.undo();
      });
      this.register("redo", function() {
        commandStack.redo();
      });
    }
    if (copyPaste && selection2) {
      this.register("copy", function() {
        var selectedElements = selection2.get();
        if (selectedElements.length) {
          return copyPaste.copy(selectedElements);
        }
      });
    }
    if (copyPaste) {
      this.register("paste", function() {
        copyPaste.paste();
      });
    }
    if (zoomScroll) {
      this.register("stepZoom", function(opts) {
        zoomScroll.stepZoom(opts.value);
      });
    }
    if (canvas) {
      this.register("zoom", function(opts) {
        canvas.zoom(opts.value);
      });
    }
    if (modeling && selection2 && rules) {
      this.register("removeSelection", function() {
        var selectedElements = selection2.get();
        if (!selectedElements.length) {
          return;
        }
        var allowed = rules.allowed("elements.delete", {
          elements: selectedElements
        }), removableElements;
        if (allowed === false) {
          return;
        } else if (isArray(allowed)) {
          removableElements = allowed;
        } else {
          removableElements = selectedElements;
        }
        if (removableElements.length) {
          modeling.removeElements(removableElements.slice());
        }
      });
    }
    if (keyboardMove) {
      this.register("moveCanvas", function(opts) {
        keyboardMove.moveCanvas(opts);
      });
    }
    if (keyboardMoveSelection) {
      this.register("moveSelection", function(opts) {
        keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
      });
    }
  };
  EditorActions.prototype.trigger = function(action, opts) {
    if (!this._actions[action]) {
      throw error(action, NOT_REGISTERED_ERROR);
    }
    return this._actions[action](opts);
  };
  EditorActions.prototype.register = function(actions, listener) {
    var self2 = this;
    if (typeof actions === "string") {
      return this._registerAction(actions, listener);
    }
    forEach(actions, function(listener2, action) {
      self2._registerAction(action, listener2);
    });
  };
  EditorActions.prototype._registerAction = function(action, listener) {
    if (this.isRegistered(action)) {
      throw error(action, IS_REGISTERED_ERROR);
    }
    this._actions[action] = listener;
  };
  EditorActions.prototype.unregister = function(action) {
    if (!this.isRegistered(action)) {
      throw error(action, NOT_REGISTERED_ERROR);
    }
    this._actions[action] = void 0;
  };
  EditorActions.prototype.getActions = function() {
    return Object.keys(this._actions);
  };
  EditorActions.prototype.isRegistered = function(action) {
    return !!this._actions[action];
  };
  function error(action, message) {
    return new Error(action + " " + message);
  }
  var BaseEditorActionsModule = {
    __init__: ["editorActions"],
    editorActions: ["type", EditorActions]
  };
  var FormEditorActions = class extends EditorActions {
    constructor(eventBus, injector) {
      super(eventBus, injector);
      eventBus.on("form.init", () => {
        this._registerDefaultActions(injector);
        eventBus.fire("editorActions.init", {
          editorActions: this
        });
      });
    }
    _registerDefaultActions(injector) {
      const commandStack = injector.get("commandStack", false), formFieldRegistry = injector.get("formFieldRegistry", false), selection2 = injector.get("selection", false);
      if (commandStack) {
        this.register("undo", () => {
          commandStack.undo();
        });
        this.register("redo", () => {
          commandStack.redo();
        });
      }
      if (formFieldRegistry && selection2) {
        this.register("selectFormField", (options2 = {}) => {
          const {
            id: id2
          } = options2;
          if (!id2) {
            return;
          }
          const formField = formFieldRegistry.get(id2);
          if (formField) {
            selection2.set(formField);
          }
        });
      }
    }
  };
  FormEditorActions.$inject = ["eventBus", "injector"];
  var EditorActionsModule = {
    __depends__: [BaseEditorActionsModule],
    editorActions: ["type", FormEditorActions]
  };
  var EditorTemplating = class {
    // same rules as viewer templating
    isTemplate(value) {
      return isString(value) && (value.startsWith("=") || /{{/.test(value));
    }
    // return the template raw, as we usually just want to display that
    evaluate(template) {
      return template;
    }
  };
  EditorTemplating.$inject = [];
  var EditorExpressionLanguageModule = {
    __init__: ["expressionLanguage", "templating"],
    expressionLanguage: ["type", FeelExpressionLanguage],
    templating: ["type", EditorTemplating]
  };
  var KEYS_COPY = ["c", "C"];
  var KEYS_PASTE = ["v", "V"];
  var KEYS_REDO = ["y", "Y"];
  var KEYS_UNDO = ["z", "Z"];
  function hasModifier(event2) {
    return event2.ctrlKey || event2.metaKey || event2.shiftKey || event2.altKey;
  }
  function isCmd(event2) {
    if (event2.altKey) {
      return false;
    }
    return event2.ctrlKey || event2.metaKey;
  }
  function isKey(keys, event2) {
    keys = isArray(keys) ? keys : [keys];
    return keys.indexOf(event2.key) !== -1 || keys.indexOf(event2.code) !== -1;
  }
  function isShift(event2) {
    return event2.shiftKey;
  }
  function isCopy(event2) {
    return isCmd(event2) && isKey(KEYS_COPY, event2);
  }
  function isPaste(event2) {
    return isCmd(event2) && isKey(KEYS_PASTE, event2);
  }
  function isUndo(event2) {
    return isCmd(event2) && !isShift(event2) && isKey(KEYS_UNDO, event2);
  }
  function isRedo(event2) {
    return isCmd(event2) && (isKey(KEYS_REDO, event2) || isKey(KEYS_UNDO, event2) && isShift(event2));
  }
  var KEYDOWN_EVENT = "keyboard.keydown";
  var KEYUP_EVENT = "keyboard.keyup";
  var DEFAULT_PRIORITY$2 = 1e3;
  var compatMessage = "Keyboard binding is now implicit; explicit binding to an element got removed. For more information, see https://github.com/bpmn-io/diagram-js/issues/661";
  function Keyboard(config2, eventBus) {
    var self2 = this;
    this._config = config2 = config2 || {};
    this._eventBus = eventBus;
    this._keydownHandler = this._keydownHandler.bind(this);
    this._keyupHandler = this._keyupHandler.bind(this);
    eventBus.on("diagram.destroy", function() {
      self2._fire("destroy");
      self2.unbind();
    });
    if (config2.bindTo) {
      console.error("unsupported configuration <keyboard.bindTo>", new Error(compatMessage));
    }
    var bind2 = config2 && config2.bind !== false;
    eventBus.on("canvas.init", function(event2) {
      self2._target = event2.svg;
      if (bind2) {
        self2.bind();
      }
      self2._fire("init");
    });
  }
  Keyboard.$inject = ["config.keyboard", "eventBus"];
  Keyboard.prototype._keydownHandler = function(event2) {
    this._keyHandler(event2, KEYDOWN_EVENT);
  };
  Keyboard.prototype._keyupHandler = function(event2) {
    this._keyHandler(event2, KEYUP_EVENT);
  };
  Keyboard.prototype._keyHandler = function(event2, type3) {
    var eventBusResult;
    if (this._isEventIgnored(event2)) {
      return;
    }
    var context = {
      keyEvent: event2
    };
    eventBusResult = this._eventBus.fire(type3 || KEYDOWN_EVENT, context);
    if (eventBusResult) {
      event2.preventDefault();
    }
  };
  Keyboard.prototype._isEventIgnored = function(event2) {
    return false;
  };
  Keyboard.prototype.bind = function(node) {
    if (node) {
      console.error("unsupported argument <node>", new Error(compatMessage));
    }
    this.unbind();
    node = this._node = this._target;
    event.bind(node, "keydown", this._keydownHandler);
    event.bind(node, "keyup", this._keyupHandler);
    this._fire("bind");
  };
  Keyboard.prototype.getBinding = function() {
    return this._node;
  };
  Keyboard.prototype.unbind = function() {
    var node = this._node;
    if (node) {
      this._fire("unbind");
      event.unbind(node, "keydown", this._keydownHandler);
      event.unbind(node, "keyup", this._keyupHandler);
    }
    this._node = null;
  };
  Keyboard.prototype._fire = function(event2) {
    this._eventBus.fire("keyboard." + event2, {
      node: this._node
    });
  };
  Keyboard.prototype.addListener = function(priority, listener, type3) {
    if (isFunction(priority)) {
      type3 = listener;
      listener = priority;
      priority = DEFAULT_PRIORITY$2;
    }
    this._eventBus.on(type3 || KEYDOWN_EVENT, priority, listener);
  };
  Keyboard.prototype.removeListener = function(listener, type3) {
    this._eventBus.off(type3 || KEYDOWN_EVENT, listener);
  };
  Keyboard.prototype.hasModifier = hasModifier;
  Keyboard.prototype.isCmd = isCmd;
  Keyboard.prototype.isShift = isShift;
  Keyboard.prototype.isKey = isKey;
  var LOW_PRIORITY$1 = 500;
  function KeyboardBindings(eventBus, keyboard) {
    var self2 = this;
    eventBus.on("editorActions.init", LOW_PRIORITY$1, function(event2) {
      var editorActions = event2.editorActions;
      self2.registerBindings(keyboard, editorActions);
    });
  }
  KeyboardBindings.$inject = ["eventBus", "keyboard"];
  KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
    function addListener(action, fn4) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn4);
      }
    }
    addListener("undo", function(context) {
      var event2 = context.keyEvent;
      if (isUndo(event2)) {
        editorActions.trigger("undo");
        return true;
      }
    });
    addListener("redo", function(context) {
      var event2 = context.keyEvent;
      if (isRedo(event2)) {
        editorActions.trigger("redo");
        return true;
      }
    });
    addListener("copy", function(context) {
      var event2 = context.keyEvent;
      if (isCopy(event2)) {
        editorActions.trigger("copy");
        return true;
      }
    });
    addListener("paste", function(context) {
      var event2 = context.keyEvent;
      if (isPaste(event2)) {
        editorActions.trigger("paste");
        return true;
      }
    });
    addListener("stepZoom", function(context) {
      var event2 = context.keyEvent;
      if (isKey(["+", "Add", "="], event2) && isCmd(event2)) {
        editorActions.trigger("stepZoom", {
          value: 1
        });
        return true;
      }
    });
    addListener("stepZoom", function(context) {
      var event2 = context.keyEvent;
      if (isKey(["-", "Subtract"], event2) && isCmd(event2)) {
        editorActions.trigger("stepZoom", {
          value: -1
        });
        return true;
      }
    });
    addListener("zoom", function(context) {
      var event2 = context.keyEvent;
      if (isKey("0", event2) && isCmd(event2)) {
        editorActions.trigger("zoom", {
          value: 1
        });
        return true;
      }
    });
    addListener("removeSelection", function(context) {
      var event2 = context.keyEvent;
      if (isKey(["Backspace", "Delete", "Del"], event2)) {
        editorActions.trigger("removeSelection");
        return true;
      }
    });
  };
  var KeyboardModule = {
    __init__: ["keyboard", "keyboardBindings"],
    keyboard: ["type", Keyboard],
    keyboardBindings: ["type", KeyboardBindings]
  };
  var LOW_PRIORITY = 500;
  var FormEditorKeyboardBindings = class {
    constructor(eventBus, keyboard) {
      eventBus.on("editorActions.init", LOW_PRIORITY, (event2) => {
        const {
          editorActions
        } = event2;
        this.registerBindings(keyboard, editorActions);
      });
    }
    registerBindings(keyboard, editorActions) {
      function addListener(action, fn4) {
        if (editorActions.isRegistered(action)) {
          keyboard.addListener(fn4);
        }
      }
      addListener("undo", (context) => {
        const {
          keyEvent
        } = context;
        if (isUndo(keyEvent)) {
          editorActions.trigger("undo");
          return true;
        }
      });
      addListener("redo", (context) => {
        const {
          keyEvent
        } = context;
        if (isRedo(keyEvent)) {
          editorActions.trigger("redo");
          return true;
        }
      });
    }
  };
  FormEditorKeyboardBindings.$inject = ["eventBus", "keyboard"];
  var FormEditorKeyboardModule = {
    __depends__: [KeyboardModule],
    __init__: ["keyboardBindings"],
    keyboardBindings: ["type", FormEditorKeyboardBindings]
  };
  var DraggingModule = {
    __init__: ["dragging"],
    dragging: ["type", Dragging]
  };
  function CommandStack2(eventBus, injector) {
    this._handlerMap = {};
    this._stack = [];
    this._stackIdx = -1;
    this._currentExecution = {
      actions: [],
      dirty: [],
      trigger: null
    };
    this._injector = injector;
    this._eventBus = eventBus;
    this._uid = 1;
    eventBus.on(["diagram.destroy", "diagram.clear"], function() {
      this.clear(false);
    }, this);
  }
  CommandStack2.$inject = ["eventBus", "injector"];
  CommandStack2.prototype.execute = function(command2, context) {
    if (!command2) {
      throw new Error("command required");
    }
    this._currentExecution.trigger = "execute";
    const action = {
      command: command2,
      context
    };
    this._pushAction(action);
    this._internalExecute(action);
    this._popAction();
  };
  CommandStack2.prototype.canExecute = function(command2, context) {
    const action = {
      command: command2,
      context
    };
    const handler = this._getHandler(command2);
    let result = this._fire(command2, "canExecute", action);
    if (result === void 0) {
      if (!handler) {
        return false;
      }
      if (handler.canExecute) {
        result = handler.canExecute(context);
      }
    }
    return result;
  };
  CommandStack2.prototype.clear = function(emit) {
    this._stack.length = 0;
    this._stackIdx = -1;
    if (emit !== false) {
      this._fire("changed", {
        trigger: "clear"
      });
    }
  };
  CommandStack2.prototype.undo = function() {
    let action = this._getUndoAction(), next;
    if (action) {
      this._currentExecution.trigger = "undo";
      this._pushAction(action);
      while (action) {
        this._internalUndo(action);
        next = this._getUndoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };
  CommandStack2.prototype.redo = function() {
    let action = this._getRedoAction(), next;
    if (action) {
      this._currentExecution.trigger = "redo";
      this._pushAction(action);
      while (action) {
        this._internalExecute(action, true);
        next = this._getRedoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };
  CommandStack2.prototype.register = function(command2, handler) {
    this._setHandler(command2, handler);
  };
  CommandStack2.prototype.registerHandler = function(command2, handlerCls) {
    if (!command2 || !handlerCls) {
      throw new Error("command and handlerCls must be defined");
    }
    const handler = this._injector.instantiate(handlerCls);
    this.register(command2, handler);
  };
  CommandStack2.prototype.canUndo = function() {
    return !!this._getUndoAction();
  };
  CommandStack2.prototype.canRedo = function() {
    return !!this._getRedoAction();
  };
  CommandStack2.prototype._getRedoAction = function() {
    return this._stack[this._stackIdx + 1];
  };
  CommandStack2.prototype._getUndoAction = function() {
    return this._stack[this._stackIdx];
  };
  CommandStack2.prototype._internalUndo = function(action) {
    const command2 = action.command, context = action.context;
    const handler = this._getHandler(command2);
    this._atomicDo(() => {
      this._fire(command2, "revert", action);
      if (handler.revert) {
        this._markDirty(handler.revert(context));
      }
      this._revertedAction(action);
      this._fire(command2, "reverted", action);
    });
  };
  CommandStack2.prototype._fire = function(command2, qualifier, event2) {
    if (arguments.length < 3) {
      event2 = qualifier;
      qualifier = null;
    }
    const names = qualifier ? [command2 + "." + qualifier, qualifier] : [command2];
    let result;
    event2 = this._eventBus.createEvent(event2);
    for (const name2 of names) {
      result = this._eventBus.fire("commandStack." + name2, event2);
      if (event2.cancelBubble) {
        break;
      }
    }
    return result;
  };
  CommandStack2.prototype._createId = function() {
    return this._uid++;
  };
  CommandStack2.prototype._atomicDo = function(fn4) {
    const execution = this._currentExecution;
    execution.atomic = true;
    try {
      fn4();
    } finally {
      execution.atomic = false;
    }
  };
  CommandStack2.prototype._internalExecute = function(action, redo) {
    const command2 = action.command, context = action.context;
    const handler = this._getHandler(command2);
    if (!handler) {
      throw new Error("no command handler registered for <" + command2 + ">");
    }
    this._pushAction(action);
    if (!redo) {
      this._fire(command2, "preExecute", action);
      if (handler.preExecute) {
        handler.preExecute(context);
      }
      this._fire(command2, "preExecuted", action);
    }
    this._atomicDo(() => {
      this._fire(command2, "execute", action);
      if (handler.execute) {
        this._markDirty(handler.execute(context));
      }
      this._executedAction(action, redo);
      this._fire(command2, "executed", action);
    });
    if (!redo) {
      this._fire(command2, "postExecute", action);
      if (handler.postExecute) {
        handler.postExecute(context);
      }
      this._fire(command2, "postExecuted", action);
    }
    this._popAction();
  };
  CommandStack2.prototype._pushAction = function(action) {
    const execution = this._currentExecution, actions = execution.actions;
    const baseAction = actions[0];
    if (execution.atomic) {
      throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
    }
    if (!action.id) {
      action.id = baseAction && baseAction.id || this._createId();
    }
    actions.push(action);
  };
  CommandStack2.prototype._popAction = function() {
    const execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
    actions.pop();
    if (!actions.length) {
      this._eventBus.fire("elements.changed", {
        elements: uniqueBy("id", dirty.reverse())
      });
      dirty.length = 0;
      this._fire("changed", {
        trigger
      });
      execution.trigger = null;
    }
  };
  CommandStack2.prototype._markDirty = function(elements) {
    const execution = this._currentExecution;
    if (!elements) {
      return;
    }
    elements = isArray(elements) ? elements : [elements];
    execution.dirty = execution.dirty.concat(elements);
  };
  CommandStack2.prototype._executedAction = function(action, redo) {
    const stackIdx = ++this._stackIdx;
    if (!redo) {
      this._stack.splice(stackIdx, this._stack.length, action);
    }
  };
  CommandStack2.prototype._revertedAction = function(action) {
    this._stackIdx--;
  };
  CommandStack2.prototype._getHandler = function(command2) {
    return this._handlerMap[command2];
  };
  CommandStack2.prototype._setHandler = function(command2, handler) {
    if (!command2 || !handler) {
      throw new Error("command and handler required");
    }
    if (this._handlerMap[command2]) {
      throw new Error("overriding handler for command <" + command2 + ">");
    }
    this._handlerMap[command2] = handler;
  };
  var commandModule = {
    commandStack: ["type", CommandStack2]
  };
  var DEFAULT_PRIORITY$1 = 1e3;
  function CommandInterceptor(eventBus) {
    this._eventBus = eventBus;
  }
  CommandInterceptor.$inject = ["eventBus"];
  function unwrapEvent(fn4, that) {
    return function(event2) {
      return fn4.call(that || null, event2.context, event2.command, event2);
    };
  }
  CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
    if (isFunction(hook) || isNumber(hook)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = hook;
      hook = null;
    }
    if (isFunction(priority)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = DEFAULT_PRIORITY$1;
    }
    if (isObject(unwrap)) {
      that = unwrap;
      unwrap = false;
    }
    if (!isFunction(handlerFn)) {
      throw new Error("handlerFn must be a function");
    }
    if (!isArray(events)) {
      events = [events];
    }
    var eventBus = this._eventBus;
    forEach(events, function(event2) {
      var fullEvent = ["commandStack", event2, hook].filter(function(e3) {
        return e3;
      }).join(".");
      eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
    });
  };
  CommandInterceptor.prototype.canExecute = createHook("canExecute");
  CommandInterceptor.prototype.preExecute = createHook("preExecute");
  CommandInterceptor.prototype.preExecuted = createHook("preExecuted");
  CommandInterceptor.prototype.execute = createHook("execute");
  CommandInterceptor.prototype.executed = createHook("executed");
  CommandInterceptor.prototype.postExecute = createHook("postExecute");
  CommandInterceptor.prototype.postExecuted = createHook("postExecuted");
  CommandInterceptor.prototype.revert = createHook("revert");
  CommandInterceptor.prototype.reverted = createHook("reverted");
  function createHook(hook) {
    const hookFn = function(events, priority, handlerFn, unwrap, that) {
      if (isFunction(events) || isNumber(events)) {
        that = unwrap;
        unwrap = handlerFn;
        handlerFn = priority;
        priority = events;
        events = null;
      }
      this.on(events, hook, priority, handlerFn, unwrap, that);
    };
    return hookFn;
  }
  var IdBehavior = class extends CommandInterceptor {
    constructor(eventBus, modeling) {
      super(eventBus);
      this.preExecute("formField.remove", function(context) {
        const {
          formField
        } = context;
        const {
          id: id2
        } = formField;
        modeling.unclaimId(formField, id2);
      }, true);
      this.preExecute("formField.edit", function(context) {
        const {
          formField,
          properties
        } = context;
        if ("id" in properties) {
          modeling.unclaimId(formField, formField.id);
          modeling.claimId(formField, properties.id);
        }
      }, true);
    }
  };
  IdBehavior.$inject = ["eventBus", "modeling"];
  var KeyBehavior = class extends CommandInterceptor {
    constructor(eventBus, modeling, formFields2) {
      super(eventBus);
      this.preExecute("formField.remove", function(context) {
        const {
          formField
        } = context;
        const {
          key,
          type: type3
        } = formField;
        const {
          config: config2
        } = formFields2.get(type3);
        if (config2.keyed) {
          modeling.unclaimKey(formField, key);
        }
      }, true);
      this.preExecute("formField.edit", function(context) {
        const {
          formField,
          properties
        } = context;
        const {
          key,
          type: type3
        } = formField;
        const {
          config: config2
        } = formFields2.get(type3);
        if (config2.keyed && "key" in properties) {
          modeling.unclaimKey(formField, key);
          modeling.claimKey(formField, properties.key);
        }
      }, true);
    }
  };
  KeyBehavior.$inject = ["eventBus", "modeling", "formFields"];
  var PathBehavior = class extends CommandInterceptor {
    constructor(eventBus, modeling, formFields2) {
      super(eventBus);
      this.preExecute("formField.remove", function(context) {
        const {
          formField
        } = context;
        const {
          path: path2,
          type: type3
        } = formField;
        const {
          config: config2
        } = formFields2.get(type3);
        if (config2.pathed) {
          modeling.unclaimPath(formField, path2);
        }
      }, true);
      this.preExecute("formField.edit", function(context) {
        const {
          formField,
          properties
        } = context;
        const {
          path: path2,
          type: type3
        } = formField;
        const {
          config: config2
        } = formFields2.get(type3);
        if (config2.pathed && "path" in properties) {
          modeling.unclaimPath(formField, path2);
          modeling.claimPath(formField, properties.path);
        }
      }, true);
    }
  };
  PathBehavior.$inject = ["eventBus", "modeling", "formFields"];
  var ValidateBehavior = class extends CommandInterceptor {
    constructor(eventBus) {
      super(eventBus);
      this.preExecute("formField.edit", function(context) {
        const {
          properties
        } = context;
        const {
          validate: validate2 = {}
        } = properties;
        if (validate2.validationType) {
          const newValidate = {
            ...validate2
          };
          delete newValidate.minLength;
          delete newValidate.maxLength;
          delete newValidate.pattern;
          properties["validate"] = newValidate;
        }
      }, true);
    }
  };
  ValidateBehavior.$inject = ["eventBus"];
  var OptionsSourceBehavior = class extends CommandInterceptor {
    constructor(eventBus) {
      super(eventBus);
      this.preExecute("formField.edit", function(context) {
        const {
          properties
        } = context;
        const newProperties = {};
        if (!isValuesSourceUpdate(properties)) {
          return;
        }
        Object.values(OPTIONS_SOURCES).forEach((source) => {
          const path2 = OPTIONS_SOURCES_PATHS[source];
          if (get(properties, path2) == void 0) {
            newProperties[OPTIONS_SOURCES_PATHS[source]] = void 0;
          }
        });
        if (get(properties, OPTIONS_SOURCES_PATHS[OPTIONS_SOURCES.EXPRESSION]) !== void 0 || get(properties, OPTIONS_SOURCES_PATHS[OPTIONS_SOURCES.INPUT]) !== void 0) {
          newProperties["defaultValue"] = void 0;
        }
        context.properties = {
          ...properties,
          ...newProperties
        };
      }, true);
    }
  };
  OptionsSourceBehavior.$inject = ["eventBus"];
  function isValuesSourceUpdate(properties) {
    return Object.values(OPTIONS_SOURCES_PATHS).some((path2) => {
      return get(properties, path2) !== void 0;
    });
  }
  var COLUMNS_SOURCE_PROPERTIES = {
    columns: "columns",
    columnsExpression: "columnsExpression"
  };
  var ColumnsSourceBehavior = class extends CommandInterceptor {
    constructor(eventBus) {
      super(eventBus);
      this.preExecute("formField.edit", function(context) {
        const {
          properties,
          oldProperties
        } = context;
        const isColumnSourceUpdate = Object.values(COLUMNS_SOURCE_PROPERTIES).some((path2) => {
          return get(properties, [path2]) !== void 0;
        });
        if (!isColumnSourceUpdate) {
          return;
        }
        const columns = get(properties, [COLUMNS_SOURCE_PROPERTIES.columns]);
        const oldColumns = get(oldProperties, [COLUMNS_SOURCE_PROPERTIES.columns]);
        const columnsExpression = get(properties, [COLUMNS_SOURCE_PROPERTIES.columnsExpression]);
        const oldColumnsExpression = get(oldProperties, [COLUMNS_SOURCE_PROPERTIES.columnsExpression]);
        if (isArray(columns) && !isDefined(oldColumns)) {
          context.properties = {
            ...properties,
            columnsExpression: void 0
          };
          return;
        }
        if (isString(columnsExpression) && !isString(oldColumnsExpression)) {
          context.properties = {
            ...properties,
            columns: void 0
          };
          return;
        }
      }, true);
    }
  };
  ColumnsSourceBehavior.$inject = ["eventBus"];
  var TableDataSourceBehavior = class extends CommandInterceptor {
    constructor(eventBus) {
      super(eventBus);
      this.preExecute("formField.add", function(context) {
        const {
          formField
        } = context;
        if (get(formField, ["type"]) !== "table") {
          return;
        }
        context.formField = {
          ...formField,
          dataSource: `=${formField.id}`
        };
      }, true);
    }
  };
  TableDataSourceBehavior.$inject = ["eventBus"];
  var BehaviorModule = {
    __init__: ["idBehavior", "keyBehavior", "pathBehavior", "validateBehavior", "optionsSourceBehavior", "columnsSourceBehavior", "tableDataSourceBehavior"],
    idBehavior: ["type", IdBehavior],
    keyBehavior: ["type", KeyBehavior],
    pathBehavior: ["type", PathBehavior],
    validateBehavior: ["type", ValidateBehavior],
    optionsSourceBehavior: ["type", OptionsSourceBehavior],
    columnsSourceBehavior: ["type", ColumnsSourceBehavior],
    tableDataSourceBehavior: ["type", TableDataSourceBehavior]
  };
  function arrayAdd$1(array, index2, item) {
    array.splice(index2, 0, item);
    return array;
  }
  function arrayRemove(array, index2) {
    array.splice(index2, 1);
    return array;
  }
  function updatePath(formFieldRegistry, formField, index2) {
    const parent = formFieldRegistry.get(formField._parent);
    refreshPathsRecursively(formField, [...parent._path, "components", index2]);
    return formField;
  }
  function refreshPathsRecursively(formField, path2) {
    formField._path = path2;
    const components = formField.components || [];
    components.forEach((component, index2) => {
      refreshPathsRecursively(component, [...path2, "components", index2]);
    });
  }
  function updateRow(formField, rowId) {
    formField.layout = {
      ...formField.layout || {},
      row: rowId
    };
    return formField;
  }
  var FormLayoutUpdater = class extends CommandInterceptor {
    constructor(eventBus, formLayouter, modeling, formEditor) {
      super(eventBus);
      this._eventBus = eventBus;
      this._formLayouter = formLayouter;
      this._modeling = modeling;
      this._formEditor = formEditor;
      this.preExecute(["formField.add", "formField.remove", "formField.move", "id.updateClaim"], (event2) => this.updateRowIds(event2));
      eventBus.on("changed", (context) => {
        const {
          schema
        } = context;
        this.updateLayout(schema);
      });
    }
    updateLayout(schema) {
      this._formLayouter.clear();
      this._formLayouter.calculateLayout(clone4(schema));
    }
    updateRowIds(event2) {
      const {
        schema
      } = this._formEditor._getState();
      const setRowIds = (parent) => {
        if (!parent.components || !parent.components.length) {
          return;
        }
        parent.components.forEach((formField) => {
          const row = this._formLayouter.getRowForField(formField);
          updateRow(formField, row.id);
          setRowIds(formField);
        });
      };
      setRowIds(schema);
    }
  };
  FormLayoutUpdater.$inject = ["eventBus", "formLayouter", "modeling", "formEditor"];
  var AddFormFieldHandler = class {
    /**
     * @constructor
     * @param { import('../../../FormEditor').FormEditor } formEditor
     * @param { import('../../../core/FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     */
    constructor(formEditor, formFieldRegistry) {
      this._formEditor = formEditor;
      this._formFieldRegistry = formFieldRegistry;
    }
    execute(context) {
      const {
        formField,
        targetFormField,
        targetIndex
      } = context;
      const {
        schema
      } = this._formEditor._getState();
      const targetPath = [...targetFormField._path, "components"];
      formField._parent = targetFormField.id;
      arrayAdd$1(get(schema, targetPath), targetIndex, formField);
      get(schema, targetPath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
      this._formFieldRegistry.add(formField);
      this._formEditor._setState({
        schema
      });
    }
    revert(context) {
      const {
        formField,
        targetFormField,
        targetIndex
      } = context;
      const {
        schema
      } = this._formEditor._getState();
      const targetPath = [...targetFormField._path, "components"];
      arrayRemove(get(schema, targetPath), targetIndex);
      get(schema, targetPath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
      this._formFieldRegistry.remove(formField);
      this._formEditor._setState({
        schema
      });
    }
  };
  AddFormFieldHandler.$inject = ["formEditor", "formFieldRegistry"];
  var EditFormFieldHandler = class {
    /**
     * @constructor
     * @param { import('../../../FormEditor').FormEditor } formEditor
     * @param { import('../../../core/FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     */
    constructor(formEditor, formFieldRegistry) {
      this._formEditor = formEditor;
      this._formFieldRegistry = formFieldRegistry;
    }
    execute(context) {
      const {
        formField,
        properties
      } = context;
      let {
        schema
      } = this._formEditor._getState();
      const oldProperties = {};
      for (let key in properties) {
        oldProperties[key] = formField[key];
        const property = properties[key];
        if (key === "id") {
          if (property !== formField.id) {
            this._formFieldRegistry.updateId(formField, property);
          }
        } else {
          formField[key] = property;
        }
      }
      context.oldProperties = oldProperties;
      this._formEditor._setState({
        schema
      });
      return formField;
    }
    revert(context) {
      const {
        formField,
        oldProperties
      } = context;
      let {
        schema
      } = this._formEditor._getState();
      for (let key in oldProperties) {
        const property = oldProperties[key];
        if (key === "id") {
          if (property !== formField.id) {
            this._formFieldRegistry.updateId(formField, property);
          }
        } else {
          formField[key] = property;
        }
      }
      this._formEditor._setState({
        schema
      });
      return formField;
    }
  };
  EditFormFieldHandler.$inject = ["formEditor", "formFieldRegistry"];
  var MoveFormFieldHandler = class {
    /**
     * @constructor
     * @param { import('../../../FormEditor').FormEditor } formEditor
     * @param { import('../../../core/FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     * @param { import('@bpmn-io/form-js-viewer').PathRegistry } pathRegistry
     * @param { import('@bpmn-io/form-js-viewer').FormLayouter } formLayouter
     */
    constructor(formEditor, formFieldRegistry, pathRegistry, formLayouter) {
      this._formEditor = formEditor;
      this._formFieldRegistry = formFieldRegistry;
      this._pathRegistry = pathRegistry;
      this._formLayouter = formLayouter;
    }
    execute(context) {
      this.moveFormField(context);
    }
    revert(context) {
      let {
        sourceFormField,
        targetFormField,
        sourceIndex,
        targetIndex,
        sourceRow,
        targetRow
      } = context;
      this.moveFormField({
        sourceFormField: targetFormField,
        targetFormField: sourceFormField,
        sourceIndex: targetIndex,
        targetIndex: sourceIndex,
        sourceRow: targetRow,
        targetRow: sourceRow
      }, true);
    }
    moveFormField(context, revert) {
      let {
        sourceFormField,
        targetFormField,
        sourceIndex,
        targetIndex,
        targetRow
      } = context;
      let {
        schema
      } = this._formEditor._getState();
      const sourcePath = [...sourceFormField._path, "components"];
      if (sourceFormField.id === targetFormField.id) {
        if (revert) {
          if (sourceIndex > targetIndex) {
            sourceIndex--;
          }
        } else {
          if (sourceIndex < targetIndex) {
            targetIndex--;
          }
        }
        const formField = get(schema, [...sourcePath, sourceIndex]);
        updateRow(formField, targetRow ? targetRow.id : this._formLayouter.nextRowId());
        arrayMoveMutable(get(schema, sourcePath), sourceIndex, targetIndex);
        get(schema, sourcePath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
      } else {
        const formField = get(schema, [...sourcePath, sourceIndex]);
        this._pathRegistry.executeRecursivelyOnFields(formField, ({
          field
        }) => {
          this._pathRegistry.unclaimPath(this._pathRegistry.getValuePath(field));
        });
        formField._parent = targetFormField.id;
        arrayRemove(get(schema, sourcePath), sourceIndex);
        get(schema, sourcePath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
        const targetPath = [...targetFormField._path, "components"];
        updateRow(formField, targetRow ? targetRow.id : this._formLayouter.nextRowId());
        arrayAdd$1(get(schema, targetPath), targetIndex, formField);
        get(schema, targetPath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
        this._pathRegistry.executeRecursivelyOnFields(formField, ({
          field,
          isClosed,
          isRepeatable
        }) => {
          this._pathRegistry.claimPath(this._pathRegistry.getValuePath(field), {
            isClosed,
            isRepeatable,
            claimerId: field.id
          });
        });
      }
      this._formEditor._setState({
        schema
      });
    }
  };
  MoveFormFieldHandler.$inject = ["formEditor", "formFieldRegistry", "pathRegistry", "formLayouter"];
  var RemoveFormFieldHandler = class {
    /**
     * @constructor
     * @param { import('../../../FormEditor').FormEditor } formEditor
     * @param { import('../../../core/FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     */
    constructor(formEditor, formFieldRegistry) {
      this._formEditor = formEditor;
      this._formFieldRegistry = formFieldRegistry;
    }
    execute(context) {
      const {
        sourceFormField,
        sourceIndex
      } = context;
      let {
        schema
      } = this._formEditor._getState();
      const sourcePath = [...sourceFormField._path, "components"];
      const formField = context.formField = get(schema, [...sourcePath, sourceIndex]);
      arrayRemove(get(schema, sourcePath), sourceIndex);
      get(schema, sourcePath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
      runRecursively(formField, (formField2) => this._formFieldRegistry.remove(formField2));
      this._formEditor._setState({
        schema
      });
    }
    revert(context) {
      const {
        formField,
        sourceFormField,
        sourceIndex
      } = context;
      let {
        schema
      } = this._formEditor._getState();
      const sourcePath = [...sourceFormField._path, "components"];
      arrayAdd$1(get(schema, sourcePath), sourceIndex, formField);
      get(schema, sourcePath).forEach((formField2, index2) => updatePath(this._formFieldRegistry, formField2, index2));
      runRecursively(formField, (formField2) => this._formFieldRegistry.add(formField2));
      this._formEditor._setState({
        schema
      });
    }
  };
  RemoveFormFieldHandler.$inject = ["formEditor", "formFieldRegistry"];
  var UpdateIdClaimHandler = class {
    /**
     * @constructor
     * @param { import('../../../core/FormFieldRegistry').FormFieldRegistry } formFieldRegistry
     */
    constructor(formFieldRegistry) {
      this._formFieldRegistry = formFieldRegistry;
    }
    execute(context) {
      const {
        claiming,
        formField,
        id: id2
      } = context;
      if (claiming) {
        this._formFieldRegistry._ids.claim(id2, formField);
      } else {
        this._formFieldRegistry._ids.unclaim(id2);
      }
    }
    revert(context) {
      const {
        claiming,
        formField,
        id: id2
      } = context;
      if (claiming) {
        this._formFieldRegistry._ids.unclaim(id2);
      } else {
        this._formFieldRegistry._ids.claim(id2, formField);
      }
    }
  };
  UpdateIdClaimHandler.$inject = ["formFieldRegistry"];
  var UpdateKeyClaimHandler = class {
    /**
     * @constructor
     * @param { import('@bpmn-io/form-js-viewer').PathRegistry } pathRegistry
     */
    constructor(pathRegistry) {
      this._pathRegistry = pathRegistry;
    }
    execute(context) {
      const {
        claiming,
        formField,
        key
      } = context;
      const options2 = {
        replacements: {
          [formField.id]: key
        }
      };
      const valuePath = this._pathRegistry.getValuePath(formField, options2);
      if (claiming) {
        this._pathRegistry.claimPath(valuePath, {
          isClosed: true,
          claimerId: formField.id
        });
      } else {
        this._pathRegistry.unclaimPath(valuePath);
      }
      context.valuePath = valuePath;
    }
    revert(context) {
      const {
        claiming,
        formField,
        valuePath
      } = context;
      if (claiming) {
        this._pathRegistry.unclaimPath(valuePath);
      } else {
        this._pathRegistry.claimPath(valuePath, {
          isClosed: true,
          claimerId: formField.id
        });
      }
    }
  };
  UpdateKeyClaimHandler.$inject = ["pathRegistry"];
  var UpdatePathClaimHandler = class {
    /**
     * @constructor
     * @param { import('@bpmn-io/form-js-viewer').PathRegistry } pathRegistry
     */
    constructor(pathRegistry) {
      this._pathRegistry = pathRegistry;
    }
    execute(context) {
      const {
        claiming,
        formField,
        path: path2
      } = context;
      const options2 = {
        replacements: {
          [formField.id]: path2
        }
      };
      const valuePaths = [];
      if (claiming) {
        this._pathRegistry.executeRecursivelyOnFields(formField, ({
          field,
          isClosed,
          isRepeatable
        }) => {
          const valuePath = this._pathRegistry.getValuePath(field, options2);
          valuePaths.push({
            valuePath,
            isClosed,
            isRepeatable,
            claimerId: field.id
          });
          this._pathRegistry.claimPath(valuePath, {
            isClosed,
            isRepeatable,
            claimerId: field.id
          });
        });
      } else {
        this._pathRegistry.executeRecursivelyOnFields(formField, ({
          field,
          isClosed,
          isRepeatable
        }) => {
          const valuePath = this._pathRegistry.getValuePath(field, options2);
          valuePaths.push({
            valuePath,
            isClosed,
            isRepeatable,
            claimerId: field.id
          });
          this._pathRegistry.unclaimPath(valuePath);
        });
      }
      context.valuePaths = valuePaths;
    }
    revert(context) {
      const {
        claiming,
        valuePaths
      } = context;
      if (claiming) {
        valuePaths.forEach(({
          valuePath
        }) => {
          this._pathRegistry.unclaimPath(valuePath);
        });
      } else {
        valuePaths.forEach(({
          valuePath,
          isClosed,
          isRepeatable,
          claimerId
        }) => {
          this._pathRegistry.claimPath(valuePath, {
            isClosed,
            isRepeatable,
            claimerId
          });
        });
      }
    }
  };
  UpdatePathClaimHandler.$inject = ["pathRegistry"];
  var Modeling = class {
    constructor(commandStack, eventBus, formEditor, formFieldRegistry, fieldFactory) {
      this._commandStack = commandStack;
      this._formEditor = formEditor;
      this._formFieldRegistry = formFieldRegistry;
      this._fieldFactory = fieldFactory;
      eventBus.on("form.init", () => {
        this.registerHandlers();
      });
    }
    registerHandlers() {
      Object.entries(this.getHandlers()).forEach(([id2, handler]) => {
        this._commandStack.registerHandler(id2, handler);
      });
    }
    getHandlers() {
      return {
        "formField.add": AddFormFieldHandler,
        "formField.edit": EditFormFieldHandler,
        "formField.move": MoveFormFieldHandler,
        "formField.remove": RemoveFormFieldHandler,
        "id.updateClaim": UpdateIdClaimHandler,
        "key.updateClaim": UpdateKeyClaimHandler,
        "path.updateClaim": UpdatePathClaimHandler
      };
    }
    addFormField(attrs, targetFormField, targetIndex) {
      const formField = this._fieldFactory.create(attrs);
      const context = {
        formField,
        targetFormField,
        targetIndex
      };
      this._commandStack.execute("formField.add", context);
      return formField;
    }
    editFormField(formField, properties, value) {
      if (!isObject(properties)) {
        properties = {
          [properties]: value
        };
      }
      const context = {
        formField,
        properties
      };
      this._commandStack.execute("formField.edit", context);
    }
    moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex, sourceRow, targetRow) {
      const context = {
        formField,
        sourceFormField,
        targetFormField,
        sourceIndex,
        targetIndex,
        sourceRow,
        targetRow
      };
      this._commandStack.execute("formField.move", context);
    }
    removeFormField(formField, sourceFormField, sourceIndex) {
      const context = {
        formField,
        sourceFormField,
        sourceIndex
      };
      this._commandStack.execute("formField.remove", context);
    }
    claimId(formField, id2) {
      const context = {
        formField,
        id: id2,
        claiming: true
      };
      this._commandStack.execute("id.updateClaim", context);
    }
    unclaimId(formField, id2) {
      const context = {
        formField,
        id: id2,
        claiming: false
      };
      this._commandStack.execute("id.updateClaim", context);
    }
    claimKey(formField, key) {
      const context = {
        formField,
        key,
        claiming: true
      };
      this._commandStack.execute("key.updateClaim", context);
    }
    unclaimKey(formField, key) {
      const context = {
        formField,
        key,
        claiming: false
      };
      this._commandStack.execute("key.updateClaim", context);
    }
    claimPath(formField, path2) {
      const context = {
        formField,
        path: path2,
        claiming: true
      };
      this._commandStack.execute("path.updateClaim", context);
    }
    unclaimPath(formField, path2) {
      const context = {
        formField,
        path: path2,
        claiming: false
      };
      this._commandStack.execute("path.updateClaim", context);
    }
  };
  Modeling.$inject = ["commandStack", "eventBus", "formEditor", "formFieldRegistry", "fieldFactory"];
  var ModelingModule = {
    __depends__: [BehaviorModule, commandModule],
    __init__: ["formLayoutUpdater", "modeling"],
    formLayoutUpdater: ["type", FormLayoutUpdater],
    modeling: ["type", Modeling]
  };
  var Selection = class {
    constructor(eventBus) {
      this._eventBus = eventBus;
      this._selection = null;
    }
    get() {
      return this._selection;
    }
    set(selection2) {
      if (this._selection === selection2) {
        return;
      }
      this._selection = selection2;
      this._eventBus.fire("selection.changed", {
        selection: this._selection
      });
    }
    toggle(selection2) {
      const newSelection = this._selection === selection2 ? null : selection2;
      this.set(newSelection);
    }
    clear() {
      this.set(null);
    }
    isSelected(formField) {
      return this._selection === formField;
    }
  };
  Selection.$inject = ["eventBus"];
  var SelectionBehavior = class {
    constructor(eventBus, selection2) {
      eventBus.on(["commandStack.formField.add.postExecuted", "commandStack.formField.move.postExecuted"], ({
        context
      }) => {
        const {
          formField
        } = context;
        selection2.set(formField);
      });
      eventBus.on("commandStack.formField.remove.postExecuted", ({
        context
      }) => {
        const {
          sourceFormField,
          sourceIndex
        } = context;
        const formField = sourceFormField.components[sourceIndex] || sourceFormField.components[sourceIndex - 1];
        if (formField) {
          selection2.set(formField);
        } else {
          selection2.clear();
        }
      });
      eventBus.on("formField.remove", ({
        formField
      }) => {
        if (selection2.isSelected(formField)) {
          selection2.clear();
        }
      });
    }
  };
  SelectionBehavior.$inject = ["eventBus", "selection"];
  var SelectionModule = {
    __init__: ["selection", "selectionBehavior"],
    selection: ["type", Selection],
    selectionBehavior: ["type", SelectionBehavior]
  };
  var SectionModuleBase = class {
    /**
     * Create a SectionModuleBase instance.
     *
     * @param {any} eventBus - The EventBus instance used for event handling.
     * @param {string} sectionKey - The type of render manager. Used to form event names.
     *
     * @constructor
     */
    constructor(eventBus, sectionKey) {
      this._eventBus = eventBus;
      this._sectionKey = sectionKey;
      this._eventBus.on(`${this._sectionKey}.section.rendered`, () => {
        this.isSectionRendered = true;
      });
      this._eventBus.on(`${this._sectionKey}.section.destroyed`, () => {
        this.isSectionRendered = false;
      });
    }
    /**
     * Attach the managed section to a parent node.
     *
     * @param {HTMLElement} container - The parent node to attach to.
     */
    attachTo(container) {
      this._onceSectionRendered(() => this._eventBus.fire(`${this._sectionKey}.attach`, {
        container
      }));
    }
    /**
     * Detach the managed section from its parent node.
     */
    detach() {
      this._onceSectionRendered(() => this._eventBus.fire(`${this._sectionKey}.detach`));
    }
    /**
     * Reset the managed section to its initial state.
     */
    reset() {
      this._onceSectionRendered(() => this._eventBus.fire(`${this._sectionKey}.reset`));
    }
    /**
     * Circumvents timing issues.
     */
    _onceSectionRendered(callback) {
      if (this.isSectionRendered) {
        callback();
      } else {
        this._eventBus.once(`${this._sectionKey}.section.rendered`, callback);
      }
    }
  };
  var PaletteRenderer = class extends SectionModuleBase {
    constructor(eventBus) {
      super(eventBus, "palette");
    }
  };
  PaletteRenderer.$inject = ["eventBus"];
  var PaletteModule = {
    __init__: ["palette"],
    palette: ["type", PaletteRenderer]
  };
  var ArrowIcon = function ArrowIcon2(props) {
    return u2("svg", {
      ...props,
      children: u2("path", {
        fillRule: "evenodd",
        d: "m11.657 8-4.95 4.95a1 1 0 0 1-1.414-1.414L8.828 8 5.293 4.464A1 1 0 1 1 6.707 3.05L11.657 8Z"
      })
    });
  };
  ArrowIcon.defaultProps = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16"
  };
  var CloseIcon = function CloseIcon2(props) {
    return u2("svg", {
      ...props,
      children: u2("path", {
        fillRule: "evenodd",
        d: "m12 4.7-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8 12 4.7Z",
        fill: "currentColor"
      })
    });
  };
  CloseIcon.defaultProps = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16"
  };
  var CreateIcon = function CreateIcon2(props) {
    return u2("svg", {
      ...props,
      children: u2("path", {
        fillRule: "evenodd",
        d: "M9 13V9h4a1 1 0 0 0 0-2H9V3a1 1 0 1 0-2 0v4H3a1 1 0 1 0 0 2h4v4a1 1 0 0 0 2 0Z"
      })
    });
  };
  CreateIcon.defaultProps = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16"
  };
  var DeleteIcon = function DeleteIcon2(props) {
    return u2("svg", {
      ...props,
      children: u2("path", {
        fillRule: "evenodd",
        d: "M12 6v7c0 1.1-.4 1.55-1.5 1.55h-5C4.4 14.55 4 14.1 4 13V6h8Zm-1.5 1.5h-5v4.3c0 .66.5 1.2 1.111 1.2H9.39c.611 0 1.111-.54 1.111-1.2V7.5ZM13 3h-2l-1-1H6L5 3H3v1.5h10V3Z"
      })
    });
  };
  DeleteIcon.defaultProps = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16"
  };
  var DragIcon = function DragIcon2(props) {
    return u2("svg", {
      ...props,
      children: [u2("path", {
        fill: "#fff",
        style: {
          mixBlendMode: "multiply"
        },
        d: "M0 0h16v16H0z"
      }), u2("path", {
        fill: "#fff",
        style: {
          mixBlendMode: "multiply"
        },
        d: "M0 0h16v16H0z"
      }), u2("path", {
        d: "M7 3H5v2h2V3zm4 0H9v2h2V3zM7 7H5v2h2V7zm4 0H9v2h2V7zm-4 4H5v2h2v-2zm4 0H9v2h2v-2z",
        fill: "#161616"
      })]
    });
  };
  DragIcon.defaultProps = {
    width: "16",
    height: "16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var ExternalLinkIcon = function ExternalLinkIcon2(props) {
    return u2("svg", {
      ...props,
      children: u2("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12.637 12.637v-4.72h1.362v4.721c0 .36-.137.676-.411.95-.275.275-.591.412-.95.412H3.362c-.38 0-.703-.132-.967-.396A1.315 1.315 0 0 1 2 12.638V3.362c0-.38.132-.703.396-.967S2.982 2 3.363 2h4.553v1.363H3.363v9.274h9.274ZM14 2H9.28l-.001 1.362h2.408L5.065 9.984l.95.95 6.622-6.622v2.409H14V2Z",
        fill: "currentcolor"
      })
    });
  };
  ExternalLinkIcon.defaultProps = {
    width: "16",
    height: "16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var FeelIcon$1 = function FeelIcon(props) {
    return u2("svg", {
      ...props,
      children: u2("path", {
        d: "M3.617 11.99c-.137.684-.392 1.19-.765 1.518-.362.328-.882.492-1.558.492H0l.309-1.579h1.264l1.515-7.64h-.912l.309-1.579h.911l.236-1.191c.137-.685.387-1.192.75-1.52C4.753.164 5.277 0 5.953 0h1.294L6.94 1.579H5.675l-.323 1.623h1.264l-.309 1.579H5.043l-1.426 7.208ZM5.605 11.021l3.029-4.155L7.28 3.202h2.073l.706 2.547h.176l1.691-2.547H14l-3.014 4.051 1.338 3.768H10.25l-.706-2.606H9.37L7.678 11.02H5.605Z",
        fill: "currentcolor"
      })
    });
  };
  FeelIcon$1.defaultProps = {
    width: "14",
    height: "14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  };
  var LaunchIcon = function LaunchIcon2(props) {
    return u2("svg", {
      ...props,
      children: [u2("path", {
        d: "M26 28H6a2.003 2.003 0 0 1-2-2V6a2.003 2.003 0 0 1 2-2h10v2H6v20h20V16h2v10a2.003 2.003 0 0 1-2 2Z"
      }), u2("path", {
        d: "M20 2v2h6.586L18 12.586 19.414 14 28 5.414V12h2V2H20z"
      })]
    });
  };
  LaunchIcon.defaultProps = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32"
  };
  var PopupIcon = function PopupIcon2(props) {
    return u2("svg", {
      ...props,
      children: [u2("path", {
        fill: "currentColor",
        d: "M28 4H10a2.006 2.006 0 0 0-2 2v14a2.006 2.006 0 0 0 2 2h18a2.006 2.006 0 0 0 2-2V6a2.006 2.006 0 0 0-2-2Zm0 16H10V6h18Z"
      }), u2("path", {
        fill: "currentColor",
        d: "M18 26H4V16h2v-2H4a2.006 2.006 0 0 0-2 2v10a2.006 2.006 0 0 0 2 2h14a2.006 2.006 0 0 0 2-2v-2h-2Z"
      })]
    });
  };
  PopupIcon.defaultProps = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 32 32"
  };
  function Header(props) {
    const {
      element,
      headerProvider
    } = props;
    const {
      getElementIcon,
      getDocumentationRef,
      getElementLabel,
      getTypeLabel
    } = headerProvider;
    const label = getElementLabel(element);
    const type3 = getTypeLabel(element);
    const documentationRef = getDocumentationRef && getDocumentationRef(element);
    const ElementIcon = getElementIcon(element);
    return u2("div", {
      class: "bio-properties-panel-header",
      children: [u2("div", {
        class: "bio-properties-panel-header-icon",
        children: ElementIcon && u2(ElementIcon, {
          width: "32",
          height: "32",
          viewBox: "0 0 32 32"
        })
      }), u2("div", {
        class: "bio-properties-panel-header-labels",
        children: [u2("div", {
          title: type3,
          class: "bio-properties-panel-header-type",
          children: type3
        }), label ? u2("div", {
          title: label,
          class: "bio-properties-panel-header-label",
          children: label
        }) : null]
      }), u2("div", {
        class: "bio-properties-panel-header-actions",
        children: documentationRef ? u2("a", {
          rel: "noreferrer",
          class: "bio-properties-panel-header-link",
          href: documentationRef,
          title: "Open documentation",
          target: "_blank",
          children: u2(ExternalLinkIcon, {})
        }) : null
      })]
    });
  }
  var DescriptionContext = K({
    description: {},
    getDescriptionForId: () => {
    }
  });
  var ErrorsContext = K({
    errors: {}
  });
  var EventContext = K({
    eventBus: null
  });
  var LayoutContext = K({
    layout: {},
    setLayout: () => {
    },
    getLayoutForKey: () => {
    },
    setLayoutForKey: () => {
    }
  });
  var TooltipContext = K({
    tooltip: {},
    getTooltipForId: () => {
    }
  });
  function useTooltipContext(id2, element) {
    const {
      getTooltipForId
    } = x2(TooltipContext);
    return getTooltipForId(id2, element);
  }
  function TooltipWrapper(props) {
    const {
      forId,
      element
    } = props;
    const contextDescription = useTooltipContext(forId, element);
    const value = props.value || contextDescription;
    if (!value) {
      return props.children;
    }
    return u2(Tooltip, {
      ...props,
      value,
      forId: `bio-properties-panel-${forId}`
    });
  }
  function Tooltip(props) {
    const {
      forId,
      value,
      parent,
      direction = "right",
      position
    } = props;
    const [visible, setVisible] = d2(false);
    const SHOW_DELAY = 200;
    let timeout = null;
    const wrapperRef = A2(null);
    const tooltipRef = A2(null);
    const show = (_3, delay3) => {
      if (visible) return;
      if (delay3) {
        timeout = setTimeout(() => {
          setVisible(true);
        }, SHOW_DELAY);
      } else {
        setVisible(true);
      }
    };
    const hide = () => {
      clearTimeout(timeout);
      setVisible(false);
    };
    const handleMouseLeave = ({
      relatedTarget
    }) => {
      if (relatedTarget === wrapperRef.current || relatedTarget === tooltipRef.current || relatedTarget?.parentElement === tooltipRef.current) {
        return;
      }
      hide();
    };
    const handleFocusOut = (e3) => {
      const {
        target
      } = e3;
      const isHovered = target.matches(":hover") || tooltipRef.current?.matches(":hover");
      if (target === wrapperRef.current && isHovered) {
        e3.stopPropagation();
        return;
      }
      hide();
    };
    const hideTooltipViaEscape = (e3) => {
      e3.code === "Escape" && hide();
    };
    const renderTooltip = () => {
      return u2("div", {
        class: `bio-properties-panel-tooltip ${direction}`,
        role: "tooltip",
        id: "bio-properties-panel-tooltip",
        "aria-labelledby": forId,
        style: position || getTooltipPosition(wrapperRef.current),
        ref: tooltipRef,
        onClick: (e3) => e3.stopPropagation(),
        onMouseLeave: handleMouseLeave,
        children: [u2("div", {
          class: "bio-properties-panel-tooltip-content",
          children: value
        }), u2("div", {
          class: "bio-properties-panel-tooltip-arrow"
        })]
      });
    };
    return u2("div", {
      class: "bio-properties-panel-tooltip-wrapper",
      tabIndex: "0",
      ref: wrapperRef,
      onMouseEnter: (e3) => show(e3, true),
      onMouseLeave: handleMouseLeave,
      onFocus: show,
      onBlur: handleFocusOut,
      onKeyDown: hideTooltipViaEscape,
      children: [props.children, visible ? parent ? $2(renderTooltip(), parent.current) : renderTooltip() : null]
    });
  }
  function getTooltipPosition(refElement) {
    const refPosition = refElement.getBoundingClientRect();
    const right = `calc(100% - ${refPosition.x}px)`;
    const top2 = `${refPosition.top - 10}px`;
    return `right: ${right}; top: ${top2};`;
  }
  function useDescriptionContext(id2, element) {
    const {
      getDescriptionForId
    } = x2(DescriptionContext);
    return getDescriptionForId(id2, element);
  }
  function useError(id2) {
    const {
      errors
    } = x2(ErrorsContext);
    return errors[id2];
  }
  function useErrors() {
    const {
      errors
    } = x2(ErrorsContext);
    return errors;
  }
  function useEvent(event2, callback, eventBus) {
    const eventContext = x2(EventContext);
    if (!eventBus) {
      ({
        eventBus
      } = eventContext);
    }
    const didMount = A2(false);
    if (eventBus && !didMount.current) {
      eventBus.on(event2, callback);
    }
    y2(() => {
      if (eventBus && didMount.current) {
        eventBus.on(event2, callback);
      }
      didMount.current = true;
      return () => {
        if (eventBus) {
          eventBus.off(event2, callback);
        }
      };
    }, [callback, event2, eventBus]);
  }
  function useLayoutState(path2, defaultValue) {
    const {
      getLayoutForKey,
      setLayoutForKey
    } = x2(LayoutContext);
    const layoutForKey = getLayoutForKey(path2, defaultValue);
    const setState = q2((newValue) => {
      setLayoutForKey(path2, newValue);
    }, [setLayoutForKey]);
    return [layoutForKey, setState];
  }
  function usePrevious2(value) {
    const ref = A2();
    y2(() => {
      ref.current = value;
    });
    return ref.current;
  }
  function useShowEntryEvent(id2) {
    const {
      onShow
    } = x2(LayoutContext);
    const ref = A2();
    const focus = A2(false);
    const onShowEntry = q2((event2) => {
      if (event2.id === id2) {
        onShow();
        if (!focus.current) {
          focus.current = true;
        }
      }
    }, [id2]);
    y2(() => {
      if (focus.current && ref.current) {
        if (isFunction(ref.current.focus)) {
          ref.current.focus();
        }
        if (isFunction(ref.current.select)) {
          ref.current.select();
        }
        focus.current = false;
      }
    });
    useEvent("propertiesPanel.showEntry", onShowEntry);
    return ref;
  }
  function useStickyIntersectionObserver(ref, scrollContainerSelector, setSticky) {
    const [scrollContainer, setScrollContainer] = d2(query(scrollContainerSelector));
    const updateScrollContainer = q2(() => {
      const newScrollContainer = query(scrollContainerSelector);
      if (newScrollContainer !== scrollContainer) {
        setScrollContainer(newScrollContainer);
      }
    }, [scrollContainerSelector, scrollContainer]);
    y2(() => {
      updateScrollContainer();
    }, [updateScrollContainer]);
    useEvent("propertiesPanel.attach", updateScrollContainer);
    useEvent("propertiesPanel.detach", updateScrollContainer);
    y2(() => {
      const Observer = IntersectionObserver;
      if (!Observer) {
        return;
      }
      if (!ref.current || !scrollContainer) {
        return;
      }
      const observer = new Observer((entries2) => {
        if (scrollContainer.scrollHeight === 0) {
          return;
        }
        entries2.forEach((entry) => {
          if (entry.intersectionRatio < 1) {
            setSticky(true);
          } else if (entry.intersectionRatio === 1) {
            setSticky(false);
          }
        });
      }, {
        root: scrollContainer,
        rootMargin: "0px 0px 999999% 0px",
        // Use bottom margin to avoid stickyness when scrolling out to bottom
        threshold: [1]
      });
      observer.observe(ref.current);
      return () => {
        observer.unobserve(ref.current);
      };
    }, [ref.current, scrollContainer, setSticky]);
  }
  function useStaticCallback(callback) {
    const callbackRef = A2(callback);
    callbackRef.current = callback;
    return q2((...args) => callbackRef.current(...args), []);
  }
  function useElementVisible(element) {
    const [visible, setVisible] = d2(!!element && !!element.clientHeight);
    _2(() => {
      if (!element) return;
      const resizeObserver = new ResizeObserver(([entry]) => {
        requestAnimationFrame(() => {
          const newVisible = !!entry.contentRect.height;
          if (newVisible !== visible) {
            setVisible(newVisible);
          }
        });
      });
      resizeObserver.observe(element);
      return () => resizeObserver.disconnect();
    }, [element, visible]);
    return visible;
  }
  function Group2(props) {
    const {
      element,
      entries: entries2 = [],
      id: id2,
      label,
      shouldOpen = false
    } = props;
    const groupRef = A2(null);
    const [open, setOpen] = useLayoutState(["groups", id2, "open"], shouldOpen);
    const onShow = q2(() => setOpen(true), [setOpen]);
    const toggleOpen = () => setOpen(!open);
    const [edited, setEdited] = d2(false);
    const [sticky, setSticky] = d2(false);
    y2(() => {
      const scheduled = requestAnimationFrame(() => {
        const hasOneEditedEntry = entries2.find((entry) => {
          const {
            id: id3,
            isEdited: isEdited2
          } = entry;
          const entryNode = query(`[data-entry-id="${id3}"]`);
          if (!isFunction(isEdited2) || !entryNode) {
            return false;
          }
          const inputNode = query(".bio-properties-panel-input", entryNode);
          return isEdited2(inputNode);
        });
        setEdited(hasOneEditedEntry);
      });
      return () => cancelAnimationFrame(scheduled);
    }, [entries2, setEdited]);
    const allErrors = useErrors();
    const hasErrors = entries2.some((entry) => allErrors[entry.id]);
    useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
    const propertiesPanelContext = {
      ...x2(LayoutContext),
      onShow
    };
    return u2("div", {
      class: "bio-properties-panel-group",
      "data-group-id": "group-" + id2,
      ref: groupRef,
      children: [u2("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-header", edited ? "" : "empty", open ? "open" : "", sticky && open ? "sticky" : ""),
        onClick: toggleOpen,
        children: [u2("div", {
          title: props.tooltip ? null : label,
          "data-title": label,
          class: "bio-properties-panel-group-header-title",
          children: u2(TooltipWrapper, {
            value: props.tooltip,
            forId: "group-" + id2,
            element,
            parent: groupRef,
            children: label
          })
        }), u2("div", {
          class: "bio-properties-panel-group-header-buttons",
          children: [u2(DataMarker, {
            edited,
            hasErrors
          }), u2("button", {
            type: "button",
            title: "Toggle section",
            class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
            children: u2(ArrowIcon, {
              class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
            })
          })]
        })]
      }), u2("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-entries", open ? "open" : ""),
        children: u2(LayoutContext.Provider, {
          value: propertiesPanelContext,
          children: entries2.map((entry) => {
            const {
              component: Component,
              id: id3
            } = entry;
            return _(Component, {
              ...entry,
              element,
              key: id3
            });
          })
        })
      })]
    });
  }
  function DataMarker(props) {
    const {
      edited,
      hasErrors
    } = props;
    if (hasErrors) {
      return u2("div", {
        title: "Section contains an error",
        class: "bio-properties-panel-dot bio-properties-panel-dot--error"
      });
    }
    if (edited) {
      return u2("div", {
        title: "Section contains data",
        class: "bio-properties-panel-dot"
      });
    }
    return null;
  }
  function Placeholder2(props) {
    const {
      text: text2,
      icon: Icon
    } = props;
    return u2("div", {
      class: "bio-properties-panel open",
      children: u2("section", {
        class: "bio-properties-panel-placeholder",
        children: [Icon && u2(Icon, {
          class: "bio-properties-panel-placeholder-icon"
        }), u2("p", {
          class: "bio-properties-panel-placeholder-text",
          children: text2
        })]
      })
    });
  }
  function Description$1(props) {
    const {
      element,
      forId,
      value
    } = props;
    const contextDescription = useDescriptionContext(forId, element);
    const description2 = value || contextDescription;
    if (description2) {
      return u2("div", {
        class: "bio-properties-panel-description",
        children: description2
      });
    }
  }
  var noop$6 = () => {
  };
  var useBufferedFocus$1 = function(editor, ref) {
    const [buffer, setBuffer] = d2(void 0);
    ref.current = T2(() => ({
      focus: (offset2) => {
        if (editor) {
          editor.focus(offset2);
        } else {
          if (typeof offset2 === "undefined") {
            offset2 = Infinity;
          }
          setBuffer(offset2);
        }
      }
    }), [editor]);
    y2(() => {
      if (typeof buffer !== "undefined" && editor) {
        editor.focus(buffer);
        setBuffer(false);
      }
    }, [editor, buffer]);
  };
  var CodeEditor$1 = D3((props, ref) => {
    const {
      onInput,
      disabled,
      tooltipContainer,
      enableGutters,
      value,
      onLint = noop$6,
      onPopupOpen = noop$6,
      popupOpen,
      contentAttributes: contentAttributes2 = {},
      hostLanguage = null,
      singleLine = false
    } = props;
    const inputRef = A2();
    const [editor, setEditor] = d2();
    const [localValue, setLocalValue] = d2(value || "");
    useBufferedFocus$1(editor, ref);
    const handleInput = useStaticCallback((newValue) => {
      onInput(newValue);
      setLocalValue(newValue);
    });
    y2(() => {
      let editor2;
      editor2 = new FeelersEditor({
        container: inputRef.current,
        onChange: handleInput,
        value: localValue,
        onLint,
        contentAttributes: contentAttributes2,
        tooltipContainer,
        enableGutters,
        hostLanguage,
        singleLine,
        lineWrap: true
      });
      setEditor(editor2);
      return () => {
        onLint([]);
        inputRef.current.innerHTML = "";
        setEditor(null);
      };
    }, []);
    y2(() => {
      if (!editor) {
        return;
      }
      if (value === localValue) {
        return;
      }
      editor.setValue(value);
      setLocalValue(value);
    }, [value]);
    const handleClick = () => {
      ref.current.focus();
    };
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-feelers-editor-container", popupOpen ? "popupOpen" : null),
      children: [u2("div", {
        class: "bio-properties-panel-feelers-editor__open-popup-placeholder",
        children: "Opened in editor"
      }), u2("div", {
        name: props.name,
        class: (0, import_classnames2.default)("bio-properties-panel-feelers-editor bio-properties-panel-input", localValue ? "edited" : null, disabled ? "disabled" : null),
        ref: inputRef,
        onClick: handleClick
      }), u2("button", {
        type: "button",
        title: "Open pop-up editor",
        class: "bio-properties-panel-open-feel-popup",
        onClick: () => onPopupOpen("feelers"),
        children: u2(PopupIcon, {})
      })]
    });
  });
  var noop$5 = () => {
  };
  var useBufferedFocus = function(editor, ref) {
    const [buffer, setBuffer] = d2(void 0);
    ref.current = T2(() => ({
      focus: (offset2) => {
        if (editor) {
          editor.focus(offset2);
        } else {
          if (typeof offset2 === "undefined") {
            offset2 = Infinity;
          }
          setBuffer(offset2);
        }
      }
    }), [editor]);
    y2(() => {
      if (typeof buffer !== "undefined" && editor) {
        editor.focus(buffer);
        setBuffer(false);
      }
    }, [editor, buffer]);
  };
  var CodeEditor = D3((props, ref) => {
    const {
      contentAttributes: contentAttributes2,
      enableGutters,
      value,
      onInput,
      onFeelToggle = noop$5,
      onLint = noop$5,
      onPopupOpen = noop$5,
      placeholder: placeholder2,
      popupOpen,
      disabled,
      tooltipContainer,
      variables
    } = props;
    const inputRef = A2();
    const [editor, setEditor] = d2();
    const [localValue, setLocalValue] = d2(value || "");
    useBufferedFocus(editor, ref);
    const handleInput = useStaticCallback((newValue) => {
      onInput(newValue);
      setLocalValue(newValue);
    });
    y2(() => {
      let editor2;
      const onKeyDown = (e3) => {
        if (e3.key !== "Backspace" || !editor2) {
          return;
        }
        const selection2 = editor2.getSelection();
        const range = selection2.ranges[selection2.mainIndex];
        if (range.from === 0 && range.to === 0) {
          onFeelToggle();
        }
      };
      editor2 = new FeelEditor({
        container: inputRef.current,
        onChange: handleInput,
        onKeyDown,
        onLint,
        placeholder: placeholder2,
        tooltipContainer,
        value: localValue,
        variables,
        extensions: [...enableGutters ? [lineNumbers()] : [], EditorView.lineWrapping],
        contentAttributes: contentAttributes2
      });
      setEditor(editor2);
      return () => {
        onLint([]);
        inputRef.current.innerHTML = "";
        setEditor(null);
      };
    }, []);
    y2(() => {
      if (!editor) {
        return;
      }
      if (value === localValue) {
        return;
      }
      editor.setValue(value);
      setLocalValue(value);
    }, [value]);
    y2(() => {
      if (!editor) {
        return;
      }
      editor.setVariables(variables);
    }, [variables]);
    y2(() => {
      if (!editor) {
        return;
      }
      editor.setPlaceholder(placeholder2);
    }, [placeholder2]);
    const handleClick = () => {
      ref.current.focus();
    };
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-feel-editor-container", disabled ? "disabled" : null, popupOpen ? "popupOpen" : null),
      children: [u2("div", {
        class: "bio-properties-panel-feel-editor__open-popup-placeholder",
        children: "Opened in editor"
      }), u2("div", {
        name: props.name,
        class: (0, import_classnames2.default)("bio-properties-panel-input", localValue ? "edited" : null),
        ref: inputRef,
        onClick: handleClick
      }), u2("button", {
        type: "button",
        title: "Open pop-up editor",
        class: "bio-properties-panel-open-feel-popup",
        onClick: () => onPopupOpen(),
        children: u2(PopupIcon, {})
      })]
    });
  });
  function FeelIndicator(props) {
    const {
      active
    } = props;
    if (!active) {
      return null;
    }
    return u2("span", {
      class: "bio-properties-panel-feel-indicator",
      children: "="
    });
  }
  var noop$4 = () => {
  };
  function FeelIcon2(props) {
    const {
      feel: feel3 = false,
      active,
      disabled = false,
      onClick = noop$4
    } = props;
    const feelRequiredLabel = "FEEL expression is mandatory";
    const feelOptionalLabel = `Click to ${active ? "remove" : "set a"} dynamic value with FEEL expression`;
    const handleClick = (e3) => {
      onClick(e3);
      if (!e3.pointerType) {
        e3.stopPropagation();
      }
    };
    return u2("button", {
      type: "button",
      class: (0, import_classnames2.default)("bio-properties-panel-feel-icon", active ? "active" : null, feel3 === "required" ? "required" : "optional"),
      onClick: handleClick,
      disabled: feel3 === "required" || disabled,
      title: feel3 === "required" ? feelRequiredLabel : feelOptionalLabel,
      children: u2(FeelIcon$1, {})
    });
  }
  var FeelPopupContext = K({
    open: () => {
    },
    close: () => {
    },
    source: null
  });
  function createDragger(fn4, dragPreview) {
    let self2;
    let startX, startY;
    function onDragStart(event2) {
      self2 = this;
      startX = event2.clientX;
      startY = event2.clientY;
      if (event2.dataTransfer) {
        event2.dataTransfer.setDragImage(dragPreview || emptyCanvas(), 0, 0);
      }
      document.addEventListener("dragover", onDrag, true);
      document.addEventListener("dragenter", preventDefault, true);
      document.addEventListener("dragend", onEnd);
      document.addEventListener("drop", preventDefault);
    }
    function onDrag(event2) {
      const delta = {
        x: event2.clientX - startX,
        y: event2.clientY - startY
      };
      return fn4.call(self2, event2, delta);
    }
    function onEnd() {
      document.removeEventListener("dragover", onDrag, true);
      document.removeEventListener("dragenter", preventDefault, true);
      document.removeEventListener("dragend", onEnd);
      document.removeEventListener("drop", preventDefault);
    }
    return onDragStart;
  }
  function preventDefault(event2) {
    event2.preventDefault();
    event2.stopPropagation();
  }
  function emptyCanvas() {
    return domify$1('<canvas width="0" height="0" />');
  }
  var noop$3 = () => {
  };
  function PopupComponent(props, globalRef) {
    const {
      container,
      className,
      delayInitialFocus,
      position,
      width,
      height,
      onClose,
      onPostActivate = noop$3,
      onPostDeactivate = noop$3,
      returnFocus = true,
      closeOnEscape = true,
      title
    } = props;
    const focusTrapRef = A2(null);
    const localRef = A2(null);
    const popupRef = globalRef || localRef;
    const containerNode = T2(() => getContainerNode(container), [container]);
    const handleKeydown = (event2) => {
      event2.stopPropagation();
      if (closeOnEscape && event2.key === "Escape") {
        onClose();
      }
    };
    const handleFocus = () => {
      if (focusTrapRef.current) {
        focusTrapRef.current.activate();
      }
    };
    let style = {};
    if (position) {
      style = {
        ...style,
        top: position.top + "px",
        left: position.left + "px"
      };
    }
    if (width) {
      style.width = width + "px";
    }
    if (height) {
      style.height = height + "px";
    }
    y2(() => {
      if (popupRef.current) {
        popupRef.current.addEventListener("focusin", handleFocus);
      }
      return () => {
        popupRef.current.removeEventListener("focusin", handleFocus);
      };
    }, [popupRef]);
    y2(() => {
      if (popupRef.current) {
        focusTrapRef.current = createFocusTrap(popupRef.current, {
          clickOutsideDeactivates: true,
          delayInitialFocus,
          fallbackFocus: popupRef.current,
          onPostActivate,
          onPostDeactivate,
          returnFocusOnDeactivate: returnFocus
        });
        focusTrapRef.current.activate();
      }
      return () => focusTrapRef.current && focusTrapRef.current.deactivate();
    }, [popupRef]);
    useEvent("propertiesPanel.detach", onClose);
    return $2(u2("div", {
      "aria-label": title,
      tabIndex: -1,
      ref: popupRef,
      onKeyDown: handleKeydown,
      role: "dialog",
      class: (0, import_classnames2.default)("bio-properties-panel-popup", className),
      style,
      children: props.children
    }), containerNode || document.body);
  }
  var Popup = D3(PopupComponent);
  Popup.Title = Title;
  Popup.Body = Body;
  Popup.Footer = Footer;
  function Title(props) {
    const {
      children,
      className,
      draggable,
      emit = () => {
      },
      title,
      showCloseButton = false,
      closeButtonTooltip = "Close popup",
      onClose,
      ...rest
    } = props;
    const context = A2({
      startPosition: null,
      newPosition: null
    });
    const dragPreviewRef = A2();
    const titleRef = A2();
    const onMove = (event2, delta) => {
      cancel(event2);
      const {
        x: dx,
        y: dy
      } = delta;
      const newPosition = {
        x: context.current.startPosition.x + dx,
        y: context.current.startPosition.y + dy
      };
      const popupParent = getPopupParent(titleRef.current);
      popupParent.style.top = newPosition.y + "px";
      popupParent.style.left = newPosition.x + "px";
      emit("dragover", {
        newPosition,
        delta
      });
    };
    const onMoveStart = (event2) => {
      const onDragStart = createDragger(onMove, dragPreviewRef.current);
      onDragStart(event2);
      event2.stopPropagation();
      const popupParent = getPopupParent(titleRef.current);
      const bounds = popupParent.getBoundingClientRect();
      context.current.startPosition = {
        x: bounds.left,
        y: bounds.top
      };
      emit("dragstart");
    };
    const onMoveEnd = () => {
      context.current.newPosition = null;
      emit("dragend");
    };
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-popup__header", draggable && "draggable", className),
      ref: titleRef,
      draggable,
      onDragStart: onMoveStart,
      onDragEnd: onMoveEnd,
      ...rest,
      children: [draggable && u2(k, {
        children: [u2("div", {
          ref: dragPreviewRef,
          class: "bio-properties-panel-popup__drag-preview"
        }), u2("div", {
          class: "bio-properties-panel-popup__drag-handle",
          children: u2(DragIcon, {})
        })]
      }), u2("div", {
        class: "bio-properties-panel-popup__title",
        children: title
      }), children, showCloseButton && u2("button", {
        title: closeButtonTooltip,
        class: "bio-properties-panel-popup__close",
        onClick: onClose,
        children: u2(CloseIcon, {})
      })]
    });
  }
  function Body(props) {
    const {
      children,
      className,
      ...rest
    } = props;
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-popup__body", className),
      ...rest,
      children
    });
  }
  function Footer(props) {
    const {
      children,
      className,
      ...rest
    } = props;
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-popup__footer", className),
      ...rest,
      children: props.children
    });
  }
  function getPopupParent(node) {
    return node.closest(".bio-properties-panel-popup");
  }
  function cancel(event2) {
    event2.preventDefault();
    event2.stopPropagation();
  }
  function getContainerNode(node) {
    if (typeof node === "string") {
      return query(node);
    }
    return node;
  }
  var FEEL_POPUP_WIDTH = 700;
  var FEEL_POPUP_HEIGHT = 250;
  function FEELPopupRoot(props) {
    const {
      element,
      eventBus = {
        fire() {
        },
        on() {
        },
        off() {
        }
      },
      popupContainer,
      getPopupLinks = () => []
    } = props;
    const prevElement = usePrevious2(element);
    const [popupConfig, setPopupConfig] = d2({});
    const [open, setOpen] = d2(false);
    const [source, setSource] = d2(null);
    const [sourceElement, setSourceElement] = d2(null);
    const emit = (type3, context) => {
      eventBus.fire("feelPopup." + type3, context);
    };
    const isOpen = q2(() => {
      return !!open;
    }, [open]);
    useUpdateEffect(() => {
      if (!open) {
        emit("closed");
      }
    }, [open]);
    const handleOpen2 = (entryId, config2, _sourceElement) => {
      setSource(entryId);
      setPopupConfig(config2);
      setOpen(true);
      setSourceElement(_sourceElement);
      emit("open");
    };
    const handleClose2 = (event2 = {}) => {
      const {
        id: id2
      } = event2;
      if (id2 && id2 !== source) {
        return;
      }
      setOpen(false);
      setSource(null);
    };
    const feelPopupContext = {
      open: handleOpen2,
      close: handleClose2,
      source
    };
    y2(() => {
      if (element && prevElement && element !== prevElement) {
        handleClose2();
      }
    }, [element]);
    y2(() => {
      const handlePopupOpen = (context) => {
        const {
          entryId,
          popupConfig: popupConfig2,
          sourceElement: sourceElement2
        } = context;
        handleOpen2(entryId, popupConfig2, sourceElement2);
      };
      const handleIsOpen = () => {
        return isOpen();
      };
      eventBus.on("feelPopup._close", handleClose2);
      eventBus.on("feelPopup._open", handlePopupOpen);
      eventBus.on("feelPopup._isOpen", handleIsOpen);
      return () => {
        eventBus.off("feelPopup._close", handleClose2);
        eventBus.off("feelPopup._open", handleOpen2);
        eventBus.off("feelPopup._isOpen", handleIsOpen);
      };
    }, [eventBus, isOpen]);
    return u2(FeelPopupContext.Provider, {
      value: feelPopupContext,
      children: [open && u2(FeelPopupComponent, {
        onClose: handleClose2,
        container: popupContainer,
        getLinks: getPopupLinks,
        sourceElement,
        emit,
        ...popupConfig
      }), props.children]
    });
  }
  function FeelPopupComponent(props) {
    const {
      container,
      getLinks,
      id: id2,
      hostLanguage,
      onInput,
      onClose,
      position,
      singleLine,
      sourceElement,
      title,
      tooltipContainer,
      type: type3,
      value,
      variables,
      emit
    } = props;
    const editorRef = A2();
    const popupRef = A2();
    const isAutoCompletionOpen = A2(false);
    const handleSetReturnFocus = () => {
      sourceElement && sourceElement.focus();
    };
    const onKeyDownCapture = (event2) => {
      if (event2.key === "Escape") {
        isAutoCompletionOpen.current = autoCompletionOpen(event2.target);
      }
    };
    const onKeyDown = (event2) => {
      if (event2.key === "Escape") {
        if (!isAutoCompletionOpen.current) {
          onClose();
          isAutoCompletionOpen.current = false;
        }
      }
    };
    y2(() => {
      emit("opened", {
        domNode: popupRef.current
      });
      return () => emit("close", {
        domNode: popupRef.current
      });
    }, []);
    y2(() => {
      if (editorRef.current) {
        editorRef.current.focus();
      }
    }, [editorRef]);
    return u2(Popup, {
      container,
      className: "bio-properties-panel-feel-popup",
      emit,
      position,
      title,
      onClose,
      returnFocus: false,
      closeOnEscape: false,
      delayInitialFocus: false,
      onPostDeactivate: handleSetReturnFocus,
      height: FEEL_POPUP_HEIGHT,
      width: FEEL_POPUP_WIDTH,
      ref: popupRef,
      children: [u2(Popup.Title, {
        title,
        emit,
        showCloseButton: true,
        closeButtonTooltip: "Save and close",
        onClose,
        draggable: true,
        children: u2(k, {
          children: getLinks(type3).map((link2, index2) => {
            return u2("a", {
              rel: "noreferrer",
              href: link2.href,
              target: "_blank",
              class: "bio-properties-panel-feel-popup__title-link",
              children: [link2.title, u2(LaunchIcon, {})]
            }, index2);
          })
        })
      }), u2(Popup.Body, {
        children: u2("div", {
          onKeyDownCapture,
          onKeyDown,
          class: "bio-properties-panel-feel-popup__body",
          children: [type3 === "feel" && u2(CodeEditor, {
            enableGutters: true,
            id: prefixId$8(id2),
            name: id2,
            onInput,
            value,
            variables,
            ref: editorRef,
            tooltipContainer
          }), type3 === "feelers" && u2(CodeEditor$1, {
            id: prefixId$8(id2),
            contentAttributes: {
              "aria-label": title
            },
            enableGutters: true,
            hostLanguage,
            name: id2,
            onInput,
            value,
            ref: editorRef,
            singleLine,
            tooltipContainer
          })]
        })
      })]
    });
  }
  function prefixId$8(id2) {
    return `bio-properties-panel-${id2}`;
  }
  function autoCompletionOpen(element) {
    return element.closest(".cm-editor").querySelector(".cm-tooltip-autocomplete");
  }
  function useUpdateEffect(effect, deps) {
    const isMounted = A2(false);
    y2(() => {
      if (isMounted.current) {
        return effect();
      } else {
        isMounted.current = true;
      }
    }, deps);
  }
  function ToggleSwitch(props) {
    const {
      id: id2,
      label,
      onInput,
      value,
      switcherLabel,
      inline: inline2,
      onFocus,
      onBlur,
      inputRef,
      tooltip
    } = props;
    const [localValue, setLocalValue] = d2(value);
    const handleInputCallback = async () => {
      onInput(!value);
    };
    const handleInput = (e3) => {
      handleInputCallback();
      setLocalValue(e3.target.value);
    };
    y2(() => {
      if (value === localValue) {
        return;
      }
      setLocalValue(value);
    }, [value]);
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-toggle-switch", {
        inline: inline2
      }),
      children: [u2("label", {
        class: "bio-properties-panel-label",
        for: prefixId$7(id2),
        children: u2(TooltipWrapper, {
          value: tooltip,
          forId: id2,
          element: props.element,
          children: label
        })
      }), u2("div", {
        class: "bio-properties-panel-field-wrapper",
        children: [u2("label", {
          class: "bio-properties-panel-toggle-switch__switcher",
          children: [u2("input", {
            ref: inputRef,
            id: prefixId$7(id2),
            class: "bio-properties-panel-input",
            type: "checkbox",
            onFocus,
            onBlur,
            name: id2,
            onInput: handleInput,
            checked: !!localValue
          }), u2("span", {
            class: "bio-properties-panel-toggle-switch__slider"
          })]
        }), switcherLabel && u2("p", {
          class: "bio-properties-panel-toggle-switch__label",
          children: switcherLabel
        })]
      })]
    });
  }
  function ToggleSwitchEntry(props) {
    const {
      element,
      id: id2,
      description: description2,
      label,
      switcherLabel,
      inline: inline2,
      getValue,
      setValue,
      onFocus,
      onBlur,
      tooltip
    } = props;
    const value = getValue(element);
    return u2("div", {
      class: "bio-properties-panel-entry bio-properties-panel-toggle-switch-entry",
      "data-entry-id": id2,
      children: [u2(ToggleSwitch, {
        id: id2,
        label,
        value,
        onInput: setValue,
        onFocus,
        onBlur,
        switcherLabel,
        inline: inline2,
        tooltip,
        element
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function isEdited$8(node) {
    return node && !!node.checked;
  }
  function prefixId$7(id2) {
    return `bio-properties-panel-${id2}`;
  }
  function NumberField(props) {
    const {
      debounce: debounce3,
      disabled,
      displayLabel = true,
      id: id2,
      inputRef,
      label,
      max,
      min,
      onInput,
      step,
      value = "",
      onFocus,
      onBlur
    } = props;
    const [localValue, setLocalValue] = d2(value);
    const handleInputCallback = T2(() => {
      return debounce3((target) => {
        if (target.validity.valid) {
          onInput(target.value ? parseFloat(target.value) : void 0);
        }
      });
    }, [onInput, debounce3]);
    const handleInput = (e3) => {
      handleInputCallback(e3.target);
      setLocalValue(e3.target.value);
    };
    y2(() => {
      if (value === localValue) {
        return;
      }
      setLocalValue(value);
    }, [value]);
    return u2("div", {
      class: "bio-properties-panel-numberfield",
      children: [displayLabel && u2("label", {
        for: prefixId$6(id2),
        class: "bio-properties-panel-label",
        children: label
      }), u2("input", {
        id: prefixId$6(id2),
        ref: inputRef,
        type: "number",
        name: id2,
        spellCheck: "false",
        autoComplete: "off",
        disabled,
        class: "bio-properties-panel-input",
        max,
        min,
        onInput: handleInput,
        onFocus,
        onBlur,
        step,
        value: localValue
      })]
    });
  }
  function NumberFieldEntry(props) {
    const {
      debounce: debounce3,
      description: description2,
      disabled,
      element,
      getValue,
      id: id2,
      label,
      max,
      min,
      setValue,
      step,
      onFocus,
      onBlur,
      validate: validate2
    } = props;
    const globalError = useError(id2);
    const [localError, setLocalError] = d2(null);
    let value = getValue(element);
    y2(() => {
      if (isFunction(validate2)) {
        const newValidationError = validate2(value) || null;
        setLocalError(newValidationError);
      }
    }, [value, validate2]);
    const onInput = (newValue) => {
      let newValidationError = null;
      if (isFunction(validate2)) {
        newValidationError = validate2(newValue) || null;
      }
      setValue(newValue, newValidationError);
      setLocalError(newValidationError);
    };
    const error2 = globalError || localError;
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
      "data-entry-id": id2,
      children: [u2(NumberField, {
        debounce: debounce3,
        disabled,
        id: id2,
        label,
        onFocus,
        onBlur,
        onInput,
        max,
        min,
        step,
        value
      }, element), error2 && u2("div", {
        class: "bio-properties-panel-error",
        children: error2
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function isEdited$7(node) {
    return node && !!node.value;
  }
  function prefixId$6(id2) {
    return `bio-properties-panel-${id2}`;
  }
  var noop$2 = () => {
  };
  function FeelTextfieldComponent(props) {
    const {
      debounce: debounce3,
      id: id2,
      element,
      label,
      hostLanguage,
      onInput,
      onBlur,
      onError,
      placeholder: placeholder2,
      feel: feel3,
      value = "",
      disabled = false,
      variables,
      singleLine,
      tooltipContainer,
      OptionalComponent = OptionalFeelInput,
      tooltip
    } = props;
    const [localValue, _setLocalValue] = d2(value);
    const editorRef = useShowEntryEvent(id2);
    const containerRef = A2();
    const feelActive = isString(localValue) && localValue.startsWith("=") || feel3 === "required";
    const feelOnlyValue = isString(localValue) && localValue.startsWith("=") ? localValue.substring(1) : localValue;
    const [focus, _setFocus] = d2(void 0);
    const {
      open: openPopup,
      source: popupSource
    } = x2(FeelPopupContext);
    const popuOpen = popupSource === id2;
    const setFocus = (offset2 = 0) => {
      const hasFocus = containerRef.current.contains(document.activeElement);
      const position = hasFocus ? document.activeElement.selectionStart : Infinity;
      _setFocus(position + offset2);
    };
    const handleInputCallback = T2(() => {
      return debounce3((newValue) => {
        onInput(newValue);
      });
    }, [onInput, debounce3]);
    const setLocalValue = (newValue) => {
      _setLocalValue(newValue);
      if (typeof newValue === "undefined" || newValue === "" || newValue === "=") {
        handleInputCallback(void 0);
      } else {
        handleInputCallback(newValue);
      }
    };
    const handleFeelToggle = useStaticCallback(() => {
      if (feel3 === "required") {
        return;
      }
      if (!feelActive) {
        setLocalValue("=" + localValue);
      } else {
        setLocalValue(feelOnlyValue);
      }
    });
    const handleLocalInput = (newValue) => {
      if (feelActive) {
        newValue = "=" + newValue;
      }
      if (newValue === localValue) {
        return;
      }
      setLocalValue(newValue);
      if (!feelActive && isString(newValue) && newValue.startsWith("=")) {
        setFocus(-1);
      }
    };
    const handleOnBlur = (e3) => {
      if (onBlur) {
        onBlur(e3);
      }
      setLocalValue(e3.target.value.trim());
    };
    const handleLint = useStaticCallback((lint2 = []) => {
      const syntaxError = lint2.some((report) => report.type === "Syntax Error");
      if (syntaxError) {
        onError("Unparsable FEEL expression.");
      } else {
        onError(void 0);
      }
    });
    const handlePopupOpen = (type3 = "feel") => {
      const popupOptions = {
        id: id2,
        hostLanguage,
        onInput: handleLocalInput,
        position: calculatePopupPosition(containerRef.current),
        singleLine,
        title: getPopupTitle(element, label),
        tooltipContainer,
        type: type3,
        value: feelOnlyValue,
        variables
      };
      openPopup(id2, popupOptions, editorRef.current);
    };
    y2(() => {
      if (typeof focus !== "undefined") {
        editorRef.current.focus(focus);
        _setFocus(void 0);
      }
    }, [focus]);
    y2(() => {
      if (value === localValue) {
        return;
      }
      if (!value) {
        setLocalValue(feelActive ? "=" : "");
        return;
      }
      setLocalValue(value);
    }, [value]);
    y2(() => {
      const copyHandler = (event2) => {
        if (!feelActive) {
          return;
        }
        event2.clipboardData.setData("application/FEEL", event2.clipboardData.getData("text"));
      };
      const pasteHandler = (event2) => {
        if (feelActive || popuOpen) {
          return;
        }
        const data = event2.clipboardData.getData("application/FEEL");
        if (data) {
          setTimeout(() => {
            handleFeelToggle();
            setFocus();
          });
        }
      };
      containerRef.current.addEventListener("copy", copyHandler);
      containerRef.current.addEventListener("cut", copyHandler);
      containerRef.current.addEventListener("paste", pasteHandler);
      return () => {
        containerRef.current.removeEventListener("copy", copyHandler);
        containerRef.current.removeEventListener("cut", copyHandler);
        containerRef.current.removeEventListener("paste", pasteHandler);
      };
    }, [containerRef, feelActive, handleFeelToggle, setFocus]);
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-feel-entry", {
        "feel-active": feelActive
      }),
      children: [u2("label", {
        for: prefixId$5(id2),
        class: "bio-properties-panel-label",
        onClick: () => setFocus(),
        children: [u2(TooltipWrapper, {
          value: tooltip,
          forId: id2,
          element: props.element,
          children: label
        }), u2(FeelIcon2, {
          label,
          feel: feel3,
          onClick: handleFeelToggle,
          active: feelActive
        })]
      }), u2("div", {
        class: "bio-properties-panel-feel-container",
        ref: containerRef,
        children: [u2(FeelIndicator, {
          active: feelActive,
          disabled: feel3 !== "optional" || disabled,
          onClick: handleFeelToggle
        }), feelActive ? u2(CodeEditor, {
          name: id2,
          onInput: handleLocalInput,
          contentAttributes: {
            "id": prefixId$5(id2),
            "aria-label": label
          },
          disabled,
          popupOpen: popuOpen,
          onFeelToggle: () => {
            handleFeelToggle();
            setFocus(true);
          },
          onLint: handleLint,
          onPopupOpen: handlePopupOpen,
          placeholder: placeholder2,
          value: feelOnlyValue,
          variables,
          ref: editorRef,
          tooltipContainer
        }) : u2(OptionalComponent, {
          ...props,
          popupOpen: popuOpen,
          onInput: handleLocalInput,
          onBlur: handleOnBlur,
          contentAttributes: {
            "id": prefixId$5(id2),
            "aria-label": label
          },
          value: localValue,
          ref: editorRef,
          onPopupOpen: handlePopupOpen,
          containerRef
        })]
      })]
    });
  }
  var FeelTextfield = withAutoClosePopup(FeelTextfieldComponent);
  var OptionalFeelInput = D3((props, ref) => {
    const {
      id: id2,
      disabled,
      onInput,
      value,
      onFocus,
      onBlur,
      placeholder: placeholder2
    } = props;
    const inputRef = A2();
    ref.current = {
      focus: (position) => {
        const input = inputRef.current;
        if (!input) {
          return;
        }
        input.focus();
        if (typeof position === "number") {
          if (position > value.length) {
            position = value.length;
          }
          input.setSelectionRange(position, position);
        }
      }
    };
    return u2("input", {
      id: prefixId$5(id2),
      type: "text",
      ref: inputRef,
      name: id2,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: (e3) => onInput(e3.target.value),
      onFocus,
      onBlur,
      placeholder: placeholder2,
      value: value || ""
    });
  });
  var OptionalFeelNumberField = D3((props, ref) => {
    const {
      id: id2,
      debounce: debounce3,
      disabled,
      onInput,
      value,
      min,
      max,
      step,
      onFocus,
      onBlur
    } = props;
    const inputRef = A2();
    ref.current = {
      focus: (position) => {
        const input = inputRef.current;
        if (!input) {
          return;
        }
        input.focus();
        if (typeof position === "number" && position !== Infinity) {
          if (position > value.length) {
            position = value.length;
          }
          input.setSelectionRange(position, position);
        }
      }
    };
    return u2(NumberField, {
      id: id2,
      debounce: debounce3,
      disabled,
      displayLabel: false,
      inputRef,
      max,
      min,
      onInput,
      step,
      value,
      onFocus,
      onBlur
    });
  });
  D3((props, ref) => {
    const {
      id: id2,
      disabled,
      onInput,
      value,
      onFocus,
      onBlur,
      placeholder: placeholder2
    } = props;
    const inputRef = A2();
    ref.current = {
      focus: () => {
        const input = inputRef.current;
        if (!input) {
          return;
        }
        input.focus();
        input.setSelectionRange(0, 0);
      }
    };
    return u2("textarea", {
      id: prefixId$5(id2),
      type: "text",
      ref: inputRef,
      name: id2,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: (e3) => onInput(e3.target.value),
      onFocus,
      onBlur,
      placeholder: placeholder2,
      value: value || "",
      "data-gramm": "false"
    });
  });
  var OptionalFeelToggleSwitch = D3((props, ref) => {
    const {
      id: id2,
      onInput,
      value,
      onFocus,
      onBlur,
      switcherLabel
    } = props;
    const inputRef = A2();
    ref.current = {
      focus: () => {
        const input = inputRef.current;
        if (!input) {
          return;
        }
        input.focus();
      }
    };
    return u2(ToggleSwitch, {
      id: id2,
      value,
      inputRef,
      onInput,
      onFocus,
      onBlur,
      switcherLabel
    });
  });
  D3((props, ref) => {
    const {
      id: id2,
      disabled,
      onInput,
      value,
      onFocus,
      onBlur
    } = props;
    const inputRef = A2();
    const handleChange = ({
      target
    }) => {
      onInput(target.checked);
    };
    ref.current = {
      focus: () => {
        const input = inputRef.current;
        if (!input) {
          return;
        }
        input.focus();
      }
    };
    return u2("input", {
      ref: inputRef,
      id: prefixId$5(id2),
      name: id2,
      onFocus,
      onBlur,
      type: "checkbox",
      class: "bio-properties-panel-input",
      onChange: handleChange,
      checked: value,
      disabled
    });
  });
  function FeelEntry(props) {
    const {
      element,
      id: id2,
      description: description2,
      debounce: debounce3,
      disabled,
      feel: feel3,
      label,
      getValue,
      setValue,
      tooltipContainer,
      hostLanguage,
      singleLine,
      validate: validate2,
      show = noop$2,
      example,
      variables,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      tooltip
    } = props;
    const [validationError, setValidationError] = d2(null);
    const [localError, setLocalError] = d2(null);
    let value = getValue(element);
    y2(() => {
      if (isFunction(validate2)) {
        const newValidationError = validate2(value) || null;
        setValidationError(newValidationError);
      }
    }, [value, validate2]);
    const onInput = useStaticCallback((newValue) => {
      let newValidationError = null;
      if (isFunction(validate2)) {
        newValidationError = validate2(newValue) || null;
      }
      if (newValue !== value) {
        setValue(newValue, newValidationError);
      }
      setValidationError(newValidationError);
    });
    const onError = q2((err) => {
      setLocalError(err);
    }, []);
    const temporaryError = useError(id2);
    const error2 = temporaryError || localError || validationError;
    return u2("div", {
      class: (0, import_classnames2.default)(props.class, "bio-properties-panel-entry", error2 ? "has-error" : ""),
      "data-entry-id": id2,
      children: [_(FeelTextfield, {
        ...props,
        debounce: debounce3,
        disabled,
        feel: feel3,
        id: id2,
        key: element,
        label,
        onInput,
        onError,
        onFocus,
        onBlur,
        placeholder: placeholder2,
        example,
        hostLanguage,
        singleLine,
        show,
        value,
        variables,
        tooltipContainer,
        OptionalComponent: props.OptionalComponent,
        tooltip
      }), error2 && u2("div", {
        class: "bio-properties-panel-error",
        children: error2
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function FeelNumberEntry(props) {
    return u2(FeelEntry, {
      class: "bio-properties-panel-feel-number",
      OptionalComponent: OptionalFeelNumberField,
      ...props
    });
  }
  function FeelToggleSwitchEntry(props) {
    return u2(FeelEntry, {
      class: "bio-properties-panel-feel-toggle-switch",
      OptionalComponent: OptionalFeelToggleSwitch,
      ...props
    });
  }
  function FeelTemplatingEntry(props) {
    return u2(FeelEntry, {
      class: "bio-properties-panel-feel-templating",
      OptionalComponent: CodeEditor$1,
      ...props
    });
  }
  function isEdited$6(node) {
    if (!node) {
      return false;
    }
    if (node.type === "checkbox") {
      return !!node.checked || node.classList.contains("edited");
    }
    return !!node.value || node.classList.contains("edited");
  }
  function prefixId$5(id2) {
    return `bio-properties-panel-${id2}`;
  }
  function calculatePopupPosition(element) {
    const {
      top: top2,
      left
    } = element.getBoundingClientRect();
    return {
      left: left - FEEL_POPUP_WIDTH - 20,
      top: top2
    };
  }
  function getPopupTitle(element, label) {
    let popupTitle = "";
    if (element && element.type) {
      popupTitle = `${element.type} / `;
    }
    return `${popupTitle}${label}`;
  }
  function withAutoClosePopup(Component) {
    return function(props) {
      const {
        id: id2
      } = props;
      const {
        close
      } = x2(FeelPopupContext);
      const closePopup = useStaticCallback(close);
      y2(() => {
        return () => {
          closePopup({
            id: id2
          });
        };
      }, []);
      return u2(Component, {
        ...props
      });
    };
  }
  var DEFAULT_LAYOUT = {};
  var DEFAULT_DESCRIPTION = {};
  var DEFAULT_TOOLTIP = {};
  function PropertiesPanel$1(props) {
    const {
      element,
      headerProvider,
      placeholderProvider,
      groups,
      layoutConfig,
      layoutChanged,
      descriptionConfig,
      descriptionLoaded,
      tooltipConfig: tooltipConfig2,
      tooltipLoaded,
      feelPopupContainer,
      getFeelPopupLinks,
      eventBus
    } = props;
    const [layout, setLayout] = d2(createLayout(layoutConfig));
    useUpdateLayoutEffect(() => {
      const newLayout = createLayout(layoutConfig);
      setLayout(newLayout);
    }, [layoutConfig]);
    y2(() => {
      if (typeof layoutChanged === "function") {
        layoutChanged(layout);
      }
    }, [layout, layoutChanged]);
    const getLayoutForKey = (key, defaultValue) => {
      return get(layout, key, defaultValue);
    };
    const setLayoutForKey = (key, config2) => {
      const newLayout = assign({}, layout);
      set(newLayout, key, config2);
      setLayout(newLayout);
    };
    const layoutContext = {
      layout,
      setLayout,
      getLayoutForKey,
      setLayoutForKey
    };
    const description2 = T2(() => createDescriptionContext(descriptionConfig), [descriptionConfig]);
    y2(() => {
      if (typeof descriptionLoaded === "function") {
        descriptionLoaded(description2);
      }
    }, [description2, descriptionLoaded]);
    const getDescriptionForId = (id2, element2) => {
      return description2[id2] && description2[id2](element2);
    };
    const descriptionContext = {
      description: description2,
      getDescriptionForId
    };
    const tooltip = T2(() => createTooltipContext(tooltipConfig2), [tooltipConfig2]);
    y2(() => {
      if (typeof tooltipLoaded === "function") {
        tooltipLoaded(tooltip);
      }
    }, [tooltip, tooltipLoaded]);
    const getTooltipForId = (id2, element2) => {
      return tooltip[id2] && tooltip[id2](element2);
    };
    const tooltipContext = {
      tooltip,
      getTooltipForId
    };
    const [errors, setErrors] = d2({});
    const onSetErrors = ({
      errors: errors2
    }) => setErrors(errors2);
    useEvent("propertiesPanel.setErrors", onSetErrors, eventBus);
    const errorsContext = {
      errors
    };
    const eventContext = {
      eventBus
    };
    const propertiesPanelContext = {
      element
    };
    if (placeholderProvider && !element) {
      return u2(Placeholder2, {
        ...placeholderProvider.getEmpty()
      });
    }
    if (placeholderProvider && isArray(element)) {
      return u2(Placeholder2, {
        ...placeholderProvider.getMultiple()
      });
    }
    return u2(LayoutContext.Provider, {
      value: propertiesPanelContext,
      children: u2(ErrorsContext.Provider, {
        value: errorsContext,
        children: u2(DescriptionContext.Provider, {
          value: descriptionContext,
          children: u2(TooltipContext.Provider, {
            value: tooltipContext,
            children: u2(LayoutContext.Provider, {
              value: layoutContext,
              children: u2(EventContext.Provider, {
                value: eventContext,
                children: u2(FEELPopupRoot, {
                  element,
                  eventBus,
                  popupContainer: feelPopupContainer,
                  getPopupLinks: getFeelPopupLinks,
                  children: u2("div", {
                    class: "bio-properties-panel",
                    children: [u2(Header, {
                      element,
                      headerProvider
                    }), u2("div", {
                      class: "bio-properties-panel-scroll-container",
                      children: groups.map((group) => {
                        const {
                          component: Component = Group2,
                          id: id2
                        } = group;
                        return _(Component, {
                          ...group,
                          key: id2,
                          element
                        });
                      })
                    })]
                  })
                })
              })
            })
          })
        })
      })
    });
  }
  function createLayout(overrides2 = {}, defaults3 = DEFAULT_LAYOUT) {
    return {
      ...defaults3,
      ...overrides2
    };
  }
  function createDescriptionContext(overrides2 = {}) {
    return {
      ...DEFAULT_DESCRIPTION,
      ...overrides2
    };
  }
  function createTooltipContext(overrides2 = {}) {
    return {
      ...DEFAULT_TOOLTIP,
      ...overrides2
    };
  }
  function useUpdateLayoutEffect(effect, deps) {
    const isMounted = A2(false);
    _2(() => {
      if (isMounted.current) {
        return effect();
      } else {
        isMounted.current = true;
      }
    }, deps);
  }
  function translateFallback(template, replacements) {
    replacements = replacements || {};
    return template.replace(/{([^}]+)}/g, function(_3, key) {
      return replacements[key] || "{" + key + "}";
    });
  }
  function CollapsibleEntry(props) {
    const {
      element,
      entries: entries2 = [],
      id: id2,
      label,
      open: shouldOpen,
      remove: remove2,
      translate = translateFallback
    } = props;
    const [open, setOpen] = d2(shouldOpen);
    const toggleOpen = () => setOpen(!open);
    const {
      onShow
    } = x2(LayoutContext);
    const propertiesPanelContext = {
      ...x2(LayoutContext),
      onShow: q2(() => {
        setOpen(true);
        if (isFunction(onShow)) {
          onShow();
        }
      }, [onShow, setOpen])
    };
    const placeholderLabel = translate("<empty>");
    return u2("div", {
      "data-entry-id": id2,
      class: (0, import_classnames2.default)("bio-properties-panel-collapsible-entry", open ? "open" : ""),
      children: [u2("div", {
        class: "bio-properties-panel-collapsible-entry-header",
        onClick: toggleOpen,
        children: [u2("div", {
          title: label || placeholderLabel,
          class: (0, import_classnames2.default)("bio-properties-panel-collapsible-entry-header-title", !label && "empty"),
          children: label || placeholderLabel
        }), u2("button", {
          type: "button",
          title: translate("Toggle list item"),
          class: "bio-properties-panel-arrow  bio-properties-panel-collapsible-entry-arrow",
          children: u2(ArrowIcon, {
            class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        }), remove2 ? u2("button", {
          type: "button",
          title: translate("Delete item"),
          class: "bio-properties-panel-remove-entry",
          onClick: remove2,
          children: u2(DeleteIcon, {})
        }) : null]
      }), u2("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-collapsible-entry-entries", open ? "open" : ""),
        children: u2(LayoutContext.Provider, {
          value: propertiesPanelContext,
          children: entries2.map((entry) => {
            const {
              component: Component,
              id: id3
            } = entry;
            return _(Component, {
              ...entry,
              element,
              key: id3
            });
          })
        })
      })]
    });
  }
  function ListItem(props) {
    const {
      autoFocusEntry,
      autoOpen,
      translate = translateFallback
    } = props;
    y2(() => {
      if (autoOpen && autoFocusEntry) {
        const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
        const focusableInput = query(".bio-properties-panel-input", entry);
        if (focusableInput) {
          if (isFunction(focusableInput.select)) {
            focusableInput.select();
          } else if (isFunction(focusableInput.focus)) {
            focusableInput.focus();
          }
          focusableInput.scrollIntoView();
        }
      }
    }, [autoOpen, autoFocusEntry]);
    return u2("div", {
      class: "bio-properties-panel-list-item",
      children: u2(CollapsibleEntry, {
        ...props,
        open: autoOpen,
        translate
      })
    });
  }
  var noop$12 = () => {
  };
  function ListGroup(props) {
    const {
      add: add2,
      element,
      id: id2,
      items,
      label,
      shouldOpen = false,
      translate = translateFallback
    } = props;
    y2(() => {
      if (props.shouldSort != void 0) {
        console.warn("the property 'shouldSort' is no longer supported");
      }
    }, [props.shouldSort]);
    const groupRef = A2(null);
    const [open, setOpen] = useLayoutState(["groups", id2, "open"], shouldOpen);
    const [sticky, setSticky] = d2(false);
    const onShow = q2(() => setOpen(true), [setOpen]);
    const [localItems, setLocalItems] = d2([]);
    const [addTriggered, setAddTriggered] = d2(false);
    const prevElement = usePrevious2(element);
    const toggleOpen = q2(() => setOpen(!open), [open]);
    const openItemIds = element === prevElement && open && addTriggered ? getNewItemIds(items, localItems) : [];
    y2(() => {
      setLocalItems(items);
      setAddTriggered(false);
    }, [items]);
    useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
    const hasItems = !!items.length;
    const propertiesPanelContext = {
      ...x2(LayoutContext),
      onShow
    };
    const handleAddClick = (e3) => {
      setAddTriggered(true);
      setOpen(true);
      add2(e3);
    };
    const allErrors = useErrors();
    const hasError = items.some((item) => {
      if (allErrors[item.id]) {
        return true;
      }
      if (!item.entries) {
        return;
      }
      return item.entries.some((entry) => allErrors[entry.id]);
    });
    return u2("div", {
      class: "bio-properties-panel-group",
      "data-group-id": "group-" + id2,
      ref: groupRef,
      children: [u2("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-header", hasItems ? "" : "empty", hasItems && open ? "open" : "", sticky && open ? "sticky" : ""),
        onClick: hasItems ? toggleOpen : noop$12,
        children: [u2("div", {
          title: props.tooltip ? null : label,
          "data-title": label,
          class: "bio-properties-panel-group-header-title",
          children: u2(TooltipWrapper, {
            value: props.tooltip,
            forId: "group-" + id2,
            element,
            parent: groupRef,
            children: label
          })
        }), u2("div", {
          class: "bio-properties-panel-group-header-buttons",
          children: [add2 ? u2("button", {
            type: "button",
            title: translate("Create new list item"),
            class: "bio-properties-panel-group-header-button bio-properties-panel-add-entry",
            onClick: handleAddClick,
            children: [u2(CreateIcon, {}), !hasItems ? u2("span", {
              class: "bio-properties-panel-add-entry-label",
              children: translate("Create")
            }) : null]
          }) : null, hasItems ? u2("div", {
            title: translate(`List contains {numOfItems} item${items.length != 1 ? "s" : ""}`, {
              numOfItems: items.length
            }),
            class: (0, import_classnames2.default)("bio-properties-panel-list-badge", hasError ? "bio-properties-panel-list-badge--error" : ""),
            children: items.length
          }) : null, hasItems ? u2("button", {
            type: "button",
            title: translate("Toggle section"),
            class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
            children: u2(ArrowIcon, {
              class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
            })
          }) : null]
        })]
      }), u2("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-list", open && hasItems ? "open" : ""),
        children: u2(LayoutContext.Provider, {
          value: propertiesPanelContext,
          children: items.map((item, index2) => {
            if (!item) {
              return;
            }
            const {
              id: id3
            } = item;
            const autoOpen = openItemIds.includes(item.id);
            return _(ListItem, {
              ...item,
              autoOpen,
              element,
              index: index2,
              key: id3,
              translate
            });
          })
        })
      })]
    });
  }
  function getNewItemIds(newItems, oldItems) {
    const newIds = newItems.map((item) => item.id);
    const oldIds = oldItems.map((item) => item.id);
    return newIds.filter((itemId) => !oldIds.includes(itemId));
  }
  function Checkbox2(props) {
    const {
      id: id2,
      label,
      onChange,
      disabled,
      value = false,
      onFocus,
      onBlur,
      tooltip
    } = props;
    const [localValue, setLocalValue] = d2(value);
    const handleChangeCallback = ({
      target
    }) => {
      onChange(target.checked);
    };
    const handleChange = (e3) => {
      handleChangeCallback(e3);
      setLocalValue(e3.target.value);
    };
    y2(() => {
      if (value === localValue) {
        return;
      }
      setLocalValue(value);
    }, [value]);
    const ref = useShowEntryEvent(id2);
    return u2("div", {
      class: "bio-properties-panel-checkbox",
      children: [u2("input", {
        ref,
        id: prefixId$4(id2),
        name: id2,
        onFocus,
        onBlur,
        type: "checkbox",
        class: "bio-properties-panel-input",
        onChange: handleChange,
        checked: localValue,
        disabled
      }), u2("label", {
        for: prefixId$4(id2),
        class: "bio-properties-panel-label",
        children: u2(TooltipWrapper, {
          value: tooltip,
          forId: id2,
          element: props.element,
          children: label
        })
      })]
    });
  }
  function CheckboxEntry(props) {
    const {
      element,
      id: id2,
      description: description2,
      label,
      getValue,
      setValue,
      disabled,
      onFocus,
      onBlur,
      tooltip
    } = props;
    const value = getValue(element);
    const error2 = useError(id2);
    return u2("div", {
      class: "bio-properties-panel-entry bio-properties-panel-checkbox-entry",
      "data-entry-id": id2,
      children: [u2(Checkbox2, {
        disabled,
        id: id2,
        label,
        onChange: setValue,
        onFocus,
        onBlur,
        value,
        tooltip,
        element
      }, element), error2 && u2("div", {
        class: "bio-properties-panel-error",
        children: error2
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function isEdited$5(node) {
    return node && !!node.checked;
  }
  function prefixId$4(id2) {
    return `bio-properties-panel-${id2}`;
  }
  function Select2(props) {
    const {
      id: id2,
      label,
      onChange,
      options: options2 = [],
      value = "",
      disabled,
      onFocus,
      onBlur,
      tooltip
    } = props;
    const ref = useShowEntryEvent(id2);
    const [localValue, setLocalValue] = d2(value);
    const handleChangeCallback = ({
      target
    }) => {
      onChange(target.value);
    };
    const handleChange = (e3) => {
      handleChangeCallback(e3);
      setLocalValue(e3.target.value);
    };
    y2(() => {
      if (value === localValue) {
        return;
      }
      setLocalValue(value);
    }, [value]);
    return u2("div", {
      class: "bio-properties-panel-select",
      children: [u2("label", {
        for: prefixId$3(id2),
        class: "bio-properties-panel-label",
        children: u2(TooltipWrapper, {
          value: tooltip,
          forId: id2,
          element: props.element,
          children: label
        })
      }), u2("select", {
        ref,
        id: prefixId$3(id2),
        name: id2,
        class: "bio-properties-panel-input",
        onInput: handleChange,
        onFocus,
        onBlur,
        value: localValue,
        disabled,
        children: options2.map((option, idx) => {
          if (option.children) {
            return u2("optgroup", {
              label: option.label,
              children: option.children.map((child, idx2) => u2("option", {
                value: child.value,
                disabled: child.disabled,
                children: child.label
              }, idx2))
            }, idx);
          }
          return u2("option", {
            value: option.value,
            disabled: option.disabled,
            children: option.label
          }, idx);
        })
      })]
    });
  }
  function SelectEntry(props) {
    const {
      element,
      id: id2,
      description: description2,
      label,
      getValue,
      setValue,
      getOptions,
      disabled,
      onFocus,
      onBlur,
      validate: validate2,
      tooltip
    } = props;
    const options2 = getOptions(element);
    const globalError = useError(id2);
    const [localError, setLocalError] = d2(null);
    let value = getValue(element);
    y2(() => {
      if (isFunction(validate2)) {
        const newValidationError = validate2(value) || null;
        setLocalError(newValidationError);
      }
    }, [value, validate2]);
    const onChange = (newValue) => {
      let newValidationError = null;
      if (isFunction(validate2)) {
        newValidationError = validate2(newValue) || null;
      }
      setValue(newValue, newValidationError);
      setLocalError(newValidationError);
    };
    const error2 = globalError || localError;
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
      "data-entry-id": id2,
      children: [u2(Select2, {
        id: id2,
        label,
        value,
        onChange,
        onFocus,
        onBlur,
        options: options2,
        disabled,
        tooltip,
        element
      }, element), error2 && u2("div", {
        class: "bio-properties-panel-error",
        children: error2
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function isEdited$3(node) {
    return node && !!node.value;
  }
  function prefixId$3(id2) {
    return `bio-properties-panel-${id2}`;
  }
  function resizeToContents(element) {
    element.style.height = "auto";
    element.style.height = `${element.scrollHeight + 2}px`;
  }
  function TextArea(props) {
    const {
      id: id2,
      label,
      debounce: debounce3,
      onInput,
      value = "",
      disabled,
      monospace,
      onFocus,
      onBlur,
      autoResize = true,
      placeholder: placeholder2,
      rows = autoResize ? 1 : 2,
      tooltip
    } = props;
    const [localValue, setLocalValue] = d2(value);
    const ref = useShowEntryEvent(id2);
    const visible = useElementVisible(ref.current);
    const handleInputCallback = T2(() => {
      return debounce3((target) => onInput(target.value.length ? target.value : void 0));
    }, [onInput, debounce3]);
    const handleInput = (e3) => {
      handleInputCallback(e3.target);
      autoResize && resizeToContents(e3.target);
      setLocalValue(e3.target.value);
    };
    const handleOnBlur = (e3) => {
      if (onBlur) {
        onBlur(e3);
      }
      setLocalValue(e3.target.value.trim());
    };
    _2(() => {
      autoResize && resizeToContents(ref.current);
    }, []);
    _2(() => {
      visible && autoResize && resizeToContents(ref.current);
    }, [visible]);
    y2(() => {
      if (value === localValue) {
        return;
      }
      setLocalValue(value);
    }, [value]);
    return u2("div", {
      class: "bio-properties-panel-textarea",
      children: [u2("label", {
        for: prefixId$1(id2),
        class: "bio-properties-panel-label",
        children: u2(TooltipWrapper, {
          value: tooltip,
          forId: id2,
          element: props.element,
          children: label
        })
      }), u2("textarea", {
        ref,
        id: prefixId$1(id2),
        name: id2,
        spellCheck: "false",
        class: (0, import_classnames2.default)("bio-properties-panel-input", monospace ? "bio-properties-panel-input-monospace" : "", autoResize ? "auto-resize" : ""),
        onInput: handleInput,
        onFocus,
        onBlur: handleOnBlur,
        placeholder: placeholder2,
        rows,
        value: localValue,
        disabled,
        "data-gramm": "false"
      })]
    });
  }
  function TextAreaEntry(props) {
    const {
      element,
      id: id2,
      description: description2,
      debounce: debounce3,
      label,
      getValue,
      setValue,
      rows,
      monospace,
      disabled,
      validate: validate2,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      autoResize,
      tooltip
    } = props;
    const globalError = useError(id2);
    const [localError, setLocalError] = d2(null);
    let value = getValue(element);
    y2(() => {
      if (isFunction(validate2)) {
        const newValidationError = validate2(value) || null;
        setLocalError(newValidationError);
      }
    }, [value, validate2]);
    const onInput = (newValue) => {
      let newValidationError = null;
      if (isFunction(validate2)) {
        newValidationError = validate2(newValue) || null;
      }
      setValue(newValue, newValidationError);
      setLocalError(newValidationError);
    };
    const error2 = globalError || localError;
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
      "data-entry-id": id2,
      children: [u2(TextArea, {
        id: id2,
        label,
        value,
        onInput,
        onFocus,
        onBlur,
        rows,
        debounce: debounce3,
        monospace,
        disabled,
        placeholder: placeholder2,
        autoResize,
        tooltip,
        element
      }, element), error2 && u2("div", {
        class: "bio-properties-panel-error",
        children: error2
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function isEdited$1(node) {
    return node && !!node.value;
  }
  function prefixId$1(id2) {
    return `bio-properties-panel-${id2}`;
  }
  function Textfield2(props) {
    const {
      debounce: debounce3,
      disabled = false,
      id: id2,
      label,
      onInput,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      value = "",
      tooltip
    } = props;
    const [localValue, setLocalValue] = d2(value || "");
    const ref = useShowEntryEvent(id2);
    const handleInputCallback = T2(() => {
      return debounce3((target) => onInput(target.value.length ? target.value : void 0));
    }, [onInput, debounce3]);
    const handleOnBlur = (e3) => {
      if (onBlur) {
        onBlur(e3);
      }
      setLocalValue(e3.target.value.trim());
    };
    const handleInput = (e3) => {
      handleInputCallback(e3.target);
      setLocalValue(e3.target.value);
    };
    y2(() => {
      if (value === localValue) {
        return;
      }
      setLocalValue(value);
    }, [value]);
    return u2("div", {
      class: "bio-properties-panel-textfield",
      children: [u2("label", {
        for: prefixId2(id2),
        class: "bio-properties-panel-label",
        children: u2(TooltipWrapper, {
          value: tooltip,
          forId: id2,
          element: props.element,
          children: label
        })
      }), u2("input", {
        ref,
        id: prefixId2(id2),
        type: "text",
        name: id2,
        spellCheck: "false",
        autoComplete: "off",
        disabled,
        class: "bio-properties-panel-input",
        onInput: handleInput,
        onFocus,
        onBlur: handleOnBlur,
        placeholder: placeholder2,
        value: localValue
      })]
    });
  }
  function TextfieldEntry(props) {
    const {
      element,
      id: id2,
      description: description2,
      debounce: debounce3,
      disabled,
      label,
      getValue,
      setValue,
      validate: validate2,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      tooltip
    } = props;
    const globalError = useError(id2);
    const [localError, setLocalError] = d2(null);
    let value = getValue(element);
    y2(() => {
      if (isFunction(validate2)) {
        const newValidationError = validate2(value) || null;
        setLocalError(newValidationError);
      }
    }, [value, validate2]);
    const onInput = (newValue) => {
      let newValidationError = null;
      if (isFunction(validate2)) {
        newValidationError = validate2(newValue) || null;
      }
      setValue(newValue, newValidationError);
      setLocalError(newValidationError);
    };
    const error2 = globalError || localError;
    return u2("div", {
      class: (0, import_classnames2.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
      "data-entry-id": id2,
      children: [u2(Textfield2, {
        debounce: debounce3,
        disabled,
        id: id2,
        label,
        onInput,
        onFocus,
        onBlur,
        placeholder: placeholder2,
        value,
        tooltip,
        element
      }, element), error2 && u2("div", {
        class: "bio-properties-panel-error",
        children: error2
      }), u2(Description$1, {
        forId: id2,
        element,
        value: description2
      })]
    });
  }
  function isEdited(node) {
    return node && !!node.value;
  }
  function prefixId2(id2) {
    return `bio-properties-panel-${id2}`;
  }
  var FeelPopupModule = class {
    constructor(eventBus) {
      this._eventBus = eventBus;
    }
    /**
     * Check if the FEEL popup is open.
     * @return {Boolean}
     */
    isOpen() {
      return this._eventBus.fire("feelPopup._isOpen");
    }
    /**
     * Open the FEEL popup.
     *
     * @param {String} entryId
     * @param {Object} popupConfig
     * @param {HTMLElement} sourceElement
     */
    open(entryId, popupConfig, sourceElement) {
      return this._eventBus.fire("feelPopup._open", {
        entryId,
        popupConfig,
        sourceElement
      });
    }
    /**
     * Close the FEEL popup.
     */
    close() {
      return this._eventBus.fire("feelPopup._close");
    }
  };
  FeelPopupModule.$inject = ["eventBus"];
  var index = {
    feelPopup: ["type", FeelPopupModule]
  };
  function getService2(type3, strict) {
  }
  var FormPropertiesPanelContext = K({
    getService: getService2
  });
  function getPropertiesPanelHeaderProvider(options2 = {}) {
    const {
      getDocumentationRef,
      formFields: formFields2
    } = options2;
    return {
      getElementLabel: (field) => {
        const {
          type: type3
        } = field;
        const fieldDefinition = formFields2.get(type3).config;
        return fieldDefinition.getSubheading ? fieldDefinition.getSubheading(field) : field.label;
      },
      getElementIcon: (field) => {
        const {
          type: type3
        } = field;
        const fieldDefinition = formFields2.get(type3).config;
        const Icon = fieldDefinition.icon || iconsByType(type3);
        if (Icon) {
          return function IconComponent() {
            return u2(Icon, {
              width: "36",
              height: "36",
              viewBox: "0 0 54 54"
            });
          };
        } else if (fieldDefinition.iconUrl) {
          return getPaletteIcon({
            iconUrl: fieldDefinition.iconUrl,
            label: fieldDefinition.label
          });
        }
      },
      getTypeLabel: (field) => {
        const {
          type: type3
        } = field;
        if (type3 === "default") {
          return "Form";
        }
        const fieldDefinition = formFields2.get(type3).config;
        return fieldDefinition.name || fieldDefinition.label || type3;
      },
      getDocumentationRef
    };
  }
  var PropertiesPanelPlaceholderProvider = {
    getEmpty: () => {
      return {
        text: "Select a form field to edit its properties."
      };
    },
    getMultiple: () => {
      return {
        text: "Multiple form fields are selected. Select a single form field to edit its properties."
      };
    }
  };
  var EMPTY = {};
  function PropertiesPanel(props) {
    const {
      eventBus,
      getProviders,
      injector
    } = props;
    const formEditor = injector.get("formEditor");
    const modeling = injector.get("modeling");
    const selectionModule = injector.get("selection");
    const propertiesPanelConfig = injector.get("config.propertiesPanel") || EMPTY;
    const {
      feelPopupContainer
    } = propertiesPanelConfig;
    const [state, setState] = d2({
      selectedFormField: selectionModule.get() || formEditor._getState().schema
    });
    const selectedFormField = state.selectedFormField;
    const refresh = q2((field) => {
      setState({
        selectedFormField: selectionModule.get() || formEditor._getState().schema
      });
      eventBus.fire("propertiesPanel.updated", {
        formField: field
      });
    }, [eventBus, formEditor, selectionModule]);
    _2(() => {
      eventBus.on("changed", refresh);
      eventBus.on("import.done", refresh);
      eventBus.on("selection.changed", refresh);
      return () => {
        eventBus.off("changed", refresh);
        eventBus.off("import.done", refresh);
        eventBus.off("selection.changed", refresh);
      };
    }, [eventBus, refresh]);
    const getService3 = (type3, strict = true) => injector.get(type3, strict);
    const propertiesPanelContext = {
      getService: getService3
    };
    const onFocus = () => eventBus.fire("propertiesPanel.focusin");
    const onBlur = () => eventBus.fire("propertiesPanel.focusout");
    const editField = q2((formField, key, value) => modeling.editFormField(formField, key, value), [modeling]);
    const providers = getProviders(selectedFormField);
    const groups = T2(() => {
      return reduce(providers, function(groups2, provider) {
        if (isArray(selectedFormField)) {
          return [];
        }
        const updater = provider.getGroups(selectedFormField, editField);
        return updater(groups2);
      }, []);
    }, [providers, selectedFormField, editField]);
    const formFields2 = getService3("formFields");
    const PropertiesPanelHeaderProvider = T2(() => getPropertiesPanelHeaderProvider({
      getDocumentationRef: propertiesPanelConfig.getDocumentationRef,
      formFields: formFields2
    }), [formFields2, propertiesPanelConfig]);
    return u2("div", {
      class: "fjs-properties-panel",
      "data-field": selectedFormField && selectedFormField.id,
      onFocusCapture: onFocus,
      onBlurCapture: onBlur,
      children: u2(FormPropertiesPanelContext.Provider, {
        value: propertiesPanelContext,
        children: u2(PropertiesPanel$1, {
          element: selectedFormField,
          eventBus,
          groups,
          headerProvider: PropertiesPanelHeaderProvider,
          placeholderProvider: PropertiesPanelPlaceholderProvider,
          feelPopupContainer
        })
      })
    });
  }
  var DEFAULT_PRIORITY2 = 1e3;
  var PropertiesPanelRenderer = class {
    constructor(propertiesPanelConfig, injector, eventBus) {
      const {
        parent
      } = propertiesPanelConfig || {};
      this._eventBus = eventBus;
      this._injector = injector;
      this._container = domify$1('<div class="fjs-properties-container" input-handle-modified-keys="y,z"></div>');
      if (parent) {
        this.attachTo(parent);
      }
      this._eventBus.once("formEditor.rendered", 500, () => {
        this._render();
      });
    }
    /**
     * Attach the properties panel to a parent node.
     *
     * @param {HTMLElement} container
     */
    attachTo(container) {
      if (!container) {
        throw new Error("container required");
      }
      if (typeof container === "string") {
        container = query(container);
      }
      this.detach();
      container.appendChild(this._container);
      this._eventBus.fire("propertiesPanel.attach");
    }
    /**
     * Detach the properties panel from its parent node.
     */
    detach() {
      const parentNode = this._container.parentNode;
      if (parentNode) {
        parentNode.removeChild(this._container);
        this._eventBus.fire("propertiesPanel.detach");
      }
    }
    _render() {
      E(u2(PropertiesPanel, {
        getProviders: this._getProviders.bind(this),
        eventBus: this._eventBus,
        injector: this._injector
      }), this._container);
      this._eventBus.fire("propertiesPanel.rendered");
    }
    _destroy() {
      if (this._container) {
        E(null, this._container);
        this._eventBus.fire("propertiesPanel.destroyed");
      }
    }
    /**
     * Register a new properties provider to the properties panel.
     *
     * @param {PropertiesProvider} provider
     * @param {Number} [priority]
     */
    registerProvider(provider, priority) {
      if (!priority) {
        priority = DEFAULT_PRIORITY2;
      }
      if (typeof provider.getGroups !== "function") {
        console.error("Properties provider does not implement #getGroups(element) API");
        return;
      }
      this._eventBus.on("propertiesPanel.getProviders", priority, function(event2) {
        event2.providers.push(provider);
      });
      this._eventBus.fire("propertiesPanel.providersChanged");
    }
    _getProviders() {
      const event2 = this._eventBus.createEvent({
        type: "propertiesPanel.getProviders",
        providers: []
      });
      this._eventBus.fire(event2);
      return event2.providers;
    }
  };
  PropertiesPanelRenderer.$inject = ["config.propertiesPanel", "injector", "eventBus"];
  function ActionEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "action",
      component: Action,
      editField,
      field,
      isEdited: isEdited$3,
      isDefaultVisible: (field2) => field2.type === "button"
    });
    return entries2;
  }
  function Action(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const path2 = ["action"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    const getOptions = () => [{
      label: "Submit",
      value: "submit"
    }, {
      label: "Reset",
      value: "reset"
    }];
    return SelectEntry({
      element: field,
      getOptions,
      getValue,
      id: id2,
      label: "Action",
      setValue
    });
  }
  function useService2(type3, strict) {
    const {
      getService: getService3
    } = x2(FormPropertiesPanelContext);
    return getService3(type3, strict);
  }
  function useVariables() {
    const form = useService2("formEditor");
    const schema = form.getSchema();
    return getSchemaVariables(schema);
  }
  function AltTextEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "alt",
      component: AltText,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => ["image"].includes(field2.type)
    });
    return entries2;
  }
  function AltText(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["alt"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue,
      id: id2,
      label: "Alternative text",
      tooltip: "Descriptive text for screen reader accessibility.",
      setValue,
      singleLine: true,
      variables
    });
  }
  var AUTO_OPTION_VALUE = "";
  function ColumnsEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [{
      id: "columns",
      component: Columns,
      field,
      editField,
      isEdited: isEdited$3
    }];
    return entries2;
  }
  function Columns(props) {
    const {
      field,
      editField,
      id: id2
    } = props;
    useService2("debounce");
    const formLayoutValidator = useService2("formLayoutValidator");
    const validate2 = q2((value) => {
      return formLayoutValidator.validateField(field, value ? parseInt(value) : null);
    }, [field, formLayoutValidator]);
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      const layout = get(field, ["layout"], {});
      const newValue = value ? parseInt(value) : null;
      editField(field, ["layout"], set(layout, ["columns"], newValue));
    };
    const getValue = () => {
      return get(field, ["layout", "columns"]);
    };
    const getOptions = () => {
      return [
        {
          label: "Auto",
          value: AUTO_OPTION_VALUE
        },
        // todo(pinussilvestrus): make options dependant on field type
        // cf. https://github.com/bpmn-io/form-js/issues/575
        ...asArray3(16).filter((i4) => i4 >= MIN_COLUMNS).map(asOption)
      ];
    };
    return SelectEntry({
      element: field,
      id: id2,
      label: "Columns",
      getOptions,
      getValue,
      setValue,
      validate: validate2
    });
  }
  function asOption(number2) {
    return {
      value: number2,
      label: number2.toString()
    };
  }
  function asArray3(length) {
    return Array.from({
      length
    }).map((_3, i4) => i4 + 1);
  }
  function arrayAdd(array, index2, item) {
    const copy = [...array];
    copy.splice(index2, 0, item);
    return copy;
  }
  function countDecimals2(number2) {
    const num = big_default(number2);
    if (num.toString() === num.toFixed(0)) return 0;
    return num.toFixed().split(".")[1].length || 0;
  }
  function isValidNumber2(value) {
    return (typeof value === "number" || typeof value === "string") && value !== "" && !isNaN(Number(value));
  }
  function isValidDotPath(path2) {
    return /^\w+(\.\w+)*$/.test(path2);
  }
  function isProhibitedPath(path2) {
    const prohibitedSegments = ["__proto__", "prototype", "constructor"];
    return path2.split(".").some((segment) => prohibitedSegments.includes(segment));
  }
  var LABELED_NON_INPUTS = ["button", "group", "dynamiclist", "iframe", "table", "documentPreview"];
  var INPUTS = ["checkbox", "checklist", "datetime", "number", "radio", "select", "taglist", "textfield", "textarea", "filepicker"];
  var OPTIONS_INPUTS = ["checklist", "radio", "select", "taglist"];
  function hasEntryConfigured(formFieldDefinition, entryId) {
    const {
      propertiesPanelEntries = []
    } = formFieldDefinition;
    if (!propertiesPanelEntries.length) {
      return false;
    }
    return propertiesPanelEntries.some((id2) => id2 === entryId);
  }
  function hasOptionsGroupsConfigured(formFieldDefinition) {
    const {
      propertiesPanelEntries = []
    } = formFieldDefinition;
    if (!propertiesPanelEntries.length) {
      return false;
    }
    return propertiesPanelEntries.some((id2) => id2 === "values");
  }
  function hasIntegerPathSegment(path2) {
    return path2.split(".").some((segment) => /^\d+$/.test(segment));
  }
  function DescriptionEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "description",
      component: Description2,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type !== "filepicker" && INPUTS.includes(field2.type)
    });
    return entries2;
  }
  function Description2(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["description"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Field description",
      singleLine: true,
      setValue,
      variables
    });
  }
  var EMPTY_OPTION = "";
  function DefaultValueEntry(props) {
    const {
      editField,
      field
    } = props;
    const {
      type: type3
    } = field;
    const entries2 = [];
    function isDefaultVisible(matchers) {
      return (field2) => {
        if (!INPUTS.includes(type3) || OPTIONS_INPUTS.includes(type3) && !field2.values) {
          return false;
        }
        return matchers(field2);
      };
    }
    const defaultValueBase = {
      editField,
      field,
      id: "defaultValue",
      label: "Default value"
    };
    entries2.push({
      ...defaultValueBase,
      component: DefaultValueCheckbox,
      isEdited: isEdited$3,
      isDefaultVisible: isDefaultVisible((field2) => field2.type === "checkbox")
    });
    entries2.push({
      ...defaultValueBase,
      component: DefaultValueNumber,
      isEdited,
      isDefaultVisible: isDefaultVisible((field2) => field2.type === "number")
    });
    entries2.push({
      ...defaultValueBase,
      component: DefaultValueSingleSelect,
      isEdited: isEdited$3,
      isDefaultVisible: isDefaultVisible((field2) => field2.type === "radio" || field2.type === "select")
    });
    entries2.push({
      ...defaultValueBase,
      component: DefaultValueTextfield,
      isEdited,
      isDefaultVisible: isDefaultVisible((field2) => field2.type === "textfield")
    });
    entries2.push({
      ...defaultValueBase,
      component: DefaultValueTextarea,
      isEdited: isEdited$1,
      isDefaultVisible: isDefaultVisible((field2) => field2.type === "textarea")
    });
    return entries2;
  }
  function DefaultValueCheckbox(props) {
    const {
      editField,
      field,
      id: id2,
      label
    } = props;
    const {
      defaultValue
    } = field;
    const path2 = ["defaultValue"];
    const getOptions = () => {
      return [{
        label: "Checked",
        value: "true"
      }, {
        label: "Not checked",
        value: "false"
      }];
    };
    const setValue = (value) => {
      return editField(field, path2, parseStringToBoolean(value));
    };
    const getValue = () => {
      return parseBooleanToString(defaultValue);
    };
    return SelectEntry({
      element: field,
      getOptions,
      getValue,
      id: id2,
      label,
      setValue
    });
  }
  function DefaultValueNumber(props) {
    const {
      editField,
      field,
      id: id2,
      label
    } = props;
    const {
      decimalDigits,
      serializeToString = false
    } = field;
    const debounce3 = useService2("debounce");
    const path2 = ["defaultValue"];
    const getValue = (e3) => {
      let value = get(field, path2);
      if (!isValidNumber2(value)) return;
      return serializeToString ? big_default(value).toFixed() : value;
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      let newValue;
      if (isValidNumber2(value)) {
        newValue = serializeToString ? value : Number(value);
      }
      return editField(field, path2, newValue);
    };
    const decimalDigitsSet = decimalDigits || decimalDigits === 0;
    const validate2 = q2((value) => {
      if (value === void 0 || value === null) {
        return;
      }
      if (!isValidNumber2(value)) {
        return "Should be a valid number";
      }
      if (decimalDigitsSet && countDecimals2(value) > decimalDigits) {
        return `Should not contain more than ${decimalDigits} decimal digits`;
      }
    }, [decimalDigitsSet, decimalDigits]);
    return TextfieldEntry({
      debounce: debounce3,
      label,
      element: field,
      getValue,
      id: id2,
      setValue,
      validate: validate2
    });
  }
  function DefaultValueSingleSelect(props) {
    const {
      editField,
      field,
      id: id2,
      label
    } = props;
    const {
      defaultValue = EMPTY_OPTION,
      values: values2 = []
    } = field;
    const path2 = ["defaultValue"];
    const getOptions = () => {
      return [{
        label: "<none>",
        value: EMPTY_OPTION
      }, ...values2];
    };
    const setValue = (value) => {
      return editField(field, path2, value.length ? value : void 0);
    };
    const getValue = () => {
      return defaultValue;
    };
    return SelectEntry({
      element: field,
      getOptions,
      getValue,
      id: id2,
      label,
      setValue
    });
  }
  function DefaultValueTextfield(props) {
    const {
      editField,
      field,
      id: id2,
      label
    } = props;
    const debounce3 = useService2("debounce");
    const path2 = ["defaultValue"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label,
      setValue
    });
  }
  function DefaultValueTextarea(props) {
    const {
      editField,
      field,
      id: id2,
      label
    } = props;
    const debounce3 = useService2("debounce");
    const path2 = ["defaultValue"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return TextAreaEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label,
      setValue
    });
  }
  function parseStringToBoolean(value) {
    if (value === "true") {
      return true;
    }
    return false;
  }
  function parseBooleanToString(value) {
    if (value === true) {
      return "true";
    }
    return "false";
  }
  function DisabledEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "disabled",
      component: Disabled,
      editField,
      field,
      isEdited: isEdited$8,
      isDefaultVisible: (field2) => INPUTS.includes(field2.type)
    });
    return entries2;
  }
  function Disabled(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const path2 = ["disabled"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return ToggleSwitchEntry({
      element: field,
      getValue,
      id: id2,
      label: "Disabled",
      tooltip: "Field cannot be edited by the end-user, and the data is not submitted. Takes precedence over read only.",
      inline: true,
      setValue
    });
  }
  function IdEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "id",
      component: Id,
      editField,
      field,
      isEdited,
      isDefaultVisible: (field2) => field2.type === "default"
    });
    return entries2;
  }
  function Id(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const formFieldRegistry = useService2("formFieldRegistry");
    const debounce3 = useService2("debounce");
    const path2 = ["id"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      return editField(field, path2, value);
    };
    const validate2 = q2((value) => {
      if (typeof value !== "string" || value.length === 0) {
        return "Must not be empty.";
      }
      const assigned = formFieldRegistry._ids.assigned(value);
      if (assigned && assigned !== field) {
        return "Must be unique.";
      }
      return validateId(value) || null;
    }, [formFieldRegistry, field]);
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "ID",
      setValue,
      validate: validate2
    });
  }
  var SPACE_REGEX = /\s/;
  var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;
  var ID_REGEX = /^[a-z_][\w-.]*$/i;
  function validateId(idValue) {
    if (containsSpace(idValue)) {
      return "Must not contain spaces.";
    }
    if (!ID_REGEX.test(idValue)) {
      if (QNAME_REGEX.test(idValue)) {
        return "Must not contain prefix.";
      }
      return "Must be a valid QName.";
    }
  }
  function containsSpace(value) {
    return SPACE_REGEX.test(value);
  }
  function KeyEntry(props) {
    const {
      editField,
      field,
      getService: getService3
    } = props;
    const entries2 = [];
    entries2.push({
      id: "key",
      component: Key$2,
      editField,
      field,
      isEdited,
      isDefaultVisible: (field2) => {
        const formFields2 = getService3("formFields");
        const {
          config: config2
        } = formFields2.get(field2.type);
        return config2.keyed;
      }
    });
    return entries2;
  }
  function Key$2(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const pathRegistry = useService2("pathRegistry");
    const debounce3 = useService2("debounce");
    const path2 = ["key"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      return editField(field, path2, value);
    };
    const validate2 = q2((value) => {
      if (value === field.key) {
        return null;
      }
      if (!isString(value) || value.length === 0) {
        return "Must not be empty.";
      }
      if (!isValidDotPath(value)) {
        return "Must be a variable or a dot separated path.";
      }
      if (hasIntegerPathSegment(value)) {
        return "Must not contain numerical path segments.";
      }
      if (isProhibitedPath(value)) {
        return "Must not be a prohibited path.";
      }
      const replacements = {
        [field.id]: value.split(".")
      };
      const oldPath = pathRegistry.getValuePath(field);
      const newPath = pathRegistry.getValuePath(field, {
        replacements
      });
      pathRegistry.unclaimPath(oldPath);
      const canClaim = pathRegistry.canClaimPath(newPath, {
        isClosed: true,
        claimerId: field.id
      });
      pathRegistry.claimPath(oldPath, {
        isClosed: true,
        claimerId: field.id
      });
      return canClaim ? null : "Must not conflict with other key/path assignments.";
    }, [field, pathRegistry]);
    return TextfieldEntry({
      debounce: debounce3,
      description: "Binds to a form variable",
      element: field,
      getValue,
      id: id2,
      label: "Key",
      tooltip: `Use a unique "key" to link the form element and the related input/output data. When dealing with nested data, break it down in the user task's input mapping before using it.`,
      setValue,
      validate: validate2
    });
  }
  function PathEntry(props) {
    const {
      editField,
      field,
      getService: getService3
    } = props;
    const {
      type: type3
    } = field;
    const entries2 = [];
    const formFieldDefinition = getService3("formFields").get(type3);
    if (formFieldDefinition && formFieldDefinition.config.pathed) {
      entries2.push({
        id: "path",
        component: Path,
        editField,
        field,
        isEdited
      });
    }
    return entries2;
  }
  function Path(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const pathRegistry = useService2("pathRegistry");
    const fieldConfig = useService2("formFields").get(field.type).config;
    const isRepeating = fieldConfig.repeatable && field.isRepeating;
    const path2 = ["path"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      return editField(field, path2, value);
    };
    const validate2 = q2((value) => {
      if (!value && isRepeating) {
        return "Must not be empty";
      }
      if (!value && !isRepeating || value === field.path) {
        return null;
      }
      if (!isValidDotPath(value)) {
        const msg = isRepeating ? "Must be a variable or a dot-separated path" : "Must be empty, a variable or a dot-separated path";
        return msg;
      }
      if (hasIntegerPathSegment(value)) {
        return "Must not contain numerical path segments.";
      }
      if (isProhibitedPath(value)) {
        return "Must not be a prohibited path.";
      }
      const options2 = {
        replacements: {
          [field.id]: value.split(".")
        }
      };
      const canClaim = pathRegistry.executeRecursivelyOnFields(field, ({
        field: field2,
        isClosed,
        isRepeatable
      }) => {
        const path3 = pathRegistry.getValuePath(field2, options2);
        return pathRegistry.canClaimPath(path3, {
          isClosed,
          isRepeatable,
          claimerId: field2.id
        });
      });
      if (!canClaim) {
        return "Must not cause two binding paths to collide";
      }
      return null;
    }, [field, isRepeating, pathRegistry]);
    const tooltip = isRepeating ? "Routes the children of this component into a form variable, may be left empty to route at the root level." : "Routes the children of this component into a form variable.";
    return TextfieldEntry({
      debounce: debounce3,
      description: "Where the child variables of this component are pathed to.",
      element: field,
      getValue,
      id: id2,
      label: "Path",
      tooltip,
      setValue,
      validate: validate2
    });
  }
  function simpleBoolEntryFactory(options2) {
    const {
      id: id2,
      label,
      description: description2,
      path: path2,
      props,
      getValue,
      setValue,
      isDefaultVisible
    } = options2;
    const {
      editField,
      field
    } = props;
    return {
      id: id2,
      label,
      path: path2,
      field,
      editField,
      description: description2,
      component: SimpleBoolComponent,
      isEdited: isEdited$8,
      isDefaultVisible,
      getValue,
      setValue
    };
  }
  var SimpleBoolComponent = (props) => {
    const {
      id: id2,
      label,
      path: path2,
      field,
      editField,
      getValue = () => get(field, path2, ""),
      setValue = (value) => editField(field, path2, value || false),
      description: description2
    } = props;
    return ToggleSwitchEntry({
      element: field,
      getValue,
      id: id2,
      label,
      setValue,
      inline: true,
      description: description2
    });
  };
  function simpleSelectEntryFactory(options2) {
    const {
      id: id2,
      label,
      path: path2,
      props,
      optionsArray
    } = options2;
    const {
      editField,
      field
    } = props;
    return {
      id: id2,
      label,
      path: path2,
      field,
      editField,
      optionsArray,
      component: SimpleSelectComponent,
      isEdited: isEdited$3
    };
  }
  var SimpleSelectComponent = (props) => {
    const {
      id: id2,
      label,
      path: path2,
      field,
      editField,
      optionsArray
    } = props;
    const getValue = () => get(field, path2, "");
    const setValue = (value) => editField(field, path2, value);
    const getOptions = () => optionsArray;
    return SelectEntry({
      label,
      element: field,
      getOptions,
      getValue,
      id: id2,
      setValue
    });
  };
  function simpleRangeIntegerEntryFactory(options2) {
    const {
      id: id2,
      label,
      path: path2,
      props,
      min,
      max
    } = options2;
    const {
      editField,
      field
    } = props;
    return {
      id: id2,
      label,
      path: path2,
      field,
      editField,
      min,
      max,
      component: SimpleRangeIntegerEntry,
      isEdited
    };
  }
  var SimpleRangeIntegerEntry = (props) => {
    const {
      id: id2,
      label,
      path: path2,
      field,
      editField,
      min = Number.MIN_SAFE_INTEGER,
      max = Number.MAX_SAFE_INTEGER
    } = props;
    const debounce3 = useService2("debounce");
    const getValue = () => {
      const value = get(field, path2);
      const isValid = isValidNumber2(value) && Number.isInteger(value);
      return isValid ? value : null;
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, path2, Number(value));
    };
    const validate2 = q2((value) => {
      if (value === void 0 || value === null || value === "") {
        return;
      }
      if (!Number.isInteger(Number(value))) {
        return "Should be an integer.";
      }
      if (big_default(value).cmp(min) < 0) {
        return `Should be at least ${min}.`;
      }
      if (big_default(value).cmp(max) > 0) {
        return `Should be at most ${max}.`;
      }
    }, [min, max]);
    return TextfieldEntry({
      debounce: debounce3,
      label,
      element: field,
      getValue,
      id: id2,
      setValue,
      validate: validate2
    });
  };
  function GroupAppearanceEntry(props) {
    const {
      field
    } = props;
    const {
      type: type3
    } = field;
    if (!["group", "dynamiclist"].includes(type3)) {
      return [];
    }
    const entries2 = [simpleBoolEntryFactory({
      id: "showOutline",
      path: ["showOutline"],
      label: "Show outline",
      props
    })];
    return entries2;
  }
  function LabelEntry(props) {
    const {
      field,
      editField
    } = props;
    const entries2 = [];
    entries2.push({
      id: "date-label",
      component: DateLabel,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: function(field2) {
        return field2.type === "datetime" && (field2.subtype === DATETIME_SUBTYPES.DATE || field2.subtype === DATETIME_SUBTYPES.DATETIME);
      }
    });
    entries2.push({
      id: "time-label",
      component: TimeLabel,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: function(field2) {
        return field2.type === "datetime" && (field2.subtype === DATETIME_SUBTYPES.TIME || field2.subtype === DATETIME_SUBTYPES.DATETIME);
      }
    });
    const isSimplyLabeled = (field2) => {
      return [...INPUTS.filter((input) => input !== "datetime"), ...LABELED_NON_INPUTS].includes(field2.type);
    };
    entries2.push({
      id: "label",
      component: Label$2,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: isSimplyLabeled
    });
    return entries2;
  }
  function Label$2(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["label"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value || "");
    };
    const label = getLabelText(field.type);
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label,
      singleLine: true,
      setValue,
      variables
    });
  }
  function DateLabel(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = DATE_LABEL_PATH;
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value || "");
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Date label",
      singleLine: true,
      setValue,
      variables
    });
  }
  function TimeLabel(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = TIME_LABEL_PATH;
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value || "");
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Time label",
      singleLine: true,
      setValue,
      variables
    });
  }
  function getLabelText(type3) {
    switch (type3) {
      case "group":
      case "dynamiclist":
        return "Group label";
      case "table":
        return "Table label";
      case "iframe":
      case "documentPreview":
        return "Title";
      default:
        return "Field label";
    }
  }
  function HeightEntry(props) {
    const {
      editField,
      field,
      id: id2,
      description: description2,
      isDefaultVisible,
      defaultValue
    } = props;
    const entries2 = [];
    entries2.push({
      id: id2 + "-height",
      component: Height,
      description: description2,
      isEdited: isEdited$7,
      editField,
      field,
      defaultValue,
      isDefaultVisible: (field2) => {
        if (isFunction(isDefaultVisible)) {
          return isDefaultVisible(field2);
        }
        return field2.type === "spacer";
      }
    });
    return entries2;
  }
  function Height(props) {
    const {
      description: description2,
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const getValue = (e3) => get(field, ["height"], null);
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, ["height"], value);
    };
    return NumberFieldEntry({
      debounce: debounce3,
      description: description2,
      label: "Height",
      element: field,
      id: id2,
      getValue,
      setValue,
      validate: validate$9
    });
  }
  var validate$9 = (value) => {
    if (typeof value !== "number") {
      return "A number is required.";
    }
    if (!Number.isInteger(value)) {
      return "Should be an integer.";
    }
    if (value < 1) {
      return "Should be greater than zero.";
    }
  };
  function IFrameHeightEntry(props) {
    return [...HeightEntry({
      ...props,
      description: "Height of the container in pixels.",
      isDefaultVisible: (field) => field.type === "iframe"
    })];
  }
  var HTTPS_PATTERN = /^(https):\/\/*/i;
  function IFrameUrlEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "url",
      component: Url,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "iframe"
    });
    return entries2;
  }
  function Url(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["url"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue,
      id: id2,
      label: "URL",
      setValue,
      singleLine: true,
      tooltip: getTooltip$1(),
      validate: validate$8,
      variables
    });
  }
  function getTooltip$1() {
    return u2(k, {
      children: [u2("p", {
        children: "Enter a HTTPS URL to a source or populate it dynamically via a template or an expression (e.g., to pass a value from the variable)."
      }), u2("p", {
        children: "Please make sure that the URL is safe as it might impose security risks."
      }), u2("p", {
        children: ["Not all external sources can be displayed in the iFrame. Read more about it in the", " ", u2("a", {
          target: "_blank",
          href: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options",
          rel: "noreferrer",
          children: "X-FRAME-OPTIONS documentation"
        }), "."]
      })]
    });
  }
  var validate$8 = (value) => {
    if (!value || value.startsWith("=")) {
      return;
    }
    if (!HTTPS_PATTERN.test(value)) {
      return 'For security reasons the URL must start with "https".';
    }
  };
  function ImageSourceEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "source",
      component: Source$1,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "image"
    });
    return entries2;
  }
  function Source$1(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["source"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      description: "Expression or static value (link/data URI)",
      element: field,
      feel: "optional",
      getValue,
      id: id2,
      label: "Image source",
      tooltip: "Link referring to a hosted image, or use a data URI directly to embed image data into the form.",
      setValue,
      singleLine: true,
      variables
    });
  }
  function TextEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [{
      id: "text",
      component: Text3,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "text"
    }];
    return entries2;
  }
  function Text3(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["text"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value || "");
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      description: description$3,
      element: field,
      getValue,
      id: id2,
      label: "Text",
      hostLanguage: "markdown",
      setValue,
      variables
    });
  }
  var description$3 = u2(k, {
    children: ["Supports markdown and templating.", " ", u2("a", {
      href: "https://docs.camunda.io/docs/components/modeler/forms/form-element-library/forms-element-library-text/",
      target: "_blank",
      rel: "noreferrer",
      children: "Learn more"
    })]
  });
  function HtmlEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [{
      id: "content",
      component: Content,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "html"
    }];
    return entries2;
  }
  function Content(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["content"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value || "");
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      description: description$2,
      element: field,
      getValue,
      id: id2,
      label: "Content",
      hostLanguage: "html",
      validate: validate$7,
      setValue,
      variables
    });
  }
  var description$2 = u2(k, {
    children: ["Supports HTML, styling, and templating. Styles are automatically scoped to the HTML component.", " ", u2("a", {
      href: "https://docs.camunda.io/docs/components/modeler/forms/form-element-library/forms-element-library-html/",
      target: "_blank",
      rel: "noreferrer",
      children: "Learn more"
    })]
  });
  var validate$7 = (value) => {
    if (typeof value !== "string" || value === "") {
      return null;
    }
    if (value.startsWith("=")) {
      return null;
    }
  };
  function NumberEntries(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const entries2 = [];
    entries2.push({
      id: id2 + "-decimalDigits",
      component: NumberDecimalDigits,
      isEdited: isEdited$7,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "number"
    });
    entries2.push({
      id: id2 + "-step",
      component: NumberArrowStep,
      isEdited,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "number"
    });
    return entries2;
  }
  function NumberDecimalDigits(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const getValue = (e3) => get(field, ["decimalDigits"]);
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, ["decimalDigits"], value);
    };
    return NumberFieldEntry({
      debounce: debounce3,
      label: "Decimal digits",
      element: field,
      step: "any",
      getValue,
      id: id2,
      setValue,
      validate: validateNumberEntries
    });
  }
  function NumberArrowStep(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const {
      decimalDigits
    } = field;
    const debounce3 = useService2("debounce");
    const getValue = (e3) => {
      let value = get(field, ["increment"]);
      if (!isValidNumber2(value)) return null;
      return value;
    };
    const clearLeadingZeroes = (value) => {
      if (!value) return value;
      const trimmed = value.replace(/^0+/g, "");
      return (trimmed.startsWith(".") ? "0" : "") + trimmed;
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, ["increment"], clearLeadingZeroes(value));
    };
    const decimalDigitsSet = decimalDigits || decimalDigits === 0;
    const validate2 = q2((value) => {
      if (value === void 0 || value === null) {
        return;
      }
      if (!isValidNumber2(value)) {
        return "Should be a valid number.";
      }
      if (big_default(value).cmp(0) <= 0) {
        return "Should be greater than zero.";
      }
      if (decimalDigitsSet) {
        const minimumValue = big_default(`1e-${decimalDigits}`);
        if (big_default(value).cmp(minimumValue) < 0) {
          return `Should be at least ${minimumValue.toString()}.`;
        }
        if (countDecimals2(value) > decimalDigits) {
          return `Should not contain more than ${decimalDigits} decimal digits.`;
        }
      }
    }, [decimalDigitsSet, decimalDigits]);
    return TextfieldEntry({
      debounce: debounce3,
      label: "Increment",
      element: field,
      getValue,
      id: id2,
      setValue,
      validate: validate2
    });
  }
  var validateNumberEntries = (value) => {
    if (typeof value !== "number") {
      return;
    }
    if (!Number.isInteger(value)) {
      return "Should be an integer.";
    }
    if (value < 0) {
      return "Should be greater than or equal to zero.";
    }
  };
  function ExpressionFieldEntries(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const entries2 = [];
    entries2.push({
      id: `${id2}-expression`,
      component: ExpressionFieldExpression,
      isEdited: isEdited$6,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "expression"
    });
    entries2.push({
      id: `${id2}-computeOn`,
      component: ExpressionFieldComputeOn,
      isEdited: isEdited$3,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "expression"
    });
    return entries2;
  }
  function ExpressionFieldExpression(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const getValue = () => field.expression || "";
    const setValue = (value) => {
      editField(field, ["expression"], value);
    };
    return FeelEntry({
      debounce: debounce3,
      description: "Define an expression to calculate the value of this field",
      element: field,
      feel: "required",
      getValue,
      id: id2,
      label: "Target value",
      setValue,
      variables
    });
  }
  function ExpressionFieldComputeOn(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const getValue = () => field.computeOn || "";
    const setValue = (value) => {
      editField(field, ["computeOn"], value);
    };
    const getOptions = () => [{
      value: "change",
      label: "Value changes"
    }, {
      value: "presubmit",
      label: "Form submission"
    }];
    return SelectEntry({
      id: id2,
      label: "Compute on",
      getValue,
      setValue,
      getOptions
    });
  }
  function NumberSerializationEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "serialize-to-string",
      component: SerializeToString,
      isEdited: isEdited$5,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "number"
    });
    return entries2;
  }
  function SerializeToString(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const {
      defaultValue
    } = field;
    const path2 = ["serializeToString"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      if (defaultValue || defaultValue === 0) {
        editField(field, ["defaultValue"], value ? big_default(defaultValue).toFixed() : Number(defaultValue));
      }
      return editField(field, path2, value);
    };
    return CheckboxEntry({
      element: field,
      getValue,
      id: id2,
      label: "Output as string",
      description: "Allows arbitrary precision values",
      setValue
    });
  }
  function DateTimeEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [{
      id: "subtype",
      component: DateTimeSubtypeSelect,
      isEdited: isEdited$3,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "datetime"
    }];
    entries2.push({
      id: "use24h",
      component: Use24h,
      isEdited: isEdited$5,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "datetime" && (field2.subtype === DATETIME_SUBTYPES.TIME || field2.subtype === DATETIME_SUBTYPES.DATETIME)
    });
    return entries2;
  }
  function DateTimeSubtypeSelect(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const getValue = (e3) => get(field, DATETIME_SUBTYPE_PATH);
    const clearTimeConfig = () => {
      const timeConfigPaths = [TIME_LABEL_PATH, TIME_USE24H_PATH, TIME_INTERVAL_PATH, TIME_SERIALISING_FORMAT_PATH];
      for (const path2 of timeConfigPaths) {
        editField(field, path2, void 0);
      }
    };
    const initTimeConfig = () => {
      editField(field, TIME_LABEL_PATH, "Time");
      editField(field, TIME_SERIALISING_FORMAT_PATH, TIME_SERIALISING_FORMATS.UTC_OFFSET);
      editField(field, TIME_INTERVAL_PATH, 15);
    };
    const clearDateConfig = () => {
      const dateConfigPaths = [DATE_LABEL_PATH, DATE_DISALLOW_PAST_PATH];
      for (const path2 of dateConfigPaths) {
        editField(field, path2, void 0);
      }
    };
    const initDateConfig = () => {
      editField(field, DATE_LABEL_PATH, "Date");
    };
    const setValue = (value) => {
      const oldValue = getValue();
      if (oldValue === value) return;
      if (value === DATETIME_SUBTYPES.DATE) {
        clearTimeConfig();
        oldValue === DATETIME_SUBTYPES.TIME && initDateConfig();
      } else if (value === DATETIME_SUBTYPES.TIME) {
        clearDateConfig();
        oldValue === DATETIME_SUBTYPES.DATE && initTimeConfig();
      } else if (value === DATETIME_SUBTYPES.DATETIME) {
        oldValue === DATETIME_SUBTYPES.DATE && initTimeConfig();
        oldValue === DATETIME_SUBTYPES.TIME && initDateConfig();
      }
      return editField(field, DATETIME_SUBTYPE_PATH, value);
    };
    const getDatetimeSubtypes = () => {
      return Object.values(DATETIME_SUBTYPES).map((subtype) => ({
        label: DATETIME_SUBTYPES_LABELS[subtype],
        value: subtype
      }));
    };
    return SelectEntry({
      label: "Subtype",
      element: field,
      getOptions: getDatetimeSubtypes,
      getValue,
      id: id2,
      setValue
    });
  }
  function Use24h(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const path2 = TIME_USE24H_PATH;
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return CheckboxEntry({
      element: field,
      getValue,
      id: id2,
      label: "Use 24h",
      setValue
    });
  }
  function DateTimeConstraintsEntry(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    function isDefaultVisible(subtypes) {
      return (field2) => {
        if (field2.type !== "datetime") {
          return false;
        }
        return subtypes.includes(field2.subtype);
      };
    }
    const entries2 = [];
    entries2.push({
      id: id2 + "-timeInterval",
      component: TimeIntervalSelect,
      isEdited: isEdited$3,
      editField,
      field,
      isDefaultVisible: isDefaultVisible([DATETIME_SUBTYPES.TIME, DATETIME_SUBTYPES.DATETIME])
    });
    entries2.push({
      id: id2 + "-disallowPassedDates",
      component: DisallowPassedDates,
      isEdited: isEdited$5,
      editField,
      field,
      isDefaultVisible: isDefaultVisible([DATETIME_SUBTYPES.DATE, DATETIME_SUBTYPES.DATETIME])
    });
    return entries2;
  }
  function DisallowPassedDates(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const path2 = DATE_DISALLOW_PAST_PATH;
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return CheckboxEntry({
      element: field,
      getValue,
      id: id2,
      label: "Disallow past dates",
      setValue
    });
  }
  function TimeIntervalSelect(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const timeIntervals = [1, 5, 10, 15, 30, 60];
    const getValue = (e3) => get(field, TIME_INTERVAL_PATH);
    const setValue = (value) => editField(field, TIME_INTERVAL_PATH, parseInt(value));
    const getTimeIntervals = () => {
      return timeIntervals.map((timeInterval) => ({
        label: timeInterval === 60 ? "1h" : timeInterval + "m",
        value: timeInterval
      }));
    };
    return SelectEntry({
      label: "Time interval",
      element: field,
      getOptions: getTimeIntervals,
      getValue,
      id: id2,
      setValue
    });
  }
  function DateTimeFormatEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "time-format",
      component: TimeFormatSelect,
      isEdited: isEdited$3,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "datetime" && (field2.subtype === DATETIME_SUBTYPES.TIME || field2.subtype === DATETIME_SUBTYPES.DATETIME)
    });
    return entries2;
  }
  function TimeFormatSelect(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const getValue = (e3) => get(field, TIME_SERIALISING_FORMAT_PATH);
    const setValue = (value) => editField(field, TIME_SERIALISING_FORMAT_PATH, value);
    const getTimeSerialisingFormats = () => {
      return Object.values(TIME_SERIALISING_FORMATS).map((format) => ({
        label: TIME_SERIALISINGFORMAT_LABELS[format],
        value: format
      }));
    };
    return SelectEntry({
      label: "Time format",
      element: field,
      getOptions: getTimeSerialisingFormats,
      getValue,
      id: id2,
      setValue
    });
  }
  function SelectEntries(props) {
    const entries2 = [simpleBoolEntryFactory({
      id: "searchable",
      path: ["searchable"],
      label: "Searchable",
      props,
      isDefaultVisible: (field) => field.type === "select"
    })];
    return entries2;
  }
  function ValueEntry(props) {
    const {
      editField,
      field,
      idPrefix,
      index: index2,
      validateFactory
    } = props;
    const entries2 = [{
      component: Label$1,
      editField,
      field,
      id: idPrefix + "-label",
      idPrefix,
      index: index2,
      validateFactory
    }, {
      component: Value$1,
      editField,
      field,
      id: idPrefix + "-value",
      idPrefix,
      index: index2,
      validateFactory
    }];
    return entries2;
  }
  function Label$1(props) {
    const {
      editField,
      field,
      id: id2,
      index: index2,
      validateFactory
    } = props;
    const debounce3 = useService2("debounce");
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      const values2 = get(field, ["values"]);
      return editField(field, "values", set(values2, [index2, "label"], value));
    };
    const getValue = () => {
      return get(field, ["values", index2, "label"]);
    };
    const validate2 = T2(() => validateFactory(get(field, ["values", index2, "label"]), (entry) => entry.label), [field, index2, validateFactory]);
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Label",
      setValue,
      validate: validate2
    });
  }
  function Value$1(props) {
    const {
      editField,
      field,
      id: id2,
      index: index2,
      validateFactory
    } = props;
    const debounce3 = useService2("debounce");
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      const values2 = get(field, ["values"]);
      return editField(field, "values", set(values2, [index2, "value"], value));
    };
    const getValue = () => {
      return get(field, ["values", index2, "value"]);
    };
    const validate2 = T2(() => validateFactory(get(field, ["values", index2, "value"]), (entry) => entry.value), [field, index2, validateFactory]);
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Value",
      setValue,
      validate: validate2
    });
  }
  function CustomValueEntry(props) {
    const {
      editField,
      field,
      idPrefix,
      index: index2,
      validateFactory
    } = props;
    const entries2 = [{
      component: Key$1,
      editField,
      field,
      id: idPrefix + "-key",
      idPrefix,
      index: index2,
      validateFactory
    }, {
      component: Value,
      editField,
      field,
      id: idPrefix + "-value",
      idPrefix,
      index: index2,
      validateFactory
    }];
    return entries2;
  }
  function Key$1(props) {
    const {
      editField,
      field,
      id: id2,
      index: index2,
      validateFactory
    } = props;
    const debounce3 = useService2("debounce");
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      const properties = get(field, ["properties"]);
      const key = Object.keys(properties)[index2];
      return editField(field, "properties", updateKey(properties, key, value));
    };
    const getValue = () => {
      return Object.keys(get(field, ["properties"]))[index2];
    };
    const validate2 = T2(() => validateFactory(Object.keys(get(field, ["properties"]))[index2]), [validateFactory, field, index2]);
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Key",
      setValue,
      validate: validate2
    });
  }
  function Value(props) {
    const {
      editField,
      field,
      id: id2,
      index: index2,
      validateFactory
    } = props;
    const debounce3 = useService2("debounce");
    const setValue = (value) => {
      const properties = get(field, ["properties"]);
      const key = Object.keys(properties)[index2];
      editField(field, "properties", updateValue(properties, key, value));
    };
    const getValue = () => {
      const properties = get(field, ["properties"]);
      const key = Object.keys(properties)[index2];
      return get(field, ["properties", key]);
    };
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Value",
      setValue,
      validate: validateFactory(getValue())
    });
  }
  function updateValue(properties, key, value) {
    return {
      ...properties,
      [key]: value
    };
  }
  function updateKey(properties, oldKey, newKey) {
    return Object.entries(properties).reduce((newProperties, entry) => {
      const [key, value] = entry;
      return {
        ...newProperties,
        [key === oldKey ? newKey : key]: value
      };
    }, {});
  }
  function AutoFocusSelectEntry(props) {
    const {
      autoFocusEntry,
      element,
      getValue
    } = props;
    const value = getValue(element);
    const prevValue = usePrevious2(value);
    const eventBus = useService2("eventBus");
    y2(() => {
      if (autoFocusEntry && prevValue && value !== prevValue) {
        setTimeout(() => {
          eventBus.fire("propertiesPanel.showEntry", {
            id: autoFocusEntry
          });
        });
      }
    }, [value, autoFocusEntry, prevValue, eventBus]);
    return u2(SelectEntry, {
      ...props
    });
  }
  function OptionsSourceSelectEntry(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    return [{
      id: id2 + "-select",
      component: ValuesSourceSelect,
      isEdited: isEdited$3,
      editField,
      field
    }];
  }
  function ValuesSourceSelect(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const getValue = getOptionsSource;
    const setValue = (value) => {
      let newField = field;
      const newProperties = {};
      newProperties[OPTIONS_SOURCES_PATHS[value]] = OPTIONS_SOURCES_DEFAULTS[value];
      newField = editField(field, newProperties);
      return newField;
    };
    const getOptionsSourceOptions = () => {
      return Object.values(OPTIONS_SOURCES).map((valueSource) => ({
        label: OPTIONS_SOURCES_LABELS[valueSource],
        value: valueSource
      }));
    };
    return AutoFocusSelectEntry({
      autoFocusEntry: getAutoFocusEntryId$1(field),
      label: "Type",
      element: field,
      getOptions: getOptionsSourceOptions,
      getValue,
      id: id2,
      setValue
    });
  }
  function getAutoFocusEntryId$1(field) {
    const valuesSource = getOptionsSource(field);
    if (valuesSource === OPTIONS_SOURCES.EXPRESSION) {
      return "optionsExpression-expression";
    } else if (valuesSource === OPTIONS_SOURCES.INPUT) {
      return "dynamicOptions-key";
    } else if (valuesSource === OPTIONS_SOURCES.STATIC) {
      return "staticOptions-0-label";
    }
    return null;
  }
  function InputKeyOptionsSourceEntry(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    return [{
      id: id2 + "-key",
      component: InputValuesKey,
      isEdited,
      editField,
      field
    }];
  }
  function InputValuesKey(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const path2 = OPTIONS_SOURCES_PATHS[OPTIONS_SOURCES.INPUT];
    const schema = '[\n  {\n    "label": "dollar",\n    "value": "$"\n  }\n]';
    const tooltip = u2("div", {
      children: ["The input property may be an array of simple values or alternatively follow this schema:", u2("pre", {
        children: u2("code", {
          children: schema
        })
      })]
    });
    const getValue = () => get(field, path2, "");
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, path2, value || "");
    };
    return TextfieldEntry({
      debounce: debounce3,
      description: "Define which input property to populate the values from",
      tooltip,
      element: field,
      getValue,
      id: id2,
      label: "Input values key",
      setValue,
      validate: validate$6
    });
  }
  var validate$6 = (value) => {
    if (typeof value !== "string" || value.length === 0) {
      return "Must not be empty.";
    }
    if (/\s/.test(value)) {
      return "Must not contain spaces.";
    }
    return null;
  };
  function StaticOptionsSourceEntry(props) {
    const {
      editField,
      field,
      id: idPrefix
    } = props;
    const {
      values: values2
    } = field;
    const addEntry = (e3) => {
      e3.stopPropagation();
      const index2 = values2.length + 1;
      const entry = getIndexedEntry(index2, values2);
      editField(field, OPTIONS_SOURCES_PATHS[OPTIONS_SOURCES.STATIC], arrayAdd(values2, values2.length, entry));
    };
    const removeEntry = (entry) => {
      if (field.defaultValue === entry.value) {
        editField(field, {
          values: without(values2, entry),
          defaultValue: void 0
        });
      } else {
        editField(field, OPTIONS_SOURCES_PATHS[OPTIONS_SOURCES.STATIC], without(values2, entry));
      }
    };
    const validateFactory = (key, getValue) => {
      return (value) => {
        if (value === key) {
          return;
        }
        if (typeof value !== "string" || value.length === 0) {
          return "Must not be empty.";
        }
        const isValueAssigned = values2.find((entry) => getValue(entry) === value);
        if (isValueAssigned) {
          return "Must be unique.";
        }
      };
    };
    const items = values2.map((entry, index2) => {
      const id2 = idPrefix + "-" + index2;
      return {
        id: id2,
        label: entry.label,
        entries: ValueEntry({
          editField,
          field,
          idPrefix: id2,
          index: index2,
          validateFactory
        }),
        autoFocusEntry: id2 + "-label",
        remove: () => removeEntry(entry)
      };
    });
    return {
      items,
      add: addEntry
    };
  }
  function getIndexedEntry(index2, values2) {
    const entry = {
      label: "Value",
      value: "value"
    };
    while (labelOrValueIsAlreadyAssignedForIndex(index2, values2)) {
      index2++;
    }
    if (index2 > 1) {
      entry.label += ` ${index2}`;
      entry.value += `${index2}`;
    }
    return entry;
  }
  function labelOrValueIsAlreadyAssignedForIndex(index2, values2) {
    return values2.some((existingEntry) => existingEntry.label === `Value ${index2}` || existingEntry.value === `value${index2}`);
  }
  function AdornerEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    const onChange = (key) => {
      return (value) => {
        const appearance = get(field, ["appearance"], {});
        editField(field, ["appearance"], set(appearance, [key], value));
      };
    };
    const getValue = (key) => {
      return () => {
        return get(field, ["appearance", key]);
      };
    };
    entries2.push({
      id: "prefix-adorner",
      component: PrefixAdorner,
      isEdited: isEdited$6,
      editField,
      field,
      onChange,
      getValue,
      isDefaultVisible: (field2) => ["number", "textfield"].includes(field2.type)
    });
    entries2.push({
      id: "suffix-adorner",
      component: SuffixAdorner,
      isEdited: isEdited$6,
      editField,
      field,
      onChange,
      getValue,
      isDefaultVisible: (field2) => ["number", "textfield"].includes(field2.type)
    });
    return entries2;
  }
  function PrefixAdorner(props) {
    const {
      field,
      id: id2,
      onChange,
      getValue
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue: getValue("prefixAdorner"),
      id: id2,
      label: "Prefix",
      setValue: onChange("prefixAdorner"),
      singleLine: true,
      variables
    });
  }
  function SuffixAdorner(props) {
    const {
      field,
      id: id2,
      onChange,
      getValue
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue: getValue("suffixAdorner"),
      id: id2,
      label: "Suffix",
      setValue: onChange("suffixAdorner"),
      singleLine: true,
      variables
    });
  }
  function ReadonlyEntry(props) {
    const {
      editField,
      field
    } = props;
    const {
      disabled
    } = field;
    const entries2 = [];
    if (!disabled) {
      entries2.push({
        id: "readonly",
        component: Readonly,
        editField,
        field,
        isEdited: isEdited$6,
        isDefaultVisible: (field2) => INPUTS.includes(field2.type)
      });
    }
    return entries2;
  }
  function Readonly(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["readonly"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value || false);
    };
    return FeelToggleSwitchEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue,
      id: id2,
      label: "Read only",
      tooltip: "Field cannot be edited by the end-user, but the data will still be submitted.",
      setValue,
      variables
    });
  }
  function LayouterAppearanceEntry(props) {
    const {
      field
    } = props;
    if (!["group", "dynamiclist"].includes(field.type)) {
      return [];
    }
    const entries2 = [simpleSelectEntryFactory({
      id: "verticalAlignment",
      path: ["verticalAlignment"],
      label: "Vertical alignment",
      optionsArray: [{
        value: "start",
        label: "Top"
      }, {
        value: "center",
        label: "Center"
      }, {
        value: "end",
        label: "Bottom"
      }],
      props
    })];
    return entries2;
  }
  function RepeatableEntry(props) {
    const {
      field,
      getService: getService3
    } = props;
    const {
      type: type3
    } = field;
    const formFieldDefinition = getService3("formFields").get(type3);
    if (!formFieldDefinition || !formFieldDefinition.config.repeatable) {
      return [];
    }
    const entries2 = [simpleRangeIntegerEntryFactory({
      id: "defaultRepetitions",
      path: ["defaultRepetitions"],
      label: "Default number of items",
      min: 1,
      max: 20,
      props
    }), simpleBoolEntryFactory({
      id: "allowAddRemove",
      path: ["allowAddRemove"],
      label: "Allow add/delete items",
      props
    }), simpleBoolEntryFactory({
      id: "disableCollapse",
      path: ["disableCollapse"],
      label: "Disable collapse",
      props
    })];
    if (!field.disableCollapse) {
      const nonCollapseItemsEntry = simpleRangeIntegerEntryFactory({
        id: "nonCollapsedItems",
        path: ["nonCollapsedItems"],
        label: "Number of non-collapsing items",
        min: 1,
        props
      });
      entries2.push(nonCollapseItemsEntry);
    }
    return entries2;
  }
  function ConditionEntry(props) {
    const {
      editField,
      field
    } = props;
    return [{
      id: "conditional-hide",
      component: Condition,
      editField,
      field,
      isEdited: isEdited$6
    }];
  }
  function Condition(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["conditional", "hide"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      if (!value) {
        return editField(field, "conditional", void 0);
      }
      return editField(field, "conditional", {
        hide: value
      });
    };
    let label = "Hide if";
    let description2 = "Condition under which the field is hidden";
    if (field.type === "expression") {
      label = "Deactivate if";
      description2 = "Condition under which the field is deactivated";
    }
    return FeelEntry({
      debounce: debounce3,
      description: description2,
      element: field,
      feel: "required",
      getValue,
      id: id2,
      label,
      setValue,
      variables
    });
  }
  function OptionsExpressionEntry(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    return [{
      id: id2 + "-expression",
      component: OptionsExpression,
      isEdited: isEdited$6,
      editField,
      field
    }];
  }
  function OptionsExpression(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = OPTIONS_SOURCES_PATHS[OPTIONS_SOURCES.EXPRESSION];
    const schema = '[\n  {\n    "label": "dollar",\n    "value": "$"\n  }\n]';
    const tooltip = u2("div", {
      children: ["The expression may result in an array of simple values or alternatively follow this schema:", u2("pre", {
        children: u2("code", {
          children: schema
        })
      })]
    });
    const getValue = () => get(field, path2, "");
    const setValue = (value) => editField(field, path2, value || "");
    return FeelEntry({
      debounce: debounce3,
      description: "Define an expression to populate the options from.",
      tooltip,
      element: field,
      feel: "required",
      getValue,
      id: id2,
      label: "Options expression",
      setValue,
      variables
    });
  }
  function TableDataSourceEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "dataSource",
      component: Source,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "table"
    });
    return entries2;
  }
  function Source(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["dataSource"];
    const getValue = () => {
      return get(field, path2, field.id);
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, path2, value);
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      description: "Specify the source from which to populate the table",
      element: field,
      feel: "required",
      getValue,
      id: id2,
      label: "Data source",
      tooltip: "Enter a form input variable that contains the data for the table or define an expression to populate the data dynamically.",
      setValue,
      singleLine: true,
      variables,
      validate: validate$5
    });
  }
  var validate$5 = (value) => {
    if (!isString(value) || value.length === 0) {
      return "Must not be empty.";
    }
    if (value.startsWith("=")) {
      return null;
    }
    if (!isValidDotPath(value)) {
      return "Must be a variable or a dot separated path.";
    }
    if (hasIntegerPathSegment(value)) {
      return "Must not contain numerical path segments.";
    }
    return null;
  };
  function PaginationEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "pagination",
      component: Pagination,
      editField,
      field,
      isEdited: isEdited$8,
      isDefaultVisible: (field2) => field2.type === "table"
    });
    return entries2;
  }
  function Pagination(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const defaultRowCount = 10;
    const path2 = ["rowCount"];
    const getValue = () => {
      return isNumber(get(field, path2));
    };
    const setValue = (value) => {
      value ? editField(field, path2, defaultRowCount) : editField(field, path2, void 0);
    };
    return ToggleSwitchEntry({
      element: field,
      getValue,
      id: id2,
      label: "Pagination",
      inline: true,
      setValue
    });
  }
  var path$2 = ["rowCount"];
  function RowCountEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "rowCount",
      component: RowCount,
      isEdited: isEdited$7,
      editField,
      field,
      isDefaultVisible: (field2) => field2.type === "table" && isNumber(get(field2, path$2))
    });
    return entries2;
  }
  function RowCount(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const getValue = () => get(field, path$2);
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, path$2, value);
    };
    return NumberFieldEntry({
      debounce: debounce3,
      label: "Number of rows per page",
      element: field,
      id: id2,
      getValue,
      setValue,
      validate: validate$4
    });
  }
  var validate$4 = (value) => {
    if (isNil(value)) {
      return null;
    }
    if (!isNumber(value)) {
      return "Must be number";
    }
    if (!Number.isInteger(value)) {
      return "Should be an integer.";
    }
    if (value < 1) {
      return "Should be greater than zero.";
    }
    return null;
  };
  var OPTIONS = {
    static: {
      label: "List of items",
      value: "static"
    },
    expression: {
      label: "Expression",
      value: "expression"
    }
  };
  var SELECT_OPTIONS = Object.values(OPTIONS);
  var COLUMNS_PATH = ["columns"];
  var COLUMNS_EXPRESSION_PATH = ["columnsExpression"];
  function HeadersSourceSelectEntry(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    return [{
      id: id2 + "-select",
      component: HeadersSourceSelect,
      isEdited: isEdited$3,
      editField,
      field
    }];
  }
  function HeadersSourceSelect(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const getValue = () => {
      const columns = get(field, COLUMNS_PATH);
      const columnsExpression = get(field, COLUMNS_EXPRESSION_PATH);
      if (isString(columnsExpression)) {
        return OPTIONS.expression.value;
      }
      if (isArray(columns)) {
        return OPTIONS.static.value;
      }
    };
    const setValue = (value) => {
      switch (value) {
        case OPTIONS.static.value:
          editField(field, {
            columns: [{
              label: "Column",
              key: "inputVariable"
            }]
          });
          break;
        case OPTIONS.expression.value:
          editField(field, {
            columnsExpression: "="
          });
          break;
      }
    };
    const getValuesSourceOptions = () => {
      return SELECT_OPTIONS;
    };
    return AutoFocusSelectEntry({
      autoFocusEntry: getAutoFocusEntryId(field),
      label: "Type",
      element: field,
      getOptions: getValuesSourceOptions,
      getValue,
      id: id2,
      setValue
    });
  }
  function getAutoFocusEntryId(field) {
    const columns = get(field, COLUMNS_PATH);
    const columnsExpression = get(field, COLUMNS_EXPRESSION_PATH);
    if (isString(columnsExpression)) {
      return `${field.id}-columnsExpression`;
    }
    if (isArray(columns)) {
      return `${field.id}-columns-0-label`;
    }
    return null;
  }
  var PATH = ["columnsExpression"];
  function ColumnsExpressionEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: `${field.id}-columnsExpression`,
      component: ColumnsExpression,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "table" && isString(get(field2, PATH))
    });
    return entries2;
  }
  function ColumnsExpression(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const getValue = () => {
      return get(field, PATH);
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      editField(field, PATH, value);
    };
    const schema = '[\n  {\n    "key": "column_1",\n    "label": "Column 1"\n  }\n]';
    const tooltip = u2("div", {
      children: ["The expression may result in an array of simple values or alternatively follow this schema:", u2("pre", {
        children: u2("code", {
          children: schema
        })
      })]
    });
    return FeelTemplatingEntry({
      debounce: debounce3,
      description: "Specify an expression to populate column items",
      element: field,
      feel: "required",
      getValue,
      id: id2,
      label: "Expression",
      tooltip,
      setValue,
      singleLine: true,
      variables,
      validate: validate$3
    });
  }
  var validate$3 = (value) => {
    if (!isString(value) || value.length === 0 || value === "=") {
      return "Must not be empty.";
    }
    return null;
  };
  var path$1 = "columns";
  var labelPath = "label";
  var keyPath = "key";
  function ColumnEntry(props) {
    const {
      editField,
      field,
      idPrefix,
      index: index2
    } = props;
    const entries2 = [{
      component: Label2,
      editField,
      field,
      id: idPrefix + "-label",
      idPrefix,
      index: index2
    }, {
      component: Key,
      editField,
      field,
      id: idPrefix + "-key",
      idPrefix,
      index: index2
    }];
    return entries2;
  }
  function Label2(props) {
    const {
      editField,
      field,
      id: id2,
      index: index2
    } = props;
    const debounce3 = useService2("debounce");
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      const columns = get(field, [path$1]);
      editField(field, path$1, set(columns, [index2, labelPath], value));
    };
    const getValue = () => {
      return get(field, [path$1, index2, labelPath]);
    };
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Label",
      setValue
    });
  }
  function Key(props) {
    const {
      editField,
      field,
      id: id2,
      index: index2
    } = props;
    const debounce3 = useService2("debounce");
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      const columns = get(field, [path$1]);
      editField(field, path$1, set(columns, [index2, keyPath], value));
    };
    const getValue = () => {
      return get(field, [path$1, index2, keyPath]);
    };
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Key",
      setValue,
      validate: validate$2
    });
  }
  function validate$2(value) {
    if (!isString(value) || value.length === 0) {
      return "Must not be empty.";
    }
    return null;
  }
  var path = ["columns"];
  function StaticColumnsSourceEntry(props) {
    const {
      editField,
      field,
      id: idPrefix
    } = props;
    const {
      columns
    } = field;
    const addEntry = (event2) => {
      event2.stopPropagation();
      const entry = {
        label: "Column",
        key: "inputVariable"
      };
      editField(field, path, arrayAdd(columns, columns.length, entry));
    };
    const removeEntry = (entry) => {
      editField(field, path, without(columns, entry));
    };
    const items = columns.map((entry, index2) => {
      const id2 = `${idPrefix}-${index2}`;
      return {
        id: id2,
        label: entry.label || entry.key,
        entries: ColumnEntry({
          editField,
          field,
          idPrefix: id2,
          index: index2
        }),
        autoFocusEntry: `${id2}-label`,
        remove: () => removeEntry(entry)
      };
    });
    return {
      items,
      add: addEntry
    };
  }
  function VersionTagEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "versionTag",
      component: VersionTag,
      editField,
      field,
      isEdited,
      isDefaultVisible: (field2) => field2.type === "default"
    });
    return entries2;
  }
  function VersionTag(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const path2 = ["versionTag"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value, error2) => {
      if (error2) {
        return;
      }
      return editField(field, path2, value);
    };
    const tooltip = u2("div", {
      children: "Version tag by which this form can be referenced."
    });
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Version tag",
      setValue,
      tooltip
    });
  }
  function AcceptEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "accept",
      component: Accept,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "filepicker"
    });
    return entries2;
  }
  function Accept(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["accept"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Supported file formats",
      singleLine: true,
      setValue,
      variables,
      description: description$1
    });
  }
  var description$1 = u2(k, {
    children: ["A comma-separated list of", " ", u2("a", {
      href: "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#unique_file_type_specifiers",
      target: "_blank",
      rel: "noreferrer",
      children: "file type specifiers"
    })]
  });
  function MultipleEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "multiple",
      component: Multiple,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "filepicker"
    });
    return entries2;
  }
  function Multiple(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["multiple"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return FeelToggleSwitchEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue,
      id: id2,
      label: "Upload multiple files",
      inline: true,
      setValue,
      variables
    });
  }
  function DocumentsDataSourceEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "dataSource",
      component: DocumentsDataSource,
      editField,
      field,
      isEdited: isEdited$6,
      isDefaultVisible: (field2) => field2.type === "documentPreview"
    });
    return entries2;
  }
  function DocumentsDataSource(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    const path2 = ["dataSource"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    const schema = `[
  {
    "documentId": "u123",
    "endpoint": "https://api.example.com/documents/u123",
    "metadata": {
      "fileName": "Document.pdf",
      "contentType": "application/pdf"
    }
  }
]`;
    const tooltip = u2("div", {
      children: [u2("p", {
        children: "A source is a JSON object containing metadata for a document or an array of documents."
      }), u2("p", {
        children: "Each entry must include a document ID, name, and MIME type."
      }), u2("p", {
        children: "Additional details are optional. The expected format is as follows:"
      }), u2("pre", {
        children: u2("code", {
          children: schema
        })
      }), u2("p", {
        children: "When using Camunda Tasklist UI, additional document reference attributes are automatically handled. Modifying the document reference may affect the document preview functionality."
      }), u2("p", {
        children: ["Learn more in our", " ", u2("a", {
          href: "https://docs.camunda.io/docs/8.7/components/modeler/forms/form-element-library/forms-element-library-document-preview/",
          target: "_blank",
          rel: "noopener noreferrer",
          children: "documentation"
        }), "."]
      })]
    });
    return FeelTemplatingEntry({
      debounce: debounce3,
      element: field,
      getValue,
      id: id2,
      label: "Document reference",
      feel: "required",
      singleLine: true,
      setValue,
      variables,
      tooltip,
      validate: validate$1
    });
  }
  var validate$1 = (value) => {
    if (typeof value !== "string" || value.length === 0) {
      return "The document data source is required.";
    }
  };
  function MaxHeightEntry(props) {
    const {
      editField,
      field
    } = props;
    const entries2 = [];
    entries2.push({
      id: "maxHeight",
      component: MaxHeight,
      editField,
      field,
      isEdited: isEdited$7,
      isDefaultVisible: (field2) => field2.type === "documentPreview"
    });
    return entries2;
  }
  function MaxHeight(props) {
    const {
      editField,
      field,
      id: id2
    } = props;
    const debounce3 = useService2("debounce");
    const path2 = ["maxHeight"];
    const getValue = () => {
      return get(field, path2, "");
    };
    const setValue = (value) => {
      return editField(field, path2, value);
    };
    return NumberFieldEntry({
      debounce: debounce3,
      label: "Max height of preview container",
      element: field,
      id: id2,
      getValue,
      setValue,
      validate,
      description
    });
  }
  var validate = (value) => {
    if (value === void 0 || value === "") {
      return null;
    }
    if (typeof value === "string") {
      return "Value must be a number.";
    }
    if (!Number.isInteger(value)) {
      return "Should be an integer.";
    }
    if (value < 1) {
      return "Should be greater than zero.";
    }
  };
  var description = u2(k, {
    children: "Documents with height that exceeds the defined value will be vertically scrollable"
  });
  function GeneralGroup(field, editField, getService3) {
    const entries2 = [...IdEntry({
      field,
      editField
    }), ...VersionTagEntry({
      field,
      editField
    }), ...LabelEntry({
      field,
      editField
    }), ...DescriptionEntry({
      field,
      editField
    }), ...KeyEntry({
      field,
      editField,
      getService: getService3
    }), ...PathEntry({
      field,
      editField,
      getService: getService3
    }), ...RepeatableEntry({
      field,
      editField,
      getService: getService3
    }), ...DefaultValueEntry({
      field,
      editField
    }), ...ActionEntry({
      field,
      editField
    }), ...DateTimeEntry({
      field,
      editField
    }), ...TextEntry({
      field,
      editField
    }), ...HtmlEntry({
      field,
      editField
    }), ...IFrameUrlEntry({
      field,
      editField
    }), ...IFrameHeightEntry({
      field,
      editField
    }), ...HeightEntry({
      field,
      editField
    }), ...NumberEntries({
      field,
      editField
    }), ...ExpressionFieldEntries({
      field,
      editField
    }), ...ImageSourceEntry({
      field,
      editField
    }), ...AltTextEntry({
      field,
      editField
    }), ...SelectEntries({
      field,
      editField
    }), ...AcceptEntry({
      field,
      editField
    }), ...MultipleEntry({
      field,
      editField
    }), ...DisabledEntry({
      field,
      editField
    }), ...ReadonlyEntry({
      field,
      editField
    }), ...TableDataSourceEntry({
      field,
      editField
    }), ...PaginationEntry({
      field,
      editField
    }), ...RowCountEntry({
      field,
      editField
    }), ...DocumentsDataSourceEntry({
      field,
      editField
    })];
    if (entries2.length === 0) {
      return null;
    }
    return {
      id: "general",
      label: "General",
      entries: entries2
    };
  }
  function SerializationGroup(field, editField) {
    const entries2 = [...NumberSerializationEntry({
      field,
      editField
    }), ...DateTimeFormatEntry({
      field,
      editField
    })];
    if (!entries2.length) {
      return null;
    }
    return {
      id: "serialization",
      label: "Serialization",
      entries: entries2
    };
  }
  function ConstraintsGroup(field, editField) {
    const entries2 = [...DateTimeConstraintsEntry({
      field,
      editField
    })];
    if (!entries2.length) {
      return null;
    }
    return {
      id: "constraints",
      label: "Constraints",
      entries: entries2
    };
  }
  var VALIDATION_TYPE_OPTIONS = {
    custom: {
      value: "",
      label: "Custom"
    },
    email: {
      value: "email",
      label: "Email"
    },
    phone: {
      value: "phone",
      label: "Phone"
    }
  };
  function ValidationGroup(field, editField) {
    const {
      type: type3
    } = field;
    const validate2 = get(field, ["validate"], {});
    const isCustomValidation = [void 0, VALIDATION_TYPE_OPTIONS.custom.value].includes(validate2.validationType);
    const onChange = (key) => {
      return (value) => {
        const validate3 = get(field, ["validate"], {});
        editField(field, ["validate"], set(validate3, [key], value));
      };
    };
    const getValue = (key) => {
      return () => {
        return get(field, ["validate", key]);
      };
    };
    let entries2 = [{
      id: "required",
      component: Required,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange,
      isDefaultVisible: (field2) => INPUTS.includes(field2.type)
    }];
    entries2.push({
      id: "validationType",
      component: ValidationType,
      getValue,
      field,
      editField,
      isEdited,
      onChange,
      isDefaultVisible: (field2) => field2.type === "textfield"
    });
    entries2.push({
      id: "minLength",
      component: MinLength,
      getValue,
      field,
      isEdited: isEdited$6,
      onChange,
      isDefaultVisible: (field2) => INPUTS.includes(field2.type) && (type3 === "textarea" || type3 === "textfield" && isCustomValidation)
    }, {
      id: "maxLength",
      component: MaxLength,
      getValue,
      field,
      isEdited: isEdited$6,
      onChange,
      isDefaultVisible: (field2) => INPUTS.includes(field2.type) && (type3 === "textarea" || type3 === "textfield" && isCustomValidation)
    });
    entries2.push({
      id: "pattern",
      component: Pattern,
      getValue,
      field,
      isEdited,
      onChange,
      isDefaultVisible: (field2) => INPUTS.includes(field2.type) && type3 === "textfield" && isCustomValidation
    });
    entries2.push({
      id: "min",
      component: Min,
      getValue,
      field,
      isEdited: isEdited$6,
      onChange,
      isDefaultVisible: (field2) => field2.type === "number"
    }, {
      id: "max",
      component: Max,
      getValue,
      field,
      isEdited: isEdited$6,
      onChange,
      isDefaultVisible: (field2) => field2.type === "number"
    });
    return {
      id: "validation",
      label: "Validation",
      entries: entries2
    };
  }
  function Required(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    return CheckboxEntry({
      element: field,
      getValue: getValue("required"),
      id: id2,
      label: "Required",
      setValue: onChange("required")
    });
  }
  function MinLength(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    return FeelNumberEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue: getValue("minLength"),
      id: id2,
      label: "Minimum length",
      min: 0,
      setValue: onChange("minLength"),
      variables
    });
  }
  function MaxLength(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    return FeelNumberEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      getValue: getValue("maxLength"),
      id: id2,
      label: "Maximum length",
      min: 0,
      setValue: onChange("maxLength"),
      variables
    });
  }
  function Pattern(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    const debounce3 = useService2("debounce");
    return TextfieldEntry({
      debounce: debounce3,
      element: field,
      getValue: getValue("pattern"),
      id: id2,
      label: "Custom regular expression",
      setValue: onChange("pattern")
    });
  }
  function Min(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    return FeelNumberEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      id: id2,
      label: "Minimum",
      step: "any",
      getValue: getValue("min"),
      setValue: onChange("min"),
      variables
    });
  }
  function Max(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    const debounce3 = useService2("debounce");
    const variables = useVariables().map((name2) => ({
      name: name2
    }));
    return FeelNumberEntry({
      debounce: debounce3,
      element: field,
      feel: "optional",
      id: id2,
      label: "Maximum",
      step: "any",
      getValue: getValue("max"),
      setValue: onChange("max"),
      variables
    });
  }
  function ValidationType(props) {
    const {
      field,
      getValue,
      id: id2,
      onChange
    } = props;
    useService2("debounce");
    const setValue = (validationType) => {
      onChange("validationType")(validationType || void 0);
    };
    return SelectEntry({
      element: field,
      getValue: getValue("validationType"),
      id: id2,
      label: "Validation pattern",
      setValue,
      getOptions: () => Object.values(VALIDATION_TYPE_OPTIONS),
      tooltip: getValue("validationType")() === VALIDATION_TYPE_OPTIONS.phone.value ? "The built-in phone validation pattern is based on the E.164 standard with no spaces. Ex: +491234567890" : void 0
    });
  }
  function OptionsGroups(field, editField, getService3) {
    const {
      type: type3
    } = field;
    const formFields2 = getService3("formFields");
    const fieldDefinition = formFields2.get(type3).config;
    if (!OPTIONS_INPUTS.includes(type3) && !hasOptionsGroupsConfigured(fieldDefinition)) {
      return [];
    }
    const context = {
      editField,
      field
    };
    const id2 = "valuesSource";
    const groups = [{
      id: id2,
      label: "Options source",
      tooltip: getValuesTooltip(),
      component: Group2,
      entries: OptionsSourceSelectEntry({
        ...context,
        id: id2
      })
    }];
    const valuesSource = getOptionsSource(field);
    if (valuesSource === OPTIONS_SOURCES.INPUT) {
      const id3 = "dynamicOptions";
      groups.push({
        id: id3,
        label: "Dynamic options",
        component: Group2,
        entries: InputKeyOptionsSourceEntry({
          ...context,
          id: id3
        })
      });
    } else if (valuesSource === OPTIONS_SOURCES.STATIC) {
      const id3 = "staticOptions";
      groups.push({
        id: id3,
        label: "Static options",
        component: ListGroup,
        ...StaticOptionsSourceEntry({
          ...context,
          id: id3
        })
      });
    } else if (valuesSource === OPTIONS_SOURCES.EXPRESSION) {
      const id3 = "optionsExpression";
      groups.push({
        id: id3,
        label: "Options expression",
        component: Group2,
        entries: OptionsExpressionEntry({
          ...context,
          id: id3
        })
      });
    }
    return groups;
  }
  function getValuesTooltip() {
    return '"Static" defines a constant, predefined set of form options.\n\n"Input data" defines options that are populated dynamically, adjusting based on variable data for flexible responses to different conditions or inputs.\n\n"Expression" defines options that are populated from a FEEL expression.';
  }
  function CustomPropertiesGroup(field, editField) {
    const {
      properties = {},
      type: type3
    } = field;
    if (type3 === "default") {
      return null;
    }
    const addEntry = (event2) => {
      event2.stopPropagation();
      let index2 = Object.keys(properties).length + 1;
      while (`key${index2}` in properties) {
        index2++;
      }
      editField(field, ["properties"], {
        ...properties,
        [`key${index2}`]: "value"
      });
    };
    const validateFactory = (key) => {
      return (value) => {
        if (value === key) {
          return;
        }
        if (typeof value !== "string" || value.length === 0) {
          return "Must not be empty.";
        }
        if (has(properties, value)) {
          return "Must be unique.";
        }
      };
    };
    const items = Object.keys(properties).map((key, index2) => {
      const removeEntry = (event2) => {
        event2.stopPropagation();
        return editField(field, ["properties"], removeKey(properties, key));
      };
      const id2 = `property-${index2}`;
      return {
        autoFocusEntry: id2 + "-key",
        entries: CustomValueEntry({
          editField,
          field,
          idPrefix: id2,
          index: index2,
          validateFactory
        }),
        id: id2,
        label: key || "",
        remove: removeEntry
      };
    });
    return {
      add: addEntry,
      component: ListGroup,
      id: "custom-values",
      items,
      label: "Custom properties",
      tooltip: "Add properties directly to the form schema, useful to configure functionality in custom-built task applications and form renderers."
    };
  }
  function removeKey(properties, oldKey) {
    return Object.entries(properties).reduce((newProperties, entry) => {
      const [key, value] = entry;
      if (key === oldKey) {
        return newProperties;
      }
      return {
        ...newProperties,
        [key]: value
      };
    }, {});
  }
  function AppearanceGroup(field, editField, getService3) {
    const entries2 = [...AdornerEntry({
      field,
      editField
    }), ...GroupAppearanceEntry({
      field,
      editField
    }), ...LayouterAppearanceEntry({
      field,
      editField
    }), ...MaxHeightEntry({
      field,
      editField
    })];
    if (!entries2.length) {
      return null;
    }
    return {
      id: "appearance",
      label: "Appearance",
      entries: entries2
    };
  }
  function LayoutGroup(field, editField) {
    const {
      type: type3
    } = field;
    if (type3 === "default") {
      return null;
    }
    const entries2 = [...ColumnsEntry({
      field,
      editField
    })];
    if (entries2.length === 0) {
      return null;
    }
    return {
      id: "layout",
      label: "Layout",
      entries: entries2
    };
  }
  function SecurityAttributesGroup(field, editField) {
    const {
      type: type3
    } = field;
    if (type3 !== "iframe") {
      return null;
    }
    const entries2 = createEntries({
      field,
      editField
    });
    if (!entries2.length) {
      return null;
    }
    return {
      id: "securityAttributes",
      label: "Security attributes",
      entries: entries2,
      tooltip: getTooltip2()
    };
  }
  function createEntries(props) {
    const {
      editField,
      field
    } = props;
    const securityEntries = SECURITY_ATTRIBUTES_DEFINITIONS.map((definition) => {
      const {
        label,
        property
      } = definition;
      return simpleBoolEntryFactory({
        id: property,
        label,
        isDefaultVisible: (field2) => field2.type === "iframe",
        path: ["security", property],
        props,
        getValue: () => get(field, ["security", property]),
        setValue: (value) => {
          const security = get(field, ["security"], {});
          editField(field, ["security"], set(security, [property], value));
        }
      });
    });
    return [{
      component: Advisory
    }, ...securityEntries];
  }
  var Advisory = (props) => {
    return u2("div", {
      class: "bio-properties-panel-description fjs-properties-panel-detached-description",
      children: "These options can incur security risks, especially if used in combination with dynamic links. Ensure that you are aware of them, that you trust the source url and only enable what your use case requires."
    });
  };
  function getTooltip2() {
    return u2(k, {
      children: u2("p", {
        children: ["Allow the iframe to access more functionality of your browser, details regarding the various options can be found in the", " ", u2("a", {
          target: "_blank",
          href: "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe",
          rel: "noreferrer",
          children: "MDN iFrame documentation."
        })]
      })
    });
  }
  function ConditionGroup(field, editField) {
    const {
      type: type3
    } = field;
    if (type3 === "default") {
      return null;
    }
    const entries2 = [...ConditionEntry({
      field,
      editField
    })];
    return {
      id: "condition",
      label: "Condition",
      entries: entries2
    };
  }
  function TableHeaderGroups(field, editField) {
    const {
      type: type3,
      id: fieldId
    } = field;
    if (type3 !== "table") {
      return [];
    }
    const areStaticColumnsEnabled = isArray(get(field, ["columns"]));
    const groups = [{
      id: `${fieldId}-columnsSource`,
      label: "Headers source",
      tooltip: TOOLTIP_TEXT,
      component: Group2,
      entries: [...HeadersSourceSelectEntry({
        field,
        editField
      }), ...ColumnsExpressionEntry({
        field,
        editField
      })]
    }];
    if (areStaticColumnsEnabled) {
      const id2 = `${fieldId}-columns`;
      groups.push({
        id: id2,
        label: "Header items",
        component: ListGroup,
        ...StaticColumnsSourceEntry({
          field,
          editField,
          id: id2
        })
      });
    }
    return groups;
  }
  var TOOLTIP_TEXT = `"List of items" defines a constant, predefined set of form options.

"Expression" defines options that are populated from a FEEL expression.
`;
  var PropertiesProvider = class {
    constructor(propertiesPanel, injector) {
      this._injector = injector;
      propertiesPanel.registerProvider(this);
    }
    _filterVisibleEntries(groups, field, getService3) {
      return groups.forEach((group) => {
        const {
          entries: entries2
        } = group;
        const {
          type: type3
        } = field;
        const formFields2 = getService3("formFields");
        const fieldDefinition = formFields2.get(type3).config;
        if (!entries2) {
          return;
        }
        group.entries = entries2.filter((entry) => {
          const {
            isDefaultVisible
          } = entry;
          if (!isDefaultVisible) {
            return true;
          }
          return isDefaultVisible(field) || hasEntryConfigured(fieldDefinition, entry.id);
        });
      });
    }
    getGroups(field, editField) {
      return (groups) => {
        if (!field) {
          return groups;
        }
        const getService3 = (type3, strict = true) => this._injector.get(type3, strict);
        groups = [...groups, GeneralGroup(field, editField, getService3), ...OptionsGroups(field, editField, getService3), ...TableHeaderGroups(field, editField), SecurityAttributesGroup(field, editField), ConditionGroup(field, editField), LayoutGroup(field, editField), AppearanceGroup(field, editField), SerializationGroup(field, editField), ConstraintsGroup(field, editField), ValidationGroup(field, editField), CustomPropertiesGroup(field, editField)].filter((group) => group != null);
        this._filterVisibleEntries(groups, field, getService3);
        return groups.filter((group) => {
          return group.items || group.entries && group.entries.length;
        });
      };
    }
  };
  PropertiesProvider.$inject = ["propertiesPanel", "injector"];
  var PropertiesPanelModule = {
    __depends__: [index],
    __init__: ["propertiesPanel", "propertiesProvider"],
    propertiesPanel: ["type", PropertiesPanelRenderer],
    propertiesProvider: ["type", PropertiesProvider]
  };
  var RenderInjector = class extends SectionModuleBase {
    constructor(eventBus) {
      super(eventBus, "renderInjector");
      this._eventBus = eventBus;
      this.registeredRenderers = [];
    }
    /**
     * Inject a new renderer into the injector.
     * @param {string} identifier - Identifier for the renderer.
     * @param {Function} Renderer - The renderer function.
     */
    attachRenderer(identifier2, Renderer3) {
      this.registeredRenderers = [...this.registeredRenderers, {
        identifier: identifier2,
        Renderer: Renderer3
      }];
    }
    /**
     * Detach a renderer from the by key injector.
     * @param {string} identifier - Identifier for the renderer.
     */
    detachRenderer(identifier2) {
      this.registeredRenderers = this.registeredRenderers.filter((r3) => r3.identifier !== identifier2);
    }
    /**
     * Returns the registered renderers.
     * @returns {Array} Array of registered renderers.
     */
    fetchRenderers() {
      return this.registeredRenderers;
    }
  };
  RenderInjector.$inject = ["eventBus"];
  var RenderInjectionModule = {
    __init__: ["renderInjector"],
    renderInjector: ["type", RenderInjector]
  };
  var _path7;
  function _extends3() {
    return _extends3 = Object.assign ? Object.assign.bind() : function(n3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t4 = arguments[e3];
        for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
      }
      return n3;
    }, _extends3.apply(null, arguments);
  }
  var SvgRepeat = function SvgRepeat2(props) {
    return /* @__PURE__ */ _("svg", _extends3({
      xmlns: "http://www.w3.org/2000/svg",
      width: 16,
      height: 16,
      fill: "none"
    }, props), _path7 || (_path7 = /* @__PURE__ */ _("path", {
      fill: "currentColor",
      d: "M3 3h10.086l-1.793-1.793L12 .5l3 3-3 3-.707-.707L13.086 4H3v3.5H2V4a1 1 0 0 1 1-1M4.707 10.207 2.914 12H13V8.5h1V12a1 1 0 0 1-1 1H2.914l1.793 1.793L4 15.5l-3-3 3-3z"
    })));
  };
  var EditorRepeatRenderManager = class {
    constructor(formFields2, formFieldRegistry) {
      this._formFields = formFields2;
      this._formFieldRegistry = formFieldRegistry;
      this.RepeatFooter = this.RepeatFooter.bind(this);
    }
    /**
     * Checks whether a field should be repeatable.
     *
     * @param {string} id - The id of the field to check
     * @returns {boolean} - True if repeatable, false otherwise
     */
    isFieldRepeating(id2) {
      if (!id2) {
        return false;
      }
      const formField = this._formFieldRegistry.get(id2);
      const formFieldDefinition = this._formFields.get(formField.type);
      return formFieldDefinition.config.repeatable && formField.isRepeating;
    }
    RepeatFooter() {
      return u2("div", {
        className: "fjs-repeat-render-footer",
        children: [u2(SvgRepeat, {}), u2("span", {
          children: "Repeatable"
        })]
      });
    }
  };
  EditorRepeatRenderManager.$inject = ["formFields", "formFieldRegistry"];
  var RepeatRenderModule = {
    __init__: ["repeatRenderManager"],
    repeatRenderManager: ["type", EditorRepeatRenderManager]
  };
  var ids2 = new index_esm_default([32, 36, 1]);
  var FormEditor = class {
    /**
     * @constructor
     * @param {FormEditorOptions} options
     */
    constructor(options2 = {}) {
      this.on = this._onEvent;
      this._id = ids2.next();
      this._container = createFormContainer();
      this._container.setAttribute("tabindex", "0");
      const {
        container,
        exporter,
        injector = this._createInjector(options2, this._container),
        properties = {}
      } = options2;
      this.exporter = exporter;
      this._state = {
        properties,
        schema: null
      };
      this.get = injector.get;
      this.invoke = injector.invoke;
      this.get("eventBus").fire("form.init");
      if (container) {
        this.attachTo(container);
      }
    }
    clear() {
      this._emit("diagram.clear");
      this._emit("form.clear");
    }
    destroy() {
      this.get("eventBus").fire("form.destroy");
      this.get("eventBus").fire("diagram.destroy");
      this._detach(false);
    }
    /**
     * @param {Schema} schema
     *
     * @return {Promise<{ warnings: Array<any> }>}
     */
    importSchema(schema) {
      return new Promise((resolve, reject) => {
        try {
          this.clear();
          const {
            schema: importedSchema,
            warnings
          } = this.get("importer").importSchema(schema);
          this._setState({
            schema: importedSchema
          });
          this._emit("import.done", {
            warnings
          });
          return resolve({
            warnings
          });
        } catch (error2) {
          this._emit("import.done", {
            error: error2,
            warnings: error2.warnings || []
          });
          return reject(error2);
        }
      });
    }
    /**
     * @returns {Schema}
     */
    saveSchema() {
      return this.getSchema();
    }
    /**
     * @returns {Schema}
     */
    getSchema() {
      const {
        schema
      } = this._getState();
      return exportSchema(schema, this.exporter, schemaVersion);
    }
    /**
     * @param {Element|string} parentNode
     */
    attachTo(parentNode) {
      if (!parentNode) {
        throw new Error("parentNode required");
      }
      this.detach();
      if (isString(parentNode)) {
        parentNode = document.querySelector(parentNode);
      }
      const container = this._container;
      parentNode.appendChild(container);
      this._emit("attach");
    }
    detach() {
      this._detach();
    }
    /**
     * @internal
     *
     * @param {boolean} [emit]
     */
    _detach(emit = true) {
      const container = this._container, parentNode = container.parentNode;
      if (!parentNode) {
        return;
      }
      if (emit) {
        this._emit("detach");
      }
      parentNode.removeChild(container);
    }
    /**
     * @param {any} property
     * @param {any} value
     */
    setProperty(property, value) {
      const properties = set(this._getState().properties, [property], value);
      this._setState({
        properties
      });
    }
    /**
     * @param {string} type
     * @param {Function} handler
     */
    off(type3, handler) {
      this.get("eventBus").off(type3, handler);
    }
    /**
     * @internal
     *
     * @param {FormEditorOptions} options
     * @param {Element} container
     *
     * @returns {Injector}
     */
    _createInjector(options2, container) {
      const {
        modules = this._getModules(),
        additionalModules = [],
        renderer = {},
        ...config2
      } = options2;
      const enrichedConfig = {
        ...config2,
        renderer: {
          ...renderer,
          container
        }
      };
      return createInjector([{
        config: ["value", enrichedConfig]
      }, {
        formEditor: ["value", this]
      }, CoreModule, ...modules, ...additionalModules]);
    }
    /**
     * @internal
     */
    _emit(type3, data) {
      this.get("eventBus").fire(type3, data);
    }
    /**
     * @internal
     */
    _getState() {
      return this._state;
    }
    /**
     * @internal
     */
    _setState(state) {
      this._state = {
        ...this._state,
        ...state
      };
      this._emit("changed", this._getState());
    }
    /**
     * @internal
     */
    _getModules() {
      return [ModelingModule, EditorActionsModule, FormEditorKeyboardModule, DraggingModule, SelectionModule, PaletteModule, EditorExpressionLanguageModule, MarkdownRendererModule, PropertiesPanelModule, RenderInjectionModule, RepeatRenderModule];
    }
    /**
     * @internal
     */
    _onEvent(type3, priority, handler) {
      this.get("eventBus").on(type3, priority, handler);
    }
  };
  function exportSchema(schema, exporter, schemaVersion2) {
    const exportDetails = exporter ? {
      exporter
    } : {};
    const cleanedSchema = clone4(schema, (name2, value) => {
      if (["_parent", "_path"].includes(name2)) {
        return void 0;
      }
      return value;
    });
    return {
      ...cleanedSchema,
      ...exportDetails,
      schemaVersion: schemaVersion2
    };
  }

  // src/webviews/formEditorWebview.ts
  (function() {
    let isUpdating = false;
    const vscode = acquireVsCodeApi();
    async function updateContent(text2) {
      let json;
      try {
        if (!text2) {
          text2 = "{}";
        }
        json = JSON.parse(text2);
        window.formEditor.importSchema(json);
      } catch {
        return;
      }
      try {
        await window.formEditor.importSchema(json);
      } catch (err) {
        console.log("importing form failed", err);
      }
    }
    const editor = new FormEditor({
      container: "#form-editor"
    });
    editor.on("changed", (event2) => {
      const schema = editor.saveSchema();
      vscode.postMessage({
        type: "updateDocument",
        data: schema
      });
    });
    window.formEditor = editor;
    window.addEventListener("message", (event2) => {
      const message = event2.data;
      switch (message.type) {
        case "update":
          isUpdating = true;
          const text2 = message.text;
          updateContent(text2);
          vscode.setState({ text: text2 });
          return;
      }
    });
    const state = vscode.getState();
    if (state) {
      updateContent(state.text);
    }
  })();
})();
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=form-editor.bundle.js.map
